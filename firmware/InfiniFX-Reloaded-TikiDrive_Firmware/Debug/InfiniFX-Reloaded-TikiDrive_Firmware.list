
InfiniFX-Reloaded-TikiDrive_Firmware.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000002ac  08000000  08000000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00012eb8  080002b0  080002b0  000012b0  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       000001a0  08013168  08013168  00014168  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .init_array   00000004  08013308  08013308  00014308  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .fini_array   00000004  0801330c  0801330c  0001430c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .data         000002a0  24000000  08013310  00015000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .bss          0000477c  240002a0  080135b0  000152a0  2**2
                  ALLOC
  7 ._user_heap_stack 00000604  24004a1c  080135b0  00015a1c  2**0
                  ALLOC
  8 .audiobuffer  000009a8  30000000  30000000  00016000  2**2
                  ALLOC
  9 .ARM.attributes 0000002e  00000000  00000000  000152a0  2**0
                  CONTENTS, READONLY
 10 .debug_info   00027949  00000000  00000000  000152ce  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 11 .debug_abbrev 00004f12  00000000  00000000  0003cc17  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 12 .debug_aranges 00002050  00000000  00000000  00041b30  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_rnglists 00001909  00000000  00000000  00043b80  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_macro  000374a7  00000000  00000000  00045489  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_line   0002ba23  00000000  00000000  0007c930  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_str    0015c0ef  00000000  00000000  000a8353  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .comment      00000043  00000000  00000000  00204442  2**0
                  CONTENTS, READONLY
 18 .debug_frame  00008d68  00000000  00000000  00204488  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_line_str 0000007f  00000000  00000000  0020d1f0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

080002b0 <__do_global_dtors_aux>:
 80002b0:	b510      	push	{r4, lr}
 80002b2:	4c05      	ldr	r4, [pc, #20]	@ (80002c8 <__do_global_dtors_aux+0x18>)
 80002b4:	7823      	ldrb	r3, [r4, #0]
 80002b6:	b933      	cbnz	r3, 80002c6 <__do_global_dtors_aux+0x16>
 80002b8:	4b04      	ldr	r3, [pc, #16]	@ (80002cc <__do_global_dtors_aux+0x1c>)
 80002ba:	b113      	cbz	r3, 80002c2 <__do_global_dtors_aux+0x12>
 80002bc:	4804      	ldr	r0, [pc, #16]	@ (80002d0 <__do_global_dtors_aux+0x20>)
 80002be:	f3af 8000 	nop.w
 80002c2:	2301      	movs	r3, #1
 80002c4:	7023      	strb	r3, [r4, #0]
 80002c6:	bd10      	pop	{r4, pc}
 80002c8:	240002a0 	.word	0x240002a0
 80002cc:	00000000 	.word	0x00000000
 80002d0:	08013150 	.word	0x08013150

080002d4 <frame_dummy>:
 80002d4:	b508      	push	{r3, lr}
 80002d6:	4b03      	ldr	r3, [pc, #12]	@ (80002e4 <frame_dummy+0x10>)
 80002d8:	b11b      	cbz	r3, 80002e2 <frame_dummy+0xe>
 80002da:	4903      	ldr	r1, [pc, #12]	@ (80002e8 <frame_dummy+0x14>)
 80002dc:	4803      	ldr	r0, [pc, #12]	@ (80002ec <frame_dummy+0x18>)
 80002de:	f3af 8000 	nop.w
 80002e2:	bd08      	pop	{r3, pc}
 80002e4:	00000000 	.word	0x00000000
 80002e8:	240002a4 	.word	0x240002a4
 80002ec:	08013150 	.word	0x08013150

080002f0 <CS4270_Init>:
										 0x00,				// Transition (Independent volume controls)
										 0x12,				// Mute right channel
										 0x00,				// DAC A Vol (0dB)
										 0xFF}; 			// DAC B Vol (Mute (-127.5dB))

uint8_t CS4270_Init() {
 80002f0:	b580      	push	{r7, lr}
 80002f2:	b082      	sub	sp, #8
 80002f4:	af00      	add	r7, sp, #0

	HAL_StatusTypeDef i2cStatus;


	// Hard reset of codec
	CS4270_Reset();
 80002f6:	f000 f859 	bl	80003ac <CS4270_Reset>

	// Put CODEC in power down mode before adjusting configuration (set freeze bit, power down ADC, DAC, enter low power mode)
	i2cStatus = CS4270_RegWrite(CS4270_REG_POWERCONTROL, 0xA3);
 80002fa:	21a3      	movs	r1, #163	@ 0xa3
 80002fc:	2002      	movs	r0, #2
 80002fe:	f000 f86b 	bl	80003d8 <CS4270_RegWrite>
 8000302:	4603      	mov	r3, r0
 8000304:	71bb      	strb	r3, [r7, #6]

	if (i2cStatus != HAL_OK) {
 8000306:	79bb      	ldrb	r3, [r7, #6]
 8000308:	2b00      	cmp	r3, #0
 800030a:	d001      	beq.n	8000310 <CS4270_Init+0x20>

		return 1;
 800030c:	2301      	movs	r3, #1
 800030e:	e046      	b.n	800039e <CS4270_Init+0xae>

	}


	// Check device ID
	uint8_t deviceID = 0x00;
 8000310:	2300      	movs	r3, #0
 8000312:	717b      	strb	r3, [r7, #5]

	i2cStatus = CS4270_RegRead(CS4270_REG_DEVICEID, &deviceID);
 8000314:	1d7b      	adds	r3, r7, #5
 8000316:	4619      	mov	r1, r3
 8000318:	2001      	movs	r0, #1
 800031a:	f000 f87b 	bl	8000414 <CS4270_RegRead>
 800031e:	4603      	mov	r3, r0
 8000320:	71bb      	strb	r3, [r7, #6]

	if ( (i2cStatus != HAL_OK) || ((deviceID & 0xF0) != CS4270_DEVICEID)) { // Upper 4 bits = device ID
 8000322:	79bb      	ldrb	r3, [r7, #6]
 8000324:	2b00      	cmp	r3, #0
 8000326:	d104      	bne.n	8000332 <CS4270_Init+0x42>
 8000328:	797b      	ldrb	r3, [r7, #5]
 800032a:	f003 03f0 	and.w	r3, r3, #240	@ 0xf0
 800032e:	2bc0      	cmp	r3, #192	@ 0xc0
 8000330:	d001      	beq.n	8000336 <CS4270_Init+0x46>

		return 2;
 8000332:	2302      	movs	r3, #2
 8000334:	e033      	b.n	800039e <CS4270_Init+0xae>

	// Set configuration registers
	int8_t  regIndex;
	uint8_t regData;

	for (regIndex = CS4270_REG_DACBVOLCONTROL; regIndex >= CS4270_REG_POWERCONTROL; regIndex--) {
 8000336:	2308      	movs	r3, #8
 8000338:	71fb      	strb	r3, [r7, #7]
 800033a:	e02b      	b.n	8000394 <CS4270_Init+0xa4>

		// Write 'default' value to register (Note: not checking reserved bits - default values are 0 in datasheet p.31!)
		i2cStatus = CS4270_RegWrite(regIndex, CS4270_REG_CONFIG_SETTINGS[regIndex - 1]);
 800033c:	79fa      	ldrb	r2, [r7, #7]
 800033e:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8000342:	3b01      	subs	r3, #1
 8000344:	4918      	ldr	r1, [pc, #96]	@ (80003a8 <CS4270_Init+0xb8>)
 8000346:	5ccb      	ldrb	r3, [r1, r3]
 8000348:	4619      	mov	r1, r3
 800034a:	4610      	mov	r0, r2
 800034c:	f000 f844 	bl	80003d8 <CS4270_RegWrite>
 8000350:	4603      	mov	r3, r0
 8000352:	71bb      	strb	r3, [r7, #6]

		if (i2cStatus != HAL_OK) {
 8000354:	79bb      	ldrb	r3, [r7, #6]
 8000356:	2b00      	cmp	r3, #0
 8000358:	d001      	beq.n	800035e <CS4270_Init+0x6e>

			return regIndex;
 800035a:	79fb      	ldrb	r3, [r7, #7]
 800035c:	e01f      	b.n	800039e <CS4270_Init+0xae>

		}

		// Read back register value
		i2cStatus = CS4270_RegRead(regIndex, &regData);
 800035e:	79fb      	ldrb	r3, [r7, #7]
 8000360:	1d3a      	adds	r2, r7, #4
 8000362:	4611      	mov	r1, r2
 8000364:	4618      	mov	r0, r3
 8000366:	f000 f855 	bl	8000414 <CS4270_RegRead>
 800036a:	4603      	mov	r3, r0
 800036c:	71bb      	strb	r3, [r7, #6]

		if ((i2cStatus != HAL_OK) || (regData != CS4270_REG_CONFIG_SETTINGS[regIndex - 1])) {
 800036e:	79bb      	ldrb	r3, [r7, #6]
 8000370:	2b00      	cmp	r3, #0
 8000372:	d107      	bne.n	8000384 <CS4270_Init+0x94>
 8000374:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8000378:	3b01      	subs	r3, #1
 800037a:	4a0b      	ldr	r2, [pc, #44]	@ (80003a8 <CS4270_Init+0xb8>)
 800037c:	5cd2      	ldrb	r2, [r2, r3]
 800037e:	793b      	ldrb	r3, [r7, #4]
 8000380:	429a      	cmp	r2, r3
 8000382:	d001      	beq.n	8000388 <CS4270_Init+0x98>

			return regIndex;
 8000384:	79fb      	ldrb	r3, [r7, #7]
 8000386:	e00a      	b.n	800039e <CS4270_Init+0xae>
	for (regIndex = CS4270_REG_DACBVOLCONTROL; regIndex >= CS4270_REG_POWERCONTROL; regIndex--) {
 8000388:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800038c:	b2db      	uxtb	r3, r3
 800038e:	3b01      	subs	r3, #1
 8000390:	b2db      	uxtb	r3, r3
 8000392:	71fb      	strb	r3, [r7, #7]
 8000394:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8000398:	2b01      	cmp	r3, #1
 800039a:	dccf      	bgt.n	800033c <CS4270_Init+0x4c>

		}

	}

	return 0;
 800039c:	2300      	movs	r3, #0

}
 800039e:	4618      	mov	r0, r3
 80003a0:	3708      	adds	r7, #8
 80003a2:	46bd      	mov	sp, r7
 80003a4:	bd80      	pop	{r7, pc}
 80003a6:	bf00      	nop
 80003a8:	24000000 	.word	0x24000000

080003ac <CS4270_Reset>:

void CS4270_Reset() {
 80003ac:	b580      	push	{r7, lr}
 80003ae:	af00      	add	r7, sp, #0

	HAL_GPIO_WritePin(CS4270_NRST_GPIO_PORT, CS4270_NRST_GPIO_PIN, GPIO_PIN_RESET);
 80003b0:	2200      	movs	r2, #0
 80003b2:	2140      	movs	r1, #64	@ 0x40
 80003b4:	4807      	ldr	r0, [pc, #28]	@ (80003d4 <CS4270_Reset+0x28>)
 80003b6:	f006 fa8b 	bl	80068d0 <HAL_GPIO_WritePin>
	HAL_Delay(25);
 80003ba:	2019      	movs	r0, #25
 80003bc:	f002 fadc 	bl	8002978 <HAL_Delay>

	HAL_GPIO_WritePin(CS4270_NRST_GPIO_PORT, CS4270_NRST_GPIO_PIN, GPIO_PIN_SET);
 80003c0:	2201      	movs	r2, #1
 80003c2:	2140      	movs	r1, #64	@ 0x40
 80003c4:	4803      	ldr	r0, [pc, #12]	@ (80003d4 <CS4270_Reset+0x28>)
 80003c6:	f006 fa83 	bl	80068d0 <HAL_GPIO_WritePin>
	HAL_Delay(25);
 80003ca:	2019      	movs	r0, #25
 80003cc:	f002 fad4 	bl	8002978 <HAL_Delay>

}
 80003d0:	bf00      	nop
 80003d2:	bd80      	pop	{r7, pc}
 80003d4:	58020c00 	.word	0x58020c00

080003d8 <CS4270_RegWrite>:

HAL_StatusTypeDef CS4270_RegWrite(uint8_t regAddr, uint8_t regData) {
 80003d8:	b580      	push	{r7, lr}
 80003da:	b086      	sub	sp, #24
 80003dc:	af04      	add	r7, sp, #16
 80003de:	4603      	mov	r3, r0
 80003e0:	460a      	mov	r2, r1
 80003e2:	71fb      	strb	r3, [r7, #7]
 80003e4:	4613      	mov	r3, r2
 80003e6:	71bb      	strb	r3, [r7, #6]

	return HAL_I2C_Mem_Write(&CS4270_I2C_HANDLE, CS4270_I2C_ADDRESS, regAddr, I2C_MEMADD_SIZE_8BIT, &regData, 1, HAL_MAX_DELAY);
 80003e8:	79fb      	ldrb	r3, [r7, #7]
 80003ea:	b29a      	uxth	r2, r3
 80003ec:	f04f 33ff 	mov.w	r3, #4294967295
 80003f0:	9302      	str	r3, [sp, #8]
 80003f2:	2301      	movs	r3, #1
 80003f4:	9301      	str	r3, [sp, #4]
 80003f6:	1dbb      	adds	r3, r7, #6
 80003f8:	9300      	str	r3, [sp, #0]
 80003fa:	2301      	movs	r3, #1
 80003fc:	2190      	movs	r1, #144	@ 0x90
 80003fe:	4804      	ldr	r0, [pc, #16]	@ (8000410 <CS4270_RegWrite+0x38>)
 8000400:	f006 fb36 	bl	8006a70 <HAL_I2C_Mem_Write>
 8000404:	4603      	mov	r3, r0

}
 8000406:	4618      	mov	r0, r3
 8000408:	3708      	adds	r7, #8
 800040a:	46bd      	mov	sp, r7
 800040c:	bd80      	pop	{r7, pc}
 800040e:	bf00      	nop
 8000410:	240003fc 	.word	0x240003fc

08000414 <CS4270_RegRead>:

HAL_StatusTypeDef CS4270_RegRead(uint8_t regAddr, uint8_t *regData) {
 8000414:	b580      	push	{r7, lr}
 8000416:	b086      	sub	sp, #24
 8000418:	af04      	add	r7, sp, #16
 800041a:	4603      	mov	r3, r0
 800041c:	6039      	str	r1, [r7, #0]
 800041e:	71fb      	strb	r3, [r7, #7]

	return HAL_I2C_Mem_Read(&CS4270_I2C_HANDLE, CS4270_I2C_ADDRESS, regAddr, I2C_MEMADD_SIZE_8BIT, regData, 1, HAL_MAX_DELAY);
 8000420:	79fb      	ldrb	r3, [r7, #7]
 8000422:	b29a      	uxth	r2, r3
 8000424:	f04f 33ff 	mov.w	r3, #4294967295
 8000428:	9302      	str	r3, [sp, #8]
 800042a:	2301      	movs	r3, #1
 800042c:	9301      	str	r3, [sp, #4]
 800042e:	683b      	ldr	r3, [r7, #0]
 8000430:	9300      	str	r3, [sp, #0]
 8000432:	2301      	movs	r3, #1
 8000434:	2190      	movs	r1, #144	@ 0x90
 8000436:	4804      	ldr	r0, [pc, #16]	@ (8000448 <CS4270_RegRead+0x34>)
 8000438:	f006 fc2e 	bl	8006c98 <HAL_I2C_Mem_Read>
 800043c:	4603      	mov	r3, r0

}
 800043e:	4618      	mov	r0, r3
 8000440:	3708      	adds	r7, #8
 8000442:	46bd      	mov	sp, r7
 8000444:	bd80      	pop	{r7, pc}
 8000446:	bf00      	nop
 8000448:	240003fc 	.word	0x240003fc
 800044c:	00000000 	.word	0x00000000

08000450 <IFX_Overdrive_Init>:
		  -0.0010648637855421347,
		  -0.0005449777163912186,
		  -0.00020692388031130378
					 };

void IFX_Overdrive_Init(IFX_Overdrive *od, float samplingFrequencyHz, float hpfCutoffFrequencyHz, float odPreGain, float lpfCutoffFrequencyHz, float lpfDamping) {
 8000450:	b480      	push	{r7}
 8000452:	b089      	sub	sp, #36	@ 0x24
 8000454:	af00      	add	r7, sp, #0
 8000456:	6178      	str	r0, [r7, #20]
 8000458:	ed87 0a04 	vstr	s0, [r7, #16]
 800045c:	edc7 0a03 	vstr	s1, [r7, #12]
 8000460:	ed87 1a02 	vstr	s2, [r7, #8]
 8000464:	edc7 1a01 	vstr	s3, [r7, #4]
 8000468:	ed87 2a00 	vstr	s4, [r7]
	/* Sampling time */
	od->T = 1.0f / samplingFrequencyHz;
 800046c:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 8000470:	ed97 7a04 	vldr	s14, [r7, #16]
 8000474:	eec6 7a87 	vdiv.f32	s15, s13, s14
 8000478:	697b      	ldr	r3, [r7, #20]
 800047a:	edc3 7a00 	vstr	s15, [r3]

	/* Input high-pass filter */
	od->hpfInpBufIn[0]  = 0.0f; od->hpfInpBufIn[1]  = 0.0f;
 800047e:	697b      	ldr	r3, [r7, #20]
 8000480:	f04f 0200 	mov.w	r2, #0
 8000484:	f8c3 2120 	str.w	r2, [r3, #288]	@ 0x120
 8000488:	697b      	ldr	r3, [r7, #20]
 800048a:	f04f 0200 	mov.w	r2, #0
 800048e:	f8c3 2124 	str.w	r2, [r3, #292]	@ 0x124
	od->hpfInpBufOut[0] = 0.0f; od->hpfInpBufOut[1] = 0.0f;
 8000492:	697b      	ldr	r3, [r7, #20]
 8000494:	f04f 0200 	mov.w	r2, #0
 8000498:	f8c3 2128 	str.w	r2, [r3, #296]	@ 0x128
 800049c:	697b      	ldr	r3, [r7, #20]
 800049e:	f04f 0200 	mov.w	r2, #0
 80004a2:	f8c3 212c 	str.w	r2, [r3, #300]	@ 0x12c
	od->hpfInpWcT = 2.0f * M_PI * hpfCutoffFrequencyHz * od->T;
 80004a6:	edd7 7a03 	vldr	s15, [r7, #12]
 80004aa:	eeb7 7ae7 	vcvt.f64.f32	d7, s15
 80004ae:	ed9f 6b30 	vldr	d6, [pc, #192]	@ 8000570 <IFX_Overdrive_Init+0x120>
 80004b2:	ee27 6b06 	vmul.f64	d6, d7, d6
 80004b6:	697b      	ldr	r3, [r7, #20]
 80004b8:	edd3 7a00 	vldr	s15, [r3]
 80004bc:	eeb7 7ae7 	vcvt.f64.f32	d7, s15
 80004c0:	ee26 7b07 	vmul.f64	d7, d6, d7
 80004c4:	eef7 7bc7 	vcvt.f32.f64	s15, d7
 80004c8:	697b      	ldr	r3, [r7, #20]
 80004ca:	edc3 7a4c 	vstr	s15, [r3, #304]	@ 0x130
	od->hpfInpOut = 0.0f;
 80004ce:	697b      	ldr	r3, [r7, #20]
 80004d0:	f04f 0200 	mov.w	r2, #0
 80004d4:	f8c3 2134 	str.w	r2, [r3, #308]	@ 0x134

	/* Input low-pass filter */
	for (uint8_t n = 0; n < IFX_OVERDRIVE_LPF_INP_LENGTH; n++) {
 80004d8:	2300      	movs	r3, #0
 80004da:	77fb      	strb	r3, [r7, #31]
 80004dc:	e00a      	b.n	80004f4 <IFX_Overdrive_Init+0xa4>
		od->lpfInpBuf[n] = 0.0f;
 80004de:	7ffb      	ldrb	r3, [r7, #31]
 80004e0:	697a      	ldr	r2, [r7, #20]
 80004e2:	009b      	lsls	r3, r3, #2
 80004e4:	4413      	add	r3, r2
 80004e6:	3304      	adds	r3, #4
 80004e8:	f04f 0200 	mov.w	r2, #0
 80004ec:	601a      	str	r2, [r3, #0]
	for (uint8_t n = 0; n < IFX_OVERDRIVE_LPF_INP_LENGTH; n++) {
 80004ee:	7ffb      	ldrb	r3, [r7, #31]
 80004f0:	3301      	adds	r3, #1
 80004f2:	77fb      	strb	r3, [r7, #31]
 80004f4:	7ffb      	ldrb	r3, [r7, #31]
 80004f6:	2b44      	cmp	r3, #68	@ 0x44
 80004f8:	d9f1      	bls.n	80004de <IFX_Overdrive_Init+0x8e>
	}
	od->lpfInpBufIndex = 0;
 80004fa:	697b      	ldr	r3, [r7, #20]
 80004fc:	2200      	movs	r2, #0
 80004fe:	f883 2118 	strb.w	r2, [r3, #280]	@ 0x118
	od->lpfInpOut   = 0.0f;
 8000502:	697b      	ldr	r3, [r7, #20]
 8000504:	f04f 0200 	mov.w	r2, #0
 8000508:	f8c3 211c 	str.w	r2, [r3, #284]	@ 0x11c

	/* Overdrive settings */
	od->preGain   = odPreGain;
 800050c:	697b      	ldr	r3, [r7, #20]
 800050e:	68ba      	ldr	r2, [r7, #8]
 8000510:	f8c3 2138 	str.w	r2, [r3, #312]	@ 0x138
	od->boostGain = 0.0f;
 8000514:	697b      	ldr	r3, [r7, #20]
 8000516:	f04f 0200 	mov.w	r2, #0
 800051a:	f8c3 213c 	str.w	r2, [r3, #316]	@ 0x13c
	od->threshold = 1.0f / 3.0f;
 800051e:	697b      	ldr	r3, [r7, #20]
 8000520:	4a15      	ldr	r2, [pc, #84]	@ (8000578 <IFX_Overdrive_Init+0x128>)
 8000522:	f8c3 2140 	str.w	r2, [r3, #320]	@ 0x140

	/* Output low-pass filter */
	od->lpfOutWcT  = 2.0f * M_PI * lpfCutoffFrequencyHz * od->T;
 8000526:	edd7 7a01 	vldr	s15, [r7, #4]
 800052a:	eeb7 7ae7 	vcvt.f64.f32	d7, s15
 800052e:	ed9f 6b10 	vldr	d6, [pc, #64]	@ 8000570 <IFX_Overdrive_Init+0x120>
 8000532:	ee27 6b06 	vmul.f64	d6, d7, d6
 8000536:	697b      	ldr	r3, [r7, #20]
 8000538:	edd3 7a00 	vldr	s15, [r3]
 800053c:	eeb7 7ae7 	vcvt.f64.f32	d7, s15
 8000540:	ee26 7b07 	vmul.f64	d7, d6, d7
 8000544:	eef7 7bc7 	vcvt.f32.f64	s15, d7
 8000548:	697b      	ldr	r3, [r7, #20]
 800054a:	edc3 7a57 	vstr	s15, [r3, #348]	@ 0x15c
	od->lpfOutDamp = lpfDamping;
 800054e:	697b      	ldr	r3, [r7, #20]
 8000550:	683a      	ldr	r2, [r7, #0]
 8000552:	f8c3 2160 	str.w	r2, [r3, #352]	@ 0x160

	od->Q = -0.2f;
 8000556:	697b      	ldr	r3, [r7, #20]
 8000558:	4a08      	ldr	r2, [pc, #32]	@ (800057c <IFX_Overdrive_Init+0x12c>)
 800055a:	f8c3 216c 	str.w	r2, [r3, #364]	@ 0x16c
}
 800055e:	bf00      	nop
 8000560:	3724      	adds	r7, #36	@ 0x24
 8000562:	46bd      	mov	sp, r7
 8000564:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000568:	4770      	bx	lr
 800056a:	bf00      	nop
 800056c:	f3af 8000 	nop.w
 8000570:	54442d18 	.word	0x54442d18
 8000574:	401921fb 	.word	0x401921fb
 8000578:	3eaaaaab 	.word	0x3eaaaaab
 800057c:	be4ccccd 	.word	0xbe4ccccd

08000580 <IFX_Overdrive_SetGain>:

void IFX_Overdrive_SetGain(IFX_Overdrive *od, float gain) {
 8000580:	b480      	push	{r7}
 8000582:	b083      	sub	sp, #12
 8000584:	af00      	add	r7, sp, #0
 8000586:	6078      	str	r0, [r7, #4]
 8000588:	ed87 0a00 	vstr	s0, [r7]

	od->preGain = gain;
 800058c:	687b      	ldr	r3, [r7, #4]
 800058e:	683a      	ldr	r2, [r7, #0]
 8000590:	f8c3 2138 	str.w	r2, [r3, #312]	@ 0x138

}
 8000594:	bf00      	nop
 8000596:	370c      	adds	r7, #12
 8000598:	46bd      	mov	sp, r7
 800059a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800059e:	4770      	bx	lr

080005a0 <IFX_Overdrive_SetHPF>:

void IFX_Overdrive_SetHPF(IFX_Overdrive *od, float hpfCutoffFrequencyHz) {
 80005a0:	b480      	push	{r7}
 80005a2:	b083      	sub	sp, #12
 80005a4:	af00      	add	r7, sp, #0
 80005a6:	6078      	str	r0, [r7, #4]
 80005a8:	ed87 0a00 	vstr	s0, [r7]

    od->hpfInpWcT = 2.0f * M_PI * hpfCutoffFrequencyHz * od->T;
 80005ac:	edd7 7a00 	vldr	s15, [r7]
 80005b0:	eeb7 7ae7 	vcvt.f64.f32	d7, s15
 80005b4:	ed9f 6b0a 	vldr	d6, [pc, #40]	@ 80005e0 <IFX_Overdrive_SetHPF+0x40>
 80005b8:	ee27 6b06 	vmul.f64	d6, d7, d6
 80005bc:	687b      	ldr	r3, [r7, #4]
 80005be:	edd3 7a00 	vldr	s15, [r3]
 80005c2:	eeb7 7ae7 	vcvt.f64.f32	d7, s15
 80005c6:	ee26 7b07 	vmul.f64	d7, d6, d7
 80005ca:	eef7 7bc7 	vcvt.f32.f64	s15, d7
 80005ce:	687b      	ldr	r3, [r7, #4]
 80005d0:	edc3 7a4c 	vstr	s15, [r3, #304]	@ 0x130

}
 80005d4:	bf00      	nop
 80005d6:	370c      	adds	r7, #12
 80005d8:	46bd      	mov	sp, r7
 80005da:	f85d 7b04 	ldr.w	r7, [sp], #4
 80005de:	4770      	bx	lr
 80005e0:	54442d18 	.word	0x54442d18
 80005e4:	401921fb 	.word	0x401921fb

080005e8 <IFX_Overdrive_SetLPF>:

void IFX_Overdrive_SetLPF(IFX_Overdrive *od, float lpfCutoffFrequencyHz, float lpfDamping) {
 80005e8:	b480      	push	{r7}
 80005ea:	b085      	sub	sp, #20
 80005ec:	af00      	add	r7, sp, #0
 80005ee:	60f8      	str	r0, [r7, #12]
 80005f0:	ed87 0a02 	vstr	s0, [r7, #8]
 80005f4:	edc7 0a01 	vstr	s1, [r7, #4]

    od->lpfOutWcT  = 2.0f * M_PI * lpfCutoffFrequencyHz * od->T;
 80005f8:	edd7 7a02 	vldr	s15, [r7, #8]
 80005fc:	eeb7 7ae7 	vcvt.f64.f32	d7, s15
 8000600:	ed9f 6b0d 	vldr	d6, [pc, #52]	@ 8000638 <IFX_Overdrive_SetLPF+0x50>
 8000604:	ee27 6b06 	vmul.f64	d6, d7, d6
 8000608:	68fb      	ldr	r3, [r7, #12]
 800060a:	edd3 7a00 	vldr	s15, [r3]
 800060e:	eeb7 7ae7 	vcvt.f64.f32	d7, s15
 8000612:	ee26 7b07 	vmul.f64	d7, d6, d7
 8000616:	eef7 7bc7 	vcvt.f32.f64	s15, d7
 800061a:	68fb      	ldr	r3, [r7, #12]
 800061c:	edc3 7a57 	vstr	s15, [r3, #348]	@ 0x15c
    od->lpfOutDamp = lpfDamping;
 8000620:	68fb      	ldr	r3, [r7, #12]
 8000622:	687a      	ldr	r2, [r7, #4]
 8000624:	f8c3 2160 	str.w	r2, [r3, #352]	@ 0x160

}
 8000628:	bf00      	nop
 800062a:	3714      	adds	r7, #20
 800062c:	46bd      	mov	sp, r7
 800062e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000632:	4770      	bx	lr
 8000634:	f3af 8000 	nop.w
 8000638:	54442d18 	.word	0x54442d18
 800063c:	401921fb 	.word	0x401921fb

08000640 <IFX_Overdrive_Update>:

float IFX_Overdrive_Update(IFX_Overdrive *od, float inp) {
 8000640:	b580      	push	{r7, lr}
 8000642:	ed2d 8b02 	vpush	{d8}
 8000646:	b086      	sub	sp, #24
 8000648:	af00      	add	r7, sp, #0
 800064a:	6078      	str	r0, [r7, #4]
 800064c:	ed87 0a00 	vstr	s0, [r7]
	/* FIR Low-pass filter at fs / 4 as squaring operation will double bandwidth and would otherwise cause aliasing distortion */
	od->lpfInpBuf[od->lpfInpBufIndex] = inp;
 8000650:	687b      	ldr	r3, [r7, #4]
 8000652:	f893 3118 	ldrb.w	r3, [r3, #280]	@ 0x118
 8000656:	687a      	ldr	r2, [r7, #4]
 8000658:	009b      	lsls	r3, r3, #2
 800065a:	4413      	add	r3, r2
 800065c:	3304      	adds	r3, #4
 800065e:	683a      	ldr	r2, [r7, #0]
 8000660:	601a      	str	r2, [r3, #0]
	od->lpfInpBufIndex++;
 8000662:	687b      	ldr	r3, [r7, #4]
 8000664:	f893 3118 	ldrb.w	r3, [r3, #280]	@ 0x118
 8000668:	3301      	adds	r3, #1
 800066a:	b2da      	uxtb	r2, r3
 800066c:	687b      	ldr	r3, [r7, #4]
 800066e:	f883 2118 	strb.w	r2, [r3, #280]	@ 0x118

	if (od->lpfInpBufIndex == IFX_OVERDRIVE_LPF_INP_LENGTH) {
 8000672:	687b      	ldr	r3, [r7, #4]
 8000674:	f893 3118 	ldrb.w	r3, [r3, #280]	@ 0x118
 8000678:	2b45      	cmp	r3, #69	@ 0x45
 800067a:	d103      	bne.n	8000684 <IFX_Overdrive_Update+0x44>
		od->lpfInpBufIndex = 0;
 800067c:	687b      	ldr	r3, [r7, #4]
 800067e:	2200      	movs	r2, #0
 8000680:	f883 2118 	strb.w	r2, [r3, #280]	@ 0x118
	}

	od->lpfInpOut = 0.0f;
 8000684:	687b      	ldr	r3, [r7, #4]
 8000686:	f04f 0200 	mov.w	r2, #0
 800068a:	f8c3 211c 	str.w	r2, [r3, #284]	@ 0x11c
	uint8_t index = od->lpfInpBufIndex;
 800068e:	687b      	ldr	r3, [r7, #4]
 8000690:	f893 3118 	ldrb.w	r3, [r3, #280]	@ 0x118
 8000694:	75fb      	strb	r3, [r7, #23]
	for (uint8_t n = 0; n < IFX_OVERDRIVE_LPF_INP_LENGTH; n++) {
 8000696:	2300      	movs	r3, #0
 8000698:	75bb      	strb	r3, [r7, #22]
 800069a:	e022      	b.n	80006e2 <IFX_Overdrive_Update+0xa2>
		if (index == 0) {
 800069c:	7dfb      	ldrb	r3, [r7, #23]
 800069e:	2b00      	cmp	r3, #0
 80006a0:	d102      	bne.n	80006a8 <IFX_Overdrive_Update+0x68>
			index = IFX_OVERDRIVE_LPF_INP_LENGTH - 1;
 80006a2:	2344      	movs	r3, #68	@ 0x44
 80006a4:	75fb      	strb	r3, [r7, #23]
 80006a6:	e002      	b.n	80006ae <IFX_Overdrive_Update+0x6e>
		} else {
			index--;
 80006a8:	7dfb      	ldrb	r3, [r7, #23]
 80006aa:	3b01      	subs	r3, #1
 80006ac:	75fb      	strb	r3, [r7, #23]
		}

		od->lpfInpOut += IFX_OD_LPF_INP_COEF[n] * od->lpfInpBuf[index];
 80006ae:	687b      	ldr	r3, [r7, #4]
 80006b0:	ed93 7a47 	vldr	s14, [r3, #284]	@ 0x11c
 80006b4:	7dbb      	ldrb	r3, [r7, #22]
 80006b6:	4ab9      	ldr	r2, [pc, #740]	@ (800099c <IFX_Overdrive_Update+0x35c>)
 80006b8:	009b      	lsls	r3, r3, #2
 80006ba:	4413      	add	r3, r2
 80006bc:	edd3 6a00 	vldr	s13, [r3]
 80006c0:	7dfb      	ldrb	r3, [r7, #23]
 80006c2:	687a      	ldr	r2, [r7, #4]
 80006c4:	009b      	lsls	r3, r3, #2
 80006c6:	4413      	add	r3, r2
 80006c8:	3304      	adds	r3, #4
 80006ca:	edd3 7a00 	vldr	s15, [r3]
 80006ce:	ee66 7aa7 	vmul.f32	s15, s13, s15
 80006d2:	ee77 7a27 	vadd.f32	s15, s14, s15
 80006d6:	687b      	ldr	r3, [r7, #4]
 80006d8:	edc3 7a47 	vstr	s15, [r3, #284]	@ 0x11c
	for (uint8_t n = 0; n < IFX_OVERDRIVE_LPF_INP_LENGTH; n++) {
 80006dc:	7dbb      	ldrb	r3, [r7, #22]
 80006de:	3301      	adds	r3, #1
 80006e0:	75bb      	strb	r3, [r7, #22]
 80006e2:	7dbb      	ldrb	r3, [r7, #22]
 80006e4:	2b44      	cmp	r3, #68	@ 0x44
 80006e6:	d9d9      	bls.n	800069c <IFX_Overdrive_Update+0x5c>
	}

	/* Variable first-order IIR High-pass filter to remove some of the low frequency components, as these sound muddy when distorted */
	od->hpfInpBufIn[1] = od->hpfInpBufIn[0];
 80006e8:	687b      	ldr	r3, [r7, #4]
 80006ea:	f8d3 2120 	ldr.w	r2, [r3, #288]	@ 0x120
 80006ee:	687b      	ldr	r3, [r7, #4]
 80006f0:	f8c3 2124 	str.w	r2, [r3, #292]	@ 0x124
	od->hpfInpBufIn[0] = od->lpfInpOut;
 80006f4:	687b      	ldr	r3, [r7, #4]
 80006f6:	f8d3 211c 	ldr.w	r2, [r3, #284]	@ 0x11c
 80006fa:	687b      	ldr	r3, [r7, #4]
 80006fc:	f8c3 2120 	str.w	r2, [r3, #288]	@ 0x120

	od->hpfInpBufOut[1] = od->hpfInpBufOut[0];
 8000700:	687b      	ldr	r3, [r7, #4]
 8000702:	f8d3 2128 	ldr.w	r2, [r3, #296]	@ 0x128
 8000706:	687b      	ldr	r3, [r7, #4]
 8000708:	f8c3 212c 	str.w	r2, [r3, #300]	@ 0x12c
	od->hpfInpBufOut[0] = (2.0f * (od->hpfInpBufIn[0] - od->hpfInpBufIn[1]) + (2.0f - od->hpfInpWcT) * od->hpfInpBufOut[1]) / (2.0f + od->hpfInpWcT);
 800070c:	687b      	ldr	r3, [r7, #4]
 800070e:	ed93 7a48 	vldr	s14, [r3, #288]	@ 0x120
 8000712:	687b      	ldr	r3, [r7, #4]
 8000714:	edd3 7a49 	vldr	s15, [r3, #292]	@ 0x124
 8000718:	ee77 7a67 	vsub.f32	s15, s14, s15
 800071c:	ee37 7aa7 	vadd.f32	s14, s15, s15
 8000720:	687b      	ldr	r3, [r7, #4]
 8000722:	edd3 7a4c 	vldr	s15, [r3, #304]	@ 0x130
 8000726:	eef0 6a00 	vmov.f32	s13, #0	@ 0x40000000  2.0
 800072a:	ee76 6ae7 	vsub.f32	s13, s13, s15
 800072e:	687b      	ldr	r3, [r7, #4]
 8000730:	edd3 7a4b 	vldr	s15, [r3, #300]	@ 0x12c
 8000734:	ee66 7aa7 	vmul.f32	s15, s13, s15
 8000738:	ee77 6a27 	vadd.f32	s13, s14, s15
 800073c:	687b      	ldr	r3, [r7, #4]
 800073e:	edd3 7a4c 	vldr	s15, [r3, #304]	@ 0x130
 8000742:	eeb0 7a00 	vmov.f32	s14, #0	@ 0x40000000  2.0
 8000746:	ee37 7a87 	vadd.f32	s14, s15, s14
 800074a:	eec6 7a87 	vdiv.f32	s15, s13, s14
 800074e:	687b      	ldr	r3, [r7, #4]
 8000750:	edc3 7a4a 	vstr	s15, [r3, #296]	@ 0x128
	od->hpfInpOut = od->hpfInpBufOut[0];
 8000754:	687b      	ldr	r3, [r7, #4]
 8000756:	f8d3 2128 	ldr.w	r2, [r3, #296]	@ 0x128
 800075a:	687b      	ldr	r3, [r7, #4]
 800075c:	f8c3 2134 	str.w	r2, [r3, #308]	@ 0x134
	} else {
		clipOut = signClipIn;
	}*/

	/* Asymmetrical clipping */
	float xGain = od->preGain * od->hpfInpOut;
 8000760:	687b      	ldr	r3, [r7, #4]
 8000762:	ed93 7a4e 	vldr	s14, [r3, #312]	@ 0x138
 8000766:	687b      	ldr	r3, [r7, #4]
 8000768:	edd3 7a4d 	vldr	s15, [r3, #308]	@ 0x134
 800076c:	ee67 7a27 	vmul.f32	s15, s14, s15
 8000770:	edc7 7a03 	vstr	s15, [r7, #12]
	static const float d =  8.0f;

	float clipOut = od->Q / (1.0f - expf(d * od->Q));
 8000774:	687b      	ldr	r3, [r7, #4]
 8000776:	ed93 8a5b 	vldr	s16, [r3, #364]	@ 0x16c
 800077a:	687b      	ldr	r3, [r7, #4]
 800077c:	ed93 7a5b 	vldr	s14, [r3, #364]	@ 0x16c
 8000780:	4b87      	ldr	r3, [pc, #540]	@ (80009a0 <IFX_Overdrive_Update+0x360>)
 8000782:	edd3 7a00 	vldr	s15, [r3]
 8000786:	ee67 7a27 	vmul.f32	s15, s14, s15
 800078a:	eeb0 0a67 	vmov.f32	s0, s15
 800078e:	f012 fc3f 	bl	8013010 <expf>
 8000792:	eef0 7a40 	vmov.f32	s15, s0
 8000796:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 800079a:	ee37 7a67 	vsub.f32	s14, s14, s15
 800079e:	eec8 7a07 	vdiv.f32	s15, s16, s14
 80007a2:	edc7 7a04 	vstr	s15, [r7, #16]

	if ((xGain - od->Q) >= 0.00001f) {
 80007a6:	687b      	ldr	r3, [r7, #4]
 80007a8:	edd3 7a5b 	vldr	s15, [r3, #364]	@ 0x16c
 80007ac:	ed97 7a03 	vldr	s14, [r7, #12]
 80007b0:	ee77 7a67 	vsub.f32	s15, s14, s15
 80007b4:	ed9f 7a7b 	vldr	s14, [pc, #492]	@ 80009a4 <IFX_Overdrive_Update+0x364>
 80007b8:	eef4 7ac7 	vcmpe.f32	s15, s14
 80007bc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80007c0:	db26      	blt.n	8000810 <IFX_Overdrive_Update+0x1d0>

		clipOut += (xGain - od->Q) / (1.0f - expf(-d * (xGain - od->Q)));
 80007c2:	687b      	ldr	r3, [r7, #4]
 80007c4:	edd3 7a5b 	vldr	s15, [r3, #364]	@ 0x16c
 80007c8:	ed97 7a03 	vldr	s14, [r7, #12]
 80007cc:	ee37 8a67 	vsub.f32	s16, s14, s15
 80007d0:	4b73      	ldr	r3, [pc, #460]	@ (80009a0 <IFX_Overdrive_Update+0x360>)
 80007d2:	edd3 7a00 	vldr	s15, [r3]
 80007d6:	eeb1 7a67 	vneg.f32	s14, s15
 80007da:	687b      	ldr	r3, [r7, #4]
 80007dc:	edd3 7a5b 	vldr	s15, [r3, #364]	@ 0x16c
 80007e0:	edd7 6a03 	vldr	s13, [r7, #12]
 80007e4:	ee76 7ae7 	vsub.f32	s15, s13, s15
 80007e8:	ee67 7a27 	vmul.f32	s15, s14, s15
 80007ec:	eeb0 0a67 	vmov.f32	s0, s15
 80007f0:	f012 fc0e 	bl	8013010 <expf>
 80007f4:	eef0 7a40 	vmov.f32	s15, s0
 80007f8:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 80007fc:	ee37 7a67 	vsub.f32	s14, s14, s15
 8000800:	eec8 7a07 	vdiv.f32	s15, s16, s14
 8000804:	ed97 7a04 	vldr	s14, [r7, #16]
 8000808:	ee77 7a27 	vadd.f32	s15, s14, s15
 800080c:	edc7 7a04 	vstr	s15, [r7, #16]

	}

	/* Variable IIR low-pass filter to remove high frequency components after clipping */
	od->lpfOutBufIn[2] = od->lpfOutBufIn[1];
 8000810:	687b      	ldr	r3, [r7, #4]
 8000812:	f8d3 2148 	ldr.w	r2, [r3, #328]	@ 0x148
 8000816:	687b      	ldr	r3, [r7, #4]
 8000818:	f8c3 214c 	str.w	r2, [r3, #332]	@ 0x14c
	od->lpfOutBufIn[1] = od->lpfOutBufIn[0];
 800081c:	687b      	ldr	r3, [r7, #4]
 800081e:	f8d3 2144 	ldr.w	r2, [r3, #324]	@ 0x144
 8000822:	687b      	ldr	r3, [r7, #4]
 8000824:	f8c3 2148 	str.w	r2, [r3, #328]	@ 0x148
	od->lpfOutBufIn[0] = clipOut;
 8000828:	687b      	ldr	r3, [r7, #4]
 800082a:	693a      	ldr	r2, [r7, #16]
 800082c:	f8c3 2144 	str.w	r2, [r3, #324]	@ 0x144

	od->lpfOutBufOut[2] = od->lpfOutBufOut[1];
 8000830:	687b      	ldr	r3, [r7, #4]
 8000832:	f8d3 2154 	ldr.w	r2, [r3, #340]	@ 0x154
 8000836:	687b      	ldr	r3, [r7, #4]
 8000838:	f8c3 2158 	str.w	r2, [r3, #344]	@ 0x158
	od->lpfOutBufOut[1] = od->lpfOutBufOut[0];
 800083c:	687b      	ldr	r3, [r7, #4]
 800083e:	f8d3 2150 	ldr.w	r2, [r3, #336]	@ 0x150
 8000842:	687b      	ldr	r3, [r7, #4]
 8000844:	f8c3 2154 	str.w	r2, [r3, #340]	@ 0x154
	od->lpfOutBufOut[0] = od->lpfOutWcT * od->lpfOutWcT * (od->lpfOutBufIn[0] + 2.0f * od->lpfOutBufIn[1] + od->lpfOutBufIn[2])
 8000848:	687b      	ldr	r3, [r7, #4]
 800084a:	ed93 7a57 	vldr	s14, [r3, #348]	@ 0x15c
 800084e:	687b      	ldr	r3, [r7, #4]
 8000850:	edd3 7a57 	vldr	s15, [r3, #348]	@ 0x15c
 8000854:	ee27 7a27 	vmul.f32	s14, s14, s15
 8000858:	687b      	ldr	r3, [r7, #4]
 800085a:	edd3 6a51 	vldr	s13, [r3, #324]	@ 0x144
 800085e:	687b      	ldr	r3, [r7, #4]
 8000860:	edd3 7a52 	vldr	s15, [r3, #328]	@ 0x148
 8000864:	ee77 7aa7 	vadd.f32	s15, s15, s15
 8000868:	ee76 6aa7 	vadd.f32	s13, s13, s15
 800086c:	687b      	ldr	r3, [r7, #4]
 800086e:	edd3 7a53 	vldr	s15, [r3, #332]	@ 0x14c
 8000872:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8000876:	ee27 7a27 	vmul.f32	s14, s14, s15
						- 2.0f * (od->lpfOutWcT * od->lpfOutWcT - 4.0f) * od->lpfOutBufOut[1]
 800087a:	687b      	ldr	r3, [r7, #4]
 800087c:	edd3 6a57 	vldr	s13, [r3, #348]	@ 0x15c
 8000880:	687b      	ldr	r3, [r7, #4]
 8000882:	edd3 7a57 	vldr	s15, [r3, #348]	@ 0x15c
 8000886:	ee66 7aa7 	vmul.f32	s15, s13, s15
 800088a:	eef1 6a00 	vmov.f32	s13, #16	@ 0x40800000  4.0
 800088e:	ee77 7ae6 	vsub.f32	s15, s15, s13
 8000892:	ee77 6aa7 	vadd.f32	s13, s15, s15
 8000896:	687b      	ldr	r3, [r7, #4]
 8000898:	edd3 7a55 	vldr	s15, [r3, #340]	@ 0x154
 800089c:	ee66 7aa7 	vmul.f32	s15, s13, s15
 80008a0:	ee37 7a67 	vsub.f32	s14, s14, s15
						- (4.0f - 4.0f * od->lpfOutDamp * od->lpfOutWcT + od->lpfOutWcT * od->lpfOutWcT) * od->lpfOutBufOut[2];
 80008a4:	687b      	ldr	r3, [r7, #4]
 80008a6:	edd3 7a58 	vldr	s15, [r3, #352]	@ 0x160
 80008aa:	eef1 6a00 	vmov.f32	s13, #16	@ 0x40800000  4.0
 80008ae:	ee67 6aa6 	vmul.f32	s13, s15, s13
 80008b2:	687b      	ldr	r3, [r7, #4]
 80008b4:	edd3 7a57 	vldr	s15, [r3, #348]	@ 0x15c
 80008b8:	ee66 7aa7 	vmul.f32	s15, s13, s15
 80008bc:	eef1 6a00 	vmov.f32	s13, #16	@ 0x40800000  4.0
 80008c0:	ee76 6ae7 	vsub.f32	s13, s13, s15
 80008c4:	687b      	ldr	r3, [r7, #4]
 80008c6:	ed93 6a57 	vldr	s12, [r3, #348]	@ 0x15c
 80008ca:	687b      	ldr	r3, [r7, #4]
 80008cc:	edd3 7a57 	vldr	s15, [r3, #348]	@ 0x15c
 80008d0:	ee66 7a27 	vmul.f32	s15, s12, s15
 80008d4:	ee76 6aa7 	vadd.f32	s13, s13, s15
 80008d8:	687b      	ldr	r3, [r7, #4]
 80008da:	edd3 7a56 	vldr	s15, [r3, #344]	@ 0x158
 80008de:	ee66 7aa7 	vmul.f32	s15, s13, s15
 80008e2:	ee77 7a67 	vsub.f32	s15, s14, s15
	od->lpfOutBufOut[0] = od->lpfOutWcT * od->lpfOutWcT * (od->lpfOutBufIn[0] + 2.0f * od->lpfOutBufIn[1] + od->lpfOutBufIn[2])
 80008e6:	687b      	ldr	r3, [r7, #4]
 80008e8:	edc3 7a54 	vstr	s15, [r3, #336]	@ 0x150
	od->lpfOutBufOut[0] /= (4.0f + 4.0f * od->lpfOutDamp * od->lpfOutWcT + od->lpfOutWcT * od->lpfOutWcT);
 80008ec:	687b      	ldr	r3, [r7, #4]
 80008ee:	edd3 6a54 	vldr	s13, [r3, #336]	@ 0x150
 80008f2:	687b      	ldr	r3, [r7, #4]
 80008f4:	edd3 7a58 	vldr	s15, [r3, #352]	@ 0x160
 80008f8:	eeb1 7a00 	vmov.f32	s14, #16	@ 0x40800000  4.0
 80008fc:	ee27 7a87 	vmul.f32	s14, s15, s14
 8000900:	687b      	ldr	r3, [r7, #4]
 8000902:	edd3 7a57 	vldr	s15, [r3, #348]	@ 0x15c
 8000906:	ee67 7a27 	vmul.f32	s15, s14, s15
 800090a:	eeb1 7a00 	vmov.f32	s14, #16	@ 0x40800000  4.0
 800090e:	ee37 7a87 	vadd.f32	s14, s15, s14
 8000912:	687b      	ldr	r3, [r7, #4]
 8000914:	ed93 6a57 	vldr	s12, [r3, #348]	@ 0x15c
 8000918:	687b      	ldr	r3, [r7, #4]
 800091a:	edd3 7a57 	vldr	s15, [r3, #348]	@ 0x15c
 800091e:	ee66 7a27 	vmul.f32	s15, s12, s15
 8000922:	ee37 7a27 	vadd.f32	s14, s14, s15
 8000926:	eec6 7a87 	vdiv.f32	s15, s13, s14
 800092a:	687b      	ldr	r3, [r7, #4]
 800092c:	edc3 7a54 	vstr	s15, [r3, #336]	@ 0x150
	od->lpfOutOut = od->lpfOutBufOut[0];
 8000930:	687b      	ldr	r3, [r7, #4]
 8000932:	f8d3 2150 	ldr.w	r2, [r3, #336]	@ 0x150
 8000936:	687b      	ldr	r3, [r7, #4]
 8000938:	f8c3 2164 	str.w	r2, [r3, #356]	@ 0x164

	/* Limit output */
	od->out = od->lpfOutOut;
 800093c:	687b      	ldr	r3, [r7, #4]
 800093e:	f8d3 2164 	ldr.w	r2, [r3, #356]	@ 0x164
 8000942:	687b      	ldr	r3, [r7, #4]
 8000944:	f8c3 2168 	str.w	r2, [r3, #360]	@ 0x168

	if (od->out > 1.0f) {
 8000948:	687b      	ldr	r3, [r7, #4]
 800094a:	edd3 7a5a 	vldr	s15, [r3, #360]	@ 0x168
 800094e:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 8000952:	eef4 7ac7 	vcmpe.f32	s15, s14
 8000956:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800095a:	dd05      	ble.n	8000968 <IFX_Overdrive_Update+0x328>
		od->out = 1.0f;
 800095c:	687b      	ldr	r3, [r7, #4]
 800095e:	f04f 527e 	mov.w	r2, #1065353216	@ 0x3f800000
 8000962:	f8c3 2168 	str.w	r2, [r3, #360]	@ 0x168
 8000966:	e00d      	b.n	8000984 <IFX_Overdrive_Update+0x344>
	} else if (od->out < -1.0f) {
 8000968:	687b      	ldr	r3, [r7, #4]
 800096a:	edd3 7a5a 	vldr	s15, [r3, #360]	@ 0x168
 800096e:	eebf 7a00 	vmov.f32	s14, #240	@ 0xbf800000 -1.0
 8000972:	eef4 7ac7 	vcmpe.f32	s15, s14
 8000976:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800097a:	d503      	bpl.n	8000984 <IFX_Overdrive_Update+0x344>
		od->out = -1.0f;
 800097c:	687b      	ldr	r3, [r7, #4]
 800097e:	4a0a      	ldr	r2, [pc, #40]	@ (80009a8 <IFX_Overdrive_Update+0x368>)
 8000980:	f8c3 2168 	str.w	r2, [r3, #360]	@ 0x168
	}

	return od->out;
 8000984:	687b      	ldr	r3, [r7, #4]
 8000986:	f8d3 3168 	ldr.w	r3, [r3, #360]	@ 0x168
 800098a:	ee07 3a90 	vmov	s15, r3
}
 800098e:	eeb0 0a67 	vmov.f32	s0, s15
 8000992:	3718      	adds	r7, #24
 8000994:	46bd      	mov	sp, r7
 8000996:	ecbd 8b02 	vpop	{d8}
 800099a:	bd80      	pop	{r7, pc}
 800099c:	24000008 	.word	0x24000008
 80009a0:	080131a0 	.word	0x080131a0
 80009a4:	3727c5ac 	.word	0x3727c5ac
 80009a8:	bf800000 	.word	0xbf800000

080009ac <MPU_Init>:
static void MX_I2C1_Init(void);
static void MX_TIM15_Init(void);
static void MX_TIM1_Init(void);
/* USER CODE BEGIN PFP */
void MPU_Init()
{
 80009ac:	b580      	push	{r7, lr}
 80009ae:	b084      	sub	sp, #16
 80009b0:	af00      	add	r7, sp, #0
	MPU_Region_InitTypeDef MPU_InitStruct;

	/* Disable MPU */
	HAL_MPU_Disable();
 80009b2:	f003 fbc7 	bl	8004144 <HAL_MPU_Disable>

	/* Configure RAM CD region as Region N°0, 128kB of size and R/W region */
	MPU_InitStruct.Enable = MPU_REGION_ENABLE;
 80009b6:	2301      	movs	r3, #1
 80009b8:	703b      	strb	r3, [r7, #0]
	MPU_InitStruct.BaseAddress = 0x30000000;
 80009ba:	f04f 5340 	mov.w	r3, #805306368	@ 0x30000000
 80009be:	607b      	str	r3, [r7, #4]
	MPU_InitStruct.Size = MPU_REGION_SIZE_128KB;
 80009c0:	2310      	movs	r3, #16
 80009c2:	723b      	strb	r3, [r7, #8]
	MPU_InitStruct.AccessPermission = MPU_REGION_FULL_ACCESS;
 80009c4:	2303      	movs	r3, #3
 80009c6:	72fb      	strb	r3, [r7, #11]
	MPU_InitStruct.IsBufferable = MPU_ACCESS_NOT_BUFFERABLE;
 80009c8:	2300      	movs	r3, #0
 80009ca:	73fb      	strb	r3, [r7, #15]
	MPU_InitStruct.IsCacheable = MPU_ACCESS_NOT_CACHEABLE;
 80009cc:	2300      	movs	r3, #0
 80009ce:	73bb      	strb	r3, [r7, #14]
	MPU_InitStruct.IsShareable = MPU_ACCESS_SHAREABLE;
 80009d0:	2301      	movs	r3, #1
 80009d2:	737b      	strb	r3, [r7, #13]
	MPU_InitStruct.Number = MPU_REGION_NUMBER0;
 80009d4:	2300      	movs	r3, #0
 80009d6:	707b      	strb	r3, [r7, #1]
	MPU_InitStruct.TypeExtField = MPU_TEX_LEVEL0;
 80009d8:	2300      	movs	r3, #0
 80009da:	72bb      	strb	r3, [r7, #10]
	MPU_InitStruct.SubRegionDisable = 0x00;
 80009dc:	2300      	movs	r3, #0
 80009de:	727b      	strb	r3, [r7, #9]
	MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_ENABLE;
 80009e0:	2300      	movs	r3, #0
 80009e2:	733b      	strb	r3, [r7, #12]
	HAL_MPU_ConfigRegion(&MPU_InitStruct);
 80009e4:	463b      	mov	r3, r7
 80009e6:	4618      	mov	r0, r3
 80009e8:	f003 fbe4 	bl	80041b4 <HAL_MPU_ConfigRegion>

	/* Enable MPU */
	HAL_MPU_Enable(MPU_PRIVILEGED_DEFAULT);
 80009ec:	2004      	movs	r0, #4
 80009ee:	f003 fbc1 	bl	8004174 <HAL_MPU_Enable>
}
 80009f2:	bf00      	nop
 80009f4:	3710      	adds	r7, #16
 80009f6:	46bd      	mov	sp, r7
 80009f8:	bd80      	pop	{r7, pc}
	...

080009fc <Process_HalfBuffer>:

void Process_HalfBuffer() {
 80009fc:	b580      	push	{r7, lr}
 80009fe:	b082      	sub	sp, #8
 8000a00:	af00      	add	r7, sp, #0

	controlSettingsLocked = 1;
 8000a02:	4b80      	ldr	r3, [pc, #512]	@ (8000c04 <Process_HalfBuffer+0x208>)
 8000a04:	2201      	movs	r2, #1
 8000a06:	701a      	strb	r2, [r3, #0]
	// Output samples
	static float leftOut	= 0.0f;
	static float rightOut	= 0.0f;

	// Loop through half of audio buffer (double buffering), convert int->float, apply processing, convert float->int, set output buffers
	for (uint16_t sampleIndex = 0; sampleIndex < (AUDIO_BUFFER_SIZE/2) - 1; sampleIndex += 2) {
 8000a08:	2300      	movs	r3, #0
 8000a0a:	80fb      	strh	r3, [r7, #6]
 8000a0c:	e0ee      	b.n	8000bec <Process_HalfBuffer+0x1f0>
		/*
		 * Convert current input samples (24-bits) to floats (two I2S data lines, two channels per data line)
		 */

		// Extract 24-bits via bit mask
		inBufPtr[sampleIndex]		&= 0xFFFFFF;
 8000a0e:	4b7e      	ldr	r3, [pc, #504]	@ (8000c08 <Process_HalfBuffer+0x20c>)
 8000a10:	681a      	ldr	r2, [r3, #0]
 8000a12:	88fb      	ldrh	r3, [r7, #6]
 8000a14:	009b      	lsls	r3, r3, #2
 8000a16:	4413      	add	r3, r2
 8000a18:	681a      	ldr	r2, [r3, #0]
 8000a1a:	4b7b      	ldr	r3, [pc, #492]	@ (8000c08 <Process_HalfBuffer+0x20c>)
 8000a1c:	6819      	ldr	r1, [r3, #0]
 8000a1e:	88fb      	ldrh	r3, [r7, #6]
 8000a20:	009b      	lsls	r3, r3, #2
 8000a22:	440b      	add	r3, r1
 8000a24:	f022 427f 	bic.w	r2, r2, #4278190080	@ 0xff000000
 8000a28:	601a      	str	r2, [r3, #0]
		inBufPtr[sampleIndex + 1]	&= 0xFFFFFF;
 8000a2a:	4b77      	ldr	r3, [pc, #476]	@ (8000c08 <Process_HalfBuffer+0x20c>)
 8000a2c:	681a      	ldr	r2, [r3, #0]
 8000a2e:	88fb      	ldrh	r3, [r7, #6]
 8000a30:	3301      	adds	r3, #1
 8000a32:	009b      	lsls	r3, r3, #2
 8000a34:	4413      	add	r3, r2
 8000a36:	681a      	ldr	r2, [r3, #0]
 8000a38:	4b73      	ldr	r3, [pc, #460]	@ (8000c08 <Process_HalfBuffer+0x20c>)
 8000a3a:	6819      	ldr	r1, [r3, #0]
 8000a3c:	88fb      	ldrh	r3, [r7, #6]
 8000a3e:	3301      	adds	r3, #1
 8000a40:	009b      	lsls	r3, r3, #2
 8000a42:	440b      	add	r3, r1
 8000a44:	f022 427f 	bic.w	r2, r2, #4278190080	@ 0xff000000
 8000a48:	601a      	str	r2, [r3, #0]

		// Check if number is negative (sign bit)
		if (inBufPtr[sampleIndex] & 0x800000) {
 8000a4a:	4b6f      	ldr	r3, [pc, #444]	@ (8000c08 <Process_HalfBuffer+0x20c>)
 8000a4c:	681a      	ldr	r2, [r3, #0]
 8000a4e:	88fb      	ldrh	r3, [r7, #6]
 8000a50:	009b      	lsls	r3, r3, #2
 8000a52:	4413      	add	r3, r2
 8000a54:	681b      	ldr	r3, [r3, #0]
 8000a56:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
 8000a5a:	2b00      	cmp	r3, #0
 8000a5c:	d00d      	beq.n	8000a7a <Process_HalfBuffer+0x7e>
			inBufPtr[sampleIndex] |= ~0xFFFFFF;
 8000a5e:	4b6a      	ldr	r3, [pc, #424]	@ (8000c08 <Process_HalfBuffer+0x20c>)
 8000a60:	681a      	ldr	r2, [r3, #0]
 8000a62:	88fb      	ldrh	r3, [r7, #6]
 8000a64:	009b      	lsls	r3, r3, #2
 8000a66:	4413      	add	r3, r2
 8000a68:	681a      	ldr	r2, [r3, #0]
 8000a6a:	4b67      	ldr	r3, [pc, #412]	@ (8000c08 <Process_HalfBuffer+0x20c>)
 8000a6c:	6819      	ldr	r1, [r3, #0]
 8000a6e:	88fb      	ldrh	r3, [r7, #6]
 8000a70:	009b      	lsls	r3, r3, #2
 8000a72:	440b      	add	r3, r1
 8000a74:	f042 427f 	orr.w	r2, r2, #4278190080	@ 0xff000000
 8000a78:	601a      	str	r2, [r3, #0]
		}

		if (inBufPtr[sampleIndex + 1] & 0x800000) {
 8000a7a:	4b63      	ldr	r3, [pc, #396]	@ (8000c08 <Process_HalfBuffer+0x20c>)
 8000a7c:	681a      	ldr	r2, [r3, #0]
 8000a7e:	88fb      	ldrh	r3, [r7, #6]
 8000a80:	3301      	adds	r3, #1
 8000a82:	009b      	lsls	r3, r3, #2
 8000a84:	4413      	add	r3, r2
 8000a86:	681b      	ldr	r3, [r3, #0]
 8000a88:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
 8000a8c:	2b00      	cmp	r3, #0
 8000a8e:	d00f      	beq.n	8000ab0 <Process_HalfBuffer+0xb4>
			inBufPtr[sampleIndex + 1] |= ~0xFFFFFF;
 8000a90:	4b5d      	ldr	r3, [pc, #372]	@ (8000c08 <Process_HalfBuffer+0x20c>)
 8000a92:	681a      	ldr	r2, [r3, #0]
 8000a94:	88fb      	ldrh	r3, [r7, #6]
 8000a96:	3301      	adds	r3, #1
 8000a98:	009b      	lsls	r3, r3, #2
 8000a9a:	4413      	add	r3, r2
 8000a9c:	681a      	ldr	r2, [r3, #0]
 8000a9e:	4b5a      	ldr	r3, [pc, #360]	@ (8000c08 <Process_HalfBuffer+0x20c>)
 8000aa0:	6819      	ldr	r1, [r3, #0]
 8000aa2:	88fb      	ldrh	r3, [r7, #6]
 8000aa4:	3301      	adds	r3, #1
 8000aa6:	009b      	lsls	r3, r3, #2
 8000aa8:	440b      	add	r3, r1
 8000aaa:	f042 427f 	orr.w	r2, r2, #4278190080	@ 0xff000000
 8000aae:	601a      	str	r2, [r3, #0]
		}

		// Normalise to float (-1.0, +1.0)
		leftIn  = (float) inBufPtr[sampleIndex]     / (float) (0x7FFFFF);
 8000ab0:	4b55      	ldr	r3, [pc, #340]	@ (8000c08 <Process_HalfBuffer+0x20c>)
 8000ab2:	681a      	ldr	r2, [r3, #0]
 8000ab4:	88fb      	ldrh	r3, [r7, #6]
 8000ab6:	009b      	lsls	r3, r3, #2
 8000ab8:	4413      	add	r3, r2
 8000aba:	681b      	ldr	r3, [r3, #0]
 8000abc:	ee07 3a90 	vmov	s15, r3
 8000ac0:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 8000ac4:	eddf 6a51 	vldr	s13, [pc, #324]	@ 8000c0c <Process_HalfBuffer+0x210>
 8000ac8:	eec7 7a26 	vdiv.f32	s15, s14, s13
 8000acc:	4b50      	ldr	r3, [pc, #320]	@ (8000c10 <Process_HalfBuffer+0x214>)
 8000ace:	edc3 7a00 	vstr	s15, [r3]
		rightIn = (float) inBufPtr[sampleIndex + 1] / (float) (0x7FFFFF);
 8000ad2:	4b4d      	ldr	r3, [pc, #308]	@ (8000c08 <Process_HalfBuffer+0x20c>)
 8000ad4:	681a      	ldr	r2, [r3, #0]
 8000ad6:	88fb      	ldrh	r3, [r7, #6]
 8000ad8:	3301      	adds	r3, #1
 8000ada:	009b      	lsls	r3, r3, #2
 8000adc:	4413      	add	r3, r2
 8000ade:	681b      	ldr	r3, [r3, #0]
 8000ae0:	ee07 3a90 	vmov	s15, r3
 8000ae4:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 8000ae8:	eddf 6a48 	vldr	s13, [pc, #288]	@ 8000c0c <Process_HalfBuffer+0x210>
 8000aec:	eec7 7a26 	vdiv.f32	s15, s14, s13
 8000af0:	4b48      	ldr	r3, [pc, #288]	@ (8000c14 <Process_HalfBuffer+0x218>)
 8000af2:	edc3 7a00 	vstr	s15, [r3]

		/*
		 * Apply processing
		 */
		leftOut  = outputVolume * IFX_Overdrive_Update(&od, leftIn);//(0.25f * leftIn + 0.75f * rightIn); //IFX_Delay_Update(&dly, leftIn);
 8000af6:	4b46      	ldr	r3, [pc, #280]	@ (8000c10 <Process_HalfBuffer+0x214>)
 8000af8:	edd3 7a00 	vldr	s15, [r3]
 8000afc:	eeb0 0a67 	vmov.f32	s0, s15
 8000b00:	4845      	ldr	r0, [pc, #276]	@ (8000c18 <Process_HalfBuffer+0x21c>)
 8000b02:	f7ff fd9d 	bl	8000640 <IFX_Overdrive_Update>
 8000b06:	eeb0 7a40 	vmov.f32	s14, s0
 8000b0a:	4b44      	ldr	r3, [pc, #272]	@ (8000c1c <Process_HalfBuffer+0x220>)
 8000b0c:	edd3 7a00 	vldr	s15, [r3]
 8000b10:	ee67 7a27 	vmul.f32	s15, s14, s15
 8000b14:	4b42      	ldr	r3, [pc, #264]	@ (8000c20 <Process_HalfBuffer+0x224>)
 8000b16:	edc3 7a00 	vstr	s15, [r3]
		rightOut = outputVolume * rightIn;
 8000b1a:	4b40      	ldr	r3, [pc, #256]	@ (8000c1c <Process_HalfBuffer+0x220>)
 8000b1c:	ed93 7a00 	vldr	s14, [r3]
 8000b20:	4b3c      	ldr	r3, [pc, #240]	@ (8000c14 <Process_HalfBuffer+0x218>)
 8000b22:	edd3 7a00 	vldr	s15, [r3]
 8000b26:	ee67 7a27 	vmul.f32	s15, s14, s15
 8000b2a:	4b3e      	ldr	r3, [pc, #248]	@ (8000c24 <Process_HalfBuffer+0x228>)
 8000b2c:	edc3 7a00 	vstr	s15, [r3]
		/*
		 * Convert floats to 32-bit output samples
		 */

		// Ensure output samples are within [-1.0,+1.0] range
		if (leftOut < -1.0f) {
 8000b30:	4b3b      	ldr	r3, [pc, #236]	@ (8000c20 <Process_HalfBuffer+0x224>)
 8000b32:	edd3 7a00 	vldr	s15, [r3]
 8000b36:	eebf 7a00 	vmov.f32	s14, #240	@ 0xbf800000 -1.0
 8000b3a:	eef4 7ac7 	vcmpe.f32	s15, s14
 8000b3e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8000b42:	d503      	bpl.n	8000b4c <Process_HalfBuffer+0x150>
			leftOut = -1.0f;
 8000b44:	4b36      	ldr	r3, [pc, #216]	@ (8000c20 <Process_HalfBuffer+0x224>)
 8000b46:	4a38      	ldr	r2, [pc, #224]	@ (8000c28 <Process_HalfBuffer+0x22c>)
 8000b48:	601a      	str	r2, [r3, #0]
 8000b4a:	e00d      	b.n	8000b68 <Process_HalfBuffer+0x16c>
		} else if (leftOut > 1.0f) {
 8000b4c:	4b34      	ldr	r3, [pc, #208]	@ (8000c20 <Process_HalfBuffer+0x224>)
 8000b4e:	edd3 7a00 	vldr	s15, [r3]
 8000b52:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 8000b56:	eef4 7ac7 	vcmpe.f32	s15, s14
 8000b5a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8000b5e:	dd03      	ble.n	8000b68 <Process_HalfBuffer+0x16c>
			leftOut =  1.0f;
 8000b60:	4b2f      	ldr	r3, [pc, #188]	@ (8000c20 <Process_HalfBuffer+0x224>)
 8000b62:	f04f 527e 	mov.w	r2, #1065353216	@ 0x3f800000
 8000b66:	601a      	str	r2, [r3, #0]
		}

		if (rightOut < -1.0f) {
 8000b68:	4b2e      	ldr	r3, [pc, #184]	@ (8000c24 <Process_HalfBuffer+0x228>)
 8000b6a:	edd3 7a00 	vldr	s15, [r3]
 8000b6e:	eebf 7a00 	vmov.f32	s14, #240	@ 0xbf800000 -1.0
 8000b72:	eef4 7ac7 	vcmpe.f32	s15, s14
 8000b76:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8000b7a:	d503      	bpl.n	8000b84 <Process_HalfBuffer+0x188>
			rightOut = -1.0f;
 8000b7c:	4b29      	ldr	r3, [pc, #164]	@ (8000c24 <Process_HalfBuffer+0x228>)
 8000b7e:	4a2a      	ldr	r2, [pc, #168]	@ (8000c28 <Process_HalfBuffer+0x22c>)
 8000b80:	601a      	str	r2, [r3, #0]
 8000b82:	e00d      	b.n	8000ba0 <Process_HalfBuffer+0x1a4>
		} else if (rightOut > 1.0f) {
 8000b84:	4b27      	ldr	r3, [pc, #156]	@ (8000c24 <Process_HalfBuffer+0x228>)
 8000b86:	edd3 7a00 	vldr	s15, [r3]
 8000b8a:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 8000b8e:	eef4 7ac7 	vcmpe.f32	s15, s14
 8000b92:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8000b96:	dd03      	ble.n	8000ba0 <Process_HalfBuffer+0x1a4>
			rightOut =  1.0f;
 8000b98:	4b22      	ldr	r3, [pc, #136]	@ (8000c24 <Process_HalfBuffer+0x228>)
 8000b9a:	f04f 527e 	mov.w	r2, #1065353216	@ 0x3f800000
 8000b9e:	601a      	str	r2, [r3, #0]
		}

		// Scale to 24-bit signed integer and set output buffer
		outBufPtr[sampleIndex]	   = (int32_t) (leftOut  * 0x7FFFFF);
 8000ba0:	4b1f      	ldr	r3, [pc, #124]	@ (8000c20 <Process_HalfBuffer+0x224>)
 8000ba2:	edd3 7a00 	vldr	s15, [r3]
 8000ba6:	ed9f 7a19 	vldr	s14, [pc, #100]	@ 8000c0c <Process_HalfBuffer+0x210>
 8000baa:	ee67 7a87 	vmul.f32	s15, s15, s14
 8000bae:	4b1f      	ldr	r3, [pc, #124]	@ (8000c2c <Process_HalfBuffer+0x230>)
 8000bb0:	681a      	ldr	r2, [r3, #0]
 8000bb2:	88fb      	ldrh	r3, [r7, #6]
 8000bb4:	009b      	lsls	r3, r3, #2
 8000bb6:	4413      	add	r3, r2
 8000bb8:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8000bbc:	ee17 2a90 	vmov	r2, s15
 8000bc0:	601a      	str	r2, [r3, #0]
		outBufPtr[sampleIndex + 1] = (int32_t) (rightOut * 0x7FFFFF);
 8000bc2:	4b18      	ldr	r3, [pc, #96]	@ (8000c24 <Process_HalfBuffer+0x228>)
 8000bc4:	edd3 7a00 	vldr	s15, [r3]
 8000bc8:	ed9f 7a10 	vldr	s14, [pc, #64]	@ 8000c0c <Process_HalfBuffer+0x210>
 8000bcc:	ee67 7a87 	vmul.f32	s15, s15, s14
 8000bd0:	4b16      	ldr	r3, [pc, #88]	@ (8000c2c <Process_HalfBuffer+0x230>)
 8000bd2:	681a      	ldr	r2, [r3, #0]
 8000bd4:	88fb      	ldrh	r3, [r7, #6]
 8000bd6:	3301      	adds	r3, #1
 8000bd8:	009b      	lsls	r3, r3, #2
 8000bda:	4413      	add	r3, r2
 8000bdc:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8000be0:	ee17 2a90 	vmov	r2, s15
 8000be4:	601a      	str	r2, [r3, #0]
	for (uint16_t sampleIndex = 0; sampleIndex < (AUDIO_BUFFER_SIZE/2) - 1; sampleIndex += 2) {
 8000be6:	88fb      	ldrh	r3, [r7, #6]
 8000be8:	3302      	adds	r3, #2
 8000bea:	80fb      	strh	r3, [r7, #6]
 8000bec:	88fb      	ldrh	r3, [r7, #6]
 8000bee:	2b7e      	cmp	r3, #126	@ 0x7e
 8000bf0:	f67f af0d 	bls.w	8000a0e <Process_HalfBuffer+0x12>


	}

	controlSettingsLocked = 0;
 8000bf4:	4b03      	ldr	r3, [pc, #12]	@ (8000c04 <Process_HalfBuffer+0x208>)
 8000bf6:	2200      	movs	r2, #0
 8000bf8:	701a      	strb	r2, [r3, #0]

}
 8000bfa:	bf00      	nop
 8000bfc:	3708      	adds	r7, #8
 8000bfe:	46bd      	mov	sp, r7
 8000c00:	bd80      	pop	{r7, pc}
 8000c02:	bf00      	nop
 8000c04:	300009a0 	.word	0x300009a0
 8000c08:	30000974 	.word	0x30000974
 8000c0c:	4afffffe 	.word	0x4afffffe
 8000c10:	240007b0 	.word	0x240007b0
 8000c14:	240007b4 	.word	0x240007b4
 8000c18:	30000000 	.word	0x30000000
 8000c1c:	300009a4 	.word	0x300009a4
 8000c20:	240007b8 	.word	0x240007b8
 8000c24:	240007bc 	.word	0x240007bc
 8000c28:	bf800000 	.word	0xbf800000
 8000c2c:	30000978 	.word	0x30000978

08000c30 <HAL_SAI_RxHalfCpltCallback>:

}
*/

/* ADC Callbacks */
void HAL_SAI_RxHalfCpltCallback(SAI_HandleTypeDef *hsai) {
 8000c30:	b580      	push	{r7, lr}
 8000c32:	b082      	sub	sp, #8
 8000c34:	af00      	add	r7, sp, #0
 8000c36:	6078      	str	r0, [r7, #4]

	inBufPtr  = &(adcBuf[0]);
 8000c38:	4b05      	ldr	r3, [pc, #20]	@ (8000c50 <HAL_SAI_RxHalfCpltCallback+0x20>)
 8000c3a:	4a06      	ldr	r2, [pc, #24]	@ (8000c54 <HAL_SAI_RxHalfCpltCallback+0x24>)
 8000c3c:	601a      	str	r2, [r3, #0]
	outBufPtr = &(dacBuf[0]);
 8000c3e:	4b06      	ldr	r3, [pc, #24]	@ (8000c58 <HAL_SAI_RxHalfCpltCallback+0x28>)
 8000c40:	4a06      	ldr	r2, [pc, #24]	@ (8000c5c <HAL_SAI_RxHalfCpltCallback+0x2c>)
 8000c42:	601a      	str	r2, [r3, #0]

	Process_HalfBuffer();
 8000c44:	f7ff feda 	bl	80009fc <Process_HalfBuffer>

}
 8000c48:	bf00      	nop
 8000c4a:	3708      	adds	r7, #8
 8000c4c:	46bd      	mov	sp, r7
 8000c4e:	bd80      	pop	{r7, pc}
 8000c50:	30000974 	.word	0x30000974
 8000c54:	30000174 	.word	0x30000174
 8000c58:	30000978 	.word	0x30000978
 8000c5c:	30000574 	.word	0x30000574

08000c60 <HAL_SAI_RxCpltCallback>:

void HAL_SAI_RxCpltCallback(SAI_HandleTypeDef *hsai) {
 8000c60:	b580      	push	{r7, lr}
 8000c62:	b082      	sub	sp, #8
 8000c64:	af00      	add	r7, sp, #0
 8000c66:	6078      	str	r0, [r7, #4]

	inBufPtr  = &(adcBuf[AUDIO_BUFFER_SIZE/2]);
 8000c68:	4b05      	ldr	r3, [pc, #20]	@ (8000c80 <HAL_SAI_RxCpltCallback+0x20>)
 8000c6a:	4a06      	ldr	r2, [pc, #24]	@ (8000c84 <HAL_SAI_RxCpltCallback+0x24>)
 8000c6c:	601a      	str	r2, [r3, #0]
	outBufPtr = &(dacBuf[AUDIO_BUFFER_SIZE/2]);
 8000c6e:	4b06      	ldr	r3, [pc, #24]	@ (8000c88 <HAL_SAI_RxCpltCallback+0x28>)
 8000c70:	4a06      	ldr	r2, [pc, #24]	@ (8000c8c <HAL_SAI_RxCpltCallback+0x2c>)
 8000c72:	601a      	str	r2, [r3, #0]

	Process_HalfBuffer();
 8000c74:	f7ff fec2 	bl	80009fc <Process_HalfBuffer>

}
 8000c78:	bf00      	nop
 8000c7a:	3708      	adds	r7, #8
 8000c7c:	46bd      	mov	sp, r7
 8000c7e:	bd80      	pop	{r7, pc}
 8000c80:	30000974 	.word	0x30000974
 8000c84:	30000374 	.word	0x30000374
 8000c88:	30000978 	.word	0x30000978
 8000c8c:	30000774 	.word	0x30000774

08000c90 <HAL_ADC_ConvCpltCallback>:

void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef *hadc) {
 8000c90:	b480      	push	{r7}
 8000c92:	b083      	sub	sp, #12
 8000c94:	af00      	add	r7, sp, #0
 8000c96:	6078      	str	r0, [r7, #4]

	if (hadc->Instance == ADC1) {
 8000c98:	687b      	ldr	r3, [r7, #4]
 8000c9a:	681b      	ldr	r3, [r3, #0]
 8000c9c:	4a05      	ldr	r2, [pc, #20]	@ (8000cb4 <HAL_ADC_ConvCpltCallback+0x24>)
 8000c9e:	4293      	cmp	r3, r2
 8000ca0:	d102      	bne.n	8000ca8 <HAL_ADC_ConvCpltCallback+0x18>

		controlSettingsFlag = 1;
 8000ca2:	4b05      	ldr	r3, [pc, #20]	@ (8000cb8 <HAL_ADC_ConvCpltCallback+0x28>)
 8000ca4:	2201      	movs	r2, #1
 8000ca6:	701a      	strb	r2, [r3, #0]

	}

}
 8000ca8:	bf00      	nop
 8000caa:	370c      	adds	r7, #12
 8000cac:	46bd      	mov	sp, r7
 8000cae:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000cb2:	4770      	bx	lr
 8000cb4:	40022000 	.word	0x40022000
 8000cb8:	300009a1 	.word	0x300009a1

08000cbc <SetLED>:

void SetLED(uint8_t index, uint8_t intensity) {
 8000cbc:	b480      	push	{r7}
 8000cbe:	b083      	sub	sp, #12
 8000cc0:	af00      	add	r7, sp, #0
 8000cc2:	4603      	mov	r3, r0
 8000cc4:	460a      	mov	r2, r1
 8000cc6:	71fb      	strb	r3, [r7, #7]
 8000cc8:	4613      	mov	r3, r2
 8000cca:	71bb      	strb	r3, [r7, #6]

	if (index == 0) {
 8000ccc:	79fb      	ldrb	r3, [r7, #7]
 8000cce:	2b00      	cmp	r3, #0
 8000cd0:	d104      	bne.n	8000cdc <SetLED+0x20>

		htim1.Instance->CCR1 = intensity;
 8000cd2:	4b07      	ldr	r3, [pc, #28]	@ (8000cf0 <SetLED+0x34>)
 8000cd4:	681b      	ldr	r3, [r3, #0]
 8000cd6:	79ba      	ldrb	r2, [r7, #6]
 8000cd8:	635a      	str	r2, [r3, #52]	@ 0x34

		htim15.Instance->CCR1 = intensity;

	}

}
 8000cda:	e003      	b.n	8000ce4 <SetLED+0x28>
		htim15.Instance->CCR1 = intensity;
 8000cdc:	4b05      	ldr	r3, [pc, #20]	@ (8000cf4 <SetLED+0x38>)
 8000cde:	681b      	ldr	r3, [r3, #0]
 8000ce0:	79ba      	ldrb	r2, [r7, #6]
 8000ce2:	635a      	str	r2, [r3, #52]	@ 0x34
}
 8000ce4:	bf00      	nop
 8000ce6:	370c      	adds	r7, #12
 8000ce8:	46bd      	mov	sp, r7
 8000cea:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000cee:	4770      	bx	lr
 8000cf0:	240006cc 	.word	0x240006cc
 8000cf4:	24000764 	.word	0x24000764

08000cf8 <Error_LED>:

void Error_LED() {
 8000cf8:	b580      	push	{r7, lr}
 8000cfa:	af00      	add	r7, sp, #0

	while (1) {

		SetLED(0, 0);
 8000cfc:	2100      	movs	r1, #0
 8000cfe:	2000      	movs	r0, #0
 8000d00:	f7ff ffdc 	bl	8000cbc <SetLED>
		SetLED(1, 0);
 8000d04:	2100      	movs	r1, #0
 8000d06:	2001      	movs	r0, #1
 8000d08:	f7ff ffd8 	bl	8000cbc <SetLED>
		HAL_Delay(500);
 8000d0c:	f44f 70fa 	mov.w	r0, #500	@ 0x1f4
 8000d10:	f001 fe32 	bl	8002978 <HAL_Delay>

		SetLED(0, 50);
 8000d14:	2132      	movs	r1, #50	@ 0x32
 8000d16:	2000      	movs	r0, #0
 8000d18:	f7ff ffd0 	bl	8000cbc <SetLED>
		SetLED(1, 50);
 8000d1c:	2132      	movs	r1, #50	@ 0x32
 8000d1e:	2001      	movs	r0, #1
 8000d20:	f7ff ffcc 	bl	8000cbc <SetLED>
		HAL_Delay(500);
 8000d24:	f44f 70fa 	mov.w	r0, #500	@ 0x1f4
 8000d28:	f001 fe26 	bl	8002978 <HAL_Delay>
		SetLED(0, 0);
 8000d2c:	bf00      	nop
 8000d2e:	e7e5      	b.n	8000cfc <Error_LED+0x4>

08000d30 <HAL_GPIO_EXTI_Callback>:
/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
 8000d30:	b580      	push	{r7, lr}
 8000d32:	b082      	sub	sp, #8
 8000d34:	af00      	add	r7, sp, #0
 8000d36:	4603      	mov	r3, r0
 8000d38:	80fb      	strh	r3, [r7, #6]

	// OD/Noise gate
	if (GPIO_Pin == FX1_EN_Pin) {
 8000d3a:	88fb      	ldrh	r3, [r7, #6]
 8000d3c:	2b40      	cmp	r3, #64	@ 0x40
 8000d3e:	d11a      	bne.n	8000d76 <HAL_GPIO_EXTI_Callback+0x46>

		fxEnabled1 = fxEnabled1 ? 0 : 1;
 8000d40:	4b24      	ldr	r3, [pc, #144]	@ (8000dd4 <HAL_GPIO_EXTI_Callback+0xa4>)
 8000d42:	781b      	ldrb	r3, [r3, #0]
 8000d44:	2b00      	cmp	r3, #0
 8000d46:	bf0c      	ite	eq
 8000d48:	2301      	moveq	r3, #1
 8000d4a:	2300      	movne	r3, #0
 8000d4c:	b2db      	uxtb	r3, r3
 8000d4e:	461a      	mov	r2, r3
 8000d50:	4b20      	ldr	r3, [pc, #128]	@ (8000dd4 <HAL_GPIO_EXTI_Callback+0xa4>)
 8000d52:	701a      	strb	r2, [r3, #0]
		SetLED(0, 50 * fxEnabled1);
 8000d54:	4b1f      	ldr	r3, [pc, #124]	@ (8000dd4 <HAL_GPIO_EXTI_Callback+0xa4>)
 8000d56:	781b      	ldrb	r3, [r3, #0]
 8000d58:	461a      	mov	r2, r3
 8000d5a:	0092      	lsls	r2, r2, #2
 8000d5c:	4413      	add	r3, r2
 8000d5e:	461a      	mov	r2, r3
 8000d60:	0091      	lsls	r1, r2, #2
 8000d62:	461a      	mov	r2, r3
 8000d64:	460b      	mov	r3, r1
 8000d66:	4413      	add	r3, r2
 8000d68:	005b      	lsls	r3, r3, #1
 8000d6a:	b2db      	uxtb	r3, r3
 8000d6c:	4619      	mov	r1, r3
 8000d6e:	2000      	movs	r0, #0
 8000d70:	f7ff ffa4 	bl	8000cbc <SetLED>

		od.boostGain = fxEnabled2 * OD_GAIN_BOOST;

	}

}
 8000d74:	e029      	b.n	8000dca <HAL_GPIO_EXTI_Callback+0x9a>
	} else if (GPIO_Pin == FX2_EN_Pin) {
 8000d76:	88fb      	ldrh	r3, [r7, #6]
 8000d78:	2b10      	cmp	r3, #16
 8000d7a:	d126      	bne.n	8000dca <HAL_GPIO_EXTI_Callback+0x9a>
		fxEnabled2 = fxEnabled2 ? 0 : 1;
 8000d7c:	4b16      	ldr	r3, [pc, #88]	@ (8000dd8 <HAL_GPIO_EXTI_Callback+0xa8>)
 8000d7e:	781b      	ldrb	r3, [r3, #0]
 8000d80:	2b00      	cmp	r3, #0
 8000d82:	bf0c      	ite	eq
 8000d84:	2301      	moveq	r3, #1
 8000d86:	2300      	movne	r3, #0
 8000d88:	b2db      	uxtb	r3, r3
 8000d8a:	461a      	mov	r2, r3
 8000d8c:	4b12      	ldr	r3, [pc, #72]	@ (8000dd8 <HAL_GPIO_EXTI_Callback+0xa8>)
 8000d8e:	701a      	strb	r2, [r3, #0]
		SetLED(1, 50 * fxEnabled2);
 8000d90:	4b11      	ldr	r3, [pc, #68]	@ (8000dd8 <HAL_GPIO_EXTI_Callback+0xa8>)
 8000d92:	781b      	ldrb	r3, [r3, #0]
 8000d94:	461a      	mov	r2, r3
 8000d96:	0092      	lsls	r2, r2, #2
 8000d98:	4413      	add	r3, r2
 8000d9a:	461a      	mov	r2, r3
 8000d9c:	0091      	lsls	r1, r2, #2
 8000d9e:	461a      	mov	r2, r3
 8000da0:	460b      	mov	r3, r1
 8000da2:	4413      	add	r3, r2
 8000da4:	005b      	lsls	r3, r3, #1
 8000da6:	b2db      	uxtb	r3, r3
 8000da8:	4619      	mov	r1, r3
 8000daa:	2001      	movs	r0, #1
 8000dac:	f7ff ff86 	bl	8000cbc <SetLED>
		od.boostGain = fxEnabled2 * OD_GAIN_BOOST;
 8000db0:	4b09      	ldr	r3, [pc, #36]	@ (8000dd8 <HAL_GPIO_EXTI_Callback+0xa8>)
 8000db2:	781b      	ldrb	r3, [r3, #0]
 8000db4:	ee07 3a90 	vmov	s15, r3
 8000db8:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8000dbc:	ed9f 7a07 	vldr	s14, [pc, #28]	@ 8000ddc <HAL_GPIO_EXTI_Callback+0xac>
 8000dc0:	ee67 7a87 	vmul.f32	s15, s15, s14
 8000dc4:	4b06      	ldr	r3, [pc, #24]	@ (8000de0 <HAL_GPIO_EXTI_Callback+0xb0>)
 8000dc6:	edc3 7a4f 	vstr	s15, [r3, #316]	@ 0x13c
}
 8000dca:	bf00      	nop
 8000dcc:	3708      	adds	r7, #8
 8000dce:	46bd      	mov	sp, r7
 8000dd0:	bd80      	pop	{r7, pc}
 8000dd2:	bf00      	nop
 8000dd4:	30000170 	.word	0x30000170
 8000dd8:	30000171 	.word	0x30000171
 8000ddc:	42c80000 	.word	0x42c80000
 8000de0:	30000000 	.word	0x30000000

08000de4 <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
 8000de4:	b580      	push	{r7, lr}
 8000de6:	b08a      	sub	sp, #40	@ 0x28
 8000de8:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN 1 */
  MPU_Init();
 8000dea:	f7ff fddf 	bl	80009ac <MPU_Init>
  \details Turns on I-Cache
  */
__STATIC_FORCEINLINE void SCB_EnableICache (void)
{
  #if defined (__ICACHE_PRESENT) && (__ICACHE_PRESENT == 1U)
    if (SCB->CCR & SCB_CCR_IC_Msk) return;  /* return if ICache is already enabled */
 8000dee:	4bb2      	ldr	r3, [pc, #712]	@ (80010b8 <main+0x2d4>)
 8000df0:	695b      	ldr	r3, [r3, #20]
 8000df2:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 8000df6:	2b00      	cmp	r3, #0
 8000df8:	d11b      	bne.n	8000e32 <main+0x4e>
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 8000dfa:	f3bf 8f4f 	dsb	sy
}
 8000dfe:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
 8000e00:	f3bf 8f6f 	isb	sy
}
 8000e04:	bf00      	nop

    __DSB();
    __ISB();
    SCB->ICIALLU = 0UL;                     /* invalidate I-Cache */
 8000e06:	4bac      	ldr	r3, [pc, #688]	@ (80010b8 <main+0x2d4>)
 8000e08:	2200      	movs	r2, #0
 8000e0a:	f8c3 2250 	str.w	r2, [r3, #592]	@ 0x250
  __ASM volatile ("dsb 0xF":::"memory");
 8000e0e:	f3bf 8f4f 	dsb	sy
}
 8000e12:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
 8000e14:	f3bf 8f6f 	isb	sy
}
 8000e18:	bf00      	nop
    __DSB();
    __ISB();
    SCB->CCR |=  (uint32_t)SCB_CCR_IC_Msk;  /* enable I-Cache */
 8000e1a:	4ba7      	ldr	r3, [pc, #668]	@ (80010b8 <main+0x2d4>)
 8000e1c:	695b      	ldr	r3, [r3, #20]
 8000e1e:	4aa6      	ldr	r2, [pc, #664]	@ (80010b8 <main+0x2d4>)
 8000e20:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 8000e24:	6153      	str	r3, [r2, #20]
  __ASM volatile ("dsb 0xF":::"memory");
 8000e26:	f3bf 8f4f 	dsb	sy
}
 8000e2a:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
 8000e2c:	f3bf 8f6f 	isb	sy
}
 8000e30:	e000      	b.n	8000e34 <main+0x50>
    if (SCB->CCR & SCB_CCR_IC_Msk) return;  /* return if ICache is already enabled */
 8000e32:	bf00      	nop
  #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
    uint32_t ccsidr;
    uint32_t sets;
    uint32_t ways;

    if (SCB->CCR & SCB_CCR_DC_Msk) return;  /* return if DCache is already enabled */
 8000e34:	4ba0      	ldr	r3, [pc, #640]	@ (80010b8 <main+0x2d4>)
 8000e36:	695b      	ldr	r3, [r3, #20]
 8000e38:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 8000e3c:	2b00      	cmp	r3, #0
 8000e3e:	d138      	bne.n	8000eb2 <main+0xce>

    SCB->CSSELR = 0U;                       /* select Level 1 data cache */
 8000e40:	4b9d      	ldr	r3, [pc, #628]	@ (80010b8 <main+0x2d4>)
 8000e42:	2200      	movs	r2, #0
 8000e44:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
  __ASM volatile ("dsb 0xF":::"memory");
 8000e48:	f3bf 8f4f 	dsb	sy
}
 8000e4c:	bf00      	nop
    __DSB();

    ccsidr = SCB->CCSIDR;
 8000e4e:	4b9a      	ldr	r3, [pc, #616]	@ (80010b8 <main+0x2d4>)
 8000e50:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
 8000e54:	623b      	str	r3, [r7, #32]

                                            /* invalidate D-Cache */
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
 8000e56:	6a3b      	ldr	r3, [r7, #32]
 8000e58:	0b5b      	lsrs	r3, r3, #13
 8000e5a:	f3c3 030e 	ubfx	r3, r3, #0, #15
 8000e5e:	61fb      	str	r3, [r7, #28]
    do {
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
 8000e60:	6a3b      	ldr	r3, [r7, #32]
 8000e62:	08db      	lsrs	r3, r3, #3
 8000e64:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8000e68:	61bb      	str	r3, [r7, #24]
      do {
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 8000e6a:	69fb      	ldr	r3, [r7, #28]
 8000e6c:	015a      	lsls	r2, r3, #5
 8000e6e:	f643 73e0 	movw	r3, #16352	@ 0x3fe0
 8000e72:	4013      	ands	r3, r2
                      ((ways << SCB_DCISW_WAY_Pos) & SCB_DCISW_WAY_Msk)  );
 8000e74:	69ba      	ldr	r2, [r7, #24]
 8000e76:	0792      	lsls	r2, r2, #30
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 8000e78:	498f      	ldr	r1, [pc, #572]	@ (80010b8 <main+0x2d4>)
 8000e7a:	4313      	orrs	r3, r2
 8000e7c:	f8c1 3260 	str.w	r3, [r1, #608]	@ 0x260
        #if defined ( __CC_ARM )
          __schedule_barrier();
        #endif
      } while (ways-- != 0U);
 8000e80:	69bb      	ldr	r3, [r7, #24]
 8000e82:	1e5a      	subs	r2, r3, #1
 8000e84:	61ba      	str	r2, [r7, #24]
 8000e86:	2b00      	cmp	r3, #0
 8000e88:	d1ef      	bne.n	8000e6a <main+0x86>
    } while(sets-- != 0U);
 8000e8a:	69fb      	ldr	r3, [r7, #28]
 8000e8c:	1e5a      	subs	r2, r3, #1
 8000e8e:	61fa      	str	r2, [r7, #28]
 8000e90:	2b00      	cmp	r3, #0
 8000e92:	d1e5      	bne.n	8000e60 <main+0x7c>
  __ASM volatile ("dsb 0xF":::"memory");
 8000e94:	f3bf 8f4f 	dsb	sy
}
 8000e98:	bf00      	nop
    __DSB();

    SCB->CCR |=  (uint32_t)SCB_CCR_DC_Msk;  /* enable D-Cache */
 8000e9a:	4b87      	ldr	r3, [pc, #540]	@ (80010b8 <main+0x2d4>)
 8000e9c:	695b      	ldr	r3, [r3, #20]
 8000e9e:	4a86      	ldr	r2, [pc, #536]	@ (80010b8 <main+0x2d4>)
 8000ea0:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 8000ea4:	6153      	str	r3, [r2, #20]
  __ASM volatile ("dsb 0xF":::"memory");
 8000ea6:	f3bf 8f4f 	dsb	sy
}
 8000eaa:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
 8000eac:	f3bf 8f6f 	isb	sy
}
 8000eb0:	e000      	b.n	8000eb4 <main+0xd0>
    if (SCB->CCR & SCB_CCR_DC_Msk) return;  /* return if DCache is already enabled */
 8000eb2:	bf00      	nop
  SCB_EnableDCache();

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
 8000eb4:	f001 fcce 	bl	8002854 <HAL_Init>

  /* USER CODE BEGIN Init */
  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();
 8000eb8:	f000 fa10 	bl	80012dc <SystemClock_Config>

/* Configure the peripherals common clocks */
  PeriphCommonClock_Config();
 8000ebc:	f000 fa84 	bl	80013c8 <PeriphCommonClock_Config>
  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
 8000ec0:	f000 fef0 	bl	8001ca4 <MX_GPIO_Init>
  MX_DMA_Init();
 8000ec4:	f000 feae 	bl	8001c24 <MX_DMA_Init>
  MX_ADC1_Init();
 8000ec8:	f000 fac6 	bl	8001458 <MX_ADC1_Init>
  MX_ADC2_Init();
 8000ecc:	f000 fb80 	bl	80015d0 <MX_ADC2_Init>
  MX_OCTOSPI2_Init();
 8000ed0:	f000 fc24 	bl	800171c <MX_OCTOSPI2_Init>
  MX_SAI1_Init();
 8000ed4:	f000 fc80 	bl	80017d8 <MX_SAI1_Init>
  MX_USB_DEVICE_Init();
 8000ed8:	f011 fba4 	bl	8012624 <MX_USB_DEVICE_Init>
  MX_TIM3_Init();
 8000edc:	f000 fd88 	bl	80019f0 <MX_TIM3_Init>
  MX_I2C1_Init();
 8000ee0:	f000 fbdc 	bl	800169c <MX_I2C1_Init>
  MX_TIM15_Init();
 8000ee4:	f000 fdfa 	bl	8001adc <MX_TIM15_Init>
  MX_TIM1_Init();
 8000ee8:	f000 fcd6 	bl	8001898 <MX_TIM1_Init>
  /* USER CODE BEGIN 2 */

  /* Reset variables */
  processHalfFlag = 0;
 8000eec:	4b73      	ldr	r3, [pc, #460]	@ (80010bc <main+0x2d8>)
 8000eee:	2200      	movs	r2, #0
 8000ef0:	701a      	strb	r2, [r3, #0]
  controlSetting[0] = 0.5f; controlSetting[1] = 0.5f; controlSetting[2] = 0.5f; controlSetting[3] = 0.5f; controlSetting[4] = 0.5f;
 8000ef2:	4b73      	ldr	r3, [pc, #460]	@ (80010c0 <main+0x2dc>)
 8000ef4:	f04f 527c 	mov.w	r2, #1056964608	@ 0x3f000000
 8000ef8:	601a      	str	r2, [r3, #0]
 8000efa:	4b71      	ldr	r3, [pc, #452]	@ (80010c0 <main+0x2dc>)
 8000efc:	f04f 527c 	mov.w	r2, #1056964608	@ 0x3f000000
 8000f00:	605a      	str	r2, [r3, #4]
 8000f02:	4b6f      	ldr	r3, [pc, #444]	@ (80010c0 <main+0x2dc>)
 8000f04:	f04f 527c 	mov.w	r2, #1056964608	@ 0x3f000000
 8000f08:	609a      	str	r2, [r3, #8]
 8000f0a:	4b6d      	ldr	r3, [pc, #436]	@ (80010c0 <main+0x2dc>)
 8000f0c:	f04f 527c 	mov.w	r2, #1056964608	@ 0x3f000000
 8000f10:	60da      	str	r2, [r3, #12]
 8000f12:	4b6b      	ldr	r3, [pc, #428]	@ (80010c0 <main+0x2dc>)
 8000f14:	f04f 527c 	mov.w	r2, #1056964608	@ 0x3f000000
 8000f18:	611a      	str	r2, [r3, #16]
  outputVolume = 1.00f;
 8000f1a:	4b6a      	ldr	r3, [pc, #424]	@ (80010c4 <main+0x2e0>)
 8000f1c:	f04f 527e 	mov.w	r2, #1065353216	@ 0x3f800000
 8000f20:	601a      	str	r2, [r3, #0]

  /* Initialise FX */
  //IFX_NoiseGate_Init(&ng, 0.1f, 2.0f, 2.0f, 20.0f, SAMPLING_FREQUENCY_HZ);

  IFX_Overdrive_Init(&od, SAMPLING_FREQUENCY_HZ, OD_HPF_CUTOFF_MAX, OD_GAIN_MIN, OD_LPF_CUTOFF_MIN, OD_LPF_DAMP);
 8000f22:	eeb7 2a00 	vmov.f32	s4, #112	@ 0x3f800000  1.0
 8000f26:	eddf 1a68 	vldr	s3, [pc, #416]	@ 80010c8 <main+0x2e4>
 8000f2a:	eeb2 1a04 	vmov.f32	s2, #36	@ 0x41200000  10.0
 8000f2e:	eddf 0a67 	vldr	s1, [pc, #412]	@ 80010cc <main+0x2e8>
 8000f32:	ed9f 0a67 	vldr	s0, [pc, #412]	@ 80010d0 <main+0x2ec>
 8000f36:	4867      	ldr	r0, [pc, #412]	@ (80010d4 <main+0x2f0>)
 8000f38:	f7ff fa8a 	bl	8000450 <IFX_Overdrive_Init>

  //IFX_Delay_Init(&dly, 500.0f, 0.5f, 0.5f, SAMPLING_FREQUENCY_HZ);
  //IFX_Delay_Init(&dly2, 500.0f, 0.5f, 0.5f, SAMPLING_FREQUENCY_HZ);

  /* Start LED timers and set duty cycle to zero */
  HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_1);
 8000f3c:	2100      	movs	r1, #0
 8000f3e:	4866      	ldr	r0, [pc, #408]	@ (80010d8 <main+0x2f4>)
 8000f40:	f00c ff7a 	bl	800de38 <HAL_TIM_PWM_Start>
  HAL_TIM_PWM_Start(&htim15, TIM_CHANNEL_1);
 8000f44:	2100      	movs	r1, #0
 8000f46:	4865      	ldr	r0, [pc, #404]	@ (80010dc <main+0x2f8>)
 8000f48:	f00c ff76 	bl	800de38 <HAL_TIM_PWM_Start>

  /* Check footswitch status */
  fxEnabled1 = HAL_GPIO_ReadPin(FX1_EN_GPIO_Port, FX1_EN_Pin);
 8000f4c:	2140      	movs	r1, #64	@ 0x40
 8000f4e:	4864      	ldr	r0, [pc, #400]	@ (80010e0 <main+0x2fc>)
 8000f50:	f005 fca6 	bl	80068a0 <HAL_GPIO_ReadPin>
 8000f54:	4603      	mov	r3, r0
 8000f56:	461a      	mov	r2, r3
 8000f58:	4b62      	ldr	r3, [pc, #392]	@ (80010e4 <main+0x300>)
 8000f5a:	701a      	strb	r2, [r3, #0]
  fxEnabled2 = HAL_GPIO_ReadPin(FX2_EN_GPIO_Port, FX2_EN_Pin);
 8000f5c:	2110      	movs	r1, #16
 8000f5e:	4862      	ldr	r0, [pc, #392]	@ (80010e8 <main+0x304>)
 8000f60:	f005 fc9e 	bl	80068a0 <HAL_GPIO_ReadPin>
 8000f64:	4603      	mov	r3, r0
 8000f66:	461a      	mov	r2, r3
 8000f68:	4b60      	ldr	r3, [pc, #384]	@ (80010ec <main+0x308>)
 8000f6a:	701a      	strb	r2, [r3, #0]

  od.boostGain = fxEnabled2 * OD_GAIN_BOOST;
 8000f6c:	4b5f      	ldr	r3, [pc, #380]	@ (80010ec <main+0x308>)
 8000f6e:	781b      	ldrb	r3, [r3, #0]
 8000f70:	ee07 3a90 	vmov	s15, r3
 8000f74:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8000f78:	ed9f 7a5d 	vldr	s14, [pc, #372]	@ 80010f0 <main+0x30c>
 8000f7c:	ee67 7a87 	vmul.f32	s15, s15, s14
 8000f80:	4b54      	ldr	r3, [pc, #336]	@ (80010d4 <main+0x2f0>)
 8000f82:	edc3 7a4f 	vstr	s15, [r3, #316]	@ 0x13c


  SetLED(0, 50 * fxEnabled1);
 8000f86:	4b57      	ldr	r3, [pc, #348]	@ (80010e4 <main+0x300>)
 8000f88:	781b      	ldrb	r3, [r3, #0]
 8000f8a:	461a      	mov	r2, r3
 8000f8c:	0092      	lsls	r2, r2, #2
 8000f8e:	4413      	add	r3, r2
 8000f90:	461a      	mov	r2, r3
 8000f92:	0091      	lsls	r1, r2, #2
 8000f94:	461a      	mov	r2, r3
 8000f96:	460b      	mov	r3, r1
 8000f98:	4413      	add	r3, r2
 8000f9a:	005b      	lsls	r3, r3, #1
 8000f9c:	b2db      	uxtb	r3, r3
 8000f9e:	4619      	mov	r1, r3
 8000fa0:	2000      	movs	r0, #0
 8000fa2:	f7ff fe8b 	bl	8000cbc <SetLED>
  SetLED(1, 50 * fxEnabled2);
 8000fa6:	4b51      	ldr	r3, [pc, #324]	@ (80010ec <main+0x308>)
 8000fa8:	781b      	ldrb	r3, [r3, #0]
 8000faa:	461a      	mov	r2, r3
 8000fac:	0092      	lsls	r2, r2, #2
 8000fae:	4413      	add	r3, r2
 8000fb0:	461a      	mov	r2, r3
 8000fb2:	0091      	lsls	r1, r2, #2
 8000fb4:	461a      	mov	r2, r3
 8000fb6:	460b      	mov	r3, r1
 8000fb8:	4413      	add	r3, r2
 8000fba:	005b      	lsls	r3, r3, #1
 8000fbc:	b2db      	uxtb	r3, r3
 8000fbe:	4619      	mov	r1, r3
 8000fc0:	2001      	movs	r0, #1
 8000fc2:	f7ff fe7b 	bl	8000cbc <SetLED>

  /* Calibrate control setting ADCs */
  HAL_StatusTypeDef halStatus;

  halStatus = HAL_ADCEx_Calibration_Start(&hadc1, ADC_CALIB_OFFSET, ADC_SINGLE_ENDED);
 8000fc6:	f240 72ff 	movw	r2, #2047	@ 0x7ff
 8000fca:	2100      	movs	r1, #0
 8000fcc:	4849      	ldr	r0, [pc, #292]	@ (80010f4 <main+0x310>)
 8000fce:	f002 fea9 	bl	8003d24 <HAL_ADCEx_Calibration_Start>
 8000fd2:	4603      	mov	r3, r0
 8000fd4:	f887 3026 	strb.w	r3, [r7, #38]	@ 0x26
  if ( halStatus != HAL_OK ) { Error_LED(); }
 8000fd8:	f897 3026 	ldrb.w	r3, [r7, #38]	@ 0x26
 8000fdc:	2b00      	cmp	r3, #0
 8000fde:	d001      	beq.n	8000fe4 <main+0x200>
 8000fe0:	f7ff fe8a 	bl	8000cf8 <Error_LED>

  /* Start control setting ADCs and sampling timer */
  halStatus = HAL_ADC_Start_DMA(&hadc1, (uint32_t *) controlSettingBuf, CONTROL_SETTING_COUNT);
 8000fe4:	2205      	movs	r2, #5
 8000fe6:	4944      	ldr	r1, [pc, #272]	@ (80010f8 <main+0x314>)
 8000fe8:	4842      	ldr	r0, [pc, #264]	@ (80010f4 <main+0x310>)
 8000fea:	f002 f851 	bl	8003090 <HAL_ADC_Start_DMA>
 8000fee:	4603      	mov	r3, r0
 8000ff0:	f887 3026 	strb.w	r3, [r7, #38]	@ 0x26
  if ( halStatus != HAL_OK ) { Error_LED(); }
 8000ff4:	f897 3026 	ldrb.w	r3, [r7, #38]	@ 0x26
 8000ff8:	2b00      	cmp	r3, #0
 8000ffa:	d001      	beq.n	8001000 <main+0x21c>
 8000ffc:	f7ff fe7c 	bl	8000cf8 <Error_LED>

  halStatus = HAL_TIM_Base_Start(&htim3);
 8001000:	483e      	ldr	r0, [pc, #248]	@ (80010fc <main+0x318>)
 8001002:	f00c fe47 	bl	800dc94 <HAL_TIM_Base_Start>
 8001006:	4603      	mov	r3, r0
 8001008:	f887 3026 	strb.w	r3, [r7, #38]	@ 0x26
  if ( halStatus != HAL_OK ) { Error_LED(); }
 800100c:	f897 3026 	ldrb.w	r3, [r7, #38]	@ 0x26
 8001010:	2b00      	cmp	r3, #0
 8001012:	d001      	beq.n	8001018 <main+0x234>
 8001014:	f7ff fe70 	bl	8000cf8 <Error_LED>

  /* Initialise SAIs (to start clocks, so that codec PLL locks) */

  halStatus = HAL_SAI_Init(&hsai_BlockA1);
 8001018:	4839      	ldr	r0, [pc, #228]	@ (8001100 <main+0x31c>)
 800101a:	f00c f823 	bl	800d064 <HAL_SAI_Init>
 800101e:	4603      	mov	r3, r0
 8001020:	f887 3026 	strb.w	r3, [r7, #38]	@ 0x26
  if ( halStatus != HAL_OK ) { Error_LED(); }
 8001024:	f897 3026 	ldrb.w	r3, [r7, #38]	@ 0x26
 8001028:	2b00      	cmp	r3, #0
 800102a:	d001      	beq.n	8001030 <main+0x24c>
 800102c:	f7ff fe64 	bl	8000cf8 <Error_LED>

  halStatus = HAL_SAI_Init(&hsai_BlockB1);
 8001030:	4834      	ldr	r0, [pc, #208]	@ (8001104 <main+0x320>)
 8001032:	f00c f817 	bl	800d064 <HAL_SAI_Init>
 8001036:	4603      	mov	r3, r0
 8001038:	f887 3026 	strb.w	r3, [r7, #38]	@ 0x26
  if ( halStatus != HAL_OK ) { Error_LED(); }
 800103c:	f897 3026 	ldrb.w	r3, [r7, #38]	@ 0x26
 8001040:	2b00      	cmp	r3, #0
 8001042:	d001      	beq.n	8001048 <main+0x264>
 8001044:	f7ff fe58 	bl	8000cf8 <Error_LED>

  /*
   * Initialise codec
   */
  uint8_t codecInitStatus = CS4270_Init();
 8001048:	f7ff f952 	bl	80002f0 <CS4270_Init>
 800104c:	4603      	mov	r3, r0
 800104e:	f887 3025 	strb.w	r3, [r7, #37]	@ 0x25
  if ( codecInitStatus != 0 ) { Error_LED(); };
 8001052:	f897 3025 	ldrb.w	r3, [r7, #37]	@ 0x25
 8001056:	2b00      	cmp	r3, #0
 8001058:	d001      	beq.n	800105e <main+0x27a>
 800105a:	f7ff fe4d 	bl	8000cf8 <Error_LED>

  /*
   * Start SAI DAC transmission
   */
  halStatus = HAL_SAI_Transmit_DMA(&hsai_BlockA1, (uint8_t *) dacBuf, AUDIO_BUFFER_SIZE);
 800105e:	f44f 7280 	mov.w	r2, #256	@ 0x100
 8001062:	4929      	ldr	r1, [pc, #164]	@ (8001108 <main+0x324>)
 8001064:	4826      	ldr	r0, [pc, #152]	@ (8001100 <main+0x31c>)
 8001066:	f00c fa05 	bl	800d474 <HAL_SAI_Transmit_DMA>
 800106a:	4603      	mov	r3, r0
 800106c:	f887 3026 	strb.w	r3, [r7, #38]	@ 0x26
  if ( halStatus != HAL_OK ) { Error_LED(); }
 8001070:	f897 3026 	ldrb.w	r3, [r7, #38]	@ 0x26
 8001074:	2b00      	cmp	r3, #0
 8001076:	d001      	beq.n	800107c <main+0x298>
 8001078:	f7ff fe3e 	bl	8000cf8 <Error_LED>

  /*
   * Start SAI ADC reception
   */
  halStatus = HAL_SAI_Receive_DMA(&hsai_BlockB1,  (uint8_t *) adcBuf, AUDIO_BUFFER_SIZE);
 800107c:	f44f 7280 	mov.w	r2, #256	@ 0x100
 8001080:	4922      	ldr	r1, [pc, #136]	@ (800110c <main+0x328>)
 8001082:	4820      	ldr	r0, [pc, #128]	@ (8001104 <main+0x320>)
 8001084:	f00c faac 	bl	800d5e0 <HAL_SAI_Receive_DMA>
 8001088:	4603      	mov	r3, r0
 800108a:	f887 3026 	strb.w	r3, [r7, #38]	@ 0x26
  if ( halStatus != HAL_OK ) { Error_LED(); }
 800108e:	f897 3026 	ldrb.w	r3, [r7, #38]	@ 0x26
 8001092:	2b00      	cmp	r3, #0
 8001094:	d001      	beq.n	800109a <main+0x2b6>
 8001096:	f7ff fe2f 	bl	8000cf8 <Error_LED>
	//		processHalfFlag = 0;
	//		Process_HalfBuffer();

	//	}

		if ( controlSettingsFlag && !controlSettingsLocked ) {
 800109a:	4b1d      	ldr	r3, [pc, #116]	@ (8001110 <main+0x32c>)
 800109c:	781b      	ldrb	r3, [r3, #0]
 800109e:	b2db      	uxtb	r3, r3
 80010a0:	2b00      	cmp	r3, #0
 80010a2:	d0fa      	beq.n	800109a <main+0x2b6>
 80010a4:	4b1b      	ldr	r3, [pc, #108]	@ (8001114 <main+0x330>)
 80010a6:	781b      	ldrb	r3, [r3, #0]
 80010a8:	b2db      	uxtb	r3, r3
 80010aa:	2b00      	cmp	r3, #0
 80010ac:	d1f5      	bne.n	800109a <main+0x2b6>

			float prevControlSetting[5];

			for (uint8_t controlSettingNum = 0; controlSettingNum < CONTROL_SETTING_COUNT; controlSettingNum++) {
 80010ae:	2300      	movs	r3, #0
 80010b0:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
 80010b4:	e0ec      	b.n	8001290 <main+0x4ac>
 80010b6:	bf00      	nop
 80010b8:	e000ed00 	.word	0xe000ed00
 80010bc:	3000097c 	.word	0x3000097c
 80010c0:	3000098c 	.word	0x3000098c
 80010c4:	300009a4 	.word	0x300009a4
 80010c8:	43fa0000 	.word	0x43fa0000
 80010cc:	447a0000 	.word	0x447a0000
 80010d0:	46fe5000 	.word	0x46fe5000
 80010d4:	30000000 	.word	0x30000000
 80010d8:	240006cc 	.word	0x240006cc
 80010dc:	24000764 	.word	0x24000764
 80010e0:	58020400 	.word	0x58020400
 80010e4:	30000170 	.word	0x30000170
 80010e8:	58020c00 	.word	0x58020c00
 80010ec:	30000171 	.word	0x30000171
 80010f0:	42c80000 	.word	0x42c80000
 80010f4:	240002bc 	.word	0x240002bc
 80010f8:	30000980 	.word	0x30000980
 80010fc:	24000718 	.word	0x24000718
 8001100:	240004ac 	.word	0x240004ac
 8001104:	24000544 	.word	0x24000544
 8001108:	30000574 	.word	0x30000574
 800110c:	30000174 	.word	0x30000174
 8001110:	300009a1 	.word	0x300009a1
 8001114:	300009a0 	.word	0x300009a0

				// Shift samples
				prevControlSetting[controlSettingNum] = controlSetting[controlSettingNum];
 8001118:	f897 2027 	ldrb.w	r2, [r7, #39]	@ 0x27
 800111c:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 8001120:	4960      	ldr	r1, [pc, #384]	@ (80012a4 <main+0x4c0>)
 8001122:	0092      	lsls	r2, r2, #2
 8001124:	440a      	add	r2, r1
 8001126:	6812      	ldr	r2, [r2, #0]
 8001128:	009b      	lsls	r3, r3, #2
 800112a:	3328      	adds	r3, #40	@ 0x28
 800112c:	443b      	add	r3, r7
 800112e:	3b24      	subs	r3, #36	@ 0x24
 8001130:	601a      	str	r2, [r3, #0]

				// Convert raw ADC readings to float (0 ... 1), and low-pass filter
				controlSetting[controlSettingNum] = CONTROL_SETTING_ALPHA * prevControlSetting[controlSettingNum] + (1.0f - CONTROL_SETTING_ALPHA) * UINT16_TO_FLOAT * controlSettingBuf[controlSettingNum];
 8001132:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 8001136:	009b      	lsls	r3, r3, #2
 8001138:	3328      	adds	r3, #40	@ 0x28
 800113a:	443b      	add	r3, r7
 800113c:	3b24      	subs	r3, #36	@ 0x24
 800113e:	edd3 7a00 	vldr	s15, [r3]
 8001142:	eeb6 7a00 	vmov.f32	s14, #96	@ 0x3f000000  0.5
 8001146:	ee27 7a87 	vmul.f32	s14, s15, s14
 800114a:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 800114e:	4a56      	ldr	r2, [pc, #344]	@ (80012a8 <main+0x4c4>)
 8001150:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 8001154:	b29b      	uxth	r3, r3
 8001156:	ee07 3a90 	vmov	s15, r3
 800115a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800115e:	eddf 6a53 	vldr	s13, [pc, #332]	@ 80012ac <main+0x4c8>
 8001162:	ee67 7aa6 	vmul.f32	s15, s15, s13
 8001166:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 800116a:	ee77 7a27 	vadd.f32	s15, s14, s15
 800116e:	4a4d      	ldr	r2, [pc, #308]	@ (80012a4 <main+0x4c0>)
 8001170:	009b      	lsls	r3, r3, #2
 8001172:	4413      	add	r3, r2
 8001174:	edc3 7a00 	vstr	s15, [r3]

				// If large enough control setting change (out of deadband), set FX parameters
				if ( (controlSetting[controlSettingNum] > (1.0f + CONTROL_SETTING_CHANGE_THRESHOLD) * prevControlSetting[controlSettingNum])
 8001178:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 800117c:	4a49      	ldr	r2, [pc, #292]	@ (80012a4 <main+0x4c0>)
 800117e:	009b      	lsls	r3, r3, #2
 8001180:	4413      	add	r3, r2
 8001182:	ed93 7a00 	vldr	s14, [r3]
 8001186:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 800118a:	009b      	lsls	r3, r3, #2
 800118c:	3328      	adds	r3, #40	@ 0x28
 800118e:	443b      	add	r3, r7
 8001190:	3b24      	subs	r3, #36	@ 0x24
 8001192:	edd3 7a00 	vldr	s15, [r3]
 8001196:	eddf 6a46 	vldr	s13, [pc, #280]	@ 80012b0 <main+0x4cc>
 800119a:	ee67 7aa6 	vmul.f32	s15, s15, s13
 800119e:	eeb4 7ae7 	vcmpe.f32	s14, s15
 80011a2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80011a6:	dc17      	bgt.n	80011d8 <main+0x3f4>
				  || (controlSetting[controlSettingNum] < (1.0f - CONTROL_SETTING_CHANGE_THRESHOLD) * prevControlSetting[controlSettingNum]) ) {
 80011a8:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 80011ac:	4a3d      	ldr	r2, [pc, #244]	@ (80012a4 <main+0x4c0>)
 80011ae:	009b      	lsls	r3, r3, #2
 80011b0:	4413      	add	r3, r2
 80011b2:	ed93 7a00 	vldr	s14, [r3]
 80011b6:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 80011ba:	009b      	lsls	r3, r3, #2
 80011bc:	3328      	adds	r3, #40	@ 0x28
 80011be:	443b      	add	r3, r7
 80011c0:	3b24      	subs	r3, #36	@ 0x24
 80011c2:	edd3 7a00 	vldr	s15, [r3]
 80011c6:	eddf 6a3b 	vldr	s13, [pc, #236]	@ 80012b4 <main+0x4d0>
 80011ca:	ee67 7aa6 	vmul.f32	s15, s15, s13
 80011ce:	eeb4 7ae7 	vcmpe.f32	s14, s15
 80011d2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80011d6:	d556      	bpl.n	8001286 <main+0x4a2>

					switch (controlSettingNum) {
 80011d8:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 80011dc:	2b04      	cmp	r3, #4
 80011de:	d852      	bhi.n	8001286 <main+0x4a2>
 80011e0:	a201      	add	r2, pc, #4	@ (adr r2, 80011e8 <main+0x404>)
 80011e2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80011e6:	bf00      	nop
 80011e8:	080011fd 	.word	0x080011fd
 80011ec:	0800121f 	.word	0x0800121f
 80011f0:	08001241 	.word	0x08001241
 80011f4:	0800124b 	.word	0x0800124b
 80011f8:	08001271 	.word	0x08001271
						// Gain
						case 0:

							// Log
							//dly.mix = controlSetting[0];
							IFX_Overdrive_SetGain(&od, OD_GAIN_MIN + OD_GAIN_SCALE * controlSetting[0]);
 80011fc:	4b29      	ldr	r3, [pc, #164]	@ (80012a4 <main+0x4c0>)
 80011fe:	edd3 7a00 	vldr	s15, [r3]
 8001202:	ed9f 7a2d 	vldr	s14, [pc, #180]	@ 80012b8 <main+0x4d4>
 8001206:	ee67 7a87 	vmul.f32	s15, s15, s14
 800120a:	eeb2 7a04 	vmov.f32	s14, #36	@ 0x41200000  10.0
 800120e:	ee77 7a87 	vadd.f32	s15, s15, s14
 8001212:	eeb0 0a67 	vmov.f32	s0, s15
 8001216:	4829      	ldr	r0, [pc, #164]	@ (80012bc <main+0x4d8>)
 8001218:	f7ff f9b2 	bl	8000580 <IFX_Overdrive_SetGain>

							break;
 800121c:	e033      	b.n	8001286 <main+0x4a2>
						// EQ Low
						case 1:


							//IFX_Delay_SetLength(&dly, 50.0f + 950.0f * controlSetting[1], SAMPLING_FREQUENCY_HZ);
							IFX_Overdrive_SetHPF(&od, OD_HPF_CUTOFF_MAX - OD_HPF_CUTOFF_SCALE * controlSetting[1]);
 800121e:	4b21      	ldr	r3, [pc, #132]	@ (80012a4 <main+0x4c0>)
 8001220:	edd3 7a01 	vldr	s15, [r3, #4]
 8001224:	ed9f 7a26 	vldr	s14, [pc, #152]	@ 80012c0 <main+0x4dc>
 8001228:	ee67 7a87 	vmul.f32	s15, s15, s14
 800122c:	ed9f 7a25 	vldr	s14, [pc, #148]	@ 80012c4 <main+0x4e0>
 8001230:	ee77 7a67 	vsub.f32	s15, s14, s15
 8001234:	eeb0 0a67 	vmov.f32	s0, s15
 8001238:	4820      	ldr	r0, [pc, #128]	@ (80012bc <main+0x4d8>)
 800123a:	f7ff f9b1 	bl	80005a0 <IFX_Overdrive_SetHPF>

							break;
 800123e:	e022      	b.n	8001286 <main+0x4a2>

						// Volume
						case 2:

							// Log
							outputVolume = controlSetting[2];
 8001240:	4b18      	ldr	r3, [pc, #96]	@ (80012a4 <main+0x4c0>)
 8001242:	689b      	ldr	r3, [r3, #8]
 8001244:	4a20      	ldr	r2, [pc, #128]	@ (80012c8 <main+0x4e4>)
 8001246:	6013      	str	r3, [r2, #0]

							break;
 8001248:	e01d      	b.n	8001286 <main+0x4a2>

						// EQ High
						case 3:

							//dly.blend = controlSetting[3];
							IFX_Overdrive_SetLPF(&od, OD_LPF_CUTOFF_MIN + OD_LPF_CUTOFF_SCALE * controlSetting[3], OD_LPF_DAMP);
 800124a:	4b16      	ldr	r3, [pc, #88]	@ (80012a4 <main+0x4c0>)
 800124c:	edd3 7a03 	vldr	s15, [r3, #12]
 8001250:	ed9f 7a1e 	vldr	s14, [pc, #120]	@ 80012cc <main+0x4e8>
 8001254:	ee67 7a87 	vmul.f32	s15, s15, s14
 8001258:	ed9f 7a1d 	vldr	s14, [pc, #116]	@ 80012d0 <main+0x4ec>
 800125c:	ee77 7a87 	vadd.f32	s15, s15, s14
 8001260:	eef7 0a00 	vmov.f32	s1, #112	@ 0x3f800000  1.0
 8001264:	eeb0 0a67 	vmov.f32	s0, s15
 8001268:	4814      	ldr	r0, [pc, #80]	@ (80012bc <main+0x4d8>)
 800126a:	f7ff f9bd 	bl	80005e8 <IFX_Overdrive_SetLPF>

							break;
 800126e:	e00a      	b.n	8001286 <main+0x4a2>

						// Noise Gate (Threshold)
						case 4:

							od.Q = -0.05f - controlSetting[4];
 8001270:	4b0c      	ldr	r3, [pc, #48]	@ (80012a4 <main+0x4c0>)
 8001272:	edd3 7a04 	vldr	s15, [r3, #16]
 8001276:	ed9f 7a17 	vldr	s14, [pc, #92]	@ 80012d4 <main+0x4f0>
 800127a:	ee77 7a67 	vsub.f32	s15, s14, s15
 800127e:	4b0f      	ldr	r3, [pc, #60]	@ (80012bc <main+0x4d8>)
 8001280:	edc3 7a5b 	vstr	s15, [r3, #364]	@ 0x16c
							//dly.feedback = controlSetting[4];
							// Log
							//IFX_Delay_SetLength(&dly, 5.0f + 500.0f * controlSetting[4], SAMPLING_FREQUENCY_HZ);
							//IFX_NoiseGate_SetThreshold(&ng, 0.3f * controlSetting[4]);

							break;
 8001284:	bf00      	nop
			for (uint8_t controlSettingNum = 0; controlSettingNum < CONTROL_SETTING_COUNT; controlSettingNum++) {
 8001286:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 800128a:	3301      	adds	r3, #1
 800128c:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
 8001290:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 8001294:	2b04      	cmp	r3, #4
 8001296:	f67f af3f 	bls.w	8001118 <main+0x334>

				}

			}

			controlSettingsFlag = 0;
 800129a:	4b0f      	ldr	r3, [pc, #60]	@ (80012d8 <main+0x4f4>)
 800129c:	2200      	movs	r2, #0
 800129e:	701a      	strb	r2, [r3, #0]
		if ( controlSettingsFlag && !controlSettingsLocked ) {
 80012a0:	e6fb      	b.n	800109a <main+0x2b6>
 80012a2:	bf00      	nop
 80012a4:	3000098c 	.word	0x3000098c
 80012a8:	30000980 	.word	0x30000980
 80012ac:	36fffff6 	.word	0x36fffff6
 80012b0:	3f833333 	.word	0x3f833333
 80012b4:	3f79999a 	.word	0x3f79999a
 80012b8:	42c80000 	.word	0x42c80000
 80012bc:	30000000 	.word	0x30000000
 80012c0:	44610000 	.word	0x44610000
 80012c4:	447a0000 	.word	0x447a0000
 80012c8:	300009a4 	.word	0x300009a4
 80012cc:	467a0000 	.word	0x467a0000
 80012d0:	43fa0000 	.word	0x43fa0000
 80012d4:	bd4ccccd 	.word	0xbd4ccccd
 80012d8:	300009a1 	.word	0x300009a1

080012dc <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
 80012dc:	b580      	push	{r7, lr}
 80012de:	b09c      	sub	sp, #112	@ 0x70
 80012e0:	af00      	add	r7, sp, #0
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 80012e2:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 80012e6:	224c      	movs	r2, #76	@ 0x4c
 80012e8:	2100      	movs	r1, #0
 80012ea:	4618      	mov	r0, r3
 80012ec:	f011 fe5e 	bl	8012fac <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 80012f0:	1d3b      	adds	r3, r7, #4
 80012f2:	2220      	movs	r2, #32
 80012f4:	2100      	movs	r1, #0
 80012f6:	4618      	mov	r0, r3
 80012f8:	f011 fe58 	bl	8012fac <memset>

  /*AXI clock gating */
  RCC->CKGAENR = 0xFFFFFFFF;
 80012fc:	4b30      	ldr	r3, [pc, #192]	@ (80013c0 <SystemClock_Config+0xe4>)
 80012fe:	f04f 32ff 	mov.w	r2, #4294967295
 8001302:	f8c3 20b0 	str.w	r2, [r3, #176]	@ 0xb0

  /** Supply configuration update enable
  */
  HAL_PWREx_ConfigSupply(PWR_LDO_SUPPLY);
 8001306:	2002      	movs	r0, #2
 8001308:	f008 fa7e 	bl	8009808 <HAL_PWREx_ConfigSupply>

  /** Configure the main internal regulator output voltage
  */
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE0);
 800130c:	2300      	movs	r3, #0
 800130e:	603b      	str	r3, [r7, #0]
 8001310:	4b2c      	ldr	r3, [pc, #176]	@ (80013c4 <SystemClock_Config+0xe8>)
 8001312:	699b      	ldr	r3, [r3, #24]
 8001314:	4a2b      	ldr	r2, [pc, #172]	@ (80013c4 <SystemClock_Config+0xe8>)
 8001316:	f443 4340 	orr.w	r3, r3, #49152	@ 0xc000
 800131a:	6193      	str	r3, [r2, #24]
 800131c:	4b29      	ldr	r3, [pc, #164]	@ (80013c4 <SystemClock_Config+0xe8>)
 800131e:	699b      	ldr	r3, [r3, #24]
 8001320:	f403 4340 	and.w	r3, r3, #49152	@ 0xc000
 8001324:	603b      	str	r3, [r7, #0]
 8001326:	683b      	ldr	r3, [r7, #0]

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY)) {}
 8001328:	bf00      	nop
 800132a:	4b26      	ldr	r3, [pc, #152]	@ (80013c4 <SystemClock_Config+0xe8>)
 800132c:	699b      	ldr	r3, [r3, #24]
 800132e:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
 8001332:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 8001336:	d1f8      	bne.n	800132a <SystemClock_Config+0x4e>

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 8001338:	2301      	movs	r3, #1
 800133a:	627b      	str	r3, [r7, #36]	@ 0x24
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 800133c:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
 8001340:	62bb      	str	r3, [r7, #40]	@ 0x28
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8001342:	2302      	movs	r3, #2
 8001344:	64bb      	str	r3, [r7, #72]	@ 0x48
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 8001346:	2302      	movs	r3, #2
 8001348:	64fb      	str	r3, [r7, #76]	@ 0x4c
  RCC_OscInitStruct.PLL.PLLM = 12;
 800134a:	230c      	movs	r3, #12
 800134c:	653b      	str	r3, [r7, #80]	@ 0x50
  RCC_OscInitStruct.PLL.PLLN = 280;
 800134e:	f44f 738c 	mov.w	r3, #280	@ 0x118
 8001352:	657b      	str	r3, [r7, #84]	@ 0x54
  RCC_OscInitStruct.PLL.PLLP = 2;
 8001354:	2302      	movs	r3, #2
 8001356:	65bb      	str	r3, [r7, #88]	@ 0x58
  RCC_OscInitStruct.PLL.PLLQ = 2;
 8001358:	2302      	movs	r3, #2
 800135a:	65fb      	str	r3, [r7, #92]	@ 0x5c
  RCC_OscInitStruct.PLL.PLLR = 2;
 800135c:	2302      	movs	r3, #2
 800135e:	663b      	str	r3, [r7, #96]	@ 0x60
  RCC_OscInitStruct.PLL.PLLRGE = RCC_PLL1VCIRANGE_1;
 8001360:	2304      	movs	r3, #4
 8001362:	667b      	str	r3, [r7, #100]	@ 0x64
  RCC_OscInitStruct.PLL.PLLVCOSEL = RCC_PLL1VCOWIDE;
 8001364:	2300      	movs	r3, #0
 8001366:	66bb      	str	r3, [r7, #104]	@ 0x68
  RCC_OscInitStruct.PLL.PLLFRACN = 0;
 8001368:	2300      	movs	r3, #0
 800136a:	66fb      	str	r3, [r7, #108]	@ 0x6c
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 800136c:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 8001370:	4618      	mov	r0, r3
 8001372:	f008 fa93 	bl	800989c <HAL_RCC_OscConfig>
 8001376:	4603      	mov	r3, r0
 8001378:	2b00      	cmp	r3, #0
 800137a:	d001      	beq.n	8001380 <SystemClock_Config+0xa4>
  {
    Error_Handler();
 800137c:	f000 fd68 	bl	8001e50 <Error_Handler>
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 8001380:	233f      	movs	r3, #63	@ 0x3f
 8001382:	607b      	str	r3, [r7, #4]
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2
                              |RCC_CLOCKTYPE_D3PCLK1|RCC_CLOCKTYPE_D1PCLK1;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 8001384:	2303      	movs	r3, #3
 8001386:	60bb      	str	r3, [r7, #8]
  RCC_ClkInitStruct.SYSCLKDivider = RCC_SYSCLK_DIV1;
 8001388:	2300      	movs	r3, #0
 800138a:	60fb      	str	r3, [r7, #12]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_HCLK_DIV1;
 800138c:	2300      	movs	r3, #0
 800138e:	613b      	str	r3, [r7, #16]
  RCC_ClkInitStruct.APB3CLKDivider = RCC_APB3_DIV2;
 8001390:	2340      	movs	r3, #64	@ 0x40
 8001392:	617b      	str	r3, [r7, #20]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_APB1_DIV2;
 8001394:	2340      	movs	r3, #64	@ 0x40
 8001396:	61bb      	str	r3, [r7, #24]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_APB2_DIV2;
 8001398:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 800139c:	61fb      	str	r3, [r7, #28]
  RCC_ClkInitStruct.APB4CLKDivider = RCC_APB4_DIV2;
 800139e:	2340      	movs	r3, #64	@ 0x40
 80013a0:	623b      	str	r3, [r7, #32]

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_6) != HAL_OK)
 80013a2:	1d3b      	adds	r3, r7, #4
 80013a4:	2106      	movs	r1, #6
 80013a6:	4618      	mov	r0, r3
 80013a8:	f008 feaa 	bl	800a100 <HAL_RCC_ClockConfig>
 80013ac:	4603      	mov	r3, r0
 80013ae:	2b00      	cmp	r3, #0
 80013b0:	d001      	beq.n	80013b6 <SystemClock_Config+0xda>
  {
    Error_Handler();
 80013b2:	f000 fd4d 	bl	8001e50 <Error_Handler>
  }
}
 80013b6:	bf00      	nop
 80013b8:	3770      	adds	r7, #112	@ 0x70
 80013ba:	46bd      	mov	sp, r7
 80013bc:	bd80      	pop	{r7, pc}
 80013be:	bf00      	nop
 80013c0:	58024400 	.word	0x58024400
 80013c4:	58024800 	.word	0x58024800

080013c8 <PeriphCommonClock_Config>:
/**
  * @brief Peripherals Common Clock Configuration
  * @retval None
  */
void PeriphCommonClock_Config(void)
{
 80013c8:	b580      	push	{r7, lr}
 80013ca:	b0b0      	sub	sp, #192	@ 0xc0
 80013cc:	af00      	add	r7, sp, #0
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 80013ce:	463b      	mov	r3, r7
 80013d0:	22c0      	movs	r2, #192	@ 0xc0
 80013d2:	2100      	movs	r1, #0
 80013d4:	4618      	mov	r0, r3
 80013d6:	f011 fde9 	bl	8012fac <memset>

  /** Initializes the peripherals clock
  */
  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_USB|RCC_PERIPHCLK_ADC
 80013da:	4a1e      	ldr	r2, [pc, #120]	@ (8001454 <PeriphCommonClock_Config+0x8c>)
 80013dc:	f04f 0300 	mov.w	r3, #0
 80013e0:	e9c7 2300 	strd	r2, r3, [r7]
                              |RCC_PERIPHCLK_SAI1;
  PeriphClkInitStruct.PLL2.PLL2M = 12;
 80013e4:	230c      	movs	r3, #12
 80013e6:	60bb      	str	r3, [r7, #8]
  PeriphClkInitStruct.PLL2.PLL2N = 98;
 80013e8:	2362      	movs	r3, #98	@ 0x62
 80013ea:	60fb      	str	r3, [r7, #12]
  PeriphClkInitStruct.PLL2.PLL2P = 2;
 80013ec:	2302      	movs	r3, #2
 80013ee:	613b      	str	r3, [r7, #16]
  PeriphClkInitStruct.PLL2.PLL2Q = 2;
 80013f0:	2302      	movs	r3, #2
 80013f2:	617b      	str	r3, [r7, #20]
  PeriphClkInitStruct.PLL2.PLL2R = 2;
 80013f4:	2302      	movs	r3, #2
 80013f6:	61bb      	str	r3, [r7, #24]
  PeriphClkInitStruct.PLL2.PLL2RGE = RCC_PLL2VCIRANGE_1;
 80013f8:	2340      	movs	r3, #64	@ 0x40
 80013fa:	61fb      	str	r3, [r7, #28]
  PeriphClkInitStruct.PLL2.PLL2VCOSEL = RCC_PLL2VCOWIDE;
 80013fc:	2300      	movs	r3, #0
 80013fe:	623b      	str	r3, [r7, #32]
  PeriphClkInitStruct.PLL2.PLL2FRACN = 0;
 8001400:	2300      	movs	r3, #0
 8001402:	627b      	str	r3, [r7, #36]	@ 0x24
  PeriphClkInitStruct.PLL3.PLL3M = 24;
 8001404:	2318      	movs	r3, #24
 8001406:	62bb      	str	r3, [r7, #40]	@ 0x28
  PeriphClkInitStruct.PLL3.PLL3N = 192;
 8001408:	23c0      	movs	r3, #192	@ 0xc0
 800140a:	62fb      	str	r3, [r7, #44]	@ 0x2c
  PeriphClkInitStruct.PLL3.PLL3P = 4;
 800140c:	2304      	movs	r3, #4
 800140e:	633b      	str	r3, [r7, #48]	@ 0x30
  PeriphClkInitStruct.PLL3.PLL3Q = 4;
 8001410:	2304      	movs	r3, #4
 8001412:	637b      	str	r3, [r7, #52]	@ 0x34
  PeriphClkInitStruct.PLL3.PLL3R = 4;
 8001414:	2304      	movs	r3, #4
 8001416:	63bb      	str	r3, [r7, #56]	@ 0x38
  PeriphClkInitStruct.PLL3.PLL3RGE = RCC_PLL3VCIRANGE_0;
 8001418:	2300      	movs	r3, #0
 800141a:	63fb      	str	r3, [r7, #60]	@ 0x3c
  PeriphClkInitStruct.PLL3.PLL3VCOSEL = RCC_PLL3VCOWIDE;
 800141c:	2300      	movs	r3, #0
 800141e:	643b      	str	r3, [r7, #64]	@ 0x40
  PeriphClkInitStruct.PLL3.PLL3FRACN = 0;
 8001420:	2300      	movs	r3, #0
 8001422:	647b      	str	r3, [r7, #68]	@ 0x44
  PeriphClkInitStruct.Sai1ClockSelection = RCC_SAI1CLKSOURCE_PLL2;
 8001424:	2301      	movs	r3, #1
 8001426:	65bb      	str	r3, [r7, #88]	@ 0x58
  PeriphClkInitStruct.UsbClockSelection = RCC_USBCLKSOURCE_PLL3;
 8001428:	f44f 1300 	mov.w	r3, #2097152	@ 0x200000
 800142c:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
  PeriphClkInitStruct.AdcClockSelection = RCC_ADCCLKSOURCE_PLL3;
 8001430:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
 8001434:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 8001438:	463b      	mov	r3, r7
 800143a:	4618      	mov	r0, r3
 800143c:	f009 f9d6 	bl	800a7ec <HAL_RCCEx_PeriphCLKConfig>
 8001440:	4603      	mov	r3, r0
 8001442:	2b00      	cmp	r3, #0
 8001444:	d001      	beq.n	800144a <PeriphCommonClock_Config+0x82>
  {
    Error_Handler();
 8001446:	f000 fd03 	bl	8001e50 <Error_Handler>
  }
}
 800144a:	bf00      	nop
 800144c:	37c0      	adds	r7, #192	@ 0xc0
 800144e:	46bd      	mov	sp, r7
 8001450:	bd80      	pop	{r7, pc}
 8001452:	bf00      	nop
 8001454:	000c0100 	.word	0x000c0100

08001458 <MX_ADC1_Init>:
  * @brief ADC1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_ADC1_Init(void)
{
 8001458:	b580      	push	{r7, lr}
 800145a:	b08a      	sub	sp, #40	@ 0x28
 800145c:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN ADC1_Init 0 */

  /* USER CODE END ADC1_Init 0 */

  ADC_MultiModeTypeDef multimode = {0};
 800145e:	f107 031c 	add.w	r3, r7, #28
 8001462:	2200      	movs	r2, #0
 8001464:	601a      	str	r2, [r3, #0]
 8001466:	605a      	str	r2, [r3, #4]
 8001468:	609a      	str	r2, [r3, #8]
  ADC_ChannelConfTypeDef sConfig = {0};
 800146a:	463b      	mov	r3, r7
 800146c:	2200      	movs	r2, #0
 800146e:	601a      	str	r2, [r3, #0]
 8001470:	605a      	str	r2, [r3, #4]
 8001472:	609a      	str	r2, [r3, #8]
 8001474:	60da      	str	r2, [r3, #12]
 8001476:	611a      	str	r2, [r3, #16]
 8001478:	615a      	str	r2, [r3, #20]
 800147a:	619a      	str	r2, [r3, #24]

  /* USER CODE END ADC1_Init 1 */

  /** Common config
  */
  hadc1.Instance = ADC1;
 800147c:	4b4d      	ldr	r3, [pc, #308]	@ (80015b4 <MX_ADC1_Init+0x15c>)
 800147e:	4a4e      	ldr	r2, [pc, #312]	@ (80015b8 <MX_ADC1_Init+0x160>)
 8001480:	601a      	str	r2, [r3, #0]
  hadc1.Init.ClockPrescaler = ADC_CLOCK_ASYNC_DIV2;
 8001482:	4b4c      	ldr	r3, [pc, #304]	@ (80015b4 <MX_ADC1_Init+0x15c>)
 8001484:	f44f 2280 	mov.w	r2, #262144	@ 0x40000
 8001488:	605a      	str	r2, [r3, #4]
  hadc1.Init.Resolution = ADC_RESOLUTION_16B;
 800148a:	4b4a      	ldr	r3, [pc, #296]	@ (80015b4 <MX_ADC1_Init+0x15c>)
 800148c:	2200      	movs	r2, #0
 800148e:	609a      	str	r2, [r3, #8]
  hadc1.Init.ScanConvMode = ADC_SCAN_ENABLE;
 8001490:	4b48      	ldr	r3, [pc, #288]	@ (80015b4 <MX_ADC1_Init+0x15c>)
 8001492:	2201      	movs	r2, #1
 8001494:	60da      	str	r2, [r3, #12]
  hadc1.Init.EOCSelection = ADC_EOC_SEQ_CONV;
 8001496:	4b47      	ldr	r3, [pc, #284]	@ (80015b4 <MX_ADC1_Init+0x15c>)
 8001498:	2208      	movs	r2, #8
 800149a:	611a      	str	r2, [r3, #16]
  hadc1.Init.LowPowerAutoWait = DISABLE;
 800149c:	4b45      	ldr	r3, [pc, #276]	@ (80015b4 <MX_ADC1_Init+0x15c>)
 800149e:	2200      	movs	r2, #0
 80014a0:	751a      	strb	r2, [r3, #20]
  hadc1.Init.ContinuousConvMode = DISABLE;
 80014a2:	4b44      	ldr	r3, [pc, #272]	@ (80015b4 <MX_ADC1_Init+0x15c>)
 80014a4:	2200      	movs	r2, #0
 80014a6:	755a      	strb	r2, [r3, #21]
  hadc1.Init.NbrOfConversion = 5;
 80014a8:	4b42      	ldr	r3, [pc, #264]	@ (80015b4 <MX_ADC1_Init+0x15c>)
 80014aa:	2205      	movs	r2, #5
 80014ac:	619a      	str	r2, [r3, #24]
  hadc1.Init.DiscontinuousConvMode = DISABLE;
 80014ae:	4b41      	ldr	r3, [pc, #260]	@ (80015b4 <MX_ADC1_Init+0x15c>)
 80014b0:	2200      	movs	r2, #0
 80014b2:	771a      	strb	r2, [r3, #28]
  hadc1.Init.ExternalTrigConv = ADC_EXTERNALTRIG_T3_TRGO;
 80014b4:	4b3f      	ldr	r3, [pc, #252]	@ (80015b4 <MX_ADC1_Init+0x15c>)
 80014b6:	f44f 6290 	mov.w	r2, #1152	@ 0x480
 80014ba:	625a      	str	r2, [r3, #36]	@ 0x24
  hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_RISING;
 80014bc:	4b3d      	ldr	r3, [pc, #244]	@ (80015b4 <MX_ADC1_Init+0x15c>)
 80014be:	f44f 6280 	mov.w	r2, #1024	@ 0x400
 80014c2:	629a      	str	r2, [r3, #40]	@ 0x28
  hadc1.Init.ConversionDataManagement = ADC_CONVERSIONDATA_DMA_CIRCULAR;
 80014c4:	4b3b      	ldr	r3, [pc, #236]	@ (80015b4 <MX_ADC1_Init+0x15c>)
 80014c6:	2203      	movs	r2, #3
 80014c8:	62da      	str	r2, [r3, #44]	@ 0x2c
  hadc1.Init.Overrun = ADC_OVR_DATA_PRESERVED;
 80014ca:	4b3a      	ldr	r3, [pc, #232]	@ (80015b4 <MX_ADC1_Init+0x15c>)
 80014cc:	2200      	movs	r2, #0
 80014ce:	631a      	str	r2, [r3, #48]	@ 0x30
  hadc1.Init.LeftBitShift = ADC_LEFTBITSHIFT_NONE;
 80014d0:	4b38      	ldr	r3, [pc, #224]	@ (80015b4 <MX_ADC1_Init+0x15c>)
 80014d2:	2200      	movs	r2, #0
 80014d4:	635a      	str	r2, [r3, #52]	@ 0x34
  hadc1.Init.OversamplingMode = DISABLE;
 80014d6:	4b37      	ldr	r3, [pc, #220]	@ (80015b4 <MX_ADC1_Init+0x15c>)
 80014d8:	2200      	movs	r2, #0
 80014da:	f883 2038 	strb.w	r2, [r3, #56]	@ 0x38
  if (HAL_ADC_Init(&hadc1) != HAL_OK)
 80014de:	4835      	ldr	r0, [pc, #212]	@ (80015b4 <MX_ADC1_Init+0x15c>)
 80014e0:	f001 fc7c 	bl	8002ddc <HAL_ADC_Init>
 80014e4:	4603      	mov	r3, r0
 80014e6:	2b00      	cmp	r3, #0
 80014e8:	d001      	beq.n	80014ee <MX_ADC1_Init+0x96>
  {
    Error_Handler();
 80014ea:	f000 fcb1 	bl	8001e50 <Error_Handler>
  }

  /** Configure the ADC multi-mode
  */
  multimode.Mode = ADC_MODE_INDEPENDENT;
 80014ee:	2300      	movs	r3, #0
 80014f0:	61fb      	str	r3, [r7, #28]
  if (HAL_ADCEx_MultiModeConfigChannel(&hadc1, &multimode) != HAL_OK)
 80014f2:	f107 031c 	add.w	r3, r7, #28
 80014f6:	4619      	mov	r1, r3
 80014f8:	482e      	ldr	r0, [pc, #184]	@ (80015b4 <MX_ADC1_Init+0x15c>)
 80014fa:	f002 fc77 	bl	8003dec <HAL_ADCEx_MultiModeConfigChannel>
 80014fe:	4603      	mov	r3, r0
 8001500:	2b00      	cmp	r3, #0
 8001502:	d001      	beq.n	8001508 <MX_ADC1_Init+0xb0>
  {
    Error_Handler();
 8001504:	f000 fca4 	bl	8001e50 <Error_Handler>
  }

  /** Configure Regular Channel
  */
  sConfig.Channel = ADC_CHANNEL_16;
 8001508:	4b2c      	ldr	r3, [pc, #176]	@ (80015bc <MX_ADC1_Init+0x164>)
 800150a:	603b      	str	r3, [r7, #0]
  sConfig.Rank = ADC_REGULAR_RANK_1;
 800150c:	2306      	movs	r3, #6
 800150e:	607b      	str	r3, [r7, #4]
  sConfig.SamplingTime = ADC_SAMPLETIME_32CYCLES_5;
 8001510:	2304      	movs	r3, #4
 8001512:	60bb      	str	r3, [r7, #8]
  sConfig.SingleDiff = ADC_SINGLE_ENDED;
 8001514:	f240 73ff 	movw	r3, #2047	@ 0x7ff
 8001518:	60fb      	str	r3, [r7, #12]
  sConfig.OffsetNumber = ADC_OFFSET_NONE;
 800151a:	2304      	movs	r3, #4
 800151c:	613b      	str	r3, [r7, #16]
  sConfig.Offset = 0;
 800151e:	2300      	movs	r3, #0
 8001520:	617b      	str	r3, [r7, #20]
  sConfig.OffsetSignedSaturation = DISABLE;
 8001522:	2300      	movs	r3, #0
 8001524:	767b      	strb	r3, [r7, #25]
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 8001526:	463b      	mov	r3, r7
 8001528:	4619      	mov	r1, r3
 800152a:	4822      	ldr	r0, [pc, #136]	@ (80015b4 <MX_ADC1_Init+0x15c>)
 800152c:	f001 fe78 	bl	8003220 <HAL_ADC_ConfigChannel>
 8001530:	4603      	mov	r3, r0
 8001532:	2b00      	cmp	r3, #0
 8001534:	d001      	beq.n	800153a <MX_ADC1_Init+0xe2>
  {
    Error_Handler();
 8001536:	f000 fc8b 	bl	8001e50 <Error_Handler>
  }

  /** Configure Regular Channel
  */
  sConfig.Channel = ADC_CHANNEL_17;
 800153a:	4b21      	ldr	r3, [pc, #132]	@ (80015c0 <MX_ADC1_Init+0x168>)
 800153c:	603b      	str	r3, [r7, #0]
  sConfig.Rank = ADC_REGULAR_RANK_2;
 800153e:	230c      	movs	r3, #12
 8001540:	607b      	str	r3, [r7, #4]
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 8001542:	463b      	mov	r3, r7
 8001544:	4619      	mov	r1, r3
 8001546:	481b      	ldr	r0, [pc, #108]	@ (80015b4 <MX_ADC1_Init+0x15c>)
 8001548:	f001 fe6a 	bl	8003220 <HAL_ADC_ConfigChannel>
 800154c:	4603      	mov	r3, r0
 800154e:	2b00      	cmp	r3, #0
 8001550:	d001      	beq.n	8001556 <MX_ADC1_Init+0xfe>
  {
    Error_Handler();
 8001552:	f000 fc7d 	bl	8001e50 <Error_Handler>
  }

  /** Configure Regular Channel
  */
  sConfig.Channel = ADC_CHANNEL_14;
 8001556:	4b1b      	ldr	r3, [pc, #108]	@ (80015c4 <MX_ADC1_Init+0x16c>)
 8001558:	603b      	str	r3, [r7, #0]
  sConfig.Rank = ADC_REGULAR_RANK_3;
 800155a:	2312      	movs	r3, #18
 800155c:	607b      	str	r3, [r7, #4]
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 800155e:	463b      	mov	r3, r7
 8001560:	4619      	mov	r1, r3
 8001562:	4814      	ldr	r0, [pc, #80]	@ (80015b4 <MX_ADC1_Init+0x15c>)
 8001564:	f001 fe5c 	bl	8003220 <HAL_ADC_ConfigChannel>
 8001568:	4603      	mov	r3, r0
 800156a:	2b00      	cmp	r3, #0
 800156c:	d001      	beq.n	8001572 <MX_ADC1_Init+0x11a>
  {
    Error_Handler();
 800156e:	f000 fc6f 	bl	8001e50 <Error_Handler>
  }

  /** Configure Regular Channel
  */
  sConfig.Channel = ADC_CHANNEL_15;
 8001572:	4b15      	ldr	r3, [pc, #84]	@ (80015c8 <MX_ADC1_Init+0x170>)
 8001574:	603b      	str	r3, [r7, #0]
  sConfig.Rank = ADC_REGULAR_RANK_4;
 8001576:	2318      	movs	r3, #24
 8001578:	607b      	str	r3, [r7, #4]
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 800157a:	463b      	mov	r3, r7
 800157c:	4619      	mov	r1, r3
 800157e:	480d      	ldr	r0, [pc, #52]	@ (80015b4 <MX_ADC1_Init+0x15c>)
 8001580:	f001 fe4e 	bl	8003220 <HAL_ADC_ConfigChannel>
 8001584:	4603      	mov	r3, r0
 8001586:	2b00      	cmp	r3, #0
 8001588:	d001      	beq.n	800158e <MX_ADC1_Init+0x136>
  {
    Error_Handler();
 800158a:	f000 fc61 	bl	8001e50 <Error_Handler>
  }

  /** Configure Regular Channel
  */
  sConfig.Channel = ADC_CHANNEL_11;
 800158e:	4b0f      	ldr	r3, [pc, #60]	@ (80015cc <MX_ADC1_Init+0x174>)
 8001590:	603b      	str	r3, [r7, #0]
  sConfig.Rank = ADC_REGULAR_RANK_5;
 8001592:	f44f 7380 	mov.w	r3, #256	@ 0x100
 8001596:	607b      	str	r3, [r7, #4]
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 8001598:	463b      	mov	r3, r7
 800159a:	4619      	mov	r1, r3
 800159c:	4805      	ldr	r0, [pc, #20]	@ (80015b4 <MX_ADC1_Init+0x15c>)
 800159e:	f001 fe3f 	bl	8003220 <HAL_ADC_ConfigChannel>
 80015a2:	4603      	mov	r3, r0
 80015a4:	2b00      	cmp	r3, #0
 80015a6:	d001      	beq.n	80015ac <MX_ADC1_Init+0x154>
  {
    Error_Handler();
 80015a8:	f000 fc52 	bl	8001e50 <Error_Handler>
  }
  /* USER CODE BEGIN ADC1_Init 2 */

  /* USER CODE END ADC1_Init 2 */

}
 80015ac:	bf00      	nop
 80015ae:	3728      	adds	r7, #40	@ 0x28
 80015b0:	46bd      	mov	sp, r7
 80015b2:	bd80      	pop	{r7, pc}
 80015b4:	240002bc 	.word	0x240002bc
 80015b8:	40022000 	.word	0x40022000
 80015bc:	43210000 	.word	0x43210000
 80015c0:	47520000 	.word	0x47520000
 80015c4:	3ac04000 	.word	0x3ac04000
 80015c8:	3ef08000 	.word	0x3ef08000
 80015cc:	2e300800 	.word	0x2e300800

080015d0 <MX_ADC2_Init>:
  * @brief ADC2 Initialization Function
  * @param None
  * @retval None
  */
static void MX_ADC2_Init(void)
{
 80015d0:	b580      	push	{r7, lr}
 80015d2:	b088      	sub	sp, #32
 80015d4:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN ADC2_Init 0 */

  /* USER CODE END ADC2_Init 0 */

  ADC_ChannelConfTypeDef sConfig = {0};
 80015d6:	1d3b      	adds	r3, r7, #4
 80015d8:	2200      	movs	r2, #0
 80015da:	601a      	str	r2, [r3, #0]
 80015dc:	605a      	str	r2, [r3, #4]
 80015de:	609a      	str	r2, [r3, #8]
 80015e0:	60da      	str	r2, [r3, #12]
 80015e2:	611a      	str	r2, [r3, #16]
 80015e4:	615a      	str	r2, [r3, #20]
 80015e6:	619a      	str	r2, [r3, #24]

  /* USER CODE END ADC2_Init 1 */

  /** Common config
  */
  hadc2.Instance = ADC2;
 80015e8:	4b29      	ldr	r3, [pc, #164]	@ (8001690 <MX_ADC2_Init+0xc0>)
 80015ea:	4a2a      	ldr	r2, [pc, #168]	@ (8001694 <MX_ADC2_Init+0xc4>)
 80015ec:	601a      	str	r2, [r3, #0]
  hadc2.Init.ClockPrescaler = ADC_CLOCK_ASYNC_DIV2;
 80015ee:	4b28      	ldr	r3, [pc, #160]	@ (8001690 <MX_ADC2_Init+0xc0>)
 80015f0:	f44f 2280 	mov.w	r2, #262144	@ 0x40000
 80015f4:	605a      	str	r2, [r3, #4]
  hadc2.Init.Resolution = ADC_RESOLUTION_16B;
 80015f6:	4b26      	ldr	r3, [pc, #152]	@ (8001690 <MX_ADC2_Init+0xc0>)
 80015f8:	2200      	movs	r2, #0
 80015fa:	609a      	str	r2, [r3, #8]
  hadc2.Init.ScanConvMode = ADC_SCAN_DISABLE;
 80015fc:	4b24      	ldr	r3, [pc, #144]	@ (8001690 <MX_ADC2_Init+0xc0>)
 80015fe:	2200      	movs	r2, #0
 8001600:	60da      	str	r2, [r3, #12]
  hadc2.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
 8001602:	4b23      	ldr	r3, [pc, #140]	@ (8001690 <MX_ADC2_Init+0xc0>)
 8001604:	2204      	movs	r2, #4
 8001606:	611a      	str	r2, [r3, #16]
  hadc2.Init.LowPowerAutoWait = DISABLE;
 8001608:	4b21      	ldr	r3, [pc, #132]	@ (8001690 <MX_ADC2_Init+0xc0>)
 800160a:	2200      	movs	r2, #0
 800160c:	751a      	strb	r2, [r3, #20]
  hadc2.Init.ContinuousConvMode = DISABLE;
 800160e:	4b20      	ldr	r3, [pc, #128]	@ (8001690 <MX_ADC2_Init+0xc0>)
 8001610:	2200      	movs	r2, #0
 8001612:	755a      	strb	r2, [r3, #21]
  hadc2.Init.NbrOfConversion = 1;
 8001614:	4b1e      	ldr	r3, [pc, #120]	@ (8001690 <MX_ADC2_Init+0xc0>)
 8001616:	2201      	movs	r2, #1
 8001618:	619a      	str	r2, [r3, #24]
  hadc2.Init.DiscontinuousConvMode = DISABLE;
 800161a:	4b1d      	ldr	r3, [pc, #116]	@ (8001690 <MX_ADC2_Init+0xc0>)
 800161c:	2200      	movs	r2, #0
 800161e:	771a      	strb	r2, [r3, #28]
  hadc2.Init.ExternalTrigConv = ADC_SOFTWARE_START;
 8001620:	4b1b      	ldr	r3, [pc, #108]	@ (8001690 <MX_ADC2_Init+0xc0>)
 8001622:	2200      	movs	r2, #0
 8001624:	625a      	str	r2, [r3, #36]	@ 0x24
  hadc2.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
 8001626:	4b1a      	ldr	r3, [pc, #104]	@ (8001690 <MX_ADC2_Init+0xc0>)
 8001628:	2200      	movs	r2, #0
 800162a:	629a      	str	r2, [r3, #40]	@ 0x28
  hadc2.Init.ConversionDataManagement = ADC_CONVERSIONDATA_DR;
 800162c:	4b18      	ldr	r3, [pc, #96]	@ (8001690 <MX_ADC2_Init+0xc0>)
 800162e:	2200      	movs	r2, #0
 8001630:	62da      	str	r2, [r3, #44]	@ 0x2c
  hadc2.Init.Overrun = ADC_OVR_DATA_PRESERVED;
 8001632:	4b17      	ldr	r3, [pc, #92]	@ (8001690 <MX_ADC2_Init+0xc0>)
 8001634:	2200      	movs	r2, #0
 8001636:	631a      	str	r2, [r3, #48]	@ 0x30
  hadc2.Init.LeftBitShift = ADC_LEFTBITSHIFT_NONE;
 8001638:	4b15      	ldr	r3, [pc, #84]	@ (8001690 <MX_ADC2_Init+0xc0>)
 800163a:	2200      	movs	r2, #0
 800163c:	635a      	str	r2, [r3, #52]	@ 0x34
  hadc2.Init.OversamplingMode = DISABLE;
 800163e:	4b14      	ldr	r3, [pc, #80]	@ (8001690 <MX_ADC2_Init+0xc0>)
 8001640:	2200      	movs	r2, #0
 8001642:	f883 2038 	strb.w	r2, [r3, #56]	@ 0x38
  if (HAL_ADC_Init(&hadc2) != HAL_OK)
 8001646:	4812      	ldr	r0, [pc, #72]	@ (8001690 <MX_ADC2_Init+0xc0>)
 8001648:	f001 fbc8 	bl	8002ddc <HAL_ADC_Init>
 800164c:	4603      	mov	r3, r0
 800164e:	2b00      	cmp	r3, #0
 8001650:	d001      	beq.n	8001656 <MX_ADC2_Init+0x86>
  {
    Error_Handler();
 8001652:	f000 fbfd 	bl	8001e50 <Error_Handler>
  }

  /** Configure Regular Channel
  */
  sConfig.Channel = ADC_CHANNEL_TEMPSENSOR;
 8001656:	4b10      	ldr	r3, [pc, #64]	@ (8001698 <MX_ADC2_Init+0xc8>)
 8001658:	607b      	str	r3, [r7, #4]
  sConfig.Rank = ADC_REGULAR_RANK_1;
 800165a:	2306      	movs	r3, #6
 800165c:	60bb      	str	r3, [r7, #8]
  sConfig.SamplingTime = ADC_SAMPLETIME_1CYCLE_5;
 800165e:	2300      	movs	r3, #0
 8001660:	60fb      	str	r3, [r7, #12]
  sConfig.SingleDiff = ADC_SINGLE_ENDED;
 8001662:	f240 73ff 	movw	r3, #2047	@ 0x7ff
 8001666:	613b      	str	r3, [r7, #16]
  sConfig.OffsetNumber = ADC_OFFSET_NONE;
 8001668:	2304      	movs	r3, #4
 800166a:	617b      	str	r3, [r7, #20]
  sConfig.Offset = 0;
 800166c:	2300      	movs	r3, #0
 800166e:	61bb      	str	r3, [r7, #24]
  sConfig.OffsetSignedSaturation = DISABLE;
 8001670:	2300      	movs	r3, #0
 8001672:	777b      	strb	r3, [r7, #29]
  if (HAL_ADC_ConfigChannel(&hadc2, &sConfig) != HAL_OK)
 8001674:	1d3b      	adds	r3, r7, #4
 8001676:	4619      	mov	r1, r3
 8001678:	4805      	ldr	r0, [pc, #20]	@ (8001690 <MX_ADC2_Init+0xc0>)
 800167a:	f001 fdd1 	bl	8003220 <HAL_ADC_ConfigChannel>
 800167e:	4603      	mov	r3, r0
 8001680:	2b00      	cmp	r3, #0
 8001682:	d001      	beq.n	8001688 <MX_ADC2_Init+0xb8>
  {
    Error_Handler();
 8001684:	f000 fbe4 	bl	8001e50 <Error_Handler>
  }
  /* USER CODE BEGIN ADC2_Init 2 */

  /* USER CODE END ADC2_Init 2 */

}
 8001688:	bf00      	nop
 800168a:	3720      	adds	r7, #32
 800168c:	46bd      	mov	sp, r7
 800168e:	bd80      	pop	{r7, pc}
 8001690:	24000320 	.word	0x24000320
 8001694:	40022100 	.word	0x40022100
 8001698:	cb840000 	.word	0xcb840000

0800169c <MX_I2C1_Init>:
  * @brief I2C1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_I2C1_Init(void)
{
 800169c:	b580      	push	{r7, lr}
 800169e:	af00      	add	r7, sp, #0
  /* USER CODE END I2C1_Init 0 */

  /* USER CODE BEGIN I2C1_Init 1 */

  /* USER CODE END I2C1_Init 1 */
  hi2c1.Instance = I2C1;
 80016a0:	4b1b      	ldr	r3, [pc, #108]	@ (8001710 <MX_I2C1_Init+0x74>)
 80016a2:	4a1c      	ldr	r2, [pc, #112]	@ (8001714 <MX_I2C1_Init+0x78>)
 80016a4:	601a      	str	r2, [r3, #0]
  hi2c1.Init.Timing = 0x20B0CCFF;
 80016a6:	4b1a      	ldr	r3, [pc, #104]	@ (8001710 <MX_I2C1_Init+0x74>)
 80016a8:	4a1b      	ldr	r2, [pc, #108]	@ (8001718 <MX_I2C1_Init+0x7c>)
 80016aa:	605a      	str	r2, [r3, #4]
  hi2c1.Init.OwnAddress1 = 0;
 80016ac:	4b18      	ldr	r3, [pc, #96]	@ (8001710 <MX_I2C1_Init+0x74>)
 80016ae:	2200      	movs	r2, #0
 80016b0:	609a      	str	r2, [r3, #8]
  hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 80016b2:	4b17      	ldr	r3, [pc, #92]	@ (8001710 <MX_I2C1_Init+0x74>)
 80016b4:	2201      	movs	r2, #1
 80016b6:	60da      	str	r2, [r3, #12]
  hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
 80016b8:	4b15      	ldr	r3, [pc, #84]	@ (8001710 <MX_I2C1_Init+0x74>)
 80016ba:	2200      	movs	r2, #0
 80016bc:	611a      	str	r2, [r3, #16]
  hi2c1.Init.OwnAddress2 = 0;
 80016be:	4b14      	ldr	r3, [pc, #80]	@ (8001710 <MX_I2C1_Init+0x74>)
 80016c0:	2200      	movs	r2, #0
 80016c2:	615a      	str	r2, [r3, #20]
  hi2c1.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
 80016c4:	4b12      	ldr	r3, [pc, #72]	@ (8001710 <MX_I2C1_Init+0x74>)
 80016c6:	2200      	movs	r2, #0
 80016c8:	619a      	str	r2, [r3, #24]
  hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
 80016ca:	4b11      	ldr	r3, [pc, #68]	@ (8001710 <MX_I2C1_Init+0x74>)
 80016cc:	2200      	movs	r2, #0
 80016ce:	61da      	str	r2, [r3, #28]
  hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
 80016d0:	4b0f      	ldr	r3, [pc, #60]	@ (8001710 <MX_I2C1_Init+0x74>)
 80016d2:	2200      	movs	r2, #0
 80016d4:	621a      	str	r2, [r3, #32]
  if (HAL_I2C_Init(&hi2c1) != HAL_OK)
 80016d6:	480e      	ldr	r0, [pc, #56]	@ (8001710 <MX_I2C1_Init+0x74>)
 80016d8:	f005 f92e 	bl	8006938 <HAL_I2C_Init>
 80016dc:	4603      	mov	r3, r0
 80016de:	2b00      	cmp	r3, #0
 80016e0:	d001      	beq.n	80016e6 <MX_I2C1_Init+0x4a>
  {
    Error_Handler();
 80016e2:	f000 fbb5 	bl	8001e50 <Error_Handler>
  }

  /** Configure Analogue filter
  */
  if (HAL_I2CEx_ConfigAnalogFilter(&hi2c1, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
 80016e6:	2100      	movs	r1, #0
 80016e8:	4809      	ldr	r0, [pc, #36]	@ (8001710 <MX_I2C1_Init+0x74>)
 80016ea:	f005 feb1 	bl	8007450 <HAL_I2CEx_ConfigAnalogFilter>
 80016ee:	4603      	mov	r3, r0
 80016f0:	2b00      	cmp	r3, #0
 80016f2:	d001      	beq.n	80016f8 <MX_I2C1_Init+0x5c>
  {
    Error_Handler();
 80016f4:	f000 fbac 	bl	8001e50 <Error_Handler>
  }

  /** Configure Digital filter
  */
  if (HAL_I2CEx_ConfigDigitalFilter(&hi2c1, 0) != HAL_OK)
 80016f8:	2100      	movs	r1, #0
 80016fa:	4805      	ldr	r0, [pc, #20]	@ (8001710 <MX_I2C1_Init+0x74>)
 80016fc:	f005 fef3 	bl	80074e6 <HAL_I2CEx_ConfigDigitalFilter>
 8001700:	4603      	mov	r3, r0
 8001702:	2b00      	cmp	r3, #0
 8001704:	d001      	beq.n	800170a <MX_I2C1_Init+0x6e>
  {
    Error_Handler();
 8001706:	f000 fba3 	bl	8001e50 <Error_Handler>
  }
  /* USER CODE BEGIN I2C1_Init 2 */

  /* USER CODE END I2C1_Init 2 */

}
 800170a:	bf00      	nop
 800170c:	bd80      	pop	{r7, pc}
 800170e:	bf00      	nop
 8001710:	240003fc 	.word	0x240003fc
 8001714:	40005400 	.word	0x40005400
 8001718:	20b0ccff 	.word	0x20b0ccff

0800171c <MX_OCTOSPI2_Init>:
  * @brief OCTOSPI2 Initialization Function
  * @param None
  * @retval None
  */
static void MX_OCTOSPI2_Init(void)
{
 800171c:	b580      	push	{r7, lr}
 800171e:	b086      	sub	sp, #24
 8001720:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN OCTOSPI2_Init 0 */

  /* USER CODE END OCTOSPI2_Init 0 */

  OSPIM_CfgTypeDef sOspiManagerCfg = {0};
 8001722:	463b      	mov	r3, r7
 8001724:	2200      	movs	r2, #0
 8001726:	601a      	str	r2, [r3, #0]
 8001728:	605a      	str	r2, [r3, #4]
 800172a:	609a      	str	r2, [r3, #8]
 800172c:	60da      	str	r2, [r3, #12]
 800172e:	611a      	str	r2, [r3, #16]
 8001730:	615a      	str	r2, [r3, #20]

  /* USER CODE BEGIN OCTOSPI2_Init 1 */

  /* USER CODE END OCTOSPI2_Init 1 */
  /* OCTOSPI2 parameter configuration*/
  hospi2.Instance = OCTOSPI2;
 8001732:	4b27      	ldr	r3, [pc, #156]	@ (80017d0 <MX_OCTOSPI2_Init+0xb4>)
 8001734:	4a27      	ldr	r2, [pc, #156]	@ (80017d4 <MX_OCTOSPI2_Init+0xb8>)
 8001736:	601a      	str	r2, [r3, #0]
  hospi2.Init.FifoThreshold = 1;
 8001738:	4b25      	ldr	r3, [pc, #148]	@ (80017d0 <MX_OCTOSPI2_Init+0xb4>)
 800173a:	2201      	movs	r2, #1
 800173c:	605a      	str	r2, [r3, #4]
  hospi2.Init.DualQuad = HAL_OSPI_DUALQUAD_DISABLE;
 800173e:	4b24      	ldr	r3, [pc, #144]	@ (80017d0 <MX_OCTOSPI2_Init+0xb4>)
 8001740:	2200      	movs	r2, #0
 8001742:	609a      	str	r2, [r3, #8]
  hospi2.Init.MemoryType = HAL_OSPI_MEMTYPE_MICRON;
 8001744:	4b22      	ldr	r3, [pc, #136]	@ (80017d0 <MX_OCTOSPI2_Init+0xb4>)
 8001746:	2200      	movs	r2, #0
 8001748:	60da      	str	r2, [r3, #12]
  hospi2.Init.DeviceSize = 32;
 800174a:	4b21      	ldr	r3, [pc, #132]	@ (80017d0 <MX_OCTOSPI2_Init+0xb4>)
 800174c:	2220      	movs	r2, #32
 800174e:	611a      	str	r2, [r3, #16]
  hospi2.Init.ChipSelectHighTime = 1;
 8001750:	4b1f      	ldr	r3, [pc, #124]	@ (80017d0 <MX_OCTOSPI2_Init+0xb4>)
 8001752:	2201      	movs	r2, #1
 8001754:	615a      	str	r2, [r3, #20]
  hospi2.Init.FreeRunningClock = HAL_OSPI_FREERUNCLK_DISABLE;
 8001756:	4b1e      	ldr	r3, [pc, #120]	@ (80017d0 <MX_OCTOSPI2_Init+0xb4>)
 8001758:	2200      	movs	r2, #0
 800175a:	619a      	str	r2, [r3, #24]
  hospi2.Init.ClockMode = HAL_OSPI_CLOCK_MODE_0;
 800175c:	4b1c      	ldr	r3, [pc, #112]	@ (80017d0 <MX_OCTOSPI2_Init+0xb4>)
 800175e:	2200      	movs	r2, #0
 8001760:	61da      	str	r2, [r3, #28]
  hospi2.Init.WrapSize = HAL_OSPI_WRAP_NOT_SUPPORTED;
 8001762:	4b1b      	ldr	r3, [pc, #108]	@ (80017d0 <MX_OCTOSPI2_Init+0xb4>)
 8001764:	2200      	movs	r2, #0
 8001766:	621a      	str	r2, [r3, #32]
  hospi2.Init.ClockPrescaler = 1;
 8001768:	4b19      	ldr	r3, [pc, #100]	@ (80017d0 <MX_OCTOSPI2_Init+0xb4>)
 800176a:	2201      	movs	r2, #1
 800176c:	625a      	str	r2, [r3, #36]	@ 0x24
  hospi2.Init.SampleShifting = HAL_OSPI_SAMPLE_SHIFTING_NONE;
 800176e:	4b18      	ldr	r3, [pc, #96]	@ (80017d0 <MX_OCTOSPI2_Init+0xb4>)
 8001770:	2200      	movs	r2, #0
 8001772:	629a      	str	r2, [r3, #40]	@ 0x28
  hospi2.Init.DelayHoldQuarterCycle = HAL_OSPI_DHQC_DISABLE;
 8001774:	4b16      	ldr	r3, [pc, #88]	@ (80017d0 <MX_OCTOSPI2_Init+0xb4>)
 8001776:	2200      	movs	r2, #0
 8001778:	62da      	str	r2, [r3, #44]	@ 0x2c
  hospi2.Init.ChipSelectBoundary = 0;
 800177a:	4b15      	ldr	r3, [pc, #84]	@ (80017d0 <MX_OCTOSPI2_Init+0xb4>)
 800177c:	2200      	movs	r2, #0
 800177e:	631a      	str	r2, [r3, #48]	@ 0x30
  hospi2.Init.DelayBlockBypass = HAL_OSPI_DELAY_BLOCK_BYPASSED;
 8001780:	4b13      	ldr	r3, [pc, #76]	@ (80017d0 <MX_OCTOSPI2_Init+0xb4>)
 8001782:	2208      	movs	r2, #8
 8001784:	635a      	str	r2, [r3, #52]	@ 0x34
  hospi2.Init.MaxTran = 0;
 8001786:	4b12      	ldr	r3, [pc, #72]	@ (80017d0 <MX_OCTOSPI2_Init+0xb4>)
 8001788:	2200      	movs	r2, #0
 800178a:	639a      	str	r2, [r3, #56]	@ 0x38
  hospi2.Init.Refresh = 0;
 800178c:	4b10      	ldr	r3, [pc, #64]	@ (80017d0 <MX_OCTOSPI2_Init+0xb4>)
 800178e:	2200      	movs	r2, #0
 8001790:	63da      	str	r2, [r3, #60]	@ 0x3c
  if (HAL_OSPI_Init(&hospi2) != HAL_OK)
 8001792:	480f      	ldr	r0, [pc, #60]	@ (80017d0 <MX_OCTOSPI2_Init+0xb4>)
 8001794:	f005 fef4 	bl	8007580 <HAL_OSPI_Init>
 8001798:	4603      	mov	r3, r0
 800179a:	2b00      	cmp	r3, #0
 800179c:	d001      	beq.n	80017a2 <MX_OCTOSPI2_Init+0x86>
  {
    Error_Handler();
 800179e:	f000 fb57 	bl	8001e50 <Error_Handler>
  }
  sOspiManagerCfg.ClkPort = 1;
 80017a2:	2301      	movs	r3, #1
 80017a4:	603b      	str	r3, [r7, #0]
  sOspiManagerCfg.NCSPort = 1;
 80017a6:	2301      	movs	r3, #1
 80017a8:	60bb      	str	r3, [r7, #8]
  sOspiManagerCfg.IOLowPort = HAL_OSPIM_IOPORT_1_LOW;
 80017aa:	f04f 1301 	mov.w	r3, #65537	@ 0x10001
 80017ae:	60fb      	str	r3, [r7, #12]
  if (HAL_OSPIM_Config(&hospi2, &sOspiManagerCfg, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 80017b0:	463b      	mov	r3, r7
 80017b2:	f241 3288 	movw	r2, #5000	@ 0x1388
 80017b6:	4619      	mov	r1, r3
 80017b8:	4805      	ldr	r0, [pc, #20]	@ (80017d0 <MX_OCTOSPI2_Init+0xb4>)
 80017ba:	f005 ffad 	bl	8007718 <HAL_OSPIM_Config>
 80017be:	4603      	mov	r3, r0
 80017c0:	2b00      	cmp	r3, #0
 80017c2:	d001      	beq.n	80017c8 <MX_OCTOSPI2_Init+0xac>
  {
    Error_Handler();
 80017c4:	f000 fb44 	bl	8001e50 <Error_Handler>
  }
  /* USER CODE BEGIN OCTOSPI2_Init 2 */

  /* USER CODE END OCTOSPI2_Init 2 */

}
 80017c8:	bf00      	nop
 80017ca:	3718      	adds	r7, #24
 80017cc:	46bd      	mov	sp, r7
 80017ce:	bd80      	pop	{r7, pc}
 80017d0:	24000450 	.word	0x24000450
 80017d4:	5200a000 	.word	0x5200a000

080017d8 <MX_SAI1_Init>:
  * @brief SAI1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_SAI1_Init(void)
{
 80017d8:	b580      	push	{r7, lr}
 80017da:	af00      	add	r7, sp, #0
  /* USER CODE END SAI1_Init 0 */

  /* USER CODE BEGIN SAI1_Init 1 */

  /* USER CODE END SAI1_Init 1 */
  hsai_BlockA1.Instance = SAI1_Block_A;
 80017dc:	4b2a      	ldr	r3, [pc, #168]	@ (8001888 <MX_SAI1_Init+0xb0>)
 80017de:	4a2b      	ldr	r2, [pc, #172]	@ (800188c <MX_SAI1_Init+0xb4>)
 80017e0:	601a      	str	r2, [r3, #0]
  hsai_BlockA1.Init.AudioMode = SAI_MODEMASTER_TX;
 80017e2:	4b29      	ldr	r3, [pc, #164]	@ (8001888 <MX_SAI1_Init+0xb0>)
 80017e4:	2200      	movs	r2, #0
 80017e6:	605a      	str	r2, [r3, #4]
  hsai_BlockA1.Init.Synchro = SAI_ASYNCHRONOUS;
 80017e8:	4b27      	ldr	r3, [pc, #156]	@ (8001888 <MX_SAI1_Init+0xb0>)
 80017ea:	2200      	movs	r2, #0
 80017ec:	609a      	str	r2, [r3, #8]
  hsai_BlockA1.Init.OutputDrive = SAI_OUTPUTDRIVE_DISABLE;
 80017ee:	4b26      	ldr	r3, [pc, #152]	@ (8001888 <MX_SAI1_Init+0xb0>)
 80017f0:	2200      	movs	r2, #0
 80017f2:	615a      	str	r2, [r3, #20]
  hsai_BlockA1.Init.NoDivider = SAI_MASTERDIVIDER_ENABLE;
 80017f4:	4b24      	ldr	r3, [pc, #144]	@ (8001888 <MX_SAI1_Init+0xb0>)
 80017f6:	2200      	movs	r2, #0
 80017f8:	619a      	str	r2, [r3, #24]
  hsai_BlockA1.Init.FIFOThreshold = SAI_FIFOTHRESHOLD_EMPTY;
 80017fa:	4b23      	ldr	r3, [pc, #140]	@ (8001888 <MX_SAI1_Init+0xb0>)
 80017fc:	2200      	movs	r2, #0
 80017fe:	61da      	str	r2, [r3, #28]
  hsai_BlockA1.Init.AudioFrequency = SAI_AUDIO_FREQUENCY_32K;
 8001800:	4b21      	ldr	r3, [pc, #132]	@ (8001888 <MX_SAI1_Init+0xb0>)
 8001802:	f44f 42fa 	mov.w	r2, #32000	@ 0x7d00
 8001806:	621a      	str	r2, [r3, #32]
  hsai_BlockA1.Init.SynchroExt = SAI_SYNCEXT_DISABLE;
 8001808:	4b1f      	ldr	r3, [pc, #124]	@ (8001888 <MX_SAI1_Init+0xb0>)
 800180a:	2200      	movs	r2, #0
 800180c:	60da      	str	r2, [r3, #12]
  hsai_BlockA1.Init.MonoStereoMode = SAI_STEREOMODE;
 800180e:	4b1e      	ldr	r3, [pc, #120]	@ (8001888 <MX_SAI1_Init+0xb0>)
 8001810:	2200      	movs	r2, #0
 8001812:	62da      	str	r2, [r3, #44]	@ 0x2c
  hsai_BlockA1.Init.CompandingMode = SAI_NOCOMPANDING;
 8001814:	4b1c      	ldr	r3, [pc, #112]	@ (8001888 <MX_SAI1_Init+0xb0>)
 8001816:	2200      	movs	r2, #0
 8001818:	631a      	str	r2, [r3, #48]	@ 0x30
  hsai_BlockA1.Init.TriState = SAI_OUTPUT_NOTRELEASED;
 800181a:	4b1b      	ldr	r3, [pc, #108]	@ (8001888 <MX_SAI1_Init+0xb0>)
 800181c:	2200      	movs	r2, #0
 800181e:	635a      	str	r2, [r3, #52]	@ 0x34
  if (HAL_SAI_InitProtocol(&hsai_BlockA1, SAI_I2S_STANDARD, SAI_PROTOCOL_DATASIZE_24BIT, 2) != HAL_OK)
 8001820:	2302      	movs	r3, #2
 8001822:	2202      	movs	r2, #2
 8001824:	2100      	movs	r1, #0
 8001826:	4818      	ldr	r0, [pc, #96]	@ (8001888 <MX_SAI1_Init+0xb0>)
 8001828:	f00b fbea 	bl	800d000 <HAL_SAI_InitProtocol>
 800182c:	4603      	mov	r3, r0
 800182e:	2b00      	cmp	r3, #0
 8001830:	d001      	beq.n	8001836 <MX_SAI1_Init+0x5e>
  {
    Error_Handler();
 8001832:	f000 fb0d 	bl	8001e50 <Error_Handler>
  }
  hsai_BlockB1.Instance = SAI1_Block_B;
 8001836:	4b16      	ldr	r3, [pc, #88]	@ (8001890 <MX_SAI1_Init+0xb8>)
 8001838:	4a16      	ldr	r2, [pc, #88]	@ (8001894 <MX_SAI1_Init+0xbc>)
 800183a:	601a      	str	r2, [r3, #0]
  hsai_BlockB1.Init.AudioMode = SAI_MODESLAVE_RX;
 800183c:	4b14      	ldr	r3, [pc, #80]	@ (8001890 <MX_SAI1_Init+0xb8>)
 800183e:	2203      	movs	r2, #3
 8001840:	605a      	str	r2, [r3, #4]
  hsai_BlockB1.Init.Synchro = SAI_SYNCHRONOUS;
 8001842:	4b13      	ldr	r3, [pc, #76]	@ (8001890 <MX_SAI1_Init+0xb8>)
 8001844:	2201      	movs	r2, #1
 8001846:	609a      	str	r2, [r3, #8]
  hsai_BlockB1.Init.OutputDrive = SAI_OUTPUTDRIVE_DISABLE;
 8001848:	4b11      	ldr	r3, [pc, #68]	@ (8001890 <MX_SAI1_Init+0xb8>)
 800184a:	2200      	movs	r2, #0
 800184c:	615a      	str	r2, [r3, #20]
  hsai_BlockB1.Init.FIFOThreshold = SAI_FIFOTHRESHOLD_EMPTY;
 800184e:	4b10      	ldr	r3, [pc, #64]	@ (8001890 <MX_SAI1_Init+0xb8>)
 8001850:	2200      	movs	r2, #0
 8001852:	61da      	str	r2, [r3, #28]
  hsai_BlockB1.Init.SynchroExt = SAI_SYNCEXT_DISABLE;
 8001854:	4b0e      	ldr	r3, [pc, #56]	@ (8001890 <MX_SAI1_Init+0xb8>)
 8001856:	2200      	movs	r2, #0
 8001858:	60da      	str	r2, [r3, #12]
  hsai_BlockB1.Init.MonoStereoMode = SAI_STEREOMODE;
 800185a:	4b0d      	ldr	r3, [pc, #52]	@ (8001890 <MX_SAI1_Init+0xb8>)
 800185c:	2200      	movs	r2, #0
 800185e:	62da      	str	r2, [r3, #44]	@ 0x2c
  hsai_BlockB1.Init.CompandingMode = SAI_NOCOMPANDING;
 8001860:	4b0b      	ldr	r3, [pc, #44]	@ (8001890 <MX_SAI1_Init+0xb8>)
 8001862:	2200      	movs	r2, #0
 8001864:	631a      	str	r2, [r3, #48]	@ 0x30
  hsai_BlockB1.Init.TriState = SAI_OUTPUT_NOTRELEASED;
 8001866:	4b0a      	ldr	r3, [pc, #40]	@ (8001890 <MX_SAI1_Init+0xb8>)
 8001868:	2200      	movs	r2, #0
 800186a:	635a      	str	r2, [r3, #52]	@ 0x34
  if (HAL_SAI_InitProtocol(&hsai_BlockB1, SAI_I2S_STANDARD, SAI_PROTOCOL_DATASIZE_24BIT, 2) != HAL_OK)
 800186c:	2302      	movs	r3, #2
 800186e:	2202      	movs	r2, #2
 8001870:	2100      	movs	r1, #0
 8001872:	4807      	ldr	r0, [pc, #28]	@ (8001890 <MX_SAI1_Init+0xb8>)
 8001874:	f00b fbc4 	bl	800d000 <HAL_SAI_InitProtocol>
 8001878:	4603      	mov	r3, r0
 800187a:	2b00      	cmp	r3, #0
 800187c:	d001      	beq.n	8001882 <MX_SAI1_Init+0xaa>
  {
    Error_Handler();
 800187e:	f000 fae7 	bl	8001e50 <Error_Handler>
  }
  /* USER CODE BEGIN SAI1_Init 2 */

  /* USER CODE END SAI1_Init 2 */

}
 8001882:	bf00      	nop
 8001884:	bd80      	pop	{r7, pc}
 8001886:	bf00      	nop
 8001888:	240004ac 	.word	0x240004ac
 800188c:	40015804 	.word	0x40015804
 8001890:	24000544 	.word	0x24000544
 8001894:	40015824 	.word	0x40015824

08001898 <MX_TIM1_Init>:
  * @brief TIM1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_TIM1_Init(void)
{
 8001898:	b580      	push	{r7, lr}
 800189a:	b09c      	sub	sp, #112	@ 0x70
 800189c:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN TIM1_Init 0 */

  /* USER CODE END TIM1_Init 0 */

  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
 800189e:	f107 0360 	add.w	r3, r7, #96	@ 0x60
 80018a2:	2200      	movs	r2, #0
 80018a4:	601a      	str	r2, [r3, #0]
 80018a6:	605a      	str	r2, [r3, #4]
 80018a8:	609a      	str	r2, [r3, #8]
 80018aa:	60da      	str	r2, [r3, #12]
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 80018ac:	f107 0354 	add.w	r3, r7, #84	@ 0x54
 80018b0:	2200      	movs	r2, #0
 80018b2:	601a      	str	r2, [r3, #0]
 80018b4:	605a      	str	r2, [r3, #4]
 80018b6:	609a      	str	r2, [r3, #8]
  TIM_OC_InitTypeDef sConfigOC = {0};
 80018b8:	f107 0338 	add.w	r3, r7, #56	@ 0x38
 80018bc:	2200      	movs	r2, #0
 80018be:	601a      	str	r2, [r3, #0]
 80018c0:	605a      	str	r2, [r3, #4]
 80018c2:	609a      	str	r2, [r3, #8]
 80018c4:	60da      	str	r2, [r3, #12]
 80018c6:	611a      	str	r2, [r3, #16]
 80018c8:	615a      	str	r2, [r3, #20]
 80018ca:	619a      	str	r2, [r3, #24]
  TIM_BreakDeadTimeConfigTypeDef sBreakDeadTimeConfig = {0};
 80018cc:	1d3b      	adds	r3, r7, #4
 80018ce:	2234      	movs	r2, #52	@ 0x34
 80018d0:	2100      	movs	r1, #0
 80018d2:	4618      	mov	r0, r3
 80018d4:	f011 fb6a 	bl	8012fac <memset>

  /* USER CODE BEGIN TIM1_Init 1 */

  /* USER CODE END TIM1_Init 1 */
  htim1.Instance = TIM1;
 80018d8:	4b43      	ldr	r3, [pc, #268]	@ (80019e8 <MX_TIM1_Init+0x150>)
 80018da:	4a44      	ldr	r2, [pc, #272]	@ (80019ec <MX_TIM1_Init+0x154>)
 80018dc:	601a      	str	r2, [r3, #0]
  htim1.Init.Prescaler = 28000-1;
 80018de:	4b42      	ldr	r3, [pc, #264]	@ (80019e8 <MX_TIM1_Init+0x150>)
 80018e0:	f646 525f 	movw	r2, #27999	@ 0x6d5f
 80018e4:	605a      	str	r2, [r3, #4]
  htim1.Init.CounterMode = TIM_COUNTERMODE_UP;
 80018e6:	4b40      	ldr	r3, [pc, #256]	@ (80019e8 <MX_TIM1_Init+0x150>)
 80018e8:	2200      	movs	r2, #0
 80018ea:	609a      	str	r2, [r3, #8]
  htim1.Init.Period = 100-1;
 80018ec:	4b3e      	ldr	r3, [pc, #248]	@ (80019e8 <MX_TIM1_Init+0x150>)
 80018ee:	2263      	movs	r2, #99	@ 0x63
 80018f0:	60da      	str	r2, [r3, #12]
  htim1.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 80018f2:	4b3d      	ldr	r3, [pc, #244]	@ (80019e8 <MX_TIM1_Init+0x150>)
 80018f4:	2200      	movs	r2, #0
 80018f6:	611a      	str	r2, [r3, #16]
  htim1.Init.RepetitionCounter = 0;
 80018f8:	4b3b      	ldr	r3, [pc, #236]	@ (80019e8 <MX_TIM1_Init+0x150>)
 80018fa:	2200      	movs	r2, #0
 80018fc:	615a      	str	r2, [r3, #20]
  htim1.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 80018fe:	4b3a      	ldr	r3, [pc, #232]	@ (80019e8 <MX_TIM1_Init+0x150>)
 8001900:	2200      	movs	r2, #0
 8001902:	619a      	str	r2, [r3, #24]
  if (HAL_TIM_Base_Init(&htim1) != HAL_OK)
 8001904:	4838      	ldr	r0, [pc, #224]	@ (80019e8 <MX_TIM1_Init+0x150>)
 8001906:	f00c f96e 	bl	800dbe6 <HAL_TIM_Base_Init>
 800190a:	4603      	mov	r3, r0
 800190c:	2b00      	cmp	r3, #0
 800190e:	d001      	beq.n	8001914 <MX_TIM1_Init+0x7c>
  {
    Error_Handler();
 8001910:	f000 fa9e 	bl	8001e50 <Error_Handler>
  }
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 8001914:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 8001918:	663b      	str	r3, [r7, #96]	@ 0x60
  if (HAL_TIM_ConfigClockSource(&htim1, &sClockSourceConfig) != HAL_OK)
 800191a:	f107 0360 	add.w	r3, r7, #96	@ 0x60
 800191e:	4619      	mov	r1, r3
 8001920:	4831      	ldr	r0, [pc, #196]	@ (80019e8 <MX_TIM1_Init+0x150>)
 8001922:	f00c fdb3 	bl	800e48c <HAL_TIM_ConfigClockSource>
 8001926:	4603      	mov	r3, r0
 8001928:	2b00      	cmp	r3, #0
 800192a:	d001      	beq.n	8001930 <MX_TIM1_Init+0x98>
  {
    Error_Handler();
 800192c:	f000 fa90 	bl	8001e50 <Error_Handler>
  }
  if (HAL_TIM_PWM_Init(&htim1) != HAL_OK)
 8001930:	482d      	ldr	r0, [pc, #180]	@ (80019e8 <MX_TIM1_Init+0x150>)
 8001932:	f00c fa1f 	bl	800dd74 <HAL_TIM_PWM_Init>
 8001936:	4603      	mov	r3, r0
 8001938:	2b00      	cmp	r3, #0
 800193a:	d001      	beq.n	8001940 <MX_TIM1_Init+0xa8>
  {
    Error_Handler();
 800193c:	f000 fa88 	bl	8001e50 <Error_Handler>
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 8001940:	2300      	movs	r3, #0
 8001942:	657b      	str	r3, [r7, #84]	@ 0x54
  sMasterConfig.MasterOutputTrigger2 = TIM_TRGO2_RESET;
 8001944:	2300      	movs	r3, #0
 8001946:	65bb      	str	r3, [r7, #88]	@ 0x58
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 8001948:	2300      	movs	r3, #0
 800194a:	65fb      	str	r3, [r7, #92]	@ 0x5c
  if (HAL_TIMEx_MasterConfigSynchronization(&htim1, &sMasterConfig) != HAL_OK)
 800194c:	f107 0354 	add.w	r3, r7, #84	@ 0x54
 8001950:	4619      	mov	r1, r3
 8001952:	4825      	ldr	r0, [pc, #148]	@ (80019e8 <MX_TIM1_Init+0x150>)
 8001954:	f00d fb04 	bl	800ef60 <HAL_TIMEx_MasterConfigSynchronization>
 8001958:	4603      	mov	r3, r0
 800195a:	2b00      	cmp	r3, #0
 800195c:	d001      	beq.n	8001962 <MX_TIM1_Init+0xca>
  {
    Error_Handler();
 800195e:	f000 fa77 	bl	8001e50 <Error_Handler>
  }
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
 8001962:	2360      	movs	r3, #96	@ 0x60
 8001964:	63bb      	str	r3, [r7, #56]	@ 0x38
  sConfigOC.Pulse = 0;
 8001966:	2300      	movs	r3, #0
 8001968:	63fb      	str	r3, [r7, #60]	@ 0x3c
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 800196a:	2300      	movs	r3, #0
 800196c:	643b      	str	r3, [r7, #64]	@ 0x40
  sConfigOC.OCNPolarity = TIM_OCNPOLARITY_HIGH;
 800196e:	2300      	movs	r3, #0
 8001970:	647b      	str	r3, [r7, #68]	@ 0x44
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 8001972:	2300      	movs	r3, #0
 8001974:	64bb      	str	r3, [r7, #72]	@ 0x48
  sConfigOC.OCIdleState = TIM_OCIDLESTATE_RESET;
 8001976:	2300      	movs	r3, #0
 8001978:	64fb      	str	r3, [r7, #76]	@ 0x4c
  sConfigOC.OCNIdleState = TIM_OCNIDLESTATE_RESET;
 800197a:	2300      	movs	r3, #0
 800197c:	653b      	str	r3, [r7, #80]	@ 0x50
  if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 800197e:	f107 0338 	add.w	r3, r7, #56	@ 0x38
 8001982:	2200      	movs	r2, #0
 8001984:	4619      	mov	r1, r3
 8001986:	4818      	ldr	r0, [pc, #96]	@ (80019e8 <MX_TIM1_Init+0x150>)
 8001988:	f00c fc6c 	bl	800e264 <HAL_TIM_PWM_ConfigChannel>
 800198c:	4603      	mov	r3, r0
 800198e:	2b00      	cmp	r3, #0
 8001990:	d001      	beq.n	8001996 <MX_TIM1_Init+0xfe>
  {
    Error_Handler();
 8001992:	f000 fa5d 	bl	8001e50 <Error_Handler>
  }
  sBreakDeadTimeConfig.OffStateRunMode = TIM_OSSR_DISABLE;
 8001996:	2300      	movs	r3, #0
 8001998:	607b      	str	r3, [r7, #4]
  sBreakDeadTimeConfig.OffStateIDLEMode = TIM_OSSI_DISABLE;
 800199a:	2300      	movs	r3, #0
 800199c:	60bb      	str	r3, [r7, #8]
  sBreakDeadTimeConfig.LockLevel = TIM_LOCKLEVEL_OFF;
 800199e:	2300      	movs	r3, #0
 80019a0:	60fb      	str	r3, [r7, #12]
  sBreakDeadTimeConfig.DeadTime = 0;
 80019a2:	2300      	movs	r3, #0
 80019a4:	613b      	str	r3, [r7, #16]
  sBreakDeadTimeConfig.BreakState = TIM_BREAK_DISABLE;
 80019a6:	2300      	movs	r3, #0
 80019a8:	617b      	str	r3, [r7, #20]
  sBreakDeadTimeConfig.BreakPolarity = TIM_BREAKPOLARITY_HIGH;
 80019aa:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
 80019ae:	61bb      	str	r3, [r7, #24]
  sBreakDeadTimeConfig.BreakFilter = 0;
 80019b0:	2300      	movs	r3, #0
 80019b2:	61fb      	str	r3, [r7, #28]
  sBreakDeadTimeConfig.Break2State = TIM_BREAK2_DISABLE;
 80019b4:	2300      	movs	r3, #0
 80019b6:	627b      	str	r3, [r7, #36]	@ 0x24
  sBreakDeadTimeConfig.Break2Polarity = TIM_BREAK2POLARITY_HIGH;
 80019b8:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
 80019bc:	62bb      	str	r3, [r7, #40]	@ 0x28
  sBreakDeadTimeConfig.Break2Filter = 0;
 80019be:	2300      	movs	r3, #0
 80019c0:	62fb      	str	r3, [r7, #44]	@ 0x2c
  sBreakDeadTimeConfig.AutomaticOutput = TIM_AUTOMATICOUTPUT_DISABLE;
 80019c2:	2300      	movs	r3, #0
 80019c4:	637b      	str	r3, [r7, #52]	@ 0x34
  if (HAL_TIMEx_ConfigBreakDeadTime(&htim1, &sBreakDeadTimeConfig) != HAL_OK)
 80019c6:	1d3b      	adds	r3, r7, #4
 80019c8:	4619      	mov	r1, r3
 80019ca:	4807      	ldr	r0, [pc, #28]	@ (80019e8 <MX_TIM1_Init+0x150>)
 80019cc:	f00d fb56 	bl	800f07c <HAL_TIMEx_ConfigBreakDeadTime>
 80019d0:	4603      	mov	r3, r0
 80019d2:	2b00      	cmp	r3, #0
 80019d4:	d001      	beq.n	80019da <MX_TIM1_Init+0x142>
  {
    Error_Handler();
 80019d6:	f000 fa3b 	bl	8001e50 <Error_Handler>
  }
  /* USER CODE BEGIN TIM1_Init 2 */

  /* USER CODE END TIM1_Init 2 */
  HAL_TIM_MspPostInit(&htim1);
 80019da:	4803      	ldr	r0, [pc, #12]	@ (80019e8 <MX_TIM1_Init+0x150>)
 80019dc:	f000 fcc8 	bl	8002370 <HAL_TIM_MspPostInit>

}
 80019e0:	bf00      	nop
 80019e2:	3770      	adds	r7, #112	@ 0x70
 80019e4:	46bd      	mov	sp, r7
 80019e6:	bd80      	pop	{r7, pc}
 80019e8:	240006cc 	.word	0x240006cc
 80019ec:	40010000 	.word	0x40010000

080019f0 <MX_TIM3_Init>:
  * @brief TIM3 Initialization Function
  * @param None
  * @retval None
  */
static void MX_TIM3_Init(void)
{
 80019f0:	b580      	push	{r7, lr}
 80019f2:	b08e      	sub	sp, #56	@ 0x38
 80019f4:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN TIM3_Init 0 */

  /* USER CODE END TIM3_Init 0 */

  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
 80019f6:	f107 0328 	add.w	r3, r7, #40	@ 0x28
 80019fa:	2200      	movs	r2, #0
 80019fc:	601a      	str	r2, [r3, #0]
 80019fe:	605a      	str	r2, [r3, #4]
 8001a00:	609a      	str	r2, [r3, #8]
 8001a02:	60da      	str	r2, [r3, #12]
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8001a04:	f107 031c 	add.w	r3, r7, #28
 8001a08:	2200      	movs	r2, #0
 8001a0a:	601a      	str	r2, [r3, #0]
 8001a0c:	605a      	str	r2, [r3, #4]
 8001a0e:	609a      	str	r2, [r3, #8]
  TIM_OC_InitTypeDef sConfigOC = {0};
 8001a10:	463b      	mov	r3, r7
 8001a12:	2200      	movs	r2, #0
 8001a14:	601a      	str	r2, [r3, #0]
 8001a16:	605a      	str	r2, [r3, #4]
 8001a18:	609a      	str	r2, [r3, #8]
 8001a1a:	60da      	str	r2, [r3, #12]
 8001a1c:	611a      	str	r2, [r3, #16]
 8001a1e:	615a      	str	r2, [r3, #20]
 8001a20:	619a      	str	r2, [r3, #24]

  /* USER CODE BEGIN TIM3_Init 1 */

  /* USER CODE END TIM3_Init 1 */
  htim3.Instance = TIM3;
 8001a22:	4b2c      	ldr	r3, [pc, #176]	@ (8001ad4 <MX_TIM3_Init+0xe4>)
 8001a24:	4a2c      	ldr	r2, [pc, #176]	@ (8001ad8 <MX_TIM3_Init+0xe8>)
 8001a26:	601a      	str	r2, [r3, #0]
  htim3.Init.Prescaler = 28000-1;
 8001a28:	4b2a      	ldr	r3, [pc, #168]	@ (8001ad4 <MX_TIM3_Init+0xe4>)
 8001a2a:	f646 525f 	movw	r2, #27999	@ 0x6d5f
 8001a2e:	605a      	str	r2, [r3, #4]
  htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
 8001a30:	4b28      	ldr	r3, [pc, #160]	@ (8001ad4 <MX_TIM3_Init+0xe4>)
 8001a32:	2200      	movs	r2, #0
 8001a34:	609a      	str	r2, [r3, #8]
  htim3.Init.Period = 1000-1;
 8001a36:	4b27      	ldr	r3, [pc, #156]	@ (8001ad4 <MX_TIM3_Init+0xe4>)
 8001a38:	f240 32e7 	movw	r2, #999	@ 0x3e7
 8001a3c:	60da      	str	r2, [r3, #12]
  htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 8001a3e:	4b25      	ldr	r3, [pc, #148]	@ (8001ad4 <MX_TIM3_Init+0xe4>)
 8001a40:	2200      	movs	r2, #0
 8001a42:	611a      	str	r2, [r3, #16]
  htim3.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 8001a44:	4b23      	ldr	r3, [pc, #140]	@ (8001ad4 <MX_TIM3_Init+0xe4>)
 8001a46:	2200      	movs	r2, #0
 8001a48:	619a      	str	r2, [r3, #24]
  if (HAL_TIM_Base_Init(&htim3) != HAL_OK)
 8001a4a:	4822      	ldr	r0, [pc, #136]	@ (8001ad4 <MX_TIM3_Init+0xe4>)
 8001a4c:	f00c f8cb 	bl	800dbe6 <HAL_TIM_Base_Init>
 8001a50:	4603      	mov	r3, r0
 8001a52:	2b00      	cmp	r3, #0
 8001a54:	d001      	beq.n	8001a5a <MX_TIM3_Init+0x6a>
  {
    Error_Handler();
 8001a56:	f000 f9fb 	bl	8001e50 <Error_Handler>
  }
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 8001a5a:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 8001a5e:	62bb      	str	r3, [r7, #40]	@ 0x28
  if (HAL_TIM_ConfigClockSource(&htim3, &sClockSourceConfig) != HAL_OK)
 8001a60:	f107 0328 	add.w	r3, r7, #40	@ 0x28
 8001a64:	4619      	mov	r1, r3
 8001a66:	481b      	ldr	r0, [pc, #108]	@ (8001ad4 <MX_TIM3_Init+0xe4>)
 8001a68:	f00c fd10 	bl	800e48c <HAL_TIM_ConfigClockSource>
 8001a6c:	4603      	mov	r3, r0
 8001a6e:	2b00      	cmp	r3, #0
 8001a70:	d001      	beq.n	8001a76 <MX_TIM3_Init+0x86>
  {
    Error_Handler();
 8001a72:	f000 f9ed 	bl	8001e50 <Error_Handler>
  }
  if (HAL_TIM_PWM_Init(&htim3) != HAL_OK)
 8001a76:	4817      	ldr	r0, [pc, #92]	@ (8001ad4 <MX_TIM3_Init+0xe4>)
 8001a78:	f00c f97c 	bl	800dd74 <HAL_TIM_PWM_Init>
 8001a7c:	4603      	mov	r3, r0
 8001a7e:	2b00      	cmp	r3, #0
 8001a80:	d001      	beq.n	8001a86 <MX_TIM3_Init+0x96>
  {
    Error_Handler();
 8001a82:	f000 f9e5 	bl	8001e50 <Error_Handler>
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_UPDATE;
 8001a86:	2320      	movs	r3, #32
 8001a88:	61fb      	str	r3, [r7, #28]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 8001a8a:	2300      	movs	r3, #0
 8001a8c:	627b      	str	r3, [r7, #36]	@ 0x24
  if (HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig) != HAL_OK)
 8001a8e:	f107 031c 	add.w	r3, r7, #28
 8001a92:	4619      	mov	r1, r3
 8001a94:	480f      	ldr	r0, [pc, #60]	@ (8001ad4 <MX_TIM3_Init+0xe4>)
 8001a96:	f00d fa63 	bl	800ef60 <HAL_TIMEx_MasterConfigSynchronization>
 8001a9a:	4603      	mov	r3, r0
 8001a9c:	2b00      	cmp	r3, #0
 8001a9e:	d001      	beq.n	8001aa4 <MX_TIM3_Init+0xb4>
  {
    Error_Handler();
 8001aa0:	f000 f9d6 	bl	8001e50 <Error_Handler>
  }
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
 8001aa4:	2360      	movs	r3, #96	@ 0x60
 8001aa6:	603b      	str	r3, [r7, #0]
  sConfigOC.Pulse = 0;
 8001aa8:	2300      	movs	r3, #0
 8001aaa:	607b      	str	r3, [r7, #4]
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 8001aac:	2300      	movs	r3, #0
 8001aae:	60bb      	str	r3, [r7, #8]
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 8001ab0:	2300      	movs	r3, #0
 8001ab2:	613b      	str	r3, [r7, #16]
  if (HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 8001ab4:	463b      	mov	r3, r7
 8001ab6:	2200      	movs	r2, #0
 8001ab8:	4619      	mov	r1, r3
 8001aba:	4806      	ldr	r0, [pc, #24]	@ (8001ad4 <MX_TIM3_Init+0xe4>)
 8001abc:	f00c fbd2 	bl	800e264 <HAL_TIM_PWM_ConfigChannel>
 8001ac0:	4603      	mov	r3, r0
 8001ac2:	2b00      	cmp	r3, #0
 8001ac4:	d001      	beq.n	8001aca <MX_TIM3_Init+0xda>
  {
    Error_Handler();
 8001ac6:	f000 f9c3 	bl	8001e50 <Error_Handler>
  }
  /* USER CODE BEGIN TIM3_Init 2 */

  /* USER CODE END TIM3_Init 2 */

}
 8001aca:	bf00      	nop
 8001acc:	3738      	adds	r7, #56	@ 0x38
 8001ace:	46bd      	mov	sp, r7
 8001ad0:	bd80      	pop	{r7, pc}
 8001ad2:	bf00      	nop
 8001ad4:	24000718 	.word	0x24000718
 8001ad8:	40000400 	.word	0x40000400

08001adc <MX_TIM15_Init>:
  * @brief TIM15 Initialization Function
  * @param None
  * @retval None
  */
static void MX_TIM15_Init(void)
{
 8001adc:	b580      	push	{r7, lr}
 8001ade:	b09c      	sub	sp, #112	@ 0x70
 8001ae0:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN TIM15_Init 0 */

  /* USER CODE END TIM15_Init 0 */

  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
 8001ae2:	f107 0360 	add.w	r3, r7, #96	@ 0x60
 8001ae6:	2200      	movs	r2, #0
 8001ae8:	601a      	str	r2, [r3, #0]
 8001aea:	605a      	str	r2, [r3, #4]
 8001aec:	609a      	str	r2, [r3, #8]
 8001aee:	60da      	str	r2, [r3, #12]
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8001af0:	f107 0354 	add.w	r3, r7, #84	@ 0x54
 8001af4:	2200      	movs	r2, #0
 8001af6:	601a      	str	r2, [r3, #0]
 8001af8:	605a      	str	r2, [r3, #4]
 8001afa:	609a      	str	r2, [r3, #8]
  TIM_OC_InitTypeDef sConfigOC = {0};
 8001afc:	f107 0338 	add.w	r3, r7, #56	@ 0x38
 8001b00:	2200      	movs	r2, #0
 8001b02:	601a      	str	r2, [r3, #0]
 8001b04:	605a      	str	r2, [r3, #4]
 8001b06:	609a      	str	r2, [r3, #8]
 8001b08:	60da      	str	r2, [r3, #12]
 8001b0a:	611a      	str	r2, [r3, #16]
 8001b0c:	615a      	str	r2, [r3, #20]
 8001b0e:	619a      	str	r2, [r3, #24]
  TIM_BreakDeadTimeConfigTypeDef sBreakDeadTimeConfig = {0};
 8001b10:	1d3b      	adds	r3, r7, #4
 8001b12:	2234      	movs	r2, #52	@ 0x34
 8001b14:	2100      	movs	r1, #0
 8001b16:	4618      	mov	r0, r3
 8001b18:	f011 fa48 	bl	8012fac <memset>

  /* USER CODE BEGIN TIM15_Init 1 */

  /* USER CODE END TIM15_Init 1 */
  htim15.Instance = TIM15;
 8001b1c:	4b3f      	ldr	r3, [pc, #252]	@ (8001c1c <MX_TIM15_Init+0x140>)
 8001b1e:	4a40      	ldr	r2, [pc, #256]	@ (8001c20 <MX_TIM15_Init+0x144>)
 8001b20:	601a      	str	r2, [r3, #0]
  htim15.Init.Prescaler = 28000-1;
 8001b22:	4b3e      	ldr	r3, [pc, #248]	@ (8001c1c <MX_TIM15_Init+0x140>)
 8001b24:	f646 525f 	movw	r2, #27999	@ 0x6d5f
 8001b28:	605a      	str	r2, [r3, #4]
  htim15.Init.CounterMode = TIM_COUNTERMODE_UP;
 8001b2a:	4b3c      	ldr	r3, [pc, #240]	@ (8001c1c <MX_TIM15_Init+0x140>)
 8001b2c:	2200      	movs	r2, #0
 8001b2e:	609a      	str	r2, [r3, #8]
  htim15.Init.Period = 100-1;
 8001b30:	4b3a      	ldr	r3, [pc, #232]	@ (8001c1c <MX_TIM15_Init+0x140>)
 8001b32:	2263      	movs	r2, #99	@ 0x63
 8001b34:	60da      	str	r2, [r3, #12]
  htim15.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 8001b36:	4b39      	ldr	r3, [pc, #228]	@ (8001c1c <MX_TIM15_Init+0x140>)
 8001b38:	2200      	movs	r2, #0
 8001b3a:	611a      	str	r2, [r3, #16]
  htim15.Init.RepetitionCounter = 0;
 8001b3c:	4b37      	ldr	r3, [pc, #220]	@ (8001c1c <MX_TIM15_Init+0x140>)
 8001b3e:	2200      	movs	r2, #0
 8001b40:	615a      	str	r2, [r3, #20]
  htim15.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 8001b42:	4b36      	ldr	r3, [pc, #216]	@ (8001c1c <MX_TIM15_Init+0x140>)
 8001b44:	2200      	movs	r2, #0
 8001b46:	619a      	str	r2, [r3, #24]
  if (HAL_TIM_Base_Init(&htim15) != HAL_OK)
 8001b48:	4834      	ldr	r0, [pc, #208]	@ (8001c1c <MX_TIM15_Init+0x140>)
 8001b4a:	f00c f84c 	bl	800dbe6 <HAL_TIM_Base_Init>
 8001b4e:	4603      	mov	r3, r0
 8001b50:	2b00      	cmp	r3, #0
 8001b52:	d001      	beq.n	8001b58 <MX_TIM15_Init+0x7c>
  {
    Error_Handler();
 8001b54:	f000 f97c 	bl	8001e50 <Error_Handler>
  }
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 8001b58:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 8001b5c:	663b      	str	r3, [r7, #96]	@ 0x60
  if (HAL_TIM_ConfigClockSource(&htim15, &sClockSourceConfig) != HAL_OK)
 8001b5e:	f107 0360 	add.w	r3, r7, #96	@ 0x60
 8001b62:	4619      	mov	r1, r3
 8001b64:	482d      	ldr	r0, [pc, #180]	@ (8001c1c <MX_TIM15_Init+0x140>)
 8001b66:	f00c fc91 	bl	800e48c <HAL_TIM_ConfigClockSource>
 8001b6a:	4603      	mov	r3, r0
 8001b6c:	2b00      	cmp	r3, #0
 8001b6e:	d001      	beq.n	8001b74 <MX_TIM15_Init+0x98>
  {
    Error_Handler();
 8001b70:	f000 f96e 	bl	8001e50 <Error_Handler>
  }
  if (HAL_TIM_PWM_Init(&htim15) != HAL_OK)
 8001b74:	4829      	ldr	r0, [pc, #164]	@ (8001c1c <MX_TIM15_Init+0x140>)
 8001b76:	f00c f8fd 	bl	800dd74 <HAL_TIM_PWM_Init>
 8001b7a:	4603      	mov	r3, r0
 8001b7c:	2b00      	cmp	r3, #0
 8001b7e:	d001      	beq.n	8001b84 <MX_TIM15_Init+0xa8>
  {
    Error_Handler();
 8001b80:	f000 f966 	bl	8001e50 <Error_Handler>
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 8001b84:	2300      	movs	r3, #0
 8001b86:	657b      	str	r3, [r7, #84]	@ 0x54
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 8001b88:	2300      	movs	r3, #0
 8001b8a:	65fb      	str	r3, [r7, #92]	@ 0x5c
  if (HAL_TIMEx_MasterConfigSynchronization(&htim15, &sMasterConfig) != HAL_OK)
 8001b8c:	f107 0354 	add.w	r3, r7, #84	@ 0x54
 8001b90:	4619      	mov	r1, r3
 8001b92:	4822      	ldr	r0, [pc, #136]	@ (8001c1c <MX_TIM15_Init+0x140>)
 8001b94:	f00d f9e4 	bl	800ef60 <HAL_TIMEx_MasterConfigSynchronization>
 8001b98:	4603      	mov	r3, r0
 8001b9a:	2b00      	cmp	r3, #0
 8001b9c:	d001      	beq.n	8001ba2 <MX_TIM15_Init+0xc6>
  {
    Error_Handler();
 8001b9e:	f000 f957 	bl	8001e50 <Error_Handler>
  }
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
 8001ba2:	2360      	movs	r3, #96	@ 0x60
 8001ba4:	63bb      	str	r3, [r7, #56]	@ 0x38
  sConfigOC.Pulse = 0;
 8001ba6:	2300      	movs	r3, #0
 8001ba8:	63fb      	str	r3, [r7, #60]	@ 0x3c
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 8001baa:	2300      	movs	r3, #0
 8001bac:	643b      	str	r3, [r7, #64]	@ 0x40
  sConfigOC.OCNPolarity = TIM_OCNPOLARITY_HIGH;
 8001bae:	2300      	movs	r3, #0
 8001bb0:	647b      	str	r3, [r7, #68]	@ 0x44
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 8001bb2:	2300      	movs	r3, #0
 8001bb4:	64bb      	str	r3, [r7, #72]	@ 0x48
  sConfigOC.OCIdleState = TIM_OCIDLESTATE_RESET;
 8001bb6:	2300      	movs	r3, #0
 8001bb8:	64fb      	str	r3, [r7, #76]	@ 0x4c
  sConfigOC.OCNIdleState = TIM_OCNIDLESTATE_RESET;
 8001bba:	2300      	movs	r3, #0
 8001bbc:	653b      	str	r3, [r7, #80]	@ 0x50
  if (HAL_TIM_PWM_ConfigChannel(&htim15, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 8001bbe:	f107 0338 	add.w	r3, r7, #56	@ 0x38
 8001bc2:	2200      	movs	r2, #0
 8001bc4:	4619      	mov	r1, r3
 8001bc6:	4815      	ldr	r0, [pc, #84]	@ (8001c1c <MX_TIM15_Init+0x140>)
 8001bc8:	f00c fb4c 	bl	800e264 <HAL_TIM_PWM_ConfigChannel>
 8001bcc:	4603      	mov	r3, r0
 8001bce:	2b00      	cmp	r3, #0
 8001bd0:	d001      	beq.n	8001bd6 <MX_TIM15_Init+0xfa>
  {
    Error_Handler();
 8001bd2:	f000 f93d 	bl	8001e50 <Error_Handler>
  }
  sBreakDeadTimeConfig.OffStateRunMode = TIM_OSSR_DISABLE;
 8001bd6:	2300      	movs	r3, #0
 8001bd8:	607b      	str	r3, [r7, #4]
  sBreakDeadTimeConfig.OffStateIDLEMode = TIM_OSSI_DISABLE;
 8001bda:	2300      	movs	r3, #0
 8001bdc:	60bb      	str	r3, [r7, #8]
  sBreakDeadTimeConfig.LockLevel = TIM_LOCKLEVEL_OFF;
 8001bde:	2300      	movs	r3, #0
 8001be0:	60fb      	str	r3, [r7, #12]
  sBreakDeadTimeConfig.DeadTime = 0;
 8001be2:	2300      	movs	r3, #0
 8001be4:	613b      	str	r3, [r7, #16]
  sBreakDeadTimeConfig.BreakState = TIM_BREAK_DISABLE;
 8001be6:	2300      	movs	r3, #0
 8001be8:	617b      	str	r3, [r7, #20]
  sBreakDeadTimeConfig.BreakPolarity = TIM_BREAKPOLARITY_HIGH;
 8001bea:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
 8001bee:	61bb      	str	r3, [r7, #24]
  sBreakDeadTimeConfig.BreakFilter = 0;
 8001bf0:	2300      	movs	r3, #0
 8001bf2:	61fb      	str	r3, [r7, #28]
  sBreakDeadTimeConfig.AutomaticOutput = TIM_AUTOMATICOUTPUT_DISABLE;
 8001bf4:	2300      	movs	r3, #0
 8001bf6:	637b      	str	r3, [r7, #52]	@ 0x34
  if (HAL_TIMEx_ConfigBreakDeadTime(&htim15, &sBreakDeadTimeConfig) != HAL_OK)
 8001bf8:	1d3b      	adds	r3, r7, #4
 8001bfa:	4619      	mov	r1, r3
 8001bfc:	4807      	ldr	r0, [pc, #28]	@ (8001c1c <MX_TIM15_Init+0x140>)
 8001bfe:	f00d fa3d 	bl	800f07c <HAL_TIMEx_ConfigBreakDeadTime>
 8001c02:	4603      	mov	r3, r0
 8001c04:	2b00      	cmp	r3, #0
 8001c06:	d001      	beq.n	8001c0c <MX_TIM15_Init+0x130>
  {
    Error_Handler();
 8001c08:	f000 f922 	bl	8001e50 <Error_Handler>
  }
  /* USER CODE BEGIN TIM15_Init 2 */

  /* USER CODE END TIM15_Init 2 */
  HAL_TIM_MspPostInit(&htim15);
 8001c0c:	4803      	ldr	r0, [pc, #12]	@ (8001c1c <MX_TIM15_Init+0x140>)
 8001c0e:	f000 fbaf 	bl	8002370 <HAL_TIM_MspPostInit>

}
 8001c12:	bf00      	nop
 8001c14:	3770      	adds	r7, #112	@ 0x70
 8001c16:	46bd      	mov	sp, r7
 8001c18:	bd80      	pop	{r7, pc}
 8001c1a:	bf00      	nop
 8001c1c:	24000764 	.word	0x24000764
 8001c20:	40014000 	.word	0x40014000

08001c24 <MX_DMA_Init>:

/**
  * Enable DMA controller clock
  */
static void MX_DMA_Init(void)
{
 8001c24:	b580      	push	{r7, lr}
 8001c26:	b082      	sub	sp, #8
 8001c28:	af00      	add	r7, sp, #0

  /* DMA controller clock enable */
  __HAL_RCC_DMA2_CLK_ENABLE();
 8001c2a:	4b1d      	ldr	r3, [pc, #116]	@ (8001ca0 <MX_DMA_Init+0x7c>)
 8001c2c:	f8d3 3138 	ldr.w	r3, [r3, #312]	@ 0x138
 8001c30:	4a1b      	ldr	r2, [pc, #108]	@ (8001ca0 <MX_DMA_Init+0x7c>)
 8001c32:	f043 0302 	orr.w	r3, r3, #2
 8001c36:	f8c2 3138 	str.w	r3, [r2, #312]	@ 0x138
 8001c3a:	4b19      	ldr	r3, [pc, #100]	@ (8001ca0 <MX_DMA_Init+0x7c>)
 8001c3c:	f8d3 3138 	ldr.w	r3, [r3, #312]	@ 0x138
 8001c40:	f003 0302 	and.w	r3, r3, #2
 8001c44:	607b      	str	r3, [r7, #4]
 8001c46:	687b      	ldr	r3, [r7, #4]
  __HAL_RCC_DMA1_CLK_ENABLE();
 8001c48:	4b15      	ldr	r3, [pc, #84]	@ (8001ca0 <MX_DMA_Init+0x7c>)
 8001c4a:	f8d3 3138 	ldr.w	r3, [r3, #312]	@ 0x138
 8001c4e:	4a14      	ldr	r2, [pc, #80]	@ (8001ca0 <MX_DMA_Init+0x7c>)
 8001c50:	f043 0301 	orr.w	r3, r3, #1
 8001c54:	f8c2 3138 	str.w	r3, [r2, #312]	@ 0x138
 8001c58:	4b11      	ldr	r3, [pc, #68]	@ (8001ca0 <MX_DMA_Init+0x7c>)
 8001c5a:	f8d3 3138 	ldr.w	r3, [r3, #312]	@ 0x138
 8001c5e:	f003 0301 	and.w	r3, r3, #1
 8001c62:	603b      	str	r3, [r7, #0]
 8001c64:	683b      	ldr	r3, [r7, #0]

  /* DMA interrupt init */
  /* DMA1_Stream0_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Stream0_IRQn, 0, 0);
 8001c66:	2200      	movs	r2, #0
 8001c68:	2100      	movs	r1, #0
 8001c6a:	200b      	movs	r0, #11
 8001c6c:	f002 fa35 	bl	80040da <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA1_Stream0_IRQn);
 8001c70:	200b      	movs	r0, #11
 8001c72:	f002 fa4c 	bl	800410e <HAL_NVIC_EnableIRQ>
  /* DMA1_Stream1_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Stream1_IRQn, 0, 0);
 8001c76:	2200      	movs	r2, #0
 8001c78:	2100      	movs	r1, #0
 8001c7a:	200c      	movs	r0, #12
 8001c7c:	f002 fa2d 	bl	80040da <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA1_Stream1_IRQn);
 8001c80:	200c      	movs	r0, #12
 8001c82:	f002 fa44 	bl	800410e <HAL_NVIC_EnableIRQ>
  /* DMA2_Stream0_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA2_Stream0_IRQn, 0, 0);
 8001c86:	2200      	movs	r2, #0
 8001c88:	2100      	movs	r1, #0
 8001c8a:	2038      	movs	r0, #56	@ 0x38
 8001c8c:	f002 fa25 	bl	80040da <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA2_Stream0_IRQn);
 8001c90:	2038      	movs	r0, #56	@ 0x38
 8001c92:	f002 fa3c 	bl	800410e <HAL_NVIC_EnableIRQ>

}
 8001c96:	bf00      	nop
 8001c98:	3708      	adds	r7, #8
 8001c9a:	46bd      	mov	sp, r7
 8001c9c:	bd80      	pop	{r7, pc}
 8001c9e:	bf00      	nop
 8001ca0:	58024400 	.word	0x58024400

08001ca4 <MX_GPIO_Init>:
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
 8001ca4:	b580      	push	{r7, lr}
 8001ca6:	b08c      	sub	sp, #48	@ 0x30
 8001ca8:	af00      	add	r7, sp, #0
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8001caa:	f107 031c 	add.w	r3, r7, #28
 8001cae:	2200      	movs	r2, #0
 8001cb0:	601a      	str	r2, [r3, #0]
 8001cb2:	605a      	str	r2, [r3, #4]
 8001cb4:	609a      	str	r2, [r3, #8]
 8001cb6:	60da      	str	r2, [r3, #12]
 8001cb8:	611a      	str	r2, [r3, #16]
/* USER CODE BEGIN MX_GPIO_Init_1 */
/* USER CODE END MX_GPIO_Init_1 */

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOE_CLK_ENABLE();
 8001cba:	4b60      	ldr	r3, [pc, #384]	@ (8001e3c <MX_GPIO_Init+0x198>)
 8001cbc:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
 8001cc0:	4a5e      	ldr	r2, [pc, #376]	@ (8001e3c <MX_GPIO_Init+0x198>)
 8001cc2:	f043 0310 	orr.w	r3, r3, #16
 8001cc6:	f8c2 3140 	str.w	r3, [r2, #320]	@ 0x140
 8001cca:	4b5c      	ldr	r3, [pc, #368]	@ (8001e3c <MX_GPIO_Init+0x198>)
 8001ccc:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
 8001cd0:	f003 0310 	and.w	r3, r3, #16
 8001cd4:	61bb      	str	r3, [r7, #24]
 8001cd6:	69bb      	ldr	r3, [r7, #24]
  __HAL_RCC_GPIOH_CLK_ENABLE();
 8001cd8:	4b58      	ldr	r3, [pc, #352]	@ (8001e3c <MX_GPIO_Init+0x198>)
 8001cda:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
 8001cde:	4a57      	ldr	r2, [pc, #348]	@ (8001e3c <MX_GPIO_Init+0x198>)
 8001ce0:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 8001ce4:	f8c2 3140 	str.w	r3, [r2, #320]	@ 0x140
 8001ce8:	4b54      	ldr	r3, [pc, #336]	@ (8001e3c <MX_GPIO_Init+0x198>)
 8001cea:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
 8001cee:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8001cf2:	617b      	str	r3, [r7, #20]
 8001cf4:	697b      	ldr	r3, [r7, #20]
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8001cf6:	4b51      	ldr	r3, [pc, #324]	@ (8001e3c <MX_GPIO_Init+0x198>)
 8001cf8:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
 8001cfc:	4a4f      	ldr	r2, [pc, #316]	@ (8001e3c <MX_GPIO_Init+0x198>)
 8001cfe:	f043 0304 	orr.w	r3, r3, #4
 8001d02:	f8c2 3140 	str.w	r3, [r2, #320]	@ 0x140
 8001d06:	4b4d      	ldr	r3, [pc, #308]	@ (8001e3c <MX_GPIO_Init+0x198>)
 8001d08:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
 8001d0c:	f003 0304 	and.w	r3, r3, #4
 8001d10:	613b      	str	r3, [r7, #16]
 8001d12:	693b      	ldr	r3, [r7, #16]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8001d14:	4b49      	ldr	r3, [pc, #292]	@ (8001e3c <MX_GPIO_Init+0x198>)
 8001d16:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
 8001d1a:	4a48      	ldr	r2, [pc, #288]	@ (8001e3c <MX_GPIO_Init+0x198>)
 8001d1c:	f043 0301 	orr.w	r3, r3, #1
 8001d20:	f8c2 3140 	str.w	r3, [r2, #320]	@ 0x140
 8001d24:	4b45      	ldr	r3, [pc, #276]	@ (8001e3c <MX_GPIO_Init+0x198>)
 8001d26:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
 8001d2a:	f003 0301 	and.w	r3, r3, #1
 8001d2e:	60fb      	str	r3, [r7, #12]
 8001d30:	68fb      	ldr	r3, [r7, #12]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8001d32:	4b42      	ldr	r3, [pc, #264]	@ (8001e3c <MX_GPIO_Init+0x198>)
 8001d34:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
 8001d38:	4a40      	ldr	r2, [pc, #256]	@ (8001e3c <MX_GPIO_Init+0x198>)
 8001d3a:	f043 0302 	orr.w	r3, r3, #2
 8001d3e:	f8c2 3140 	str.w	r3, [r2, #320]	@ 0x140
 8001d42:	4b3e      	ldr	r3, [pc, #248]	@ (8001e3c <MX_GPIO_Init+0x198>)
 8001d44:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
 8001d48:	f003 0302 	and.w	r3, r3, #2
 8001d4c:	60bb      	str	r3, [r7, #8]
 8001d4e:	68bb      	ldr	r3, [r7, #8]
  __HAL_RCC_GPIOD_CLK_ENABLE();
 8001d50:	4b3a      	ldr	r3, [pc, #232]	@ (8001e3c <MX_GPIO_Init+0x198>)
 8001d52:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
 8001d56:	4a39      	ldr	r2, [pc, #228]	@ (8001e3c <MX_GPIO_Init+0x198>)
 8001d58:	f043 0308 	orr.w	r3, r3, #8
 8001d5c:	f8c2 3140 	str.w	r3, [r2, #320]	@ 0x140
 8001d60:	4b36      	ldr	r3, [pc, #216]	@ (8001e3c <MX_GPIO_Init+0x198>)
 8001d62:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
 8001d66:	f003 0308 	and.w	r3, r3, #8
 8001d6a:	607b      	str	r3, [r7, #4]
 8001d6c:	687b      	ldr	r3, [r7, #4]

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(QUIET_LOW_GPIO_Port, QUIET_LOW_Pin, GPIO_PIN_RESET);
 8001d6e:	2200      	movs	r2, #0
 8001d70:	2110      	movs	r1, #16
 8001d72:	4833      	ldr	r0, [pc, #204]	@ (8001e40 <MX_GPIO_Init+0x19c>)
 8001d74:	f004 fdac 	bl	80068d0 <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(QUIET_HIGH_GPIO_Port, QUIET_HIGH_Pin, GPIO_PIN_SET);
 8001d78:	2201      	movs	r2, #1
 8001d7a:	2120      	movs	r1, #32
 8001d7c:	4830      	ldr	r0, [pc, #192]	@ (8001e40 <MX_GPIO_Init+0x19c>)
 8001d7e:	f004 fda7 	bl	80068d0 <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(CODEC_NRST_GPIO_Port, CODEC_NRST_Pin, GPIO_PIN_RESET);
 8001d82:	2200      	movs	r2, #0
 8001d84:	2140      	movs	r1, #64	@ 0x40
 8001d86:	482f      	ldr	r0, [pc, #188]	@ (8001e44 <MX_GPIO_Init+0x1a0>)
 8001d88:	f004 fda2 	bl	80068d0 <HAL_GPIO_WritePin>

  /*Configure GPIO pins : QUIET_LOW_Pin QUIET_HIGH_Pin */
  GPIO_InitStruct.Pin = QUIET_LOW_Pin|QUIET_HIGH_Pin;
 8001d8c:	2330      	movs	r3, #48	@ 0x30
 8001d8e:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8001d90:	2301      	movs	r3, #1
 8001d92:	623b      	str	r3, [r7, #32]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001d94:	2300      	movs	r3, #0
 8001d96:	627b      	str	r3, [r7, #36]	@ 0x24
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8001d98:	2303      	movs	r3, #3
 8001d9a:	62bb      	str	r3, [r7, #40]	@ 0x28
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8001d9c:	f107 031c 	add.w	r3, r7, #28
 8001da0:	4619      	mov	r1, r3
 8001da2:	4827      	ldr	r0, [pc, #156]	@ (8001e40 <MX_GPIO_Init+0x19c>)
 8001da4:	f004 fbcc 	bl	8006540 <HAL_GPIO_Init>

  /*Configure GPIO pins : DIP3_Pin DIP2_Pin DIP1_Pin */
  GPIO_InitStruct.Pin = DIP3_Pin|DIP2_Pin|DIP1_Pin;
 8001da8:	f44f 4360 	mov.w	r3, #57344	@ 0xe000
 8001dac:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 8001dae:	2300      	movs	r3, #0
 8001db0:	623b      	str	r3, [r7, #32]
  GPIO_InitStruct.Pull = GPIO_PULLUP;
 8001db2:	2301      	movs	r3, #1
 8001db4:	627b      	str	r3, [r7, #36]	@ 0x24
  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8001db6:	f107 031c 	add.w	r3, r7, #28
 8001dba:	4619      	mov	r1, r3
 8001dbc:	4822      	ldr	r0, [pc, #136]	@ (8001e48 <MX_GPIO_Init+0x1a4>)
 8001dbe:	f004 fbbf 	bl	8006540 <HAL_GPIO_Init>

  /*Configure GPIO pin : FX2_EN_Pin */
  GPIO_InitStruct.Pin = FX2_EN_Pin;
 8001dc2:	2310      	movs	r3, #16
 8001dc4:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING_FALLING;
 8001dc6:	f44f 1344 	mov.w	r3, #3211264	@ 0x310000
 8001dca:	623b      	str	r3, [r7, #32]
  GPIO_InitStruct.Pull = GPIO_PULLUP;
 8001dcc:	2301      	movs	r3, #1
 8001dce:	627b      	str	r3, [r7, #36]	@ 0x24
  HAL_GPIO_Init(FX2_EN_GPIO_Port, &GPIO_InitStruct);
 8001dd0:	f107 031c 	add.w	r3, r7, #28
 8001dd4:	4619      	mov	r1, r3
 8001dd6:	481b      	ldr	r0, [pc, #108]	@ (8001e44 <MX_GPIO_Init+0x1a0>)
 8001dd8:	f004 fbb2 	bl	8006540 <HAL_GPIO_Init>

  /*Configure GPIO pin : CODEC_NRST_Pin */
  GPIO_InitStruct.Pin = CODEC_NRST_Pin;
 8001ddc:	2340      	movs	r3, #64	@ 0x40
 8001dde:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8001de0:	2301      	movs	r3, #1
 8001de2:	623b      	str	r3, [r7, #32]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001de4:	2300      	movs	r3, #0
 8001de6:	627b      	str	r3, [r7, #36]	@ 0x24
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8001de8:	2300      	movs	r3, #0
 8001dea:	62bb      	str	r3, [r7, #40]	@ 0x28
  HAL_GPIO_Init(CODEC_NRST_GPIO_Port, &GPIO_InitStruct);
 8001dec:	f107 031c 	add.w	r3, r7, #28
 8001df0:	4619      	mov	r1, r3
 8001df2:	4814      	ldr	r0, [pc, #80]	@ (8001e44 <MX_GPIO_Init+0x1a0>)
 8001df4:	f004 fba4 	bl	8006540 <HAL_GPIO_Init>

  /*Configure GPIO pin : FX1_EN_Pin */
  GPIO_InitStruct.Pin = FX1_EN_Pin;
 8001df8:	2340      	movs	r3, #64	@ 0x40
 8001dfa:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING_FALLING;
 8001dfc:	f44f 1344 	mov.w	r3, #3211264	@ 0x310000
 8001e00:	623b      	str	r3, [r7, #32]
  GPIO_InitStruct.Pull = GPIO_PULLUP;
 8001e02:	2301      	movs	r3, #1
 8001e04:	627b      	str	r3, [r7, #36]	@ 0x24
  HAL_GPIO_Init(FX1_EN_GPIO_Port, &GPIO_InitStruct);
 8001e06:	f107 031c 	add.w	r3, r7, #28
 8001e0a:	4619      	mov	r1, r3
 8001e0c:	480f      	ldr	r0, [pc, #60]	@ (8001e4c <MX_GPIO_Init+0x1a8>)
 8001e0e:	f004 fb97 	bl	8006540 <HAL_GPIO_Init>

  /* EXTI interrupt init*/
  HAL_NVIC_SetPriority(EXTI4_IRQn, 0, 0);
 8001e12:	2200      	movs	r2, #0
 8001e14:	2100      	movs	r1, #0
 8001e16:	200a      	movs	r0, #10
 8001e18:	f002 f95f 	bl	80040da <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(EXTI4_IRQn);
 8001e1c:	200a      	movs	r0, #10
 8001e1e:	f002 f976 	bl	800410e <HAL_NVIC_EnableIRQ>

  HAL_NVIC_SetPriority(EXTI9_5_IRQn, 0, 0);
 8001e22:	2200      	movs	r2, #0
 8001e24:	2100      	movs	r1, #0
 8001e26:	2017      	movs	r0, #23
 8001e28:	f002 f957 	bl	80040da <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(EXTI9_5_IRQn);
 8001e2c:	2017      	movs	r0, #23
 8001e2e:	f002 f96e 	bl	800410e <HAL_NVIC_EnableIRQ>

/* USER CODE BEGIN MX_GPIO_Init_2 */
/* USER CODE END MX_GPIO_Init_2 */
}
 8001e32:	bf00      	nop
 8001e34:	3730      	adds	r7, #48	@ 0x30
 8001e36:	46bd      	mov	sp, r7
 8001e38:	bd80      	pop	{r7, pc}
 8001e3a:	bf00      	nop
 8001e3c:	58024400 	.word	0x58024400
 8001e40:	58020000 	.word	0x58020000
 8001e44:	58020c00 	.word	0x58020c00
 8001e48:	58021000 	.word	0x58021000
 8001e4c:	58020400 	.word	0x58020400

08001e50 <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
 8001e50:	b480      	push	{r7}
 8001e52:	af00      	add	r7, sp, #0
  __ASM volatile ("cpsid i" : : : "memory");
 8001e54:	b672      	cpsid	i
}
 8001e56:	bf00      	nop
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
 8001e58:	bf00      	nop
 8001e5a:	e7fd      	b.n	8001e58 <Error_Handler+0x8>

08001e5c <HAL_MspInit>:
void HAL_TIM_MspPostInit(TIM_HandleTypeDef *htim);
                                        /**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 8001e5c:	b480      	push	{r7}
 8001e5e:	b083      	sub	sp, #12
 8001e60:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8001e62:	4b0a      	ldr	r3, [pc, #40]	@ (8001e8c <HAL_MspInit+0x30>)
 8001e64:	f8d3 3154 	ldr.w	r3, [r3, #340]	@ 0x154
 8001e68:	4a08      	ldr	r2, [pc, #32]	@ (8001e8c <HAL_MspInit+0x30>)
 8001e6a:	f043 0302 	orr.w	r3, r3, #2
 8001e6e:	f8c2 3154 	str.w	r3, [r2, #340]	@ 0x154
 8001e72:	4b06      	ldr	r3, [pc, #24]	@ (8001e8c <HAL_MspInit+0x30>)
 8001e74:	f8d3 3154 	ldr.w	r3, [r3, #340]	@ 0x154
 8001e78:	f003 0302 	and.w	r3, r3, #2
 8001e7c:	607b      	str	r3, [r7, #4]
 8001e7e:	687b      	ldr	r3, [r7, #4]
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 8001e80:	bf00      	nop
 8001e82:	370c      	adds	r7, #12
 8001e84:	46bd      	mov	sp, r7
 8001e86:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001e8a:	4770      	bx	lr
 8001e8c:	58024400 	.word	0x58024400

08001e90 <HAL_ADC_MspInit>:
* This function configures the hardware resources used in this example
* @param hadc: ADC handle pointer
* @retval None
*/
void HAL_ADC_MspInit(ADC_HandleTypeDef* hadc)
{
 8001e90:	b580      	push	{r7, lr}
 8001e92:	b08c      	sub	sp, #48	@ 0x30
 8001e94:	af00      	add	r7, sp, #0
 8001e96:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8001e98:	f107 031c 	add.w	r3, r7, #28
 8001e9c:	2200      	movs	r2, #0
 8001e9e:	601a      	str	r2, [r3, #0]
 8001ea0:	605a      	str	r2, [r3, #4]
 8001ea2:	609a      	str	r2, [r3, #8]
 8001ea4:	60da      	str	r2, [r3, #12]
 8001ea6:	611a      	str	r2, [r3, #16]
  if(hadc->Instance==ADC1)
 8001ea8:	687b      	ldr	r3, [r7, #4]
 8001eaa:	681b      	ldr	r3, [r3, #0]
 8001eac:	4a51      	ldr	r2, [pc, #324]	@ (8001ff4 <HAL_ADC_MspInit+0x164>)
 8001eae:	4293      	cmp	r3, r2
 8001eb0:	d17e      	bne.n	8001fb0 <HAL_ADC_MspInit+0x120>
  {
  /* USER CODE BEGIN ADC1_MspInit 0 */

  /* USER CODE END ADC1_MspInit 0 */
    /* Peripheral clock enable */
    HAL_RCC_ADC12_CLK_ENABLED++;
 8001eb2:	4b51      	ldr	r3, [pc, #324]	@ (8001ff8 <HAL_ADC_MspInit+0x168>)
 8001eb4:	681b      	ldr	r3, [r3, #0]
 8001eb6:	3301      	adds	r3, #1
 8001eb8:	4a4f      	ldr	r2, [pc, #316]	@ (8001ff8 <HAL_ADC_MspInit+0x168>)
 8001eba:	6013      	str	r3, [r2, #0]
    if(HAL_RCC_ADC12_CLK_ENABLED==1){
 8001ebc:	4b4e      	ldr	r3, [pc, #312]	@ (8001ff8 <HAL_ADC_MspInit+0x168>)
 8001ebe:	681b      	ldr	r3, [r3, #0]
 8001ec0:	2b01      	cmp	r3, #1
 8001ec2:	d10e      	bne.n	8001ee2 <HAL_ADC_MspInit+0x52>
      __HAL_RCC_ADC12_CLK_ENABLE();
 8001ec4:	4b4d      	ldr	r3, [pc, #308]	@ (8001ffc <HAL_ADC_MspInit+0x16c>)
 8001ec6:	f8d3 3138 	ldr.w	r3, [r3, #312]	@ 0x138
 8001eca:	4a4c      	ldr	r2, [pc, #304]	@ (8001ffc <HAL_ADC_MspInit+0x16c>)
 8001ecc:	f043 0320 	orr.w	r3, r3, #32
 8001ed0:	f8c2 3138 	str.w	r3, [r2, #312]	@ 0x138
 8001ed4:	4b49      	ldr	r3, [pc, #292]	@ (8001ffc <HAL_ADC_MspInit+0x16c>)
 8001ed6:	f8d3 3138 	ldr.w	r3, [r3, #312]	@ 0x138
 8001eda:	f003 0320 	and.w	r3, r3, #32
 8001ede:	61bb      	str	r3, [r7, #24]
 8001ee0:	69bb      	ldr	r3, [r7, #24]
    }

    __HAL_RCC_GPIOC_CLK_ENABLE();
 8001ee2:	4b46      	ldr	r3, [pc, #280]	@ (8001ffc <HAL_ADC_MspInit+0x16c>)
 8001ee4:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
 8001ee8:	4a44      	ldr	r2, [pc, #272]	@ (8001ffc <HAL_ADC_MspInit+0x16c>)
 8001eea:	f043 0304 	orr.w	r3, r3, #4
 8001eee:	f8c2 3140 	str.w	r3, [r2, #320]	@ 0x140
 8001ef2:	4b42      	ldr	r3, [pc, #264]	@ (8001ffc <HAL_ADC_MspInit+0x16c>)
 8001ef4:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
 8001ef8:	f003 0304 	and.w	r3, r3, #4
 8001efc:	617b      	str	r3, [r7, #20]
 8001efe:	697b      	ldr	r3, [r7, #20]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8001f00:	4b3e      	ldr	r3, [pc, #248]	@ (8001ffc <HAL_ADC_MspInit+0x16c>)
 8001f02:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
 8001f06:	4a3d      	ldr	r2, [pc, #244]	@ (8001ffc <HAL_ADC_MspInit+0x16c>)
 8001f08:	f043 0301 	orr.w	r3, r3, #1
 8001f0c:	f8c2 3140 	str.w	r3, [r2, #320]	@ 0x140
 8001f10:	4b3a      	ldr	r3, [pc, #232]	@ (8001ffc <HAL_ADC_MspInit+0x16c>)
 8001f12:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
 8001f16:	f003 0301 	and.w	r3, r3, #1
 8001f1a:	613b      	str	r3, [r7, #16]
 8001f1c:	693b      	ldr	r3, [r7, #16]
    PA0     ------> ADC1_INP16
    PA1     ------> ADC1_INP17
    PA2     ------> ADC1_INP14
    PA3     ------> ADC1_INP15
    */
    GPIO_InitStruct.Pin = GPIO_PIN_1;
 8001f1e:	2302      	movs	r3, #2
 8001f20:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8001f22:	2303      	movs	r3, #3
 8001f24:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001f26:	2300      	movs	r3, #0
 8001f28:	627b      	str	r3, [r7, #36]	@ 0x24
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8001f2a:	f107 031c 	add.w	r3, r7, #28
 8001f2e:	4619      	mov	r1, r3
 8001f30:	4833      	ldr	r0, [pc, #204]	@ (8002000 <HAL_ADC_MspInit+0x170>)
 8001f32:	f004 fb05 	bl	8006540 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3;
 8001f36:	230f      	movs	r3, #15
 8001f38:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8001f3a:	2303      	movs	r3, #3
 8001f3c:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001f3e:	2300      	movs	r3, #0
 8001f40:	627b      	str	r3, [r7, #36]	@ 0x24
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8001f42:	f107 031c 	add.w	r3, r7, #28
 8001f46:	4619      	mov	r1, r3
 8001f48:	482e      	ldr	r0, [pc, #184]	@ (8002004 <HAL_ADC_MspInit+0x174>)
 8001f4a:	f004 faf9 	bl	8006540 <HAL_GPIO_Init>

    /* ADC1 DMA Init */
    /* ADC1 Init */
    hdma_adc1.Instance = DMA2_Stream0;
 8001f4e:	4b2e      	ldr	r3, [pc, #184]	@ (8002008 <HAL_ADC_MspInit+0x178>)
 8001f50:	4a2e      	ldr	r2, [pc, #184]	@ (800200c <HAL_ADC_MspInit+0x17c>)
 8001f52:	601a      	str	r2, [r3, #0]
    hdma_adc1.Init.Request = DMA_REQUEST_ADC1;
 8001f54:	4b2c      	ldr	r3, [pc, #176]	@ (8002008 <HAL_ADC_MspInit+0x178>)
 8001f56:	2209      	movs	r2, #9
 8001f58:	605a      	str	r2, [r3, #4]
    hdma_adc1.Init.Direction = DMA_PERIPH_TO_MEMORY;
 8001f5a:	4b2b      	ldr	r3, [pc, #172]	@ (8002008 <HAL_ADC_MspInit+0x178>)
 8001f5c:	2200      	movs	r2, #0
 8001f5e:	609a      	str	r2, [r3, #8]
    hdma_adc1.Init.PeriphInc = DMA_PINC_DISABLE;
 8001f60:	4b29      	ldr	r3, [pc, #164]	@ (8002008 <HAL_ADC_MspInit+0x178>)
 8001f62:	2200      	movs	r2, #0
 8001f64:	60da      	str	r2, [r3, #12]
    hdma_adc1.Init.MemInc = DMA_MINC_ENABLE;
 8001f66:	4b28      	ldr	r3, [pc, #160]	@ (8002008 <HAL_ADC_MspInit+0x178>)
 8001f68:	f44f 6280 	mov.w	r2, #1024	@ 0x400
 8001f6c:	611a      	str	r2, [r3, #16]
    hdma_adc1.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD;
 8001f6e:	4b26      	ldr	r3, [pc, #152]	@ (8002008 <HAL_ADC_MspInit+0x178>)
 8001f70:	f44f 6200 	mov.w	r2, #2048	@ 0x800
 8001f74:	615a      	str	r2, [r3, #20]
    hdma_adc1.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD;
 8001f76:	4b24      	ldr	r3, [pc, #144]	@ (8002008 <HAL_ADC_MspInit+0x178>)
 8001f78:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
 8001f7c:	619a      	str	r2, [r3, #24]
    hdma_adc1.Init.Mode = DMA_CIRCULAR;
 8001f7e:	4b22      	ldr	r3, [pc, #136]	@ (8002008 <HAL_ADC_MspInit+0x178>)
 8001f80:	f44f 7280 	mov.w	r2, #256	@ 0x100
 8001f84:	61da      	str	r2, [r3, #28]
    hdma_adc1.Init.Priority = DMA_PRIORITY_LOW;
 8001f86:	4b20      	ldr	r3, [pc, #128]	@ (8002008 <HAL_ADC_MspInit+0x178>)
 8001f88:	2200      	movs	r2, #0
 8001f8a:	621a      	str	r2, [r3, #32]
    hdma_adc1.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
 8001f8c:	4b1e      	ldr	r3, [pc, #120]	@ (8002008 <HAL_ADC_MspInit+0x178>)
 8001f8e:	2200      	movs	r2, #0
 8001f90:	625a      	str	r2, [r3, #36]	@ 0x24
    if (HAL_DMA_Init(&hdma_adc1) != HAL_OK)
 8001f92:	481d      	ldr	r0, [pc, #116]	@ (8002008 <HAL_ADC_MspInit+0x178>)
 8001f94:	f002 f94e 	bl	8004234 <HAL_DMA_Init>
 8001f98:	4603      	mov	r3, r0
 8001f9a:	2b00      	cmp	r3, #0
 8001f9c:	d001      	beq.n	8001fa2 <HAL_ADC_MspInit+0x112>
    {
      Error_Handler();
 8001f9e:	f7ff ff57 	bl	8001e50 <Error_Handler>
    }

    __HAL_LINKDMA(hadc,DMA_Handle,hdma_adc1);
 8001fa2:	687b      	ldr	r3, [r7, #4]
 8001fa4:	4a18      	ldr	r2, [pc, #96]	@ (8002008 <HAL_ADC_MspInit+0x178>)
 8001fa6:	64da      	str	r2, [r3, #76]	@ 0x4c
 8001fa8:	4a17      	ldr	r2, [pc, #92]	@ (8002008 <HAL_ADC_MspInit+0x178>)
 8001faa:	687b      	ldr	r3, [r7, #4]
 8001fac:	6393      	str	r3, [r2, #56]	@ 0x38
  /* USER CODE BEGIN ADC2_MspInit 1 */

  /* USER CODE END ADC2_MspInit 1 */
  }

}
 8001fae:	e01c      	b.n	8001fea <HAL_ADC_MspInit+0x15a>
  else if(hadc->Instance==ADC2)
 8001fb0:	687b      	ldr	r3, [r7, #4]
 8001fb2:	681b      	ldr	r3, [r3, #0]
 8001fb4:	4a16      	ldr	r2, [pc, #88]	@ (8002010 <HAL_ADC_MspInit+0x180>)
 8001fb6:	4293      	cmp	r3, r2
 8001fb8:	d117      	bne.n	8001fea <HAL_ADC_MspInit+0x15a>
    HAL_RCC_ADC12_CLK_ENABLED++;
 8001fba:	4b0f      	ldr	r3, [pc, #60]	@ (8001ff8 <HAL_ADC_MspInit+0x168>)
 8001fbc:	681b      	ldr	r3, [r3, #0]
 8001fbe:	3301      	adds	r3, #1
 8001fc0:	4a0d      	ldr	r2, [pc, #52]	@ (8001ff8 <HAL_ADC_MspInit+0x168>)
 8001fc2:	6013      	str	r3, [r2, #0]
    if(HAL_RCC_ADC12_CLK_ENABLED==1){
 8001fc4:	4b0c      	ldr	r3, [pc, #48]	@ (8001ff8 <HAL_ADC_MspInit+0x168>)
 8001fc6:	681b      	ldr	r3, [r3, #0]
 8001fc8:	2b01      	cmp	r3, #1
 8001fca:	d10e      	bne.n	8001fea <HAL_ADC_MspInit+0x15a>
      __HAL_RCC_ADC12_CLK_ENABLE();
 8001fcc:	4b0b      	ldr	r3, [pc, #44]	@ (8001ffc <HAL_ADC_MspInit+0x16c>)
 8001fce:	f8d3 3138 	ldr.w	r3, [r3, #312]	@ 0x138
 8001fd2:	4a0a      	ldr	r2, [pc, #40]	@ (8001ffc <HAL_ADC_MspInit+0x16c>)
 8001fd4:	f043 0320 	orr.w	r3, r3, #32
 8001fd8:	f8c2 3138 	str.w	r3, [r2, #312]	@ 0x138
 8001fdc:	4b07      	ldr	r3, [pc, #28]	@ (8001ffc <HAL_ADC_MspInit+0x16c>)
 8001fde:	f8d3 3138 	ldr.w	r3, [r3, #312]	@ 0x138
 8001fe2:	f003 0320 	and.w	r3, r3, #32
 8001fe6:	60fb      	str	r3, [r7, #12]
 8001fe8:	68fb      	ldr	r3, [r7, #12]
}
 8001fea:	bf00      	nop
 8001fec:	3730      	adds	r7, #48	@ 0x30
 8001fee:	46bd      	mov	sp, r7
 8001ff0:	bd80      	pop	{r7, pc}
 8001ff2:	bf00      	nop
 8001ff4:	40022000 	.word	0x40022000
 8001ff8:	240007c0 	.word	0x240007c0
 8001ffc:	58024400 	.word	0x58024400
 8002000:	58020800 	.word	0x58020800
 8002004:	58020000 	.word	0x58020000
 8002008:	24000384 	.word	0x24000384
 800200c:	40020410 	.word	0x40020410
 8002010:	40022100 	.word	0x40022100

08002014 <HAL_I2C_MspInit>:
* This function configures the hardware resources used in this example
* @param hi2c: I2C handle pointer
* @retval None
*/
void HAL_I2C_MspInit(I2C_HandleTypeDef* hi2c)
{
 8002014:	b580      	push	{r7, lr}
 8002016:	b0ba      	sub	sp, #232	@ 0xe8
 8002018:	af00      	add	r7, sp, #0
 800201a:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800201c:	f107 03d4 	add.w	r3, r7, #212	@ 0xd4
 8002020:	2200      	movs	r2, #0
 8002022:	601a      	str	r2, [r3, #0]
 8002024:	605a      	str	r2, [r3, #4]
 8002026:	609a      	str	r2, [r3, #8]
 8002028:	60da      	str	r2, [r3, #12]
 800202a:	611a      	str	r2, [r3, #16]
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 800202c:	f107 0310 	add.w	r3, r7, #16
 8002030:	22c0      	movs	r2, #192	@ 0xc0
 8002032:	2100      	movs	r1, #0
 8002034:	4618      	mov	r0, r3
 8002036:	f010 ffb9 	bl	8012fac <memset>
  if(hi2c->Instance==I2C1)
 800203a:	687b      	ldr	r3, [r7, #4]
 800203c:	681b      	ldr	r3, [r3, #0]
 800203e:	4a27      	ldr	r2, [pc, #156]	@ (80020dc <HAL_I2C_MspInit+0xc8>)
 8002040:	4293      	cmp	r3, r2
 8002042:	d146      	bne.n	80020d2 <HAL_I2C_MspInit+0xbe>

  /* USER CODE END I2C1_MspInit 0 */

  /** Initializes the peripherals clock
  */
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_I2C1;
 8002044:	f04f 0208 	mov.w	r2, #8
 8002048:	f04f 0300 	mov.w	r3, #0
 800204c:	e9c7 2304 	strd	r2, r3, [r7, #16]
    PeriphClkInitStruct.I2c123ClockSelection = RCC_I2C123CLKSOURCE_D2PCLK1;
 8002050:	2300      	movs	r3, #0
 8002052:	f8c7 309c 	str.w	r3, [r7, #156]	@ 0x9c
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 8002056:	f107 0310 	add.w	r3, r7, #16
 800205a:	4618      	mov	r0, r3
 800205c:	f008 fbc6 	bl	800a7ec <HAL_RCCEx_PeriphCLKConfig>
 8002060:	4603      	mov	r3, r0
 8002062:	2b00      	cmp	r3, #0
 8002064:	d001      	beq.n	800206a <HAL_I2C_MspInit+0x56>
    {
      Error_Handler();
 8002066:	f7ff fef3 	bl	8001e50 <Error_Handler>
    }

    __HAL_RCC_GPIOB_CLK_ENABLE();
 800206a:	4b1d      	ldr	r3, [pc, #116]	@ (80020e0 <HAL_I2C_MspInit+0xcc>)
 800206c:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
 8002070:	4a1b      	ldr	r2, [pc, #108]	@ (80020e0 <HAL_I2C_MspInit+0xcc>)
 8002072:	f043 0302 	orr.w	r3, r3, #2
 8002076:	f8c2 3140 	str.w	r3, [r2, #320]	@ 0x140
 800207a:	4b19      	ldr	r3, [pc, #100]	@ (80020e0 <HAL_I2C_MspInit+0xcc>)
 800207c:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
 8002080:	f003 0302 	and.w	r3, r3, #2
 8002084:	60fb      	str	r3, [r7, #12]
 8002086:	68fb      	ldr	r3, [r7, #12]
    /**I2C1 GPIO Configuration
    PB8     ------> I2C1_SCL
    PB9     ------> I2C1_SDA
    */
    GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9;
 8002088:	f44f 7340 	mov.w	r3, #768	@ 0x300
 800208c:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 8002090:	2312      	movs	r3, #18
 8002092:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8002096:	2300      	movs	r3, #0
 8002098:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800209c:	2300      	movs	r3, #0
 800209e:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C1;
 80020a2:	2304      	movs	r3, #4
 80020a4:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80020a8:	f107 03d4 	add.w	r3, r7, #212	@ 0xd4
 80020ac:	4619      	mov	r1, r3
 80020ae:	480d      	ldr	r0, [pc, #52]	@ (80020e4 <HAL_I2C_MspInit+0xd0>)
 80020b0:	f004 fa46 	bl	8006540 <HAL_GPIO_Init>

    /* Peripheral clock enable */
    __HAL_RCC_I2C1_CLK_ENABLE();
 80020b4:	4b0a      	ldr	r3, [pc, #40]	@ (80020e0 <HAL_I2C_MspInit+0xcc>)
 80020b6:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
 80020ba:	4a09      	ldr	r2, [pc, #36]	@ (80020e0 <HAL_I2C_MspInit+0xcc>)
 80020bc:	f443 1300 	orr.w	r3, r3, #2097152	@ 0x200000
 80020c0:	f8c2 3148 	str.w	r3, [r2, #328]	@ 0x148
 80020c4:	4b06      	ldr	r3, [pc, #24]	@ (80020e0 <HAL_I2C_MspInit+0xcc>)
 80020c6:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
 80020ca:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
 80020ce:	60bb      	str	r3, [r7, #8]
 80020d0:	68bb      	ldr	r3, [r7, #8]
  /* USER CODE BEGIN I2C1_MspInit 1 */

  /* USER CODE END I2C1_MspInit 1 */
  }

}
 80020d2:	bf00      	nop
 80020d4:	37e8      	adds	r7, #232	@ 0xe8
 80020d6:	46bd      	mov	sp, r7
 80020d8:	bd80      	pop	{r7, pc}
 80020da:	bf00      	nop
 80020dc:	40005400 	.word	0x40005400
 80020e0:	58024400 	.word	0x58024400
 80020e4:	58020400 	.word	0x58020400

080020e8 <HAL_OSPI_MspInit>:
* This function configures the hardware resources used in this example
* @param hospi: OSPI handle pointer
* @retval None
*/
void HAL_OSPI_MspInit(OSPI_HandleTypeDef* hospi)
{
 80020e8:	b580      	push	{r7, lr}
 80020ea:	b0be      	sub	sp, #248	@ 0xf8
 80020ec:	af00      	add	r7, sp, #0
 80020ee:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80020f0:	f107 03e4 	add.w	r3, r7, #228	@ 0xe4
 80020f4:	2200      	movs	r2, #0
 80020f6:	601a      	str	r2, [r3, #0]
 80020f8:	605a      	str	r2, [r3, #4]
 80020fa:	609a      	str	r2, [r3, #8]
 80020fc:	60da      	str	r2, [r3, #12]
 80020fe:	611a      	str	r2, [r3, #16]
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 8002100:	f107 0320 	add.w	r3, r7, #32
 8002104:	22c0      	movs	r2, #192	@ 0xc0
 8002106:	2100      	movs	r1, #0
 8002108:	4618      	mov	r0, r3
 800210a:	f010 ff4f 	bl	8012fac <memset>
  if(hospi->Instance==OCTOSPI2)
 800210e:	687b      	ldr	r3, [r7, #4]
 8002110:	681b      	ldr	r3, [r3, #0]
 8002112:	4a67      	ldr	r2, [pc, #412]	@ (80022b0 <HAL_OSPI_MspInit+0x1c8>)
 8002114:	4293      	cmp	r3, r2
 8002116:	f040 80c7 	bne.w	80022a8 <HAL_OSPI_MspInit+0x1c0>

  /* USER CODE END OCTOSPI2_MspInit 0 */

  /** Initializes the peripherals clock
  */
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_OSPI;
 800211a:	f04f 7200 	mov.w	r2, #33554432	@ 0x2000000
 800211e:	f04f 0300 	mov.w	r3, #0
 8002122:	e9c7 2308 	strd	r2, r3, [r7, #32]
    PeriphClkInitStruct.OspiClockSelection = RCC_OSPICLKSOURCE_D1HCLK;
 8002126:	2300      	movs	r3, #0
 8002128:	66fb      	str	r3, [r7, #108]	@ 0x6c
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 800212a:	f107 0320 	add.w	r3, r7, #32
 800212e:	4618      	mov	r0, r3
 8002130:	f008 fb5c 	bl	800a7ec <HAL_RCCEx_PeriphCLKConfig>
 8002134:	4603      	mov	r3, r0
 8002136:	2b00      	cmp	r3, #0
 8002138:	d001      	beq.n	800213e <HAL_OSPI_MspInit+0x56>
    {
      Error_Handler();
 800213a:	f7ff fe89 	bl	8001e50 <Error_Handler>
    }

    /* Peripheral clock enable */
    __HAL_RCC_OCTOSPIM_CLK_ENABLE();
 800213e:	4b5d      	ldr	r3, [pc, #372]	@ (80022b4 <HAL_OSPI_MspInit+0x1cc>)
 8002140:	f8d3 3134 	ldr.w	r3, [r3, #308]	@ 0x134
 8002144:	4a5b      	ldr	r2, [pc, #364]	@ (80022b4 <HAL_OSPI_MspInit+0x1cc>)
 8002146:	f443 1300 	orr.w	r3, r3, #2097152	@ 0x200000
 800214a:	f8c2 3134 	str.w	r3, [r2, #308]	@ 0x134
 800214e:	4b59      	ldr	r3, [pc, #356]	@ (80022b4 <HAL_OSPI_MspInit+0x1cc>)
 8002150:	f8d3 3134 	ldr.w	r3, [r3, #308]	@ 0x134
 8002154:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
 8002158:	61fb      	str	r3, [r7, #28]
 800215a:	69fb      	ldr	r3, [r7, #28]
    __HAL_RCC_OSPI2_CLK_ENABLE();
 800215c:	4b55      	ldr	r3, [pc, #340]	@ (80022b4 <HAL_OSPI_MspInit+0x1cc>)
 800215e:	f8d3 3134 	ldr.w	r3, [r3, #308]	@ 0x134
 8002162:	4a54      	ldr	r2, [pc, #336]	@ (80022b4 <HAL_OSPI_MspInit+0x1cc>)
 8002164:	f443 2300 	orr.w	r3, r3, #524288	@ 0x80000
 8002168:	f8c2 3134 	str.w	r3, [r2, #308]	@ 0x134
 800216c:	4b51      	ldr	r3, [pc, #324]	@ (80022b4 <HAL_OSPI_MspInit+0x1cc>)
 800216e:	f8d3 3134 	ldr.w	r3, [r3, #308]	@ 0x134
 8002172:	f403 2300 	and.w	r3, r3, #524288	@ 0x80000
 8002176:	61bb      	str	r3, [r7, #24]
 8002178:	69bb      	ldr	r3, [r7, #24]

    __HAL_RCC_GPIOA_CLK_ENABLE();
 800217a:	4b4e      	ldr	r3, [pc, #312]	@ (80022b4 <HAL_OSPI_MspInit+0x1cc>)
 800217c:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
 8002180:	4a4c      	ldr	r2, [pc, #304]	@ (80022b4 <HAL_OSPI_MspInit+0x1cc>)
 8002182:	f043 0301 	orr.w	r3, r3, #1
 8002186:	f8c2 3140 	str.w	r3, [r2, #320]	@ 0x140
 800218a:	4b4a      	ldr	r3, [pc, #296]	@ (80022b4 <HAL_OSPI_MspInit+0x1cc>)
 800218c:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
 8002190:	f003 0301 	and.w	r3, r3, #1
 8002194:	617b      	str	r3, [r7, #20]
 8002196:	697b      	ldr	r3, [r7, #20]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8002198:	4b46      	ldr	r3, [pc, #280]	@ (80022b4 <HAL_OSPI_MspInit+0x1cc>)
 800219a:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
 800219e:	4a45      	ldr	r2, [pc, #276]	@ (80022b4 <HAL_OSPI_MspInit+0x1cc>)
 80021a0:	f043 0302 	orr.w	r3, r3, #2
 80021a4:	f8c2 3140 	str.w	r3, [r2, #320]	@ 0x140
 80021a8:	4b42      	ldr	r3, [pc, #264]	@ (80022b4 <HAL_OSPI_MspInit+0x1cc>)
 80021aa:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
 80021ae:	f003 0302 	and.w	r3, r3, #2
 80021b2:	613b      	str	r3, [r7, #16]
 80021b4:	693b      	ldr	r3, [r7, #16]
    __HAL_RCC_GPIOE_CLK_ENABLE();
 80021b6:	4b3f      	ldr	r3, [pc, #252]	@ (80022b4 <HAL_OSPI_MspInit+0x1cc>)
 80021b8:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
 80021bc:	4a3d      	ldr	r2, [pc, #244]	@ (80022b4 <HAL_OSPI_MspInit+0x1cc>)
 80021be:	f043 0310 	orr.w	r3, r3, #16
 80021c2:	f8c2 3140 	str.w	r3, [r2, #320]	@ 0x140
 80021c6:	4b3b      	ldr	r3, [pc, #236]	@ (80022b4 <HAL_OSPI_MspInit+0x1cc>)
 80021c8:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
 80021cc:	f003 0310 	and.w	r3, r3, #16
 80021d0:	60fb      	str	r3, [r7, #12]
 80021d2:	68fb      	ldr	r3, [r7, #12]
    PB0     ------> OCTOSPIM_P1_IO1
    PB1     ------> OCTOSPIM_P1_IO0
    PB2     ------> OCTOSPIM_P1_CLK
    PE11     ------> OCTOSPIM_P1_NCS
    */
    GPIO_InitStruct.Pin = GPIO_PIN_6;
 80021d4:	2340      	movs	r3, #64	@ 0x40
 80021d6:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80021da:	2302      	movs	r3, #2
 80021dc:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 80021e0:	2301      	movs	r3, #1
 80021e2:	f8c7 30ec 	str.w	r3, [r7, #236]	@ 0xec
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 80021e6:	2303      	movs	r3, #3
 80021e8:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0
    GPIO_InitStruct.Alternate = GPIO_AF6_OCTOSPIM_P1;
 80021ec:	2306      	movs	r3, #6
 80021ee:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80021f2:	f107 03e4 	add.w	r3, r7, #228	@ 0xe4
 80021f6:	4619      	mov	r1, r3
 80021f8:	482f      	ldr	r0, [pc, #188]	@ (80022b8 <HAL_OSPI_MspInit+0x1d0>)
 80021fa:	f004 f9a1 	bl	8006540 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_7;
 80021fe:	2380      	movs	r3, #128	@ 0x80
 8002200:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8002204:	2302      	movs	r3, #2
 8002206:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 800220a:	2301      	movs	r3, #1
 800220c:	f8c7 30ec 	str.w	r3, [r7, #236]	@ 0xec
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8002210:	2303      	movs	r3, #3
 8002212:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0
    GPIO_InitStruct.Alternate = GPIO_AF10_OCTOSPIM_P1;
 8002216:	230a      	movs	r3, #10
 8002218:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800221c:	f107 03e4 	add.w	r3, r7, #228	@ 0xe4
 8002220:	4619      	mov	r1, r3
 8002222:	4825      	ldr	r0, [pc, #148]	@ (80022b8 <HAL_OSPI_MspInit+0x1d0>)
 8002224:	f004 f98c 	bl	8006540 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1;
 8002228:	2303      	movs	r3, #3
 800222a:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800222e:	2302      	movs	r3, #2
 8002230:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 8002234:	2301      	movs	r3, #1
 8002236:	f8c7 30ec 	str.w	r3, [r7, #236]	@ 0xec
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800223a:	2303      	movs	r3, #3
 800223c:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0
    GPIO_InitStruct.Alternate = GPIO_AF11_OCTOSPIM_P1;
 8002240:	230b      	movs	r3, #11
 8002242:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8002246:	f107 03e4 	add.w	r3, r7, #228	@ 0xe4
 800224a:	4619      	mov	r1, r3
 800224c:	481b      	ldr	r0, [pc, #108]	@ (80022bc <HAL_OSPI_MspInit+0x1d4>)
 800224e:	f004 f977 	bl	8006540 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_2;
 8002252:	2304      	movs	r3, #4
 8002254:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8002258:	2302      	movs	r3, #2
 800225a:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 800225e:	2300      	movs	r3, #0
 8002260:	f8c7 30ec 	str.w	r3, [r7, #236]	@ 0xec
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8002264:	2303      	movs	r3, #3
 8002266:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0
    GPIO_InitStruct.Alternate = GPIO_AF9_OCTOSPIM_P1;
 800226a:	2309      	movs	r3, #9
 800226c:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8002270:	f107 03e4 	add.w	r3, r7, #228	@ 0xe4
 8002274:	4619      	mov	r1, r3
 8002276:	4811      	ldr	r0, [pc, #68]	@ (80022bc <HAL_OSPI_MspInit+0x1d4>)
 8002278:	f004 f962 	bl	8006540 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_11;
 800227c:	f44f 6300 	mov.w	r3, #2048	@ 0x800
 8002280:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8002284:	2302      	movs	r3, #2
 8002286:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 800228a:	2300      	movs	r3, #0
 800228c:	f8c7 30ec 	str.w	r3, [r7, #236]	@ 0xec
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8002290:	2303      	movs	r3, #3
 8002292:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0
    GPIO_InitStruct.Alternate = GPIO_AF11_OCTOSPIM_P1;
 8002296:	230b      	movs	r3, #11
 8002298:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 800229c:	f107 03e4 	add.w	r3, r7, #228	@ 0xe4
 80022a0:	4619      	mov	r1, r3
 80022a2:	4807      	ldr	r0, [pc, #28]	@ (80022c0 <HAL_OSPI_MspInit+0x1d8>)
 80022a4:	f004 f94c 	bl	8006540 <HAL_GPIO_Init>
  /* USER CODE BEGIN OCTOSPI2_MspInit 1 */

  /* USER CODE END OCTOSPI2_MspInit 1 */
  }

}
 80022a8:	bf00      	nop
 80022aa:	37f8      	adds	r7, #248	@ 0xf8
 80022ac:	46bd      	mov	sp, r7
 80022ae:	bd80      	pop	{r7, pc}
 80022b0:	5200a000 	.word	0x5200a000
 80022b4:	58024400 	.word	0x58024400
 80022b8:	58020000 	.word	0x58020000
 80022bc:	58020400 	.word	0x58020400
 80022c0:	58021000 	.word	0x58021000

080022c4 <HAL_TIM_Base_MspInit>:
* This function configures the hardware resources used in this example
* @param htim_base: TIM_Base handle pointer
* @retval None
*/
void HAL_TIM_Base_MspInit(TIM_HandleTypeDef* htim_base)
{
 80022c4:	b580      	push	{r7, lr}
 80022c6:	b086      	sub	sp, #24
 80022c8:	af00      	add	r7, sp, #0
 80022ca:	6078      	str	r0, [r7, #4]
  if(htim_base->Instance==TIM1)
 80022cc:	687b      	ldr	r3, [r7, #4]
 80022ce:	681b      	ldr	r3, [r3, #0]
 80022d0:	4a23      	ldr	r2, [pc, #140]	@ (8002360 <HAL_TIM_Base_MspInit+0x9c>)
 80022d2:	4293      	cmp	r3, r2
 80022d4:	d10f      	bne.n	80022f6 <HAL_TIM_Base_MspInit+0x32>
  {
  /* USER CODE BEGIN TIM1_MspInit 0 */

  /* USER CODE END TIM1_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_TIM1_CLK_ENABLE();
 80022d6:	4b23      	ldr	r3, [pc, #140]	@ (8002364 <HAL_TIM_Base_MspInit+0xa0>)
 80022d8:	f8d3 3150 	ldr.w	r3, [r3, #336]	@ 0x150
 80022dc:	4a21      	ldr	r2, [pc, #132]	@ (8002364 <HAL_TIM_Base_MspInit+0xa0>)
 80022de:	f043 0301 	orr.w	r3, r3, #1
 80022e2:	f8c2 3150 	str.w	r3, [r2, #336]	@ 0x150
 80022e6:	4b1f      	ldr	r3, [pc, #124]	@ (8002364 <HAL_TIM_Base_MspInit+0xa0>)
 80022e8:	f8d3 3150 	ldr.w	r3, [r3, #336]	@ 0x150
 80022ec:	f003 0301 	and.w	r3, r3, #1
 80022f0:	617b      	str	r3, [r7, #20]
 80022f2:	697b      	ldr	r3, [r7, #20]
  /* USER CODE BEGIN TIM15_MspInit 1 */

  /* USER CODE END TIM15_MspInit 1 */
  }

}
 80022f4:	e030      	b.n	8002358 <HAL_TIM_Base_MspInit+0x94>
  else if(htim_base->Instance==TIM3)
 80022f6:	687b      	ldr	r3, [r7, #4]
 80022f8:	681b      	ldr	r3, [r3, #0]
 80022fa:	4a1b      	ldr	r2, [pc, #108]	@ (8002368 <HAL_TIM_Base_MspInit+0xa4>)
 80022fc:	4293      	cmp	r3, r2
 80022fe:	d117      	bne.n	8002330 <HAL_TIM_Base_MspInit+0x6c>
    __HAL_RCC_TIM3_CLK_ENABLE();
 8002300:	4b18      	ldr	r3, [pc, #96]	@ (8002364 <HAL_TIM_Base_MspInit+0xa0>)
 8002302:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
 8002306:	4a17      	ldr	r2, [pc, #92]	@ (8002364 <HAL_TIM_Base_MspInit+0xa0>)
 8002308:	f043 0302 	orr.w	r3, r3, #2
 800230c:	f8c2 3148 	str.w	r3, [r2, #328]	@ 0x148
 8002310:	4b14      	ldr	r3, [pc, #80]	@ (8002364 <HAL_TIM_Base_MspInit+0xa0>)
 8002312:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
 8002316:	f003 0302 	and.w	r3, r3, #2
 800231a:	613b      	str	r3, [r7, #16]
 800231c:	693b      	ldr	r3, [r7, #16]
    HAL_NVIC_SetPriority(TIM3_IRQn, 0, 0);
 800231e:	2200      	movs	r2, #0
 8002320:	2100      	movs	r1, #0
 8002322:	201d      	movs	r0, #29
 8002324:	f001 fed9 	bl	80040da <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(TIM3_IRQn);
 8002328:	201d      	movs	r0, #29
 800232a:	f001 fef0 	bl	800410e <HAL_NVIC_EnableIRQ>
}
 800232e:	e013      	b.n	8002358 <HAL_TIM_Base_MspInit+0x94>
  else if(htim_base->Instance==TIM15)
 8002330:	687b      	ldr	r3, [r7, #4]
 8002332:	681b      	ldr	r3, [r3, #0]
 8002334:	4a0d      	ldr	r2, [pc, #52]	@ (800236c <HAL_TIM_Base_MspInit+0xa8>)
 8002336:	4293      	cmp	r3, r2
 8002338:	d10e      	bne.n	8002358 <HAL_TIM_Base_MspInit+0x94>
    __HAL_RCC_TIM15_CLK_ENABLE();
 800233a:	4b0a      	ldr	r3, [pc, #40]	@ (8002364 <HAL_TIM_Base_MspInit+0xa0>)
 800233c:	f8d3 3150 	ldr.w	r3, [r3, #336]	@ 0x150
 8002340:	4a08      	ldr	r2, [pc, #32]	@ (8002364 <HAL_TIM_Base_MspInit+0xa0>)
 8002342:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 8002346:	f8c2 3150 	str.w	r3, [r2, #336]	@ 0x150
 800234a:	4b06      	ldr	r3, [pc, #24]	@ (8002364 <HAL_TIM_Base_MspInit+0xa0>)
 800234c:	f8d3 3150 	ldr.w	r3, [r3, #336]	@ 0x150
 8002350:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 8002354:	60fb      	str	r3, [r7, #12]
 8002356:	68fb      	ldr	r3, [r7, #12]
}
 8002358:	bf00      	nop
 800235a:	3718      	adds	r7, #24
 800235c:	46bd      	mov	sp, r7
 800235e:	bd80      	pop	{r7, pc}
 8002360:	40010000 	.word	0x40010000
 8002364:	58024400 	.word	0x58024400
 8002368:	40000400 	.word	0x40000400
 800236c:	40014000 	.word	0x40014000

08002370 <HAL_TIM_MspPostInit>:

void HAL_TIM_MspPostInit(TIM_HandleTypeDef* htim)
{
 8002370:	b580      	push	{r7, lr}
 8002372:	b08a      	sub	sp, #40	@ 0x28
 8002374:	af00      	add	r7, sp, #0
 8002376:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8002378:	f107 0314 	add.w	r3, r7, #20
 800237c:	2200      	movs	r2, #0
 800237e:	601a      	str	r2, [r3, #0]
 8002380:	605a      	str	r2, [r3, #4]
 8002382:	609a      	str	r2, [r3, #8]
 8002384:	60da      	str	r2, [r3, #12]
 8002386:	611a      	str	r2, [r3, #16]
  if(htim->Instance==TIM1)
 8002388:	687b      	ldr	r3, [r7, #4]
 800238a:	681b      	ldr	r3, [r3, #0]
 800238c:	4a26      	ldr	r2, [pc, #152]	@ (8002428 <HAL_TIM_MspPostInit+0xb8>)
 800238e:	4293      	cmp	r3, r2
 8002390:	d120      	bne.n	80023d4 <HAL_TIM_MspPostInit+0x64>
  {
  /* USER CODE BEGIN TIM1_MspPostInit 0 */

  /* USER CODE END TIM1_MspPostInit 0 */
    __HAL_RCC_GPIOE_CLK_ENABLE();
 8002392:	4b26      	ldr	r3, [pc, #152]	@ (800242c <HAL_TIM_MspPostInit+0xbc>)
 8002394:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
 8002398:	4a24      	ldr	r2, [pc, #144]	@ (800242c <HAL_TIM_MspPostInit+0xbc>)
 800239a:	f043 0310 	orr.w	r3, r3, #16
 800239e:	f8c2 3140 	str.w	r3, [r2, #320]	@ 0x140
 80023a2:	4b22      	ldr	r3, [pc, #136]	@ (800242c <HAL_TIM_MspPostInit+0xbc>)
 80023a4:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
 80023a8:	f003 0310 	and.w	r3, r3, #16
 80023ac:	613b      	str	r3, [r7, #16]
 80023ae:	693b      	ldr	r3, [r7, #16]
    /**TIM1 GPIO Configuration
    PE9     ------> TIM1_CH1
    */
    GPIO_InitStruct.Pin = LED_LEFT_TIM1_Pin;
 80023b0:	f44f 7300 	mov.w	r3, #512	@ 0x200
 80023b4:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80023b6:	2302      	movs	r3, #2
 80023b8:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80023ba:	2300      	movs	r3, #0
 80023bc:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_MEDIUM;
 80023be:	2301      	movs	r3, #1
 80023c0:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM1;
 80023c2:	2301      	movs	r3, #1
 80023c4:	627b      	str	r3, [r7, #36]	@ 0x24
    HAL_GPIO_Init(LED_LEFT_TIM1_GPIO_Port, &GPIO_InitStruct);
 80023c6:	f107 0314 	add.w	r3, r7, #20
 80023ca:	4619      	mov	r1, r3
 80023cc:	4818      	ldr	r0, [pc, #96]	@ (8002430 <HAL_TIM_MspPostInit+0xc0>)
 80023ce:	f004 f8b7 	bl	8006540 <HAL_GPIO_Init>
  /* USER CODE BEGIN TIM15_MspPostInit 1 */

  /* USER CODE END TIM15_MspPostInit 1 */
  }

}
 80023d2:	e024      	b.n	800241e <HAL_TIM_MspPostInit+0xae>
  else if(htim->Instance==TIM15)
 80023d4:	687b      	ldr	r3, [r7, #4]
 80023d6:	681b      	ldr	r3, [r3, #0]
 80023d8:	4a16      	ldr	r2, [pc, #88]	@ (8002434 <HAL_TIM_MspPostInit+0xc4>)
 80023da:	4293      	cmp	r3, r2
 80023dc:	d11f      	bne.n	800241e <HAL_TIM_MspPostInit+0xae>
    __HAL_RCC_GPIOC_CLK_ENABLE();
 80023de:	4b13      	ldr	r3, [pc, #76]	@ (800242c <HAL_TIM_MspPostInit+0xbc>)
 80023e0:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
 80023e4:	4a11      	ldr	r2, [pc, #68]	@ (800242c <HAL_TIM_MspPostInit+0xbc>)
 80023e6:	f043 0304 	orr.w	r3, r3, #4
 80023ea:	f8c2 3140 	str.w	r3, [r2, #320]	@ 0x140
 80023ee:	4b0f      	ldr	r3, [pc, #60]	@ (800242c <HAL_TIM_MspPostInit+0xbc>)
 80023f0:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
 80023f4:	f003 0304 	and.w	r3, r3, #4
 80023f8:	60fb      	str	r3, [r7, #12]
 80023fa:	68fb      	ldr	r3, [r7, #12]
    GPIO_InitStruct.Pin = LED_RIGHT_TIM15_Pin;
 80023fc:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 8002400:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8002402:	2302      	movs	r3, #2
 8002404:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8002406:	2300      	movs	r3, #0
 8002408:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_MEDIUM;
 800240a:	2301      	movs	r3, #1
 800240c:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM15;
 800240e:	2302      	movs	r3, #2
 8002410:	627b      	str	r3, [r7, #36]	@ 0x24
    HAL_GPIO_Init(LED_RIGHT_TIM15_GPIO_Port, &GPIO_InitStruct);
 8002412:	f107 0314 	add.w	r3, r7, #20
 8002416:	4619      	mov	r1, r3
 8002418:	4807      	ldr	r0, [pc, #28]	@ (8002438 <HAL_TIM_MspPostInit+0xc8>)
 800241a:	f004 f891 	bl	8006540 <HAL_GPIO_Init>
}
 800241e:	bf00      	nop
 8002420:	3728      	adds	r7, #40	@ 0x28
 8002422:	46bd      	mov	sp, r7
 8002424:	bd80      	pop	{r7, pc}
 8002426:	bf00      	nop
 8002428:	40010000 	.word	0x40010000
 800242c:	58024400 	.word	0x58024400
 8002430:	58021000 	.word	0x58021000
 8002434:	40014000 	.word	0x40014000
 8002438:	58020800 	.word	0x58020800

0800243c <HAL_SAI_MspInit>:
extern DMA_HandleTypeDef hdma_sai1_b;

static uint32_t SAI1_client =0;

void HAL_SAI_MspInit(SAI_HandleTypeDef* hsai)
{
 800243c:	b580      	push	{r7, lr}
 800243e:	b08a      	sub	sp, #40	@ 0x28
 8002440:	af00      	add	r7, sp, #0
 8002442:	6078      	str	r0, [r7, #4]

  GPIO_InitTypeDef GPIO_InitStruct;
/* SAI1 */
    if(hsai->Instance==SAI1_Block_A)
 8002444:	687b      	ldr	r3, [r7, #4]
 8002446:	681b      	ldr	r3, [r3, #0]
 8002448:	4a66      	ldr	r2, [pc, #408]	@ (80025e4 <HAL_SAI_MspInit+0x1a8>)
 800244a:	4293      	cmp	r3, r2
 800244c:	d160      	bne.n	8002510 <HAL_SAI_MspInit+0xd4>
    {
    /* Peripheral clock enable */
    if (SAI1_client == 0)
 800244e:	4b66      	ldr	r3, [pc, #408]	@ (80025e8 <HAL_SAI_MspInit+0x1ac>)
 8002450:	681b      	ldr	r3, [r3, #0]
 8002452:	2b00      	cmp	r3, #0
 8002454:	d10e      	bne.n	8002474 <HAL_SAI_MspInit+0x38>
    {
       __HAL_RCC_SAI1_CLK_ENABLE();
 8002456:	4b65      	ldr	r3, [pc, #404]	@ (80025ec <HAL_SAI_MspInit+0x1b0>)
 8002458:	f8d3 3150 	ldr.w	r3, [r3, #336]	@ 0x150
 800245c:	4a63      	ldr	r2, [pc, #396]	@ (80025ec <HAL_SAI_MspInit+0x1b0>)
 800245e:	f443 0380 	orr.w	r3, r3, #4194304	@ 0x400000
 8002462:	f8c2 3150 	str.w	r3, [r2, #336]	@ 0x150
 8002466:	4b61      	ldr	r3, [pc, #388]	@ (80025ec <HAL_SAI_MspInit+0x1b0>)
 8002468:	f8d3 3150 	ldr.w	r3, [r3, #336]	@ 0x150
 800246c:	f403 0380 	and.w	r3, r3, #4194304	@ 0x400000
 8002470:	613b      	str	r3, [r7, #16]
 8002472:	693b      	ldr	r3, [r7, #16]
    }
    SAI1_client ++;
 8002474:	4b5c      	ldr	r3, [pc, #368]	@ (80025e8 <HAL_SAI_MspInit+0x1ac>)
 8002476:	681b      	ldr	r3, [r3, #0]
 8002478:	3301      	adds	r3, #1
 800247a:	4a5b      	ldr	r2, [pc, #364]	@ (80025e8 <HAL_SAI_MspInit+0x1ac>)
 800247c:	6013      	str	r3, [r2, #0]
    PE2     ------> SAI1_MCLK_A
    PE4     ------> SAI1_FS_A
    PE5     ------> SAI1_SCK_A
    PE6     ------> SAI1_SD_A
    */
    GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_4|GPIO_PIN_5|GPIO_PIN_6;
 800247e:	2374      	movs	r3, #116	@ 0x74
 8002480:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8002482:	2302      	movs	r3, #2
 8002484:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8002486:	2300      	movs	r3, #0
 8002488:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800248a:	2303      	movs	r3, #3
 800248c:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Alternate = GPIO_AF6_SAI1;
 800248e:	2306      	movs	r3, #6
 8002490:	627b      	str	r3, [r7, #36]	@ 0x24
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8002492:	f107 0314 	add.w	r3, r7, #20
 8002496:	4619      	mov	r1, r3
 8002498:	4855      	ldr	r0, [pc, #340]	@ (80025f0 <HAL_SAI_MspInit+0x1b4>)
 800249a:	f004 f851 	bl	8006540 <HAL_GPIO_Init>

      /* Peripheral DMA init*/

    hdma_sai1_a.Instance = DMA1_Stream0;
 800249e:	4b55      	ldr	r3, [pc, #340]	@ (80025f4 <HAL_SAI_MspInit+0x1b8>)
 80024a0:	4a55      	ldr	r2, [pc, #340]	@ (80025f8 <HAL_SAI_MspInit+0x1bc>)
 80024a2:	601a      	str	r2, [r3, #0]
    hdma_sai1_a.Init.Request = DMA_REQUEST_SAI1_A;
 80024a4:	4b53      	ldr	r3, [pc, #332]	@ (80025f4 <HAL_SAI_MspInit+0x1b8>)
 80024a6:	2257      	movs	r2, #87	@ 0x57
 80024a8:	605a      	str	r2, [r3, #4]
    hdma_sai1_a.Init.Direction = DMA_MEMORY_TO_PERIPH;
 80024aa:	4b52      	ldr	r3, [pc, #328]	@ (80025f4 <HAL_SAI_MspInit+0x1b8>)
 80024ac:	2240      	movs	r2, #64	@ 0x40
 80024ae:	609a      	str	r2, [r3, #8]
    hdma_sai1_a.Init.PeriphInc = DMA_PINC_DISABLE;
 80024b0:	4b50      	ldr	r3, [pc, #320]	@ (80025f4 <HAL_SAI_MspInit+0x1b8>)
 80024b2:	2200      	movs	r2, #0
 80024b4:	60da      	str	r2, [r3, #12]
    hdma_sai1_a.Init.MemInc = DMA_MINC_ENABLE;
 80024b6:	4b4f      	ldr	r3, [pc, #316]	@ (80025f4 <HAL_SAI_MspInit+0x1b8>)
 80024b8:	f44f 6280 	mov.w	r2, #1024	@ 0x400
 80024bc:	611a      	str	r2, [r3, #16]
    hdma_sai1_a.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
 80024be:	4b4d      	ldr	r3, [pc, #308]	@ (80025f4 <HAL_SAI_MspInit+0x1b8>)
 80024c0:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
 80024c4:	615a      	str	r2, [r3, #20]
    hdma_sai1_a.Init.MemDataAlignment = DMA_MDATAALIGN_WORD;
 80024c6:	4b4b      	ldr	r3, [pc, #300]	@ (80025f4 <HAL_SAI_MspInit+0x1b8>)
 80024c8:	f44f 4280 	mov.w	r2, #16384	@ 0x4000
 80024cc:	619a      	str	r2, [r3, #24]
    hdma_sai1_a.Init.Mode = DMA_CIRCULAR;
 80024ce:	4b49      	ldr	r3, [pc, #292]	@ (80025f4 <HAL_SAI_MspInit+0x1b8>)
 80024d0:	f44f 7280 	mov.w	r2, #256	@ 0x100
 80024d4:	61da      	str	r2, [r3, #28]
    hdma_sai1_a.Init.Priority = DMA_PRIORITY_VERY_HIGH;
 80024d6:	4b47      	ldr	r3, [pc, #284]	@ (80025f4 <HAL_SAI_MspInit+0x1b8>)
 80024d8:	f44f 3240 	mov.w	r2, #196608	@ 0x30000
 80024dc:	621a      	str	r2, [r3, #32]
    hdma_sai1_a.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
 80024de:	4b45      	ldr	r3, [pc, #276]	@ (80025f4 <HAL_SAI_MspInit+0x1b8>)
 80024e0:	2200      	movs	r2, #0
 80024e2:	625a      	str	r2, [r3, #36]	@ 0x24
    if (HAL_DMA_Init(&hdma_sai1_a) != HAL_OK)
 80024e4:	4843      	ldr	r0, [pc, #268]	@ (80025f4 <HAL_SAI_MspInit+0x1b8>)
 80024e6:	f001 fea5 	bl	8004234 <HAL_DMA_Init>
 80024ea:	4603      	mov	r3, r0
 80024ec:	2b00      	cmp	r3, #0
 80024ee:	d001      	beq.n	80024f4 <HAL_SAI_MspInit+0xb8>
    {
      Error_Handler();
 80024f0:	f7ff fcae 	bl	8001e50 <Error_Handler>
    }

    /* Several peripheral DMA handle pointers point to the same DMA handle.
     Be aware that there is only one channel to perform all the requested DMAs. */
    __HAL_LINKDMA(hsai,hdmarx,hdma_sai1_a);
 80024f4:	687b      	ldr	r3, [r7, #4]
 80024f6:	4a3f      	ldr	r2, [pc, #252]	@ (80025f4 <HAL_SAI_MspInit+0x1b8>)
 80024f8:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
 80024fc:	4a3d      	ldr	r2, [pc, #244]	@ (80025f4 <HAL_SAI_MspInit+0x1b8>)
 80024fe:	687b      	ldr	r3, [r7, #4]
 8002500:	6393      	str	r3, [r2, #56]	@ 0x38

    __HAL_LINKDMA(hsai,hdmatx,hdma_sai1_a);
 8002502:	687b      	ldr	r3, [r7, #4]
 8002504:	4a3b      	ldr	r2, [pc, #236]	@ (80025f4 <HAL_SAI_MspInit+0x1b8>)
 8002506:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
 800250a:	4a3a      	ldr	r2, [pc, #232]	@ (80025f4 <HAL_SAI_MspInit+0x1b8>)
 800250c:	687b      	ldr	r3, [r7, #4]
 800250e:	6393      	str	r3, [r2, #56]	@ 0x38

    }
    if(hsai->Instance==SAI1_Block_B)
 8002510:	687b      	ldr	r3, [r7, #4]
 8002512:	681b      	ldr	r3, [r3, #0]
 8002514:	4a39      	ldr	r2, [pc, #228]	@ (80025fc <HAL_SAI_MspInit+0x1c0>)
 8002516:	4293      	cmp	r3, r2
 8002518:	d160      	bne.n	80025dc <HAL_SAI_MspInit+0x1a0>
    {
      /* Peripheral clock enable */
      if (SAI1_client == 0)
 800251a:	4b33      	ldr	r3, [pc, #204]	@ (80025e8 <HAL_SAI_MspInit+0x1ac>)
 800251c:	681b      	ldr	r3, [r3, #0]
 800251e:	2b00      	cmp	r3, #0
 8002520:	d10e      	bne.n	8002540 <HAL_SAI_MspInit+0x104>
      {
       __HAL_RCC_SAI1_CLK_ENABLE();
 8002522:	4b32      	ldr	r3, [pc, #200]	@ (80025ec <HAL_SAI_MspInit+0x1b0>)
 8002524:	f8d3 3150 	ldr.w	r3, [r3, #336]	@ 0x150
 8002528:	4a30      	ldr	r2, [pc, #192]	@ (80025ec <HAL_SAI_MspInit+0x1b0>)
 800252a:	f443 0380 	orr.w	r3, r3, #4194304	@ 0x400000
 800252e:	f8c2 3150 	str.w	r3, [r2, #336]	@ 0x150
 8002532:	4b2e      	ldr	r3, [pc, #184]	@ (80025ec <HAL_SAI_MspInit+0x1b0>)
 8002534:	f8d3 3150 	ldr.w	r3, [r3, #336]	@ 0x150
 8002538:	f403 0380 	and.w	r3, r3, #4194304	@ 0x400000
 800253c:	60fb      	str	r3, [r7, #12]
 800253e:	68fb      	ldr	r3, [r7, #12]
      }
    SAI1_client ++;
 8002540:	4b29      	ldr	r3, [pc, #164]	@ (80025e8 <HAL_SAI_MspInit+0x1ac>)
 8002542:	681b      	ldr	r3, [r3, #0]
 8002544:	3301      	adds	r3, #1
 8002546:	4a28      	ldr	r2, [pc, #160]	@ (80025e8 <HAL_SAI_MspInit+0x1ac>)
 8002548:	6013      	str	r3, [r2, #0]

    /**SAI1_B_Block_B GPIO Configuration
    PE3     ------> SAI1_SD_B
    */
    GPIO_InitStruct.Pin = GPIO_PIN_3;
 800254a:	2308      	movs	r3, #8
 800254c:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800254e:	2302      	movs	r3, #2
 8002550:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Pull = GPIO_PULLDOWN;
 8002552:	2302      	movs	r3, #2
 8002554:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8002556:	2303      	movs	r3, #3
 8002558:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Alternate = GPIO_AF6_SAI1;
 800255a:	2306      	movs	r3, #6
 800255c:	627b      	str	r3, [r7, #36]	@ 0x24
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 800255e:	f107 0314 	add.w	r3, r7, #20
 8002562:	4619      	mov	r1, r3
 8002564:	4822      	ldr	r0, [pc, #136]	@ (80025f0 <HAL_SAI_MspInit+0x1b4>)
 8002566:	f003 ffeb 	bl	8006540 <HAL_GPIO_Init>

      /* Peripheral DMA init*/

    hdma_sai1_b.Instance = DMA1_Stream1;
 800256a:	4b25      	ldr	r3, [pc, #148]	@ (8002600 <HAL_SAI_MspInit+0x1c4>)
 800256c:	4a25      	ldr	r2, [pc, #148]	@ (8002604 <HAL_SAI_MspInit+0x1c8>)
 800256e:	601a      	str	r2, [r3, #0]
    hdma_sai1_b.Init.Request = DMA_REQUEST_SAI1_B;
 8002570:	4b23      	ldr	r3, [pc, #140]	@ (8002600 <HAL_SAI_MspInit+0x1c4>)
 8002572:	2258      	movs	r2, #88	@ 0x58
 8002574:	605a      	str	r2, [r3, #4]
    hdma_sai1_b.Init.Direction = DMA_PERIPH_TO_MEMORY;
 8002576:	4b22      	ldr	r3, [pc, #136]	@ (8002600 <HAL_SAI_MspInit+0x1c4>)
 8002578:	2200      	movs	r2, #0
 800257a:	609a      	str	r2, [r3, #8]
    hdma_sai1_b.Init.PeriphInc = DMA_PINC_DISABLE;
 800257c:	4b20      	ldr	r3, [pc, #128]	@ (8002600 <HAL_SAI_MspInit+0x1c4>)
 800257e:	2200      	movs	r2, #0
 8002580:	60da      	str	r2, [r3, #12]
    hdma_sai1_b.Init.MemInc = DMA_MINC_ENABLE;
 8002582:	4b1f      	ldr	r3, [pc, #124]	@ (8002600 <HAL_SAI_MspInit+0x1c4>)
 8002584:	f44f 6280 	mov.w	r2, #1024	@ 0x400
 8002588:	611a      	str	r2, [r3, #16]
    hdma_sai1_b.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
 800258a:	4b1d      	ldr	r3, [pc, #116]	@ (8002600 <HAL_SAI_MspInit+0x1c4>)
 800258c:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
 8002590:	615a      	str	r2, [r3, #20]
    hdma_sai1_b.Init.MemDataAlignment = DMA_MDATAALIGN_WORD;
 8002592:	4b1b      	ldr	r3, [pc, #108]	@ (8002600 <HAL_SAI_MspInit+0x1c4>)
 8002594:	f44f 4280 	mov.w	r2, #16384	@ 0x4000
 8002598:	619a      	str	r2, [r3, #24]
    hdma_sai1_b.Init.Mode = DMA_CIRCULAR;
 800259a:	4b19      	ldr	r3, [pc, #100]	@ (8002600 <HAL_SAI_MspInit+0x1c4>)
 800259c:	f44f 7280 	mov.w	r2, #256	@ 0x100
 80025a0:	61da      	str	r2, [r3, #28]
    hdma_sai1_b.Init.Priority = DMA_PRIORITY_VERY_HIGH;
 80025a2:	4b17      	ldr	r3, [pc, #92]	@ (8002600 <HAL_SAI_MspInit+0x1c4>)
 80025a4:	f44f 3240 	mov.w	r2, #196608	@ 0x30000
 80025a8:	621a      	str	r2, [r3, #32]
    hdma_sai1_b.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
 80025aa:	4b15      	ldr	r3, [pc, #84]	@ (8002600 <HAL_SAI_MspInit+0x1c4>)
 80025ac:	2200      	movs	r2, #0
 80025ae:	625a      	str	r2, [r3, #36]	@ 0x24
    if (HAL_DMA_Init(&hdma_sai1_b) != HAL_OK)
 80025b0:	4813      	ldr	r0, [pc, #76]	@ (8002600 <HAL_SAI_MspInit+0x1c4>)
 80025b2:	f001 fe3f 	bl	8004234 <HAL_DMA_Init>
 80025b6:	4603      	mov	r3, r0
 80025b8:	2b00      	cmp	r3, #0
 80025ba:	d001      	beq.n	80025c0 <HAL_SAI_MspInit+0x184>
    {
      Error_Handler();
 80025bc:	f7ff fc48 	bl	8001e50 <Error_Handler>
    }

    /* Several peripheral DMA handle pointers point to the same DMA handle.
     Be aware that there is only one channel to perform all the requested DMAs. */
    __HAL_LINKDMA(hsai,hdmarx,hdma_sai1_b);
 80025c0:	687b      	ldr	r3, [r7, #4]
 80025c2:	4a0f      	ldr	r2, [pc, #60]	@ (8002600 <HAL_SAI_MspInit+0x1c4>)
 80025c4:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
 80025c8:	4a0d      	ldr	r2, [pc, #52]	@ (8002600 <HAL_SAI_MspInit+0x1c4>)
 80025ca:	687b      	ldr	r3, [r7, #4]
 80025cc:	6393      	str	r3, [r2, #56]	@ 0x38
    __HAL_LINKDMA(hsai,hdmatx,hdma_sai1_b);
 80025ce:	687b      	ldr	r3, [r7, #4]
 80025d0:	4a0b      	ldr	r2, [pc, #44]	@ (8002600 <HAL_SAI_MspInit+0x1c4>)
 80025d2:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
 80025d6:	4a0a      	ldr	r2, [pc, #40]	@ (8002600 <HAL_SAI_MspInit+0x1c4>)
 80025d8:	687b      	ldr	r3, [r7, #4]
 80025da:	6393      	str	r3, [r2, #56]	@ 0x38
    }
}
 80025dc:	bf00      	nop
 80025de:	3728      	adds	r7, #40	@ 0x28
 80025e0:	46bd      	mov	sp, r7
 80025e2:	bd80      	pop	{r7, pc}
 80025e4:	40015804 	.word	0x40015804
 80025e8:	240007c4 	.word	0x240007c4
 80025ec:	58024400 	.word	0x58024400
 80025f0:	58021000 	.word	0x58021000
 80025f4:	240005dc 	.word	0x240005dc
 80025f8:	40020010 	.word	0x40020010
 80025fc:	40015824 	.word	0x40015824
 8002600:	24000654 	.word	0x24000654
 8002604:	40020028 	.word	0x40020028

08002608 <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
 8002608:	b480      	push	{r7}
 800260a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
  while (1)
 800260c:	bf00      	nop
 800260e:	e7fd      	b.n	800260c <NMI_Handler+0x4>

08002610 <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
 8002610:	b480      	push	{r7}
 8002612:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 8002614:	bf00      	nop
 8002616:	e7fd      	b.n	8002614 <HardFault_Handler+0x4>

08002618 <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
 8002618:	b480      	push	{r7}
 800261a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
 800261c:	bf00      	nop
 800261e:	e7fd      	b.n	800261c <MemManage_Handler+0x4>

08002620 <BusFault_Handler>:

/**
  * @brief This function handles Pre-fetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
 8002620:	b480      	push	{r7}
 8002622:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
 8002624:	bf00      	nop
 8002626:	e7fd      	b.n	8002624 <BusFault_Handler+0x4>

08002628 <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
 8002628:	b480      	push	{r7}
 800262a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
 800262c:	bf00      	nop
 800262e:	e7fd      	b.n	800262c <UsageFault_Handler+0x4>

08002630 <SVC_Handler>:

/**
  * @brief This function handles System service call via SWI instruction.
  */
void SVC_Handler(void)
{
 8002630:	b480      	push	{r7}
 8002632:	af00      	add	r7, sp, #0

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
 8002634:	bf00      	nop
 8002636:	46bd      	mov	sp, r7
 8002638:	f85d 7b04 	ldr.w	r7, [sp], #4
 800263c:	4770      	bx	lr

0800263e <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
{
 800263e:	b480      	push	{r7}
 8002640:	af00      	add	r7, sp, #0

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
 8002642:	bf00      	nop
 8002644:	46bd      	mov	sp, r7
 8002646:	f85d 7b04 	ldr.w	r7, [sp], #4
 800264a:	4770      	bx	lr

0800264c <PendSV_Handler>:

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
{
 800264c:	b480      	push	{r7}
 800264e:	af00      	add	r7, sp, #0

  /* USER CODE END PendSV_IRQn 0 */
  /* USER CODE BEGIN PendSV_IRQn 1 */

  /* USER CODE END PendSV_IRQn 1 */
}
 8002650:	bf00      	nop
 8002652:	46bd      	mov	sp, r7
 8002654:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002658:	4770      	bx	lr

0800265a <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
 800265a:	b580      	push	{r7, lr}
 800265c:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 800265e:	f000 f96b 	bl	8002938 <HAL_IncTick>
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
 8002662:	bf00      	nop
 8002664:	bd80      	pop	{r7, pc}

08002666 <EXTI4_IRQHandler>:

/**
  * @brief This function handles EXTI line4 interrupt.
  */
void EXTI4_IRQHandler(void)
{
 8002666:	b580      	push	{r7, lr}
 8002668:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN EXTI4_IRQn 0 */

  /* USER CODE END EXTI4_IRQn 0 */
  HAL_GPIO_EXTI_IRQHandler(FX2_EN_Pin);
 800266a:	2010      	movs	r0, #16
 800266c:	f004 f949 	bl	8006902 <HAL_GPIO_EXTI_IRQHandler>
  /* USER CODE BEGIN EXTI4_IRQn 1 */

  /* USER CODE END EXTI4_IRQn 1 */
}
 8002670:	bf00      	nop
 8002672:	bd80      	pop	{r7, pc}

08002674 <DMA1_Stream0_IRQHandler>:

/**
  * @brief This function handles DMA1 stream0 global interrupt.
  */
void DMA1_Stream0_IRQHandler(void)
{
 8002674:	b580      	push	{r7, lr}
 8002676:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN DMA1_Stream0_IRQn 0 */

  /* USER CODE END DMA1_Stream0_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_sai1_a);
 8002678:	4802      	ldr	r0, [pc, #8]	@ (8002684 <DMA1_Stream0_IRQHandler+0x10>)
 800267a:	f002 fbd3 	bl	8004e24 <HAL_DMA_IRQHandler>
  /* USER CODE BEGIN DMA1_Stream0_IRQn 1 */

  /* USER CODE END DMA1_Stream0_IRQn 1 */
}
 800267e:	bf00      	nop
 8002680:	bd80      	pop	{r7, pc}
 8002682:	bf00      	nop
 8002684:	240005dc 	.word	0x240005dc

08002688 <DMA1_Stream1_IRQHandler>:

/**
  * @brief This function handles DMA1 stream1 global interrupt.
  */
void DMA1_Stream1_IRQHandler(void)
{
 8002688:	b580      	push	{r7, lr}
 800268a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN DMA1_Stream1_IRQn 0 */

  /* USER CODE END DMA1_Stream1_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_sai1_b);
 800268c:	4802      	ldr	r0, [pc, #8]	@ (8002698 <DMA1_Stream1_IRQHandler+0x10>)
 800268e:	f002 fbc9 	bl	8004e24 <HAL_DMA_IRQHandler>
  /* USER CODE BEGIN DMA1_Stream1_IRQn 1 */

  /* USER CODE END DMA1_Stream1_IRQn 1 */
}
 8002692:	bf00      	nop
 8002694:	bd80      	pop	{r7, pc}
 8002696:	bf00      	nop
 8002698:	24000654 	.word	0x24000654

0800269c <EXTI9_5_IRQHandler>:

/**
  * @brief This function handles EXTI line[9:5] interrupts.
  */
void EXTI9_5_IRQHandler(void)
{
 800269c:	b580      	push	{r7, lr}
 800269e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN EXTI9_5_IRQn 0 */

  /* USER CODE END EXTI9_5_IRQn 0 */
  HAL_GPIO_EXTI_IRQHandler(FX1_EN_Pin);
 80026a0:	2040      	movs	r0, #64	@ 0x40
 80026a2:	f004 f92e 	bl	8006902 <HAL_GPIO_EXTI_IRQHandler>
  /* USER CODE BEGIN EXTI9_5_IRQn 1 */

  /* USER CODE END EXTI9_5_IRQn 1 */
}
 80026a6:	bf00      	nop
 80026a8:	bd80      	pop	{r7, pc}
	...

080026ac <TIM3_IRQHandler>:

/**
  * @brief This function handles TIM3 global interrupt.
  */
void TIM3_IRQHandler(void)
{
 80026ac:	b580      	push	{r7, lr}
 80026ae:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN TIM3_IRQn 0 */

  /* USER CODE END TIM3_IRQn 0 */
  HAL_TIM_IRQHandler(&htim3);
 80026b0:	4802      	ldr	r0, [pc, #8]	@ (80026bc <TIM3_IRQHandler+0x10>)
 80026b2:	f00b fccf 	bl	800e054 <HAL_TIM_IRQHandler>
  /* USER CODE BEGIN TIM3_IRQn 1 */

  /* USER CODE END TIM3_IRQn 1 */
}
 80026b6:	bf00      	nop
 80026b8:	bd80      	pop	{r7, pc}
 80026ba:	bf00      	nop
 80026bc:	24000718 	.word	0x24000718

080026c0 <DMA2_Stream0_IRQHandler>:

/**
  * @brief This function handles DMA2 stream0 global interrupt.
  */
void DMA2_Stream0_IRQHandler(void)
{
 80026c0:	b580      	push	{r7, lr}
 80026c2:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN DMA2_Stream0_IRQn 0 */

  /* USER CODE END DMA2_Stream0_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_adc1);
 80026c4:	4802      	ldr	r0, [pc, #8]	@ (80026d0 <DMA2_Stream0_IRQHandler+0x10>)
 80026c6:	f002 fbad 	bl	8004e24 <HAL_DMA_IRQHandler>
  /* USER CODE BEGIN DMA2_Stream0_IRQn 1 */

  /* USER CODE END DMA2_Stream0_IRQn 1 */
}
 80026ca:	bf00      	nop
 80026cc:	bd80      	pop	{r7, pc}
 80026ce:	bf00      	nop
 80026d0:	24000384 	.word	0x24000384

080026d4 <OTG_HS_EP1_OUT_IRQHandler>:

/**
  * @brief This function handles USB On The Go HS End Point 1 Out global interrupt.
  */
void OTG_HS_EP1_OUT_IRQHandler(void)
{
 80026d4:	b580      	push	{r7, lr}
 80026d6:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN OTG_HS_EP1_OUT_IRQn 0 */

  /* USER CODE END OTG_HS_EP1_OUT_IRQn 0 */
  HAL_PCD_IRQHandler(&hpcd_USB_OTG_HS);
 80026d8:	4802      	ldr	r0, [pc, #8]	@ (80026e4 <OTG_HS_EP1_OUT_IRQHandler+0x10>)
 80026da:	f005 ff38 	bl	800854e <HAL_PCD_IRQHandler>
  /* USER CODE BEGIN OTG_HS_EP1_OUT_IRQn 1 */

  /* USER CODE END OTG_HS_EP1_OUT_IRQn 1 */
}
 80026de:	bf00      	nop
 80026e0:	bd80      	pop	{r7, pc}
 80026e2:	bf00      	nop
 80026e4:	24000cac 	.word	0x24000cac

080026e8 <OTG_HS_EP1_IN_IRQHandler>:

/**
  * @brief This function handles USB On The Go HS End Point 1 In global interrupt.
  */
void OTG_HS_EP1_IN_IRQHandler(void)
{
 80026e8:	b580      	push	{r7, lr}
 80026ea:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN OTG_HS_EP1_IN_IRQn 0 */

  /* USER CODE END OTG_HS_EP1_IN_IRQn 0 */
  HAL_PCD_IRQHandler(&hpcd_USB_OTG_HS);
 80026ec:	4802      	ldr	r0, [pc, #8]	@ (80026f8 <OTG_HS_EP1_IN_IRQHandler+0x10>)
 80026ee:	f005 ff2e 	bl	800854e <HAL_PCD_IRQHandler>
  /* USER CODE BEGIN OTG_HS_EP1_IN_IRQn 1 */

  /* USER CODE END OTG_HS_EP1_IN_IRQn 1 */
}
 80026f2:	bf00      	nop
 80026f4:	bd80      	pop	{r7, pc}
 80026f6:	bf00      	nop
 80026f8:	24000cac 	.word	0x24000cac

080026fc <OTG_HS_IRQHandler>:

/**
  * @brief This function handles USB On The Go HS global interrupt.
  */
void OTG_HS_IRQHandler(void)
{
 80026fc:	b580      	push	{r7, lr}
 80026fe:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN OTG_HS_IRQn 0 */

  /* USER CODE END OTG_HS_IRQn 0 */
  HAL_PCD_IRQHandler(&hpcd_USB_OTG_HS);
 8002700:	4802      	ldr	r0, [pc, #8]	@ (800270c <OTG_HS_IRQHandler+0x10>)
 8002702:	f005 ff24 	bl	800854e <HAL_PCD_IRQHandler>
  /* USER CODE BEGIN OTG_HS_IRQn 1 */

  /* USER CODE END OTG_HS_IRQn 1 */
}
 8002706:	bf00      	nop
 8002708:	bd80      	pop	{r7, pc}
 800270a:	bf00      	nop
 800270c:	24000cac 	.word	0x24000cac

08002710 <SystemInit>:
  *         configuration.
  * @param  None
  * @retval None
  */
void SystemInit (void)
{
 8002710:	b480      	push	{r7}
 8002712:	af00      	add	r7, sp, #0
 __IO uint32_t tmpreg;
#endif /* DATA_IN_D2_SRAM */

  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << (10*2))|(3UL << (11*2)));  /* set CP10 and CP11 Full Access */
 8002714:	4b32      	ldr	r3, [pc, #200]	@ (80027e0 <SystemInit+0xd0>)
 8002716:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 800271a:	4a31      	ldr	r2, [pc, #196]	@ (80027e0 <SystemInit+0xd0>)
 800271c:	f443 0370 	orr.w	r3, r3, #15728640	@ 0xf00000
 8002720:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/

   /* Increasing the CPU frequency */
  if(FLASH_LATENCY_DEFAULT  > (READ_BIT((FLASH->ACR), FLASH_ACR_LATENCY)))
 8002724:	4b2f      	ldr	r3, [pc, #188]	@ (80027e4 <SystemInit+0xd4>)
 8002726:	681b      	ldr	r3, [r3, #0]
 8002728:	f003 030f 	and.w	r3, r3, #15
 800272c:	2b02      	cmp	r3, #2
 800272e:	d807      	bhi.n	8002740 <SystemInit+0x30>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    MODIFY_REG(FLASH->ACR, FLASH_ACR_LATENCY, (uint32_t)(FLASH_LATENCY_DEFAULT));
 8002730:	4b2c      	ldr	r3, [pc, #176]	@ (80027e4 <SystemInit+0xd4>)
 8002732:	681b      	ldr	r3, [r3, #0]
 8002734:	f023 030f 	bic.w	r3, r3, #15
 8002738:	4a2a      	ldr	r2, [pc, #168]	@ (80027e4 <SystemInit+0xd4>)
 800273a:	f043 0303 	orr.w	r3, r3, #3
 800273e:	6013      	str	r3, [r2, #0]
  }

  /* Set HSION bit */
  RCC->CR |= RCC_CR_HSION;
 8002740:	4b29      	ldr	r3, [pc, #164]	@ (80027e8 <SystemInit+0xd8>)
 8002742:	681b      	ldr	r3, [r3, #0]
 8002744:	4a28      	ldr	r2, [pc, #160]	@ (80027e8 <SystemInit+0xd8>)
 8002746:	f043 0301 	orr.w	r3, r3, #1
 800274a:	6013      	str	r3, [r2, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 800274c:	4b26      	ldr	r3, [pc, #152]	@ (80027e8 <SystemInit+0xd8>)
 800274e:	2200      	movs	r2, #0
 8002750:	611a      	str	r2, [r3, #16]

  /* Reset HSEON, HSECSSON, CSION, HSI48ON, CSIKERON, PLL1ON, PLL2ON and PLL3ON bits */
  RCC->CR &= 0xEAF6ED7FU;
 8002752:	4b25      	ldr	r3, [pc, #148]	@ (80027e8 <SystemInit+0xd8>)
 8002754:	681a      	ldr	r2, [r3, #0]
 8002756:	4924      	ldr	r1, [pc, #144]	@ (80027e8 <SystemInit+0xd8>)
 8002758:	4b24      	ldr	r3, [pc, #144]	@ (80027ec <SystemInit+0xdc>)
 800275a:	4013      	ands	r3, r2
 800275c:	600b      	str	r3, [r1, #0]

   /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLASH_LATENCY_DEFAULT  < (READ_BIT((FLASH->ACR), FLASH_ACR_LATENCY)))
 800275e:	4b21      	ldr	r3, [pc, #132]	@ (80027e4 <SystemInit+0xd4>)
 8002760:	681b      	ldr	r3, [r3, #0]
 8002762:	f003 030c 	and.w	r3, r3, #12
 8002766:	2b00      	cmp	r3, #0
 8002768:	d007      	beq.n	800277a <SystemInit+0x6a>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    MODIFY_REG(FLASH->ACR, FLASH_ACR_LATENCY, (uint32_t)(FLASH_LATENCY_DEFAULT));
 800276a:	4b1e      	ldr	r3, [pc, #120]	@ (80027e4 <SystemInit+0xd4>)
 800276c:	681b      	ldr	r3, [r3, #0]
 800276e:	f023 030f 	bic.w	r3, r3, #15
 8002772:	4a1c      	ldr	r2, [pc, #112]	@ (80027e4 <SystemInit+0xd4>)
 8002774:	f043 0303 	orr.w	r3, r3, #3
 8002778:	6013      	str	r3, [r2, #0]

  /* Reset D3CFGR register */
  RCC->D3CFGR = 0x00000000;
#else
  /* Reset CDCFGR1 register */
  RCC->CDCFGR1 = 0x00000000;
 800277a:	4b1b      	ldr	r3, [pc, #108]	@ (80027e8 <SystemInit+0xd8>)
 800277c:	2200      	movs	r2, #0
 800277e:	619a      	str	r2, [r3, #24]

  /* Reset CDCFGR2 register */
  RCC->CDCFGR2 = 0x00000000;
 8002780:	4b19      	ldr	r3, [pc, #100]	@ (80027e8 <SystemInit+0xd8>)
 8002782:	2200      	movs	r2, #0
 8002784:	61da      	str	r2, [r3, #28]

  /* Reset SRDCFGR register */
  RCC->SRDCFGR = 0x00000000;
 8002786:	4b18      	ldr	r3, [pc, #96]	@ (80027e8 <SystemInit+0xd8>)
 8002788:	2200      	movs	r2, #0
 800278a:	621a      	str	r2, [r3, #32]
#endif
  /* Reset PLLCKSELR register */
  RCC->PLLCKSELR = 0x02020200;
 800278c:	4b16      	ldr	r3, [pc, #88]	@ (80027e8 <SystemInit+0xd8>)
 800278e:	4a18      	ldr	r2, [pc, #96]	@ (80027f0 <SystemInit+0xe0>)
 8002790:	629a      	str	r2, [r3, #40]	@ 0x28

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x01FF0000;
 8002792:	4b15      	ldr	r3, [pc, #84]	@ (80027e8 <SystemInit+0xd8>)
 8002794:	4a17      	ldr	r2, [pc, #92]	@ (80027f4 <SystemInit+0xe4>)
 8002796:	62da      	str	r2, [r3, #44]	@ 0x2c
  /* Reset PLL1DIVR register */
  RCC->PLL1DIVR = 0x01010280;
 8002798:	4b13      	ldr	r3, [pc, #76]	@ (80027e8 <SystemInit+0xd8>)
 800279a:	4a17      	ldr	r2, [pc, #92]	@ (80027f8 <SystemInit+0xe8>)
 800279c:	631a      	str	r2, [r3, #48]	@ 0x30
  /* Reset PLL1FRACR register */
  RCC->PLL1FRACR = 0x00000000;
 800279e:	4b12      	ldr	r3, [pc, #72]	@ (80027e8 <SystemInit+0xd8>)
 80027a0:	2200      	movs	r2, #0
 80027a2:	635a      	str	r2, [r3, #52]	@ 0x34

  /* Reset PLL2DIVR register */
  RCC->PLL2DIVR = 0x01010280;
 80027a4:	4b10      	ldr	r3, [pc, #64]	@ (80027e8 <SystemInit+0xd8>)
 80027a6:	4a14      	ldr	r2, [pc, #80]	@ (80027f8 <SystemInit+0xe8>)
 80027a8:	639a      	str	r2, [r3, #56]	@ 0x38

  /* Reset PLL2FRACR register */

  RCC->PLL2FRACR = 0x00000000;
 80027aa:	4b0f      	ldr	r3, [pc, #60]	@ (80027e8 <SystemInit+0xd8>)
 80027ac:	2200      	movs	r2, #0
 80027ae:	63da      	str	r2, [r3, #60]	@ 0x3c
  /* Reset PLL3DIVR register */
  RCC->PLL3DIVR = 0x01010280;
 80027b0:	4b0d      	ldr	r3, [pc, #52]	@ (80027e8 <SystemInit+0xd8>)
 80027b2:	4a11      	ldr	r2, [pc, #68]	@ (80027f8 <SystemInit+0xe8>)
 80027b4:	641a      	str	r2, [r3, #64]	@ 0x40

  /* Reset PLL3FRACR register */
  RCC->PLL3FRACR = 0x00000000;
 80027b6:	4b0c      	ldr	r3, [pc, #48]	@ (80027e8 <SystemInit+0xd8>)
 80027b8:	2200      	movs	r2, #0
 80027ba:	645a      	str	r2, [r3, #68]	@ 0x44

  /* Reset HSEBYP bit */
  RCC->CR &= 0xFFFBFFFFU;
 80027bc:	4b0a      	ldr	r3, [pc, #40]	@ (80027e8 <SystemInit+0xd8>)
 80027be:	681b      	ldr	r3, [r3, #0]
 80027c0:	4a09      	ldr	r2, [pc, #36]	@ (80027e8 <SystemInit+0xd8>)
 80027c2:	f423 2380 	bic.w	r3, r3, #262144	@ 0x40000
 80027c6:	6013      	str	r3, [r2, #0]

  /* Disable all interrupts */
  RCC->CIER = 0x00000000;
 80027c8:	4b07      	ldr	r3, [pc, #28]	@ (80027e8 <SystemInit+0xd8>)
 80027ca:	2200      	movs	r2, #0
 80027cc:	661a      	str	r2, [r3, #96]	@ 0x60
  /*
   * Disable the FMC bank1 (enabled after reset).
   * This, prevents CPU speculation access on this bank which blocks the use of FMC during
   * 24us. During this time the others FMC master (such as LTDC) cannot use it!
   */
  FMC_Bank1_R->BTCR[0] = 0x000030D2;
 80027ce:	4b0b      	ldr	r3, [pc, #44]	@ (80027fc <SystemInit+0xec>)
 80027d0:	f243 02d2 	movw	r2, #12498	@ 0x30d2
 80027d4:	601a      	str	r2, [r3, #0]
#if defined(USER_VECT_TAB_ADDRESS)
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal D1 AXI-RAM or in Internal FLASH */
#endif /* USER_VECT_TAB_ADDRESS */

#endif /*DUAL_CORE && CORE_CM4*/
}
 80027d6:	bf00      	nop
 80027d8:	46bd      	mov	sp, r7
 80027da:	f85d 7b04 	ldr.w	r7, [sp], #4
 80027de:	4770      	bx	lr
 80027e0:	e000ed00 	.word	0xe000ed00
 80027e4:	52002000 	.word	0x52002000
 80027e8:	58024400 	.word	0x58024400
 80027ec:	eaf6ed7f 	.word	0xeaf6ed7f
 80027f0:	02020200 	.word	0x02020200
 80027f4:	01ff0000 	.word	0x01ff0000
 80027f8:	01010280 	.word	0x01010280
 80027fc:	52004000 	.word	0x52004000

08002800 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack      /* set stack pointer */
 8002800:	f8df d034 	ldr.w	sp, [pc, #52]	@ 8002838 <LoopFillZerobss+0xe>
  
/* Call the clock system initialization function.*/
  bl  SystemInit
 8002804:	f7ff ff84 	bl	8002710 <SystemInit>
  
/* Copy the data segment initializers from flash to SRAM */  
  ldr r0, =_sdata
 8002808:	480c      	ldr	r0, [pc, #48]	@ (800283c <LoopFillZerobss+0x12>)
  ldr r1, =_edata
 800280a:	490d      	ldr	r1, [pc, #52]	@ (8002840 <LoopFillZerobss+0x16>)
  ldr r2, =_sidata
 800280c:	4a0d      	ldr	r2, [pc, #52]	@ (8002844 <LoopFillZerobss+0x1a>)
  movs r3, #0
 800280e:	2300      	movs	r3, #0
  b LoopCopyDataInit
 8002810:	e002      	b.n	8002818 <LoopCopyDataInit>

08002812 <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 8002812:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 8002814:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 8002816:	3304      	adds	r3, #4

08002818 <LoopCopyDataInit>:
    
LoopCopyDataInit:
  adds r4, r0, r3
 8002818:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 800281a:	428c      	cmp	r4, r1
  bcc CopyDataInit
 800281c:	d3f9      	bcc.n	8002812 <CopyDataInit>
/* Zero fill the bss segment. */
  ldr r2, =_sbss
 800281e:	4a0a      	ldr	r2, [pc, #40]	@ (8002848 <LoopFillZerobss+0x1e>)
  ldr r4, =_ebss
 8002820:	4c0a      	ldr	r4, [pc, #40]	@ (800284c <LoopFillZerobss+0x22>)
  movs r3, #0
 8002822:	2300      	movs	r3, #0
  b LoopFillZerobss
 8002824:	e001      	b.n	800282a <LoopFillZerobss>

08002826 <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 8002826:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 8002828:	3204      	adds	r2, #4

0800282a <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 800282a:	42a2      	cmp	r2, r4
  bcc FillZerobss
 800282c:	d3fb      	bcc.n	8002826 <FillZerobss>
  
/* Call static constructors */
    bl __libc_init_array
 800282e:	f010 fbcb 	bl	8012fc8 <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 8002832:	f7fe fad7 	bl	8000de4 <main>
  bx  lr
 8002836:	4770      	bx	lr
  ldr   sp, =_estack      /* set stack pointer */
 8002838:	24100000 	.word	0x24100000
  ldr r0, =_sdata
 800283c:	24000000 	.word	0x24000000
  ldr r1, =_edata
 8002840:	240002a0 	.word	0x240002a0
  ldr r2, =_sidata
 8002844:	08013310 	.word	0x08013310
  ldr r2, =_sbss
 8002848:	240002a0 	.word	0x240002a0
  ldr r4, =_ebss
 800284c:	24004a1c 	.word	0x24004a1c

08002850 <ADC_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 8002850:	e7fe      	b.n	8002850 <ADC_IRQHandler>
	...

08002854 <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 8002854:	b580      	push	{r7, lr}
 8002856:	b082      	sub	sp, #8
 8002858:	af00      	add	r7, sp, #0
   __HAL_ART_CONFIG_BASE_ADDRESS(0x08100000UL);  /* Configure the Cortex-M4 ART Base address to the Flash Bank 2 : */
   __HAL_ART_ENABLE();                           /* Enable the Cortex-M4 ART */
#endif /* DUAL_CORE &&  CORE_CM4 */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 800285a:	2003      	movs	r0, #3
 800285c:	f001 fc32 	bl	80040c4 <HAL_NVIC_SetPriorityGrouping>

  /* Update the SystemCoreClock global variable */
#if defined(RCC_D1CFGR_D1CPRE)
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
#else
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_CDCPRE)>> RCC_CDCFGR1_CDCPRE_Pos]) & 0x1FU);
 8002860:	f007 fe04 	bl	800a46c <HAL_RCC_GetSysClockFreq>
 8002864:	4602      	mov	r2, r0
 8002866:	4b15      	ldr	r3, [pc, #84]	@ (80028bc <HAL_Init+0x68>)
 8002868:	699b      	ldr	r3, [r3, #24]
 800286a:	0a1b      	lsrs	r3, r3, #8
 800286c:	f003 030f 	and.w	r3, r3, #15
 8002870:	4913      	ldr	r1, [pc, #76]	@ (80028c0 <HAL_Init+0x6c>)
 8002872:	5ccb      	ldrb	r3, [r1, r3]
 8002874:	f003 031f 	and.w	r3, r3, #31
 8002878:	fa22 f303 	lsr.w	r3, r2, r3
 800287c:	607b      	str	r3, [r7, #4]

  /* Update the SystemD2Clock global variable */
#if defined(RCC_D1CFGR_HPRE)
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
#else
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_HPRE)>> RCC_CDCFGR1_HPRE_Pos]) & 0x1FU));
 800287e:	4b0f      	ldr	r3, [pc, #60]	@ (80028bc <HAL_Init+0x68>)
 8002880:	699b      	ldr	r3, [r3, #24]
 8002882:	f003 030f 	and.w	r3, r3, #15
 8002886:	4a0e      	ldr	r2, [pc, #56]	@ (80028c0 <HAL_Init+0x6c>)
 8002888:	5cd3      	ldrb	r3, [r2, r3]
 800288a:	f003 031f 	and.w	r3, r3, #31
 800288e:	687a      	ldr	r2, [r7, #4]
 8002890:	fa22 f303 	lsr.w	r3, r2, r3
 8002894:	4a0b      	ldr	r2, [pc, #44]	@ (80028c4 <HAL_Init+0x70>)
 8002896:	6013      	str	r3, [r2, #0]
#endif

#if defined(DUAL_CORE) && defined(CORE_CM4)
  SystemCoreClock = SystemD2Clock;
#else
  SystemCoreClock = common_system_clock;
 8002898:	4a0b      	ldr	r2, [pc, #44]	@ (80028c8 <HAL_Init+0x74>)
 800289a:	687b      	ldr	r3, [r7, #4]
 800289c:	6013      	str	r3, [r2, #0]
#endif /* DUAL_CORE && CORE_CM4 */

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  if(HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 800289e:	200f      	movs	r0, #15
 80028a0:	f000 f814 	bl	80028cc <HAL_InitTick>
 80028a4:	4603      	mov	r3, r0
 80028a6:	2b00      	cmp	r3, #0
 80028a8:	d001      	beq.n	80028ae <HAL_Init+0x5a>
  {
    return HAL_ERROR;
 80028aa:	2301      	movs	r3, #1
 80028ac:	e002      	b.n	80028b4 <HAL_Init+0x60>
  }

  /* Init the low level hardware */
  HAL_MspInit();
 80028ae:	f7ff fad5 	bl	8001e5c <HAL_MspInit>

  /* Return function status */
  return HAL_OK;
 80028b2:	2300      	movs	r3, #0
}
 80028b4:	4618      	mov	r0, r3
 80028b6:	3708      	adds	r7, #8
 80028b8:	46bd      	mov	sp, r7
 80028ba:	bd80      	pop	{r7, pc}
 80028bc:	58024400 	.word	0x58024400
 80028c0:	080131a4 	.word	0x080131a4
 80028c4:	24000120 	.word	0x24000120
 80028c8:	2400011c 	.word	0x2400011c

080028cc <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 80028cc:	b580      	push	{r7, lr}
 80028ce:	b082      	sub	sp, #8
 80028d0:	af00      	add	r7, sp, #0
 80028d2:	6078      	str	r0, [r7, #4]
  /* Check uwTickFreq for MisraC 2012 (even if uwTickFreq is a enum type that don't take the value zero)*/
  if((uint32_t)uwTickFreq == 0UL)
 80028d4:	4b15      	ldr	r3, [pc, #84]	@ (800292c <HAL_InitTick+0x60>)
 80028d6:	781b      	ldrb	r3, [r3, #0]
 80028d8:	2b00      	cmp	r3, #0
 80028da:	d101      	bne.n	80028e0 <HAL_InitTick+0x14>
  {
    return HAL_ERROR;
 80028dc:	2301      	movs	r3, #1
 80028de:	e021      	b.n	8002924 <HAL_InitTick+0x58>
  }

    /* Configure the SysTick to have interrupt in 1ms time basis*/
    if (HAL_SYSTICK_Config(SystemCoreClock / (1000UL / (uint32_t)uwTickFreq)) > 0U)
 80028e0:	4b13      	ldr	r3, [pc, #76]	@ (8002930 <HAL_InitTick+0x64>)
 80028e2:	681a      	ldr	r2, [r3, #0]
 80028e4:	4b11      	ldr	r3, [pc, #68]	@ (800292c <HAL_InitTick+0x60>)
 80028e6:	781b      	ldrb	r3, [r3, #0]
 80028e8:	4619      	mov	r1, r3
 80028ea:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
 80028ee:	fbb3 f3f1 	udiv	r3, r3, r1
 80028f2:	fbb2 f3f3 	udiv	r3, r2, r3
 80028f6:	4618      	mov	r0, r3
 80028f8:	f001 fc17 	bl	800412a <HAL_SYSTICK_Config>
 80028fc:	4603      	mov	r3, r0
 80028fe:	2b00      	cmp	r3, #0
 8002900:	d001      	beq.n	8002906 <HAL_InitTick+0x3a>
    {
      return HAL_ERROR;
 8002902:	2301      	movs	r3, #1
 8002904:	e00e      	b.n	8002924 <HAL_InitTick+0x58>
    }

  /* Configure the SysTick IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 8002906:	687b      	ldr	r3, [r7, #4]
 8002908:	2b0f      	cmp	r3, #15
 800290a:	d80a      	bhi.n	8002922 <HAL_InitTick+0x56>
  {
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 800290c:	2200      	movs	r2, #0
 800290e:	6879      	ldr	r1, [r7, #4]
 8002910:	f04f 30ff 	mov.w	r0, #4294967295
 8002914:	f001 fbe1 	bl	80040da <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
 8002918:	4a06      	ldr	r2, [pc, #24]	@ (8002934 <HAL_InitTick+0x68>)
 800291a:	687b      	ldr	r3, [r7, #4]
 800291c:	6013      	str	r3, [r2, #0]
  {
    return HAL_ERROR;
  }

  /* Return function status */
  return HAL_OK;
 800291e:	2300      	movs	r3, #0
 8002920:	e000      	b.n	8002924 <HAL_InitTick+0x58>
    return HAL_ERROR;
 8002922:	2301      	movs	r3, #1
}
 8002924:	4618      	mov	r0, r3
 8002926:	3708      	adds	r7, #8
 8002928:	46bd      	mov	sp, r7
 800292a:	bd80      	pop	{r7, pc}
 800292c:	24000128 	.word	0x24000128
 8002930:	2400011c 	.word	0x2400011c
 8002934:	24000124 	.word	0x24000124

08002938 <HAL_IncTick>:
 * @note This function is declared as __weak to be overwritten in case of other
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
 8002938:	b480      	push	{r7}
 800293a:	af00      	add	r7, sp, #0
  uwTick += (uint32_t)uwTickFreq;
 800293c:	4b06      	ldr	r3, [pc, #24]	@ (8002958 <HAL_IncTick+0x20>)
 800293e:	781b      	ldrb	r3, [r3, #0]
 8002940:	461a      	mov	r2, r3
 8002942:	4b06      	ldr	r3, [pc, #24]	@ (800295c <HAL_IncTick+0x24>)
 8002944:	681b      	ldr	r3, [r3, #0]
 8002946:	4413      	add	r3, r2
 8002948:	4a04      	ldr	r2, [pc, #16]	@ (800295c <HAL_IncTick+0x24>)
 800294a:	6013      	str	r3, [r2, #0]
}
 800294c:	bf00      	nop
 800294e:	46bd      	mov	sp, r7
 8002950:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002954:	4770      	bx	lr
 8002956:	bf00      	nop
 8002958:	24000128 	.word	0x24000128
 800295c:	240007c8 	.word	0x240007c8

08002960 <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
 8002960:	b480      	push	{r7}
 8002962:	af00      	add	r7, sp, #0
  return uwTick;
 8002964:	4b03      	ldr	r3, [pc, #12]	@ (8002974 <HAL_GetTick+0x14>)
 8002966:	681b      	ldr	r3, [r3, #0]
}
 8002968:	4618      	mov	r0, r3
 800296a:	46bd      	mov	sp, r7
 800296c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002970:	4770      	bx	lr
 8002972:	bf00      	nop
 8002974:	240007c8 	.word	0x240007c8

08002978 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay  specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 8002978:	b580      	push	{r7, lr}
 800297a:	b084      	sub	sp, #16
 800297c:	af00      	add	r7, sp, #0
 800297e:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = HAL_GetTick();
 8002980:	f7ff ffee 	bl	8002960 <HAL_GetTick>
 8002984:	60b8      	str	r0, [r7, #8]
  uint32_t wait = Delay;
 8002986:	687b      	ldr	r3, [r7, #4]
 8002988:	60fb      	str	r3, [r7, #12]

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 800298a:	68fb      	ldr	r3, [r7, #12]
 800298c:	f1b3 3fff 	cmp.w	r3, #4294967295
 8002990:	d005      	beq.n	800299e <HAL_Delay+0x26>
  {
    wait += (uint32_t)(uwTickFreq);
 8002992:	4b0a      	ldr	r3, [pc, #40]	@ (80029bc <HAL_Delay+0x44>)
 8002994:	781b      	ldrb	r3, [r3, #0]
 8002996:	461a      	mov	r2, r3
 8002998:	68fb      	ldr	r3, [r7, #12]
 800299a:	4413      	add	r3, r2
 800299c:	60fb      	str	r3, [r7, #12]
  }

  while ((HAL_GetTick() - tickstart) < wait)
 800299e:	bf00      	nop
 80029a0:	f7ff ffde 	bl	8002960 <HAL_GetTick>
 80029a4:	4602      	mov	r2, r0
 80029a6:	68bb      	ldr	r3, [r7, #8]
 80029a8:	1ad3      	subs	r3, r2, r3
 80029aa:	68fa      	ldr	r2, [r7, #12]
 80029ac:	429a      	cmp	r2, r3
 80029ae:	d8f7      	bhi.n	80029a0 <HAL_Delay+0x28>
  {
  }
}
 80029b0:	bf00      	nop
 80029b2:	bf00      	nop
 80029b4:	3710      	adds	r7, #16
 80029b6:	46bd      	mov	sp, r7
 80029b8:	bd80      	pop	{r7, pc}
 80029ba:	bf00      	nop
 80029bc:	24000128 	.word	0x24000128

080029c0 <LL_ADC_SetCommonClock>:
  *         @arg @ref LL_ADC_CLOCK_ASYNC_DIV128
  *         @arg @ref LL_ADC_CLOCK_ASYNC_DIV256
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetCommonClock(ADC_Common_TypeDef *ADCxy_COMMON, uint32_t CommonClock)
{
 80029c0:	b480      	push	{r7}
 80029c2:	b083      	sub	sp, #12
 80029c4:	af00      	add	r7, sp, #0
 80029c6:	6078      	str	r0, [r7, #4]
 80029c8:	6039      	str	r1, [r7, #0]
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_CKMODE | ADC_CCR_PRESC, CommonClock);
 80029ca:	687b      	ldr	r3, [r7, #4]
 80029cc:	689b      	ldr	r3, [r3, #8]
 80029ce:	f423 127c 	bic.w	r2, r3, #4128768	@ 0x3f0000
 80029d2:	683b      	ldr	r3, [r7, #0]
 80029d4:	431a      	orrs	r2, r3
 80029d6:	687b      	ldr	r3, [r7, #4]
 80029d8:	609a      	str	r2, [r3, #8]
}
 80029da:	bf00      	nop
 80029dc:	370c      	adds	r7, #12
 80029de:	46bd      	mov	sp, r7
 80029e0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80029e4:	4770      	bx	lr

080029e6 <LL_ADC_SetCommonPathInternalCh>:
  *         @arg @ref LL_ADC_PATH_INTERNAL_TEMPSENSOR
  *         @arg @ref LL_ADC_PATH_INTERNAL_VBAT
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetCommonPathInternalCh(ADC_Common_TypeDef *ADCxy_COMMON, uint32_t PathInternal)
{
 80029e6:	b480      	push	{r7}
 80029e8:	b083      	sub	sp, #12
 80029ea:	af00      	add	r7, sp, #0
 80029ec:	6078      	str	r0, [r7, #4]
 80029ee:	6039      	str	r1, [r7, #0]
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN, PathInternal);
 80029f0:	687b      	ldr	r3, [r7, #4]
 80029f2:	689b      	ldr	r3, [r3, #8]
 80029f4:	f023 72e0 	bic.w	r2, r3, #29360128	@ 0x1c00000
 80029f8:	683b      	ldr	r3, [r7, #0]
 80029fa:	431a      	orrs	r2, r3
 80029fc:	687b      	ldr	r3, [r7, #4]
 80029fe:	609a      	str	r2, [r3, #8]
}
 8002a00:	bf00      	nop
 8002a02:	370c      	adds	r7, #12
 8002a04:	46bd      	mov	sp, r7
 8002a06:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002a0a:	4770      	bx	lr

08002a0c <LL_ADC_GetCommonPathInternalCh>:
  *         @arg @ref LL_ADC_PATH_INTERNAL_VREFINT
  *         @arg @ref LL_ADC_PATH_INTERNAL_TEMPSENSOR
  *         @arg @ref LL_ADC_PATH_INTERNAL_VBAT
  */
__STATIC_INLINE uint32_t LL_ADC_GetCommonPathInternalCh(ADC_Common_TypeDef *ADCxy_COMMON)
{
 8002a0c:	b480      	push	{r7}
 8002a0e:	b083      	sub	sp, #12
 8002a10:	af00      	add	r7, sp, #0
 8002a12:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN));
 8002a14:	687b      	ldr	r3, [r7, #4]
 8002a16:	689b      	ldr	r3, [r3, #8]
 8002a18:	f003 73e0 	and.w	r3, r3, #29360128	@ 0x1c00000
}
 8002a1c:	4618      	mov	r0, r3
 8002a1e:	370c      	adds	r7, #12
 8002a20:	46bd      	mov	sp, r7
 8002a22:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002a26:	4770      	bx	lr

08002a28 <LL_ADC_SetOffset>:
  *             Other channels are slow channels (conversion rate: refer to reference manual).
  * @param  OffsetLevel Value between Min_Data=0x000 and Max_Data=0x3FFFFFF
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetOffset(ADC_TypeDef *ADCx, uint32_t Offsety, uint32_t Channel, uint32_t OffsetLevel)
{
 8002a28:	b480      	push	{r7}
 8002a2a:	b087      	sub	sp, #28
 8002a2c:	af00      	add	r7, sp, #0
 8002a2e:	60f8      	str	r0, [r7, #12]
 8002a30:	60b9      	str	r1, [r7, #8]
 8002a32:	607a      	str	r2, [r7, #4]
 8002a34:	603b      	str	r3, [r7, #0]
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8002a36:	68fb      	ldr	r3, [r7, #12]
 8002a38:	3360      	adds	r3, #96	@ 0x60
 8002a3a:	461a      	mov	r2, r3
 8002a3c:	68bb      	ldr	r3, [r7, #8]
 8002a3e:	009b      	lsls	r3, r3, #2
 8002a40:	4413      	add	r3, r2
 8002a42:	617b      	str	r3, [r7, #20]
               ADC3_OFR1_OFFSET1_EN | (Channel & ADC_CHANNEL_ID_NUMBER_MASK) | OffsetLevel);
  }
  else
#endif /* ADC_VER_V5_V90 */
  {
    MODIFY_REG(*preg,
 8002a44:	697b      	ldr	r3, [r7, #20]
 8002a46:	681b      	ldr	r3, [r3, #0]
 8002a48:	f003 4200 	and.w	r2, r3, #2147483648	@ 0x80000000
 8002a4c:	687b      	ldr	r3, [r7, #4]
 8002a4e:	f003 41f8 	and.w	r1, r3, #2080374784	@ 0x7c000000
 8002a52:	683b      	ldr	r3, [r7, #0]
 8002a54:	430b      	orrs	r3, r1
 8002a56:	431a      	orrs	r2, r3
 8002a58:	697b      	ldr	r3, [r7, #20]
 8002a5a:	601a      	str	r2, [r3, #0]
               ADC_OFR1_OFFSET1_CH | ADC_OFR1_OFFSET1,
               (Channel & ADC_CHANNEL_ID_NUMBER_MASK) | OffsetLevel);
  }
}
 8002a5c:	bf00      	nop
 8002a5e:	371c      	adds	r7, #28
 8002a60:	46bd      	mov	sp, r7
 8002a62:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002a66:	4770      	bx	lr

08002a68 <LL_ADC_SetDataRightShift>:
  *         @arg @ref LL_ADC_OFFSET_RSHIFT_ENABLE
  *         @arg @ref LL_ADC_OFFSET_RSHIFT_DISABLE
  * @retval Returned None
  */
__STATIC_INLINE void LL_ADC_SetDataRightShift(ADC_TypeDef *ADCx, uint32_t Offsety, uint32_t RigthShift)
{
 8002a68:	b480      	push	{r7}
 8002a6a:	b085      	sub	sp, #20
 8002a6c:	af00      	add	r7, sp, #0
 8002a6e:	60f8      	str	r0, [r7, #12]
 8002a70:	60b9      	str	r1, [r7, #8]
 8002a72:	607a      	str	r2, [r7, #4]
  MODIFY_REG(ADCx->CFGR2, (ADC_CFGR2_RSHIFT1 | ADC_CFGR2_RSHIFT2 | ADC_CFGR2_RSHIFT3 | ADC_CFGR2_RSHIFT4), RigthShift << (Offsety & 0x1FUL));
 8002a74:	68fb      	ldr	r3, [r7, #12]
 8002a76:	691b      	ldr	r3, [r3, #16]
 8002a78:	f423 42f0 	bic.w	r2, r3, #30720	@ 0x7800
 8002a7c:	68bb      	ldr	r3, [r7, #8]
 8002a7e:	f003 031f 	and.w	r3, r3, #31
 8002a82:	6879      	ldr	r1, [r7, #4]
 8002a84:	fa01 f303 	lsl.w	r3, r1, r3
 8002a88:	431a      	orrs	r2, r3
 8002a8a:	68fb      	ldr	r3, [r7, #12]
 8002a8c:	611a      	str	r2, [r3, #16]
}
 8002a8e:	bf00      	nop
 8002a90:	3714      	adds	r7, #20
 8002a92:	46bd      	mov	sp, r7
 8002a94:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002a98:	4770      	bx	lr

08002a9a <LL_ADC_SetOffsetSignedSaturation>:
  *         @arg @ref LL_ADC_OFFSET_SIGNED_SATURATION_ENABLE
  *         @arg @ref LL_ADC_OFFSET_SIGNED_SATURATION_DISABLE
  * @retval Returned None
  */
__STATIC_INLINE void LL_ADC_SetOffsetSignedSaturation(ADC_TypeDef *ADCx, uint32_t Offsety, uint32_t OffsetSignedSaturation)
{
 8002a9a:	b480      	push	{r7}
 8002a9c:	b087      	sub	sp, #28
 8002a9e:	af00      	add	r7, sp, #0
 8002aa0:	60f8      	str	r0, [r7, #12]
 8002aa2:	60b9      	str	r1, [r7, #8]
 8002aa4:	607a      	str	r2, [r7, #4]
    /* Function not available on this instance */
  }
  else
#endif  /* ADC_VER_V5_V90 */
  {
    __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8002aa6:	68fb      	ldr	r3, [r7, #12]
 8002aa8:	3360      	adds	r3, #96	@ 0x60
 8002aaa:	461a      	mov	r2, r3
 8002aac:	68bb      	ldr	r3, [r7, #8]
 8002aae:	009b      	lsls	r3, r3, #2
 8002ab0:	4413      	add	r3, r2
 8002ab2:	617b      	str	r3, [r7, #20]
    MODIFY_REG(*preg, ADC_OFR1_SSATE, OffsetSignedSaturation);
 8002ab4:	697b      	ldr	r3, [r7, #20]
 8002ab6:	681b      	ldr	r3, [r3, #0]
 8002ab8:	f023 4200 	bic.w	r2, r3, #2147483648	@ 0x80000000
 8002abc:	687b      	ldr	r3, [r7, #4]
 8002abe:	431a      	orrs	r2, r3
 8002ac0:	697b      	ldr	r3, [r7, #20]
 8002ac2:	601a      	str	r2, [r3, #0]
  }
}
 8002ac4:	bf00      	nop
 8002ac6:	371c      	adds	r7, #28
 8002ac8:	46bd      	mov	sp, r7
 8002aca:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002ace:	4770      	bx	lr

08002ad0 <LL_ADC_REG_IsTriggerSourceSWStart>:
  * @param  ADCx ADC instance
  * @retval Value "0" if trigger source external trigger
  *         Value "1" if trigger source SW start.
  */
__STATIC_INLINE uint32_t LL_ADC_REG_IsTriggerSourceSWStart(ADC_TypeDef *ADCx)
{
 8002ad0:	b480      	push	{r7}
 8002ad2:	b083      	sub	sp, #12
 8002ad4:	af00      	add	r7, sp, #0
 8002ad6:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CFGR, ADC_CFGR_EXTEN) == (LL_ADC_REG_TRIG_SOFTWARE & ADC_CFGR_EXTEN)) ? 1UL : 0UL);
 8002ad8:	687b      	ldr	r3, [r7, #4]
 8002ada:	68db      	ldr	r3, [r3, #12]
 8002adc:	f403 6340 	and.w	r3, r3, #3072	@ 0xc00
 8002ae0:	2b00      	cmp	r3, #0
 8002ae2:	d101      	bne.n	8002ae8 <LL_ADC_REG_IsTriggerSourceSWStart+0x18>
 8002ae4:	2301      	movs	r3, #1
 8002ae6:	e000      	b.n	8002aea <LL_ADC_REG_IsTriggerSourceSWStart+0x1a>
 8002ae8:	2300      	movs	r3, #0
}
 8002aea:	4618      	mov	r0, r3
 8002aec:	370c      	adds	r7, #12
 8002aee:	46bd      	mov	sp, r7
 8002af0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002af4:	4770      	bx	lr

08002af6 <LL_ADC_REG_SetSequencerRanks>:
  *         (3) On STM32H7, fast channel (0.125 us for 14-bit resolution (ADC conversion rate up to 8 Ms/s)).
  *             Other channels are slow channels (conversion rate: refer to reference manual).
  * @retval None
  */
__STATIC_INLINE void LL_ADC_REG_SetSequencerRanks(ADC_TypeDef *ADCx, uint32_t Rank, uint32_t Channel)
{
 8002af6:	b480      	push	{r7}
 8002af8:	b087      	sub	sp, #28
 8002afa:	af00      	add	r7, sp, #0
 8002afc:	60f8      	str	r0, [r7, #12]
 8002afe:	60b9      	str	r1, [r7, #8]
 8002b00:	607a      	str	r2, [r7, #4]
  /* Set bits with content of parameter "Channel" with bits position          */
  /* in register and register position depending on parameter "Rank".         */
  /* Parameters "Rank" and "Channel" are used with masks because containing   */
  /* other bits reserved for other purpose.                                   */
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SQR1, ((Rank & ADC_REG_SQRX_REGOFFSET_MASK) >> ADC_SQRX_REGOFFSET_POS));
 8002b02:	68fb      	ldr	r3, [r7, #12]
 8002b04:	3330      	adds	r3, #48	@ 0x30
 8002b06:	461a      	mov	r2, r3
 8002b08:	68bb      	ldr	r3, [r7, #8]
 8002b0a:	0a1b      	lsrs	r3, r3, #8
 8002b0c:	009b      	lsls	r3, r3, #2
 8002b0e:	f003 030c 	and.w	r3, r3, #12
 8002b12:	4413      	add	r3, r2
 8002b14:	617b      	str	r3, [r7, #20]

  MODIFY_REG(*preg,
 8002b16:	697b      	ldr	r3, [r7, #20]
 8002b18:	681a      	ldr	r2, [r3, #0]
 8002b1a:	68bb      	ldr	r3, [r7, #8]
 8002b1c:	f003 031f 	and.w	r3, r3, #31
 8002b20:	211f      	movs	r1, #31
 8002b22:	fa01 f303 	lsl.w	r3, r1, r3
 8002b26:	43db      	mvns	r3, r3
 8002b28:	401a      	ands	r2, r3
 8002b2a:	687b      	ldr	r3, [r7, #4]
 8002b2c:	0e9b      	lsrs	r3, r3, #26
 8002b2e:	f003 011f 	and.w	r1, r3, #31
 8002b32:	68bb      	ldr	r3, [r7, #8]
 8002b34:	f003 031f 	and.w	r3, r3, #31
 8002b38:	fa01 f303 	lsl.w	r3, r1, r3
 8002b3c:	431a      	orrs	r2, r3
 8002b3e:	697b      	ldr	r3, [r7, #20]
 8002b40:	601a      	str	r2, [r3, #0]
             ADC_CHANNEL_ID_NUMBER_MASK_POSBIT0 << (Rank & ADC_REG_RANK_ID_SQRX_MASK),
             ((Channel & ADC_CHANNEL_ID_NUMBER_MASK) >> ADC_CHANNEL_ID_NUMBER_BITOFFSET_POS) << (Rank & ADC_REG_RANK_ID_SQRX_MASK));
}
 8002b42:	bf00      	nop
 8002b44:	371c      	adds	r7, #28
 8002b46:	46bd      	mov	sp, r7
 8002b48:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002b4c:	4770      	bx	lr

08002b4e <LL_ADC_REG_SetDataTransferMode>:
  * @param  ADCx ADC instance
  * @param  DataTransferMode Select Data Management configuration
  * @retval None
  */
__STATIC_INLINE void LL_ADC_REG_SetDataTransferMode(ADC_TypeDef *ADCx, uint32_t DataTransferMode)
{
 8002b4e:	b480      	push	{r7}
 8002b50:	b083      	sub	sp, #12
 8002b52:	af00      	add	r7, sp, #0
 8002b54:	6078      	str	r0, [r7, #4]
 8002b56:	6039      	str	r1, [r7, #0]
  MODIFY_REG(ADCx->CFGR, ADC_CFGR_DMNGT, DataTransferMode);
 8002b58:	687b      	ldr	r3, [r7, #4]
 8002b5a:	68db      	ldr	r3, [r3, #12]
 8002b5c:	f023 0203 	bic.w	r2, r3, #3
 8002b60:	683b      	ldr	r3, [r7, #0]
 8002b62:	431a      	orrs	r2, r3
 8002b64:	687b      	ldr	r3, [r7, #4]
 8002b66:	60da      	str	r2, [r3, #12]
}
 8002b68:	bf00      	nop
 8002b6a:	370c      	adds	r7, #12
 8002b6c:	46bd      	mov	sp, r7
 8002b6e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002b72:	4770      	bx	lr

08002b74 <LL_ADC_SetChannelSamplingTime>:
  *         @arg @ref LL_ADC_SAMPLINGTIME_387CYCLES_5
  *         @arg @ref LL_ADC_SAMPLINGTIME_810CYCLES_5
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetChannelSamplingTime(ADC_TypeDef *ADCx, uint32_t Channel, uint32_t SamplingTime)
{
 8002b74:	b480      	push	{r7}
 8002b76:	b087      	sub	sp, #28
 8002b78:	af00      	add	r7, sp, #0
 8002b7a:	60f8      	str	r0, [r7, #12]
 8002b7c:	60b9      	str	r1, [r7, #8]
 8002b7e:	607a      	str	r2, [r7, #4]
  /* Set bits with content of parameter "SamplingTime" with bits position     */
  /* in register and register position depending on parameter "Channel".      */
  /* Parameter "Channel" is used with masks because containing                */
  /* other bits reserved for other purpose.                                   */
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1, ((Channel & ADC_CHANNEL_SMPRX_REGOFFSET_MASK) >> ADC_SMPRX_REGOFFSET_POS));
 8002b80:	68fb      	ldr	r3, [r7, #12]
 8002b82:	3314      	adds	r3, #20
 8002b84:	461a      	mov	r2, r3
 8002b86:	68bb      	ldr	r3, [r7, #8]
 8002b88:	0e5b      	lsrs	r3, r3, #25
 8002b8a:	009b      	lsls	r3, r3, #2
 8002b8c:	f003 0304 	and.w	r3, r3, #4
 8002b90:	4413      	add	r3, r2
 8002b92:	617b      	str	r3, [r7, #20]

  MODIFY_REG(*preg,
 8002b94:	697b      	ldr	r3, [r7, #20]
 8002b96:	681a      	ldr	r2, [r3, #0]
 8002b98:	68bb      	ldr	r3, [r7, #8]
 8002b9a:	0d1b      	lsrs	r3, r3, #20
 8002b9c:	f003 031f 	and.w	r3, r3, #31
 8002ba0:	2107      	movs	r1, #7
 8002ba2:	fa01 f303 	lsl.w	r3, r1, r3
 8002ba6:	43db      	mvns	r3, r3
 8002ba8:	401a      	ands	r2, r3
 8002baa:	68bb      	ldr	r3, [r7, #8]
 8002bac:	0d1b      	lsrs	r3, r3, #20
 8002bae:	f003 031f 	and.w	r3, r3, #31
 8002bb2:	6879      	ldr	r1, [r7, #4]
 8002bb4:	fa01 f303 	lsl.w	r3, r1, r3
 8002bb8:	431a      	orrs	r2, r3
 8002bba:	697b      	ldr	r3, [r7, #20]
 8002bbc:	601a      	str	r2, [r3, #0]
             ADC_SMPR1_SMP0 << ((Channel & ADC_CHANNEL_SMPx_BITOFFSET_MASK) >> ADC_CHANNEL_SMPx_BITOFFSET_POS),
             SamplingTime   << ((Channel & ADC_CHANNEL_SMPx_BITOFFSET_MASK) >> ADC_CHANNEL_SMPx_BITOFFSET_POS));
}
 8002bbe:	bf00      	nop
 8002bc0:	371c      	adds	r7, #28
 8002bc2:	46bd      	mov	sp, r7
 8002bc4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002bc8:	4770      	bx	lr
	...

08002bcc <LL_ADC_SetChannelSingleDiff>:
  *         @arg @ref LL_ADC_SINGLE_ENDED
  *         @arg @ref LL_ADC_DIFFERENTIAL_ENDED
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetChannelSingleDiff(ADC_TypeDef *ADCx, uint32_t Channel, uint32_t SingleDiff)
{
 8002bcc:	b480      	push	{r7}
 8002bce:	b085      	sub	sp, #20
 8002bd0:	af00      	add	r7, sp, #0
 8002bd2:	60f8      	str	r0, [r7, #12]
 8002bd4:	60b9      	str	r1, [r7, #8]
 8002bd6:	607a      	str	r2, [r7, #4]
  }
#else  /* ADC_VER_V5_V90 */
  /* Bits of channels in single or differential mode are set only for         */
  /* differential mode (for single mode, mask of bits allowed to be set is    */
  /* shifted out of range of bits of channels in single or differential mode. */
  MODIFY_REG(ADCx->DIFSEL,
 8002bd8:	68fb      	ldr	r3, [r7, #12]
 8002bda:	f8d3 20c0 	ldr.w	r2, [r3, #192]	@ 0xc0
 8002bde:	68bb      	ldr	r3, [r7, #8]
 8002be0:	f3c3 0313 	ubfx	r3, r3, #0, #20
 8002be4:	43db      	mvns	r3, r3
 8002be6:	401a      	ands	r2, r3
 8002be8:	687b      	ldr	r3, [r7, #4]
 8002bea:	f003 0318 	and.w	r3, r3, #24
 8002bee:	4908      	ldr	r1, [pc, #32]	@ (8002c10 <LL_ADC_SetChannelSingleDiff+0x44>)
 8002bf0:	40d9      	lsrs	r1, r3
 8002bf2:	68bb      	ldr	r3, [r7, #8]
 8002bf4:	400b      	ands	r3, r1
 8002bf6:	f3c3 0313 	ubfx	r3, r3, #0, #20
 8002bfa:	431a      	orrs	r2, r3
 8002bfc:	68fb      	ldr	r3, [r7, #12]
 8002bfe:	f8c3 20c0 	str.w	r2, [r3, #192]	@ 0xc0
             Channel & ADC_SINGLEDIFF_CHANNEL_MASK,
             (Channel & ADC_SINGLEDIFF_CHANNEL_MASK) & (ADC_DIFSEL_DIFSEL >> (SingleDiff & ADC_SINGLEDIFF_CHANNEL_SHIFT_MASK)));
#endif /* ADC_VER_V5_V90 */
}
 8002c02:	bf00      	nop
 8002c04:	3714      	adds	r7, #20
 8002c06:	46bd      	mov	sp, r7
 8002c08:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002c0c:	4770      	bx	lr
 8002c0e:	bf00      	nop
 8002c10:	000fffff 	.word	0x000fffff

08002c14 <LL_ADC_GetMultimode>:
  *         @arg @ref LL_ADC_MULTI_DUAL_REG_SIM_INJ_SIM
  *         @arg @ref LL_ADC_MULTI_DUAL_REG_SIM_INJ_ALT
  *         @arg @ref LL_ADC_MULTI_DUAL_REG_INT_INJ_SIM
  */
__STATIC_INLINE uint32_t LL_ADC_GetMultimode(ADC_Common_TypeDef *ADCxy_COMMON)
{
 8002c14:	b480      	push	{r7}
 8002c16:	b083      	sub	sp, #12
 8002c18:	af00      	add	r7, sp, #0
 8002c1a:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_DUAL));
 8002c1c:	687b      	ldr	r3, [r7, #4]
 8002c1e:	689b      	ldr	r3, [r3, #8]
 8002c20:	f003 031f 	and.w	r3, r3, #31
}
 8002c24:	4618      	mov	r0, r3
 8002c26:	370c      	adds	r7, #12
 8002c28:	46bd      	mov	sp, r7
 8002c2a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002c2e:	4770      	bx	lr

08002c30 <LL_ADC_DisableDeepPowerDown>:
  * @rmtoll CR       DEEPPWD        LL_ADC_DisableDeepPowerDown
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_DisableDeepPowerDown(ADC_TypeDef *ADCx)
{
 8002c30:	b480      	push	{r7}
 8002c32:	b083      	sub	sp, #12
 8002c34:	af00      	add	r7, sp, #0
 8002c36:	6078      	str	r0, [r7, #4]
  /* Note: Write register with some additional bits forced to state reset     */
  /*       instead of modifying only the selected bit for this function,      */
  /*       to not interfere with bits with HW property "rs".                  */
  CLEAR_BIT(ADCx->CR, (ADC_CR_DEEPPWD | ADC_CR_BITS_PROPERTY_RS));
 8002c38:	687b      	ldr	r3, [r7, #4]
 8002c3a:	689a      	ldr	r2, [r3, #8]
 8002c3c:	4b04      	ldr	r3, [pc, #16]	@ (8002c50 <LL_ADC_DisableDeepPowerDown+0x20>)
 8002c3e:	4013      	ands	r3, r2
 8002c40:	687a      	ldr	r2, [r7, #4]
 8002c42:	6093      	str	r3, [r2, #8]
}
 8002c44:	bf00      	nop
 8002c46:	370c      	adds	r7, #12
 8002c48:	46bd      	mov	sp, r7
 8002c4a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002c4e:	4770      	bx	lr
 8002c50:	5fffffc0 	.word	0x5fffffc0

08002c54 <LL_ADC_IsDeepPowerDownEnabled>:
  * @rmtoll CR       DEEPPWD        LL_ADC_IsDeepPowerDownEnabled
  * @param  ADCx ADC instance
  * @retval 0: deep power down is disabled, 1: deep power down is enabled.
  */
__STATIC_INLINE uint32_t LL_ADC_IsDeepPowerDownEnabled(ADC_TypeDef *ADCx)
{
 8002c54:	b480      	push	{r7}
 8002c56:	b083      	sub	sp, #12
 8002c58:	af00      	add	r7, sp, #0
 8002c5a:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_DEEPPWD) == (ADC_CR_DEEPPWD)) ? 1UL : 0UL);
 8002c5c:	687b      	ldr	r3, [r7, #4]
 8002c5e:	689b      	ldr	r3, [r3, #8]
 8002c60:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
 8002c64:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 8002c68:	d101      	bne.n	8002c6e <LL_ADC_IsDeepPowerDownEnabled+0x1a>
 8002c6a:	2301      	movs	r3, #1
 8002c6c:	e000      	b.n	8002c70 <LL_ADC_IsDeepPowerDownEnabled+0x1c>
 8002c6e:	2300      	movs	r3, #0
}
 8002c70:	4618      	mov	r0, r3
 8002c72:	370c      	adds	r7, #12
 8002c74:	46bd      	mov	sp, r7
 8002c76:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002c7a:	4770      	bx	lr

08002c7c <LL_ADC_EnableInternalRegulator>:
  * @rmtoll CR       ADVREGEN       LL_ADC_EnableInternalRegulator
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_EnableInternalRegulator(ADC_TypeDef *ADCx)
{
 8002c7c:	b480      	push	{r7}
 8002c7e:	b083      	sub	sp, #12
 8002c80:	af00      	add	r7, sp, #0
 8002c82:	6078      	str	r0, [r7, #4]
  /* Note: Write register with some additional bits forced to state reset     */
  /*       instead of modifying only the selected bit for this function,      */
  /*       to not interfere with bits with HW property "rs".                  */
  MODIFY_REG(ADCx->CR,
 8002c84:	687b      	ldr	r3, [r7, #4]
 8002c86:	689a      	ldr	r2, [r3, #8]
 8002c88:	4b05      	ldr	r3, [pc, #20]	@ (8002ca0 <LL_ADC_EnableInternalRegulator+0x24>)
 8002c8a:	4013      	ands	r3, r2
 8002c8c:	f043 5280 	orr.w	r2, r3, #268435456	@ 0x10000000
 8002c90:	687b      	ldr	r3, [r7, #4]
 8002c92:	609a      	str	r2, [r3, #8]
             ADC_CR_BITS_PROPERTY_RS,
             ADC_CR_ADVREGEN);
}
 8002c94:	bf00      	nop
 8002c96:	370c      	adds	r7, #12
 8002c98:	46bd      	mov	sp, r7
 8002c9a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002c9e:	4770      	bx	lr
 8002ca0:	6fffffc0 	.word	0x6fffffc0

08002ca4 <LL_ADC_IsInternalRegulatorEnabled>:
  * @rmtoll CR       ADVREGEN       LL_ADC_IsInternalRegulatorEnabled
  * @param  ADCx ADC instance
  * @retval 0: internal regulator is disabled, 1: internal regulator is enabled.
  */
__STATIC_INLINE uint32_t LL_ADC_IsInternalRegulatorEnabled(ADC_TypeDef *ADCx)
{
 8002ca4:	b480      	push	{r7}
 8002ca6:	b083      	sub	sp, #12
 8002ca8:	af00      	add	r7, sp, #0
 8002caa:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADVREGEN) == (ADC_CR_ADVREGEN)) ? 1UL : 0UL);
 8002cac:	687b      	ldr	r3, [r7, #4]
 8002cae:	689b      	ldr	r3, [r3, #8]
 8002cb0:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 8002cb4:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
 8002cb8:	d101      	bne.n	8002cbe <LL_ADC_IsInternalRegulatorEnabled+0x1a>
 8002cba:	2301      	movs	r3, #1
 8002cbc:	e000      	b.n	8002cc0 <LL_ADC_IsInternalRegulatorEnabled+0x1c>
 8002cbe:	2300      	movs	r3, #0
}
 8002cc0:	4618      	mov	r0, r3
 8002cc2:	370c      	adds	r7, #12
 8002cc4:	46bd      	mov	sp, r7
 8002cc6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002cca:	4770      	bx	lr

08002ccc <LL_ADC_Enable>:
  * @rmtoll CR       ADEN           LL_ADC_Enable
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_Enable(ADC_TypeDef *ADCx)
{
 8002ccc:	b480      	push	{r7}
 8002cce:	b083      	sub	sp, #12
 8002cd0:	af00      	add	r7, sp, #0
 8002cd2:	6078      	str	r0, [r7, #4]
  /* Note: Write register with some additional bits forced to state reset     */
  /*       instead of modifying only the selected bit for this function,      */
  /*       to not interfere with bits with HW property "rs".                  */
  MODIFY_REG(ADCx->CR,
 8002cd4:	687b      	ldr	r3, [r7, #4]
 8002cd6:	689a      	ldr	r2, [r3, #8]
 8002cd8:	4b05      	ldr	r3, [pc, #20]	@ (8002cf0 <LL_ADC_Enable+0x24>)
 8002cda:	4013      	ands	r3, r2
 8002cdc:	f043 0201 	orr.w	r2, r3, #1
 8002ce0:	687b      	ldr	r3, [r7, #4]
 8002ce2:	609a      	str	r2, [r3, #8]
             ADC_CR_BITS_PROPERTY_RS,
             ADC_CR_ADEN);
}
 8002ce4:	bf00      	nop
 8002ce6:	370c      	adds	r7, #12
 8002ce8:	46bd      	mov	sp, r7
 8002cea:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002cee:	4770      	bx	lr
 8002cf0:	7fffffc0 	.word	0x7fffffc0

08002cf4 <LL_ADC_Disable>:
  * @rmtoll CR       ADDIS          LL_ADC_Disable
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_Disable(ADC_TypeDef *ADCx)
{
 8002cf4:	b480      	push	{r7}
 8002cf6:	b083      	sub	sp, #12
 8002cf8:	af00      	add	r7, sp, #0
 8002cfa:	6078      	str	r0, [r7, #4]
  /* Note: Write register with some additional bits forced to state reset     */
  /*       instead of modifying only the selected bit for this function,      */
  /*       to not interfere with bits with HW property "rs".                  */
  MODIFY_REG(ADCx->CR,
 8002cfc:	687b      	ldr	r3, [r7, #4]
 8002cfe:	689a      	ldr	r2, [r3, #8]
 8002d00:	4b05      	ldr	r3, [pc, #20]	@ (8002d18 <LL_ADC_Disable+0x24>)
 8002d02:	4013      	ands	r3, r2
 8002d04:	f043 0202 	orr.w	r2, r3, #2
 8002d08:	687b      	ldr	r3, [r7, #4]
 8002d0a:	609a      	str	r2, [r3, #8]
             ADC_CR_BITS_PROPERTY_RS,
             ADC_CR_ADDIS);
}
 8002d0c:	bf00      	nop
 8002d0e:	370c      	adds	r7, #12
 8002d10:	46bd      	mov	sp, r7
 8002d12:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002d16:	4770      	bx	lr
 8002d18:	7fffffc0 	.word	0x7fffffc0

08002d1c <LL_ADC_IsEnabled>:
  * @rmtoll CR       ADEN           LL_ADC_IsEnabled
  * @param  ADCx ADC instance
  * @retval 0: ADC is disabled, 1: ADC is enabled.
  */
__STATIC_INLINE uint32_t LL_ADC_IsEnabled(ADC_TypeDef *ADCx)
{
 8002d1c:	b480      	push	{r7}
 8002d1e:	b083      	sub	sp, #12
 8002d20:	af00      	add	r7, sp, #0
 8002d22:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 8002d24:	687b      	ldr	r3, [r7, #4]
 8002d26:	689b      	ldr	r3, [r3, #8]
 8002d28:	f003 0301 	and.w	r3, r3, #1
 8002d2c:	2b01      	cmp	r3, #1
 8002d2e:	d101      	bne.n	8002d34 <LL_ADC_IsEnabled+0x18>
 8002d30:	2301      	movs	r3, #1
 8002d32:	e000      	b.n	8002d36 <LL_ADC_IsEnabled+0x1a>
 8002d34:	2300      	movs	r3, #0
}
 8002d36:	4618      	mov	r0, r3
 8002d38:	370c      	adds	r7, #12
 8002d3a:	46bd      	mov	sp, r7
 8002d3c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002d40:	4770      	bx	lr

08002d42 <LL_ADC_IsDisableOngoing>:
  * @rmtoll CR       ADDIS          LL_ADC_IsDisableOngoing
  * @param  ADCx ADC instance
  * @retval 0: no ADC disable command on going.
  */
__STATIC_INLINE uint32_t LL_ADC_IsDisableOngoing(ADC_TypeDef *ADCx)
{
 8002d42:	b480      	push	{r7}
 8002d44:	b083      	sub	sp, #12
 8002d46:	af00      	add	r7, sp, #0
 8002d48:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADDIS) == (ADC_CR_ADDIS)) ? 1UL : 0UL);
 8002d4a:	687b      	ldr	r3, [r7, #4]
 8002d4c:	689b      	ldr	r3, [r3, #8]
 8002d4e:	f003 0302 	and.w	r3, r3, #2
 8002d52:	2b02      	cmp	r3, #2
 8002d54:	d101      	bne.n	8002d5a <LL_ADC_IsDisableOngoing+0x18>
 8002d56:	2301      	movs	r3, #1
 8002d58:	e000      	b.n	8002d5c <LL_ADC_IsDisableOngoing+0x1a>
 8002d5a:	2300      	movs	r3, #0
}
 8002d5c:	4618      	mov	r0, r3
 8002d5e:	370c      	adds	r7, #12
 8002d60:	46bd      	mov	sp, r7
 8002d62:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002d66:	4770      	bx	lr

08002d68 <LL_ADC_REG_StartConversion>:
  * @rmtoll CR       ADSTART        LL_ADC_REG_StartConversion
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_REG_StartConversion(ADC_TypeDef *ADCx)
{
 8002d68:	b480      	push	{r7}
 8002d6a:	b083      	sub	sp, #12
 8002d6c:	af00      	add	r7, sp, #0
 8002d6e:	6078      	str	r0, [r7, #4]
  /* Note: Write register with some additional bits forced to state reset     */
  /*       instead of modifying only the selected bit for this function,      */
  /*       to not interfere with bits with HW property "rs".                  */
  MODIFY_REG(ADCx->CR,
 8002d70:	687b      	ldr	r3, [r7, #4]
 8002d72:	689a      	ldr	r2, [r3, #8]
 8002d74:	4b05      	ldr	r3, [pc, #20]	@ (8002d8c <LL_ADC_REG_StartConversion+0x24>)
 8002d76:	4013      	ands	r3, r2
 8002d78:	f043 0204 	orr.w	r2, r3, #4
 8002d7c:	687b      	ldr	r3, [r7, #4]
 8002d7e:	609a      	str	r2, [r3, #8]
             ADC_CR_BITS_PROPERTY_RS,
             ADC_CR_ADSTART);
}
 8002d80:	bf00      	nop
 8002d82:	370c      	adds	r7, #12
 8002d84:	46bd      	mov	sp, r7
 8002d86:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002d8a:	4770      	bx	lr
 8002d8c:	7fffffc0 	.word	0x7fffffc0

08002d90 <LL_ADC_REG_IsConversionOngoing>:
  * @rmtoll CR       ADSTART        LL_ADC_REG_IsConversionOngoing
  * @param  ADCx ADC instance
  * @retval 0: no conversion is on going on ADC group regular.
  */
__STATIC_INLINE uint32_t LL_ADC_REG_IsConversionOngoing(ADC_TypeDef *ADCx)
{
 8002d90:	b480      	push	{r7}
 8002d92:	b083      	sub	sp, #12
 8002d94:	af00      	add	r7, sp, #0
 8002d96:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 8002d98:	687b      	ldr	r3, [r7, #4]
 8002d9a:	689b      	ldr	r3, [r3, #8]
 8002d9c:	f003 0304 	and.w	r3, r3, #4
 8002da0:	2b04      	cmp	r3, #4
 8002da2:	d101      	bne.n	8002da8 <LL_ADC_REG_IsConversionOngoing+0x18>
 8002da4:	2301      	movs	r3, #1
 8002da6:	e000      	b.n	8002daa <LL_ADC_REG_IsConversionOngoing+0x1a>
 8002da8:	2300      	movs	r3, #0
}
 8002daa:	4618      	mov	r0, r3
 8002dac:	370c      	adds	r7, #12
 8002dae:	46bd      	mov	sp, r7
 8002db0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002db4:	4770      	bx	lr

08002db6 <LL_ADC_INJ_IsConversionOngoing>:
  * @rmtoll CR       JADSTART       LL_ADC_INJ_IsConversionOngoing
  * @param  ADCx ADC instance
  * @retval 0: no conversion is on going on ADC group injected.
  */
__STATIC_INLINE uint32_t LL_ADC_INJ_IsConversionOngoing(ADC_TypeDef *ADCx)
{
 8002db6:	b480      	push	{r7}
 8002db8:	b083      	sub	sp, #12
 8002dba:	af00      	add	r7, sp, #0
 8002dbc:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
 8002dbe:	687b      	ldr	r3, [r7, #4]
 8002dc0:	689b      	ldr	r3, [r3, #8]
 8002dc2:	f003 0308 	and.w	r3, r3, #8
 8002dc6:	2b08      	cmp	r3, #8
 8002dc8:	d101      	bne.n	8002dce <LL_ADC_INJ_IsConversionOngoing+0x18>
 8002dca:	2301      	movs	r3, #1
 8002dcc:	e000      	b.n	8002dd0 <LL_ADC_INJ_IsConversionOngoing+0x1a>
 8002dce:	2300      	movs	r3, #0
}
 8002dd0:	4618      	mov	r0, r3
 8002dd2:	370c      	adds	r7, #12
 8002dd4:	46bd      	mov	sp, r7
 8002dd6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002dda:	4770      	bx	lr

08002ddc <HAL_ADC_Init>:
  *         without  disabling the other ADCs.
  * @param hadc ADC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_Init(ADC_HandleTypeDef *hadc)
{
 8002ddc:	b590      	push	{r4, r7, lr}
 8002dde:	b089      	sub	sp, #36	@ 0x24
 8002de0:	af00      	add	r7, sp, #0
 8002de2:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 8002de4:	2300      	movs	r3, #0
 8002de6:	77fb      	strb	r3, [r7, #31]
  uint32_t tmpCFGR;
  uint32_t tmp_adc_reg_is_conversion_on_going;
  __IO uint32_t wait_loop_index = 0UL;
 8002de8:	2300      	movs	r3, #0
 8002dea:	60bb      	str	r3, [r7, #8]
  uint32_t tmp_adc_is_conversion_on_going_regular;
  uint32_t tmp_adc_is_conversion_on_going_injected;

  /* Check ADC handle */
  if (hadc == NULL)
 8002dec:	687b      	ldr	r3, [r7, #4]
 8002dee:	2b00      	cmp	r3, #0
 8002df0:	d101      	bne.n	8002df6 <HAL_ADC_Init+0x1a>
  {
    return HAL_ERROR;
 8002df2:	2301      	movs	r3, #1
 8002df4:	e138      	b.n	8003068 <HAL_ADC_Init+0x28c>
  assert_param(IS_ADC_EOC_SELECTION(hadc->Init.EOCSelection));
  assert_param(IS_ADC_OVERRUN(hadc->Init.Overrun));
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.LowPowerAutoWait));
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.OversamplingMode));

  if (hadc->Init.ScanConvMode != ADC_SCAN_DISABLE)
 8002df6:	687b      	ldr	r3, [r7, #4]
 8002df8:	68db      	ldr	r3, [r3, #12]
 8002dfa:	2b00      	cmp	r3, #0
  /* DISCEN and CONT bits cannot be set at the same time */
  assert_param(!((hadc->Init.DiscontinuousConvMode == ENABLE) && (hadc->Init.ContinuousConvMode == ENABLE)));

  /* Actions performed only if ADC is coming from state reset:                */
  /* - Initialization of ADC MSP                                              */
  if (hadc->State == HAL_ADC_STATE_RESET)
 8002dfc:	687b      	ldr	r3, [r7, #4]
 8002dfe:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8002e00:	2b00      	cmp	r3, #0
 8002e02:	d109      	bne.n	8002e18 <HAL_ADC_Init+0x3c>

    /* Init the low level hardware */
    hadc->MspInitCallback(hadc);
#else
    /* Init the low level hardware */
    HAL_ADC_MspInit(hadc);
 8002e04:	6878      	ldr	r0, [r7, #4]
 8002e06:	f7ff f843 	bl	8001e90 <HAL_ADC_MspInit>
#endif /* USE_HAL_ADC_REGISTER_CALLBACKS */

    /* Set ADC error code to none */
    ADC_CLEAR_ERRORCODE(hadc);
 8002e0a:	687b      	ldr	r3, [r7, #4]
 8002e0c:	2200      	movs	r2, #0
 8002e0e:	659a      	str	r2, [r3, #88]	@ 0x58

    /* Initialize Lock */
    hadc->Lock = HAL_UNLOCKED;
 8002e10:	687b      	ldr	r3, [r7, #4]
 8002e12:	2200      	movs	r2, #0
 8002e14:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50
  }

  /* - Exit from deep-power-down mode and ADC voltage regulator enable        */
  if (LL_ADC_IsDeepPowerDownEnabled(hadc->Instance) != 0UL)
 8002e18:	687b      	ldr	r3, [r7, #4]
 8002e1a:	681b      	ldr	r3, [r3, #0]
 8002e1c:	4618      	mov	r0, r3
 8002e1e:	f7ff ff19 	bl	8002c54 <LL_ADC_IsDeepPowerDownEnabled>
 8002e22:	4603      	mov	r3, r0
 8002e24:	2b00      	cmp	r3, #0
 8002e26:	d004      	beq.n	8002e32 <HAL_ADC_Init+0x56>
  {
    /* Disable ADC deep power down mode */
    LL_ADC_DisableDeepPowerDown(hadc->Instance);
 8002e28:	687b      	ldr	r3, [r7, #4]
 8002e2a:	681b      	ldr	r3, [r3, #0]
 8002e2c:	4618      	mov	r0, r3
 8002e2e:	f7ff feff 	bl	8002c30 <LL_ADC_DisableDeepPowerDown>
    /* System was in deep power down mode, calibration must
     be relaunched or a previously saved calibration factor
     re-applied once the ADC voltage regulator is enabled */
  }

  if (LL_ADC_IsInternalRegulatorEnabled(hadc->Instance) == 0UL)
 8002e32:	687b      	ldr	r3, [r7, #4]
 8002e34:	681b      	ldr	r3, [r3, #0]
 8002e36:	4618      	mov	r0, r3
 8002e38:	f7ff ff34 	bl	8002ca4 <LL_ADC_IsInternalRegulatorEnabled>
 8002e3c:	4603      	mov	r3, r0
 8002e3e:	2b00      	cmp	r3, #0
 8002e40:	d114      	bne.n	8002e6c <HAL_ADC_Init+0x90>
  {
    /* Enable ADC internal voltage regulator */
    LL_ADC_EnableInternalRegulator(hadc->Instance);
 8002e42:	687b      	ldr	r3, [r7, #4]
 8002e44:	681b      	ldr	r3, [r3, #0]
 8002e46:	4618      	mov	r0, r3
 8002e48:	f7ff ff18 	bl	8002c7c <LL_ADC_EnableInternalRegulator>

    /* Note: Variable divided by 2 to compensate partially              */
    /*       CPU processing cycles, scaling in us split to not          */
    /*       exceed 32 bits register capacity and handle low frequency. */
    wait_loop_index = ((LL_ADC_DELAY_INTERNAL_REGUL_STAB_US / 10UL) * ((SystemCoreClock / (100000UL * 2UL)) + 1UL));
 8002e4c:	4b88      	ldr	r3, [pc, #544]	@ (8003070 <HAL_ADC_Init+0x294>)
 8002e4e:	681b      	ldr	r3, [r3, #0]
 8002e50:	099b      	lsrs	r3, r3, #6
 8002e52:	4a88      	ldr	r2, [pc, #544]	@ (8003074 <HAL_ADC_Init+0x298>)
 8002e54:	fba2 2303 	umull	r2, r3, r2, r3
 8002e58:	099b      	lsrs	r3, r3, #6
 8002e5a:	3301      	adds	r3, #1
 8002e5c:	60bb      	str	r3, [r7, #8]
    while (wait_loop_index != 0UL)
 8002e5e:	e002      	b.n	8002e66 <HAL_ADC_Init+0x8a>
    {
      wait_loop_index--;
 8002e60:	68bb      	ldr	r3, [r7, #8]
 8002e62:	3b01      	subs	r3, #1
 8002e64:	60bb      	str	r3, [r7, #8]
    while (wait_loop_index != 0UL)
 8002e66:	68bb      	ldr	r3, [r7, #8]
 8002e68:	2b00      	cmp	r3, #0
 8002e6a:	d1f9      	bne.n	8002e60 <HAL_ADC_Init+0x84>
  }

  /* Verification that ADC voltage regulator is correctly enabled, whether    */
  /* or not ADC is coming from state reset (if any potential problem of       */
  /* clocking, voltage regulator would not be enabled).                       */
  if (LL_ADC_IsInternalRegulatorEnabled(hadc->Instance) == 0UL)
 8002e6c:	687b      	ldr	r3, [r7, #4]
 8002e6e:	681b      	ldr	r3, [r3, #0]
 8002e70:	4618      	mov	r0, r3
 8002e72:	f7ff ff17 	bl	8002ca4 <LL_ADC_IsInternalRegulatorEnabled>
 8002e76:	4603      	mov	r3, r0
 8002e78:	2b00      	cmp	r3, #0
 8002e7a:	d10d      	bne.n	8002e98 <HAL_ADC_Init+0xbc>
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8002e7c:	687b      	ldr	r3, [r7, #4]
 8002e7e:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8002e80:	f043 0210 	orr.w	r2, r3, #16
 8002e84:	687b      	ldr	r3, [r7, #4]
 8002e86:	655a      	str	r2, [r3, #84]	@ 0x54

    /* Set ADC error code to ADC peripheral internal error */
    SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8002e88:	687b      	ldr	r3, [r7, #4]
 8002e8a:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8002e8c:	f043 0201 	orr.w	r2, r3, #1
 8002e90:	687b      	ldr	r3, [r7, #4]
 8002e92:	659a      	str	r2, [r3, #88]	@ 0x58

    tmp_hal_status = HAL_ERROR;
 8002e94:	2301      	movs	r3, #1
 8002e96:	77fb      	strb	r3, [r7, #31]

  /* Configuration of ADC parameters if previous preliminary actions are      */
  /* correctly completed and if there is no conversion on going on regular    */
  /* group (ADC may already be enabled at this point if HAL_ADC_Init() is     */
  /* called to update a parameter on the fly).                                */
  tmp_adc_reg_is_conversion_on_going = LL_ADC_REG_IsConversionOngoing(hadc->Instance);
 8002e98:	687b      	ldr	r3, [r7, #4]
 8002e9a:	681b      	ldr	r3, [r3, #0]
 8002e9c:	4618      	mov	r0, r3
 8002e9e:	f7ff ff77 	bl	8002d90 <LL_ADC_REG_IsConversionOngoing>
 8002ea2:	6178      	str	r0, [r7, #20]

  if (((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) == 0UL)
 8002ea4:	687b      	ldr	r3, [r7, #4]
 8002ea6:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8002ea8:	f003 0310 	and.w	r3, r3, #16
 8002eac:	2b00      	cmp	r3, #0
 8002eae:	f040 80d2 	bne.w	8003056 <HAL_ADC_Init+0x27a>
      && (tmp_adc_reg_is_conversion_on_going == 0UL)
 8002eb2:	697b      	ldr	r3, [r7, #20]
 8002eb4:	2b00      	cmp	r3, #0
 8002eb6:	f040 80ce 	bne.w	8003056 <HAL_ADC_Init+0x27a>
     )
  {
    /* Set ADC state */
    ADC_STATE_CLR_SET(hadc->State,
 8002eba:	687b      	ldr	r3, [r7, #4]
 8002ebc:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8002ebe:	f423 7381 	bic.w	r3, r3, #258	@ 0x102
 8002ec2:	f043 0202 	orr.w	r2, r3, #2
 8002ec6:	687b      	ldr	r3, [r7, #4]
 8002ec8:	655a      	str	r2, [r3, #84]	@ 0x54
    /* Configuration of common ADC parameters                                 */

    /* Parameters update conditioned to ADC state:                            */
    /* Parameters that can be updated only when ADC is disabled:              */
    /*  - clock configuration                                                 */
    if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
 8002eca:	687b      	ldr	r3, [r7, #4]
 8002ecc:	681b      	ldr	r3, [r3, #0]
 8002ece:	4618      	mov	r0, r3
 8002ed0:	f7ff ff24 	bl	8002d1c <LL_ADC_IsEnabled>
 8002ed4:	4603      	mov	r3, r0
 8002ed6:	2b00      	cmp	r3, #0
 8002ed8:	d110      	bne.n	8002efc <HAL_ADC_Init+0x120>
    {
      if (__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) == 0UL)
 8002eda:	4867      	ldr	r0, [pc, #412]	@ (8003078 <HAL_ADC_Init+0x29c>)
 8002edc:	f7ff ff1e 	bl	8002d1c <LL_ADC_IsEnabled>
 8002ee0:	4604      	mov	r4, r0
 8002ee2:	4866      	ldr	r0, [pc, #408]	@ (800307c <HAL_ADC_Init+0x2a0>)
 8002ee4:	f7ff ff1a 	bl	8002d1c <LL_ADC_IsEnabled>
 8002ee8:	4603      	mov	r3, r0
 8002eea:	4323      	orrs	r3, r4
 8002eec:	2b00      	cmp	r3, #0
 8002eee:	d105      	bne.n	8002efc <HAL_ADC_Init+0x120>
        /*     parameters: MDMA, DMACFG, DELAY, DUAL (set by API                */
        /*     HAL_ADCEx_MultiModeConfigChannel() )                             */
        /*   - internal measurement paths: Vbat, temperature sensor, Vref       */
        /*     (set into HAL_ADC_ConfigChannel() or                             */
        /*     HAL_ADCEx_InjectedConfigChannel() )                              */
        LL_ADC_SetCommonClock(__LL_ADC_COMMON_INSTANCE(hadc->Instance), hadc->Init.ClockPrescaler);
 8002ef0:	687b      	ldr	r3, [r7, #4]
 8002ef2:	685b      	ldr	r3, [r3, #4]
 8002ef4:	4619      	mov	r1, r3
 8002ef6:	4862      	ldr	r0, [pc, #392]	@ (8003080 <HAL_ADC_Init+0x2a4>)
 8002ef8:	f7ff fd62 	bl	80029c0 <LL_ADC_SetCommonClock>
    /*  - overrun                                  Init.Overrun               */
    /*  - discontinuous mode                       Init.DiscontinuousConvMode */
    /*  - discontinuous mode channel count         Init.NbrOfDiscConversion   */
#if defined(ADC_VER_V5_3)

    tmpCFGR  = (ADC_CFGR_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)           |
 8002efc:	687b      	ldr	r3, [r7, #4]
 8002efe:	7d5b      	ldrb	r3, [r3, #21]
 8002f00:	035a      	lsls	r2, r3, #13
                hadc->Init.Overrun                                                    |
 8002f02:	687b      	ldr	r3, [r7, #4]
 8002f04:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
    tmpCFGR  = (ADC_CFGR_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)           |
 8002f06:	431a      	orrs	r2, r3
                hadc->Init.Resolution                                                 |
 8002f08:	687b      	ldr	r3, [r7, #4]
 8002f0a:	689b      	ldr	r3, [r3, #8]
                hadc->Init.Overrun                                                    |
 8002f0c:	431a      	orrs	r2, r3
                ADC_CFGR_REG_DISCONTINUOUS((uint32_t)hadc->Init.DiscontinuousConvMode));
 8002f0e:	687b      	ldr	r3, [r7, #4]
 8002f10:	7f1b      	ldrb	r3, [r3, #28]
 8002f12:	041b      	lsls	r3, r3, #16
    tmpCFGR  = (ADC_CFGR_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)           |
 8002f14:	4313      	orrs	r3, r2
 8002f16:	61bb      	str	r3, [r7, #24]
                  ADC_CFGR_REG_DISCONTINUOUS((uint32_t)hadc->Init.DiscontinuousConvMode));
    }

#endif /* ADC_VER_V5_3 */

    if (hadc->Init.DiscontinuousConvMode == ENABLE)
 8002f18:	687b      	ldr	r3, [r7, #4]
 8002f1a:	7f1b      	ldrb	r3, [r3, #28]
 8002f1c:	2b01      	cmp	r3, #1
 8002f1e:	d106      	bne.n	8002f2e <HAL_ADC_Init+0x152>
    {
      tmpCFGR |= ADC_CFGR_DISCONTINUOUS_NUM(hadc->Init.NbrOfDiscConversion);
 8002f20:	687b      	ldr	r3, [r7, #4]
 8002f22:	6a1b      	ldr	r3, [r3, #32]
 8002f24:	3b01      	subs	r3, #1
 8002f26:	045b      	lsls	r3, r3, #17
 8002f28:	69ba      	ldr	r2, [r7, #24]
 8002f2a:	4313      	orrs	r3, r2
 8002f2c:	61bb      	str	r3, [r7, #24]
    /* Enable external trigger if trigger selection is different of software  */
    /* start.                                                                 */
    /* Note: This configuration keeps the hardware feature of parameter       */
    /*       ExternalTrigConvEdge "trigger edge none" equivalent to           */
    /*       software start.                                                  */
    if (hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
 8002f2e:	687b      	ldr	r3, [r7, #4]
 8002f30:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8002f32:	2b00      	cmp	r3, #0
 8002f34:	d009      	beq.n	8002f4a <HAL_ADC_Init+0x16e>
    {
      tmpCFGR |= ((hadc->Init.ExternalTrigConv & ADC_CFGR_EXTSEL)
 8002f36:	687b      	ldr	r3, [r7, #4]
 8002f38:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8002f3a:	f403 7278 	and.w	r2, r3, #992	@ 0x3e0
                  | hadc->Init.ExternalTrigConvEdge
 8002f3e:	687b      	ldr	r3, [r7, #4]
 8002f40:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8002f42:	4313      	orrs	r3, r2
      tmpCFGR |= ((hadc->Init.ExternalTrigConv & ADC_CFGR_EXTSEL)
 8002f44:	69ba      	ldr	r2, [r7, #24]
 8002f46:	4313      	orrs	r3, r2
 8002f48:	61bb      	str	r3, [r7, #24]
      /* Update Configuration Register CFGR */
      MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_1, tmpCFGR);
    }
#else
    /* Update Configuration Register CFGR */
    MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_1, tmpCFGR);
 8002f4a:	687b      	ldr	r3, [r7, #4]
 8002f4c:	681b      	ldr	r3, [r3, #0]
 8002f4e:	68da      	ldr	r2, [r3, #12]
 8002f50:	4b4c      	ldr	r3, [pc, #304]	@ (8003084 <HAL_ADC_Init+0x2a8>)
 8002f52:	4013      	ands	r3, r2
 8002f54:	687a      	ldr	r2, [r7, #4]
 8002f56:	6812      	ldr	r2, [r2, #0]
 8002f58:	69b9      	ldr	r1, [r7, #24]
 8002f5a:	430b      	orrs	r3, r1
 8002f5c:	60d3      	str	r3, [r2, #12]
    /* Parameters that can be updated when ADC is disabled or enabled without */
    /* conversion on going on regular and injected groups:                    */
    /*  - Conversion data management      Init.ConversionDataManagement       */
    /*  - LowPowerAutoWait feature        Init.LowPowerAutoWait               */
    /*  - Oversampling parameters         Init.Oversampling                   */
    tmp_adc_is_conversion_on_going_regular = LL_ADC_REG_IsConversionOngoing(hadc->Instance);
 8002f5e:	687b      	ldr	r3, [r7, #4]
 8002f60:	681b      	ldr	r3, [r3, #0]
 8002f62:	4618      	mov	r0, r3
 8002f64:	f7ff ff14 	bl	8002d90 <LL_ADC_REG_IsConversionOngoing>
 8002f68:	6138      	str	r0, [r7, #16]
    tmp_adc_is_conversion_on_going_injected = LL_ADC_INJ_IsConversionOngoing(hadc->Instance);
 8002f6a:	687b      	ldr	r3, [r7, #4]
 8002f6c:	681b      	ldr	r3, [r3, #0]
 8002f6e:	4618      	mov	r0, r3
 8002f70:	f7ff ff21 	bl	8002db6 <LL_ADC_INJ_IsConversionOngoing>
 8002f74:	60f8      	str	r0, [r7, #12]
    if ((tmp_adc_is_conversion_on_going_regular == 0UL)
 8002f76:	693b      	ldr	r3, [r7, #16]
 8002f78:	2b00      	cmp	r3, #0
 8002f7a:	d14a      	bne.n	8003012 <HAL_ADC_Init+0x236>
        && (tmp_adc_is_conversion_on_going_injected == 0UL)
 8002f7c:	68fb      	ldr	r3, [r7, #12]
 8002f7e:	2b00      	cmp	r3, #0
 8002f80:	d147      	bne.n	8003012 <HAL_ADC_Init+0x236>
                    ADC_CFGR_AUTOWAIT((uint32_t)hadc->Init.LowPowerAutoWait)        |
                    ADC_CFGR_DMACONTREQ((uint32_t)hadc->Init.ConversionDataManagement));
      }
#else
      tmpCFGR = (
                  ADC_CFGR_AUTOWAIT((uint32_t)hadc->Init.LowPowerAutoWait)        |
 8002f82:	687b      	ldr	r3, [r7, #4]
 8002f84:	7d1b      	ldrb	r3, [r3, #20]
 8002f86:	039a      	lsls	r2, r3, #14
                  ADC_CFGR_DMACONTREQ((uint32_t)hadc->Init.ConversionDataManagement));
 8002f88:	687b      	ldr	r3, [r7, #4]
 8002f8a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
      tmpCFGR = (
 8002f8c:	4313      	orrs	r3, r2
 8002f8e:	61bb      	str	r3, [r7, #24]
#endif

      MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_2, tmpCFGR);
 8002f90:	687b      	ldr	r3, [r7, #4]
 8002f92:	681b      	ldr	r3, [r3, #0]
 8002f94:	68da      	ldr	r2, [r3, #12]
 8002f96:	4b3c      	ldr	r3, [pc, #240]	@ (8003088 <HAL_ADC_Init+0x2ac>)
 8002f98:	4013      	ands	r3, r2
 8002f9a:	687a      	ldr	r2, [r7, #4]
 8002f9c:	6812      	ldr	r2, [r2, #0]
 8002f9e:	69b9      	ldr	r1, [r7, #24]
 8002fa0:	430b      	orrs	r3, r1
 8002fa2:	60d3      	str	r3, [r2, #12]

      if (hadc->Init.OversamplingMode == ENABLE)
 8002fa4:	687b      	ldr	r3, [r7, #4]
 8002fa6:	f893 3038 	ldrb.w	r3, [r3, #56]	@ 0x38
 8002faa:	2b01      	cmp	r3, #1
 8002fac:	d11b      	bne.n	8002fe6 <HAL_ADC_Init+0x20a>
#endif
        assert_param(IS_ADC_RIGHT_BIT_SHIFT(hadc->Init.Oversampling.RightBitShift));
        assert_param(IS_ADC_TRIGGERED_OVERSAMPLING_MODE(hadc->Init.Oversampling.TriggeredMode));
        assert_param(IS_ADC_REGOVERSAMPLING_MODE(hadc->Init.Oversampling.OversamplingStopReset));

        if ((hadc->Init.ExternalTrigConv == ADC_SOFTWARE_START)
 8002fae:	687b      	ldr	r3, [r7, #4]
 8002fb0:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8002fb2:	2b00      	cmp	r3, #0
        /*  - Oversampling Ratio                                               */
        /*  - Right bit shift                                                  */
        /*  - Left bit shift                                                   */
        /*  - Triggered mode                                                   */
        /*  - Oversampling mode (continued/resumed)                            */
        MODIFY_REG(hadc->Instance->CFGR2, ADC_CFGR2_FIELDS,
 8002fb4:	687b      	ldr	r3, [r7, #4]
 8002fb6:	681b      	ldr	r3, [r3, #0]
 8002fb8:	691a      	ldr	r2, [r3, #16]
 8002fba:	4b34      	ldr	r3, [pc, #208]	@ (800308c <HAL_ADC_Init+0x2b0>)
 8002fbc:	4013      	ands	r3, r2
 8002fbe:	687a      	ldr	r2, [r7, #4]
 8002fc0:	6bd2      	ldr	r2, [r2, #60]	@ 0x3c
 8002fc2:	3a01      	subs	r2, #1
 8002fc4:	0411      	lsls	r1, r2, #16
 8002fc6:	687a      	ldr	r2, [r7, #4]
 8002fc8:	6c12      	ldr	r2, [r2, #64]	@ 0x40
 8002fca:	4311      	orrs	r1, r2
 8002fcc:	687a      	ldr	r2, [r7, #4]
 8002fce:	6c52      	ldr	r2, [r2, #68]	@ 0x44
 8002fd0:	4311      	orrs	r1, r2
 8002fd2:	687a      	ldr	r2, [r7, #4]
 8002fd4:	6c92      	ldr	r2, [r2, #72]	@ 0x48
 8002fd6:	430a      	orrs	r2, r1
 8002fd8:	431a      	orrs	r2, r3
 8002fda:	687b      	ldr	r3, [r7, #4]
 8002fdc:	681b      	ldr	r3, [r3, #0]
 8002fde:	f042 0201 	orr.w	r2, r2, #1
 8002fe2:	611a      	str	r2, [r3, #16]
 8002fe4:	e007      	b.n	8002ff6 <HAL_ADC_Init+0x21a>

      }
      else
      {
        /* Disable ADC oversampling scope on ADC group regular */
        CLEAR_BIT(hadc->Instance->CFGR2, ADC_CFGR2_ROVSE);
 8002fe6:	687b      	ldr	r3, [r7, #4]
 8002fe8:	681b      	ldr	r3, [r3, #0]
 8002fea:	691a      	ldr	r2, [r3, #16]
 8002fec:	687b      	ldr	r3, [r7, #4]
 8002fee:	681b      	ldr	r3, [r3, #0]
 8002ff0:	f022 0201 	bic.w	r2, r2, #1
 8002ff4:	611a      	str	r2, [r3, #16]
      }

      /* Set the LeftShift parameter: it is applied to the final result with or without oversampling */
      MODIFY_REG(hadc->Instance->CFGR2, ADC_CFGR2_LSHIFT, hadc->Init.LeftBitShift);
 8002ff6:	687b      	ldr	r3, [r7, #4]
 8002ff8:	681b      	ldr	r3, [r3, #0]
 8002ffa:	691b      	ldr	r3, [r3, #16]
 8002ffc:	f023 4170 	bic.w	r1, r3, #4026531840	@ 0xf0000000
 8003000:	687b      	ldr	r3, [r7, #4]
 8003002:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 8003004:	687b      	ldr	r3, [r7, #4]
 8003006:	681b      	ldr	r3, [r3, #0]
 8003008:	430a      	orrs	r2, r1
 800300a:	611a      	str	r2, [r3, #16]
        /* Configure the BOOST Mode */
        ADC_ConfigureBoostMode(hadc);
      }
#else
      /* Configure the BOOST Mode */
      ADC_ConfigureBoostMode(hadc);
 800300c:	6878      	ldr	r0, [r7, #4]
 800300e:	f000 fd61 	bl	8003ad4 <ADC_ConfigureBoostMode>
    /*   Note: Scan mode is not present by hardware on this device, but       */
    /*   emulated by software for alignment over all STM32 devices.           */
    /* - if scan mode is enabled, regular channels sequence length is set to  */
    /*   parameter "NbrOfConversion".                                         */

    if (hadc->Init.ScanConvMode == ADC_SCAN_ENABLE)
 8003012:	687b      	ldr	r3, [r7, #4]
 8003014:	68db      	ldr	r3, [r3, #12]
 8003016:	2b01      	cmp	r3, #1
 8003018:	d10c      	bne.n	8003034 <HAL_ADC_Init+0x258>
    {
      /* Set number of ranks in regular group sequencer */
      MODIFY_REG(hadc->Instance->SQR1, ADC_SQR1_L, (hadc->Init.NbrOfConversion - (uint8_t)1));
 800301a:	687b      	ldr	r3, [r7, #4]
 800301c:	681b      	ldr	r3, [r3, #0]
 800301e:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8003020:	f023 010f 	bic.w	r1, r3, #15
 8003024:	687b      	ldr	r3, [r7, #4]
 8003026:	699b      	ldr	r3, [r3, #24]
 8003028:	1e5a      	subs	r2, r3, #1
 800302a:	687b      	ldr	r3, [r7, #4]
 800302c:	681b      	ldr	r3, [r3, #0]
 800302e:	430a      	orrs	r2, r1
 8003030:	631a      	str	r2, [r3, #48]	@ 0x30
 8003032:	e007      	b.n	8003044 <HAL_ADC_Init+0x268>
    }
    else
    {
      CLEAR_BIT(hadc->Instance->SQR1, ADC_SQR1_L);
 8003034:	687b      	ldr	r3, [r7, #4]
 8003036:	681b      	ldr	r3, [r3, #0]
 8003038:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 800303a:	687b      	ldr	r3, [r7, #4]
 800303c:	681b      	ldr	r3, [r3, #0]
 800303e:	f022 020f 	bic.w	r2, r2, #15
 8003042:	631a      	str	r2, [r3, #48]	@ 0x30
    }

    /* Initialize the ADC state */
    /* Clear HAL_ADC_STATE_BUSY_INTERNAL bit, set HAL_ADC_STATE_READY bit */
    ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_BUSY_INTERNAL, HAL_ADC_STATE_READY);
 8003044:	687b      	ldr	r3, [r7, #4]
 8003046:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8003048:	f023 0303 	bic.w	r3, r3, #3
 800304c:	f043 0201 	orr.w	r2, r3, #1
 8003050:	687b      	ldr	r3, [r7, #4]
 8003052:	655a      	str	r2, [r3, #84]	@ 0x54
 8003054:	e007      	b.n	8003066 <HAL_ADC_Init+0x28a>
  }
  else
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8003056:	687b      	ldr	r3, [r7, #4]
 8003058:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 800305a:	f043 0210 	orr.w	r2, r3, #16
 800305e:	687b      	ldr	r3, [r7, #4]
 8003060:	655a      	str	r2, [r3, #84]	@ 0x54

    tmp_hal_status = HAL_ERROR;
 8003062:	2301      	movs	r3, #1
 8003064:	77fb      	strb	r3, [r7, #31]
  }

  /* Return function status */
  return tmp_hal_status;
 8003066:	7ffb      	ldrb	r3, [r7, #31]
}
 8003068:	4618      	mov	r0, r3
 800306a:	3724      	adds	r7, #36	@ 0x24
 800306c:	46bd      	mov	sp, r7
 800306e:	bd90      	pop	{r4, r7, pc}
 8003070:	2400011c 	.word	0x2400011c
 8003074:	053e2d63 	.word	0x053e2d63
 8003078:	40022000 	.word	0x40022000
 800307c:	40022100 	.word	0x40022100
 8003080:	40022300 	.word	0x40022300
 8003084:	fff0c003 	.word	0xfff0c003
 8003088:	ffffbffc 	.word	0xffffbffc
 800308c:	fc00f81e 	.word	0xfc00f81e

08003090 <HAL_ADC_Start_DMA>:
  * @param pData Destination Buffer address.
  * @param Length Number of data to be transferred from ADC peripheral to memory
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_ADC_Start_DMA(ADC_HandleTypeDef *hadc, uint32_t *pData, uint32_t Length)
{
 8003090:	b580      	push	{r7, lr}
 8003092:	b086      	sub	sp, #24
 8003094:	af00      	add	r7, sp, #0
 8003096:	60f8      	str	r0, [r7, #12]
 8003098:	60b9      	str	r1, [r7, #8]
 800309a:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef tmp_hal_status;
  uint32_t tmp_multimode_config = LL_ADC_GetMultimode(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
 800309c:	484f      	ldr	r0, [pc, #316]	@ (80031dc <HAL_ADC_Start_DMA+0x14c>)
 800309e:	f7ff fdb9 	bl	8002c14 <LL_ADC_GetMultimode>
 80030a2:	6138      	str	r0, [r7, #16]

  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));

  /* Perform ADC enable and conversion start if no conversion is on going */
  if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 0UL)
 80030a4:	68fb      	ldr	r3, [r7, #12]
 80030a6:	681b      	ldr	r3, [r3, #0]
 80030a8:	4618      	mov	r0, r3
 80030aa:	f7ff fe71 	bl	8002d90 <LL_ADC_REG_IsConversionOngoing>
 80030ae:	4603      	mov	r3, r0
 80030b0:	2b00      	cmp	r3, #0
 80030b2:	f040 808c 	bne.w	80031ce <HAL_ADC_Start_DMA+0x13e>
  {
    /* Process locked */
    __HAL_LOCK(hadc);
 80030b6:	68fb      	ldr	r3, [r7, #12]
 80030b8:	f893 3050 	ldrb.w	r3, [r3, #80]	@ 0x50
 80030bc:	2b01      	cmp	r3, #1
 80030be:	d101      	bne.n	80030c4 <HAL_ADC_Start_DMA+0x34>
 80030c0:	2302      	movs	r3, #2
 80030c2:	e087      	b.n	80031d4 <HAL_ADC_Start_DMA+0x144>
 80030c4:	68fb      	ldr	r3, [r7, #12]
 80030c6:	2201      	movs	r2, #1
 80030c8:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50

    /* Ensure that multimode regular conversions are not enabled.   */
    /* Otherwise, dedicated API HAL_ADCEx_MultiModeStart_DMA() must be used.  */
    if ((tmp_multimode_config == LL_ADC_MULTI_INDEPENDENT)
 80030cc:	693b      	ldr	r3, [r7, #16]
 80030ce:	2b00      	cmp	r3, #0
 80030d0:	d005      	beq.n	80030de <HAL_ADC_Start_DMA+0x4e>
        || (tmp_multimode_config == LL_ADC_MULTI_DUAL_INJ_SIMULT)
 80030d2:	693b      	ldr	r3, [r7, #16]
 80030d4:	2b05      	cmp	r3, #5
 80030d6:	d002      	beq.n	80030de <HAL_ADC_Start_DMA+0x4e>
        || (tmp_multimode_config == LL_ADC_MULTI_DUAL_INJ_ALTERN)
 80030d8:	693b      	ldr	r3, [r7, #16]
 80030da:	2b09      	cmp	r3, #9
 80030dc:	d170      	bne.n	80031c0 <HAL_ADC_Start_DMA+0x130>
       )
    {
      /* Enable the ADC peripheral */
      tmp_hal_status = ADC_Enable(hadc);
 80030de:	68f8      	ldr	r0, [r7, #12]
 80030e0:	f000 fb88 	bl	80037f4 <ADC_Enable>
 80030e4:	4603      	mov	r3, r0
 80030e6:	75fb      	strb	r3, [r7, #23]

      /* Start conversion if ADC is effectively enabled */
      if (tmp_hal_status == HAL_OK)
 80030e8:	7dfb      	ldrb	r3, [r7, #23]
 80030ea:	2b00      	cmp	r3, #0
 80030ec:	d163      	bne.n	80031b6 <HAL_ADC_Start_DMA+0x126>
      {
        /* Set ADC state                                                        */
        /* - Clear state bitfield related to regular group conversion results   */
        /* - Set state bitfield related to regular operation                    */
        ADC_STATE_CLR_SET(hadc->State,
 80030ee:	68fb      	ldr	r3, [r7, #12]
 80030f0:	6d5a      	ldr	r2, [r3, #84]	@ 0x54
 80030f2:	4b3b      	ldr	r3, [pc, #236]	@ (80031e0 <HAL_ADC_Start_DMA+0x150>)
 80030f4:	4013      	ands	r3, r2
 80030f6:	f443 7280 	orr.w	r2, r3, #256	@ 0x100
 80030fa:	68fb      	ldr	r3, [r7, #12]
 80030fc:	655a      	str	r2, [r3, #84]	@ 0x54
                          HAL_ADC_STATE_REG_BUSY);

        /* Reset HAL_ADC_STATE_MULTIMODE_SLAVE bit
          - if ADC instance is master or if multimode feature is not available
          - if multimode setting is disabled (ADC instance slave in independent mode) */
        if ((__LL_ADC_MULTI_INSTANCE_MASTER(hadc->Instance) == hadc->Instance)
 80030fe:	68fb      	ldr	r3, [r7, #12]
 8003100:	681b      	ldr	r3, [r3, #0]
 8003102:	4a38      	ldr	r2, [pc, #224]	@ (80031e4 <HAL_ADC_Start_DMA+0x154>)
 8003104:	4293      	cmp	r3, r2
 8003106:	d002      	beq.n	800310e <HAL_ADC_Start_DMA+0x7e>
 8003108:	68fb      	ldr	r3, [r7, #12]
 800310a:	681b      	ldr	r3, [r3, #0]
 800310c:	e000      	b.n	8003110 <HAL_ADC_Start_DMA+0x80>
 800310e:	4b36      	ldr	r3, [pc, #216]	@ (80031e8 <HAL_ADC_Start_DMA+0x158>)
 8003110:	68fa      	ldr	r2, [r7, #12]
 8003112:	6812      	ldr	r2, [r2, #0]
 8003114:	4293      	cmp	r3, r2
 8003116:	d002      	beq.n	800311e <HAL_ADC_Start_DMA+0x8e>
            || (tmp_multimode_config == LL_ADC_MULTI_INDEPENDENT)
 8003118:	693b      	ldr	r3, [r7, #16]
 800311a:	2b00      	cmp	r3, #0
 800311c:	d105      	bne.n	800312a <HAL_ADC_Start_DMA+0x9a>
           )
        {
          CLEAR_BIT(hadc->State, HAL_ADC_STATE_MULTIMODE_SLAVE);
 800311e:	68fb      	ldr	r3, [r7, #12]
 8003120:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8003122:	f423 1280 	bic.w	r2, r3, #1048576	@ 0x100000
 8003126:	68fb      	ldr	r3, [r7, #12]
 8003128:	655a      	str	r2, [r3, #84]	@ 0x54
        }

        /* Check if a conversion is on going on ADC group injected */
        if ((hadc->State & HAL_ADC_STATE_INJ_BUSY) != 0UL)
 800312a:	68fb      	ldr	r3, [r7, #12]
 800312c:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 800312e:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
 8003132:	2b00      	cmp	r3, #0
 8003134:	d006      	beq.n	8003144 <HAL_ADC_Start_DMA+0xb4>
        {
          /* Reset ADC error code fields related to regular conversions only */
          CLEAR_BIT(hadc->ErrorCode, (HAL_ADC_ERROR_OVR | HAL_ADC_ERROR_DMA));
 8003136:	68fb      	ldr	r3, [r7, #12]
 8003138:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 800313a:	f023 0206 	bic.w	r2, r3, #6
 800313e:	68fb      	ldr	r3, [r7, #12]
 8003140:	659a      	str	r2, [r3, #88]	@ 0x58
 8003142:	e002      	b.n	800314a <HAL_ADC_Start_DMA+0xba>
        }
        else
        {
          /* Reset all ADC error code fields */
          ADC_CLEAR_ERRORCODE(hadc);
 8003144:	68fb      	ldr	r3, [r7, #12]
 8003146:	2200      	movs	r2, #0
 8003148:	659a      	str	r2, [r3, #88]	@ 0x58
        }

        /* Set the DMA transfer complete callback */
        hadc->DMA_Handle->XferCpltCallback = ADC_DMAConvCplt;
 800314a:	68fb      	ldr	r3, [r7, #12]
 800314c:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 800314e:	4a27      	ldr	r2, [pc, #156]	@ (80031ec <HAL_ADC_Start_DMA+0x15c>)
 8003150:	63da      	str	r2, [r3, #60]	@ 0x3c

        /* Set the DMA half transfer complete callback */
        hadc->DMA_Handle->XferHalfCpltCallback = ADC_DMAHalfConvCplt;
 8003152:	68fb      	ldr	r3, [r7, #12]
 8003154:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 8003156:	4a26      	ldr	r2, [pc, #152]	@ (80031f0 <HAL_ADC_Start_DMA+0x160>)
 8003158:	641a      	str	r2, [r3, #64]	@ 0x40

        /* Set the DMA error callback */
        hadc->DMA_Handle->XferErrorCallback = ADC_DMAError;
 800315a:	68fb      	ldr	r3, [r7, #12]
 800315c:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 800315e:	4a25      	ldr	r2, [pc, #148]	@ (80031f4 <HAL_ADC_Start_DMA+0x164>)
 8003160:	64da      	str	r2, [r3, #76]	@ 0x4c
        /* ADC start (in case of SW start):                                   */

        /* Clear regular group conversion flag and overrun flag               */
        /* (To ensure of no unknown state from potential previous ADC         */
        /* operations)                                                        */
        __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS | ADC_FLAG_OVR));
 8003162:	68fb      	ldr	r3, [r7, #12]
 8003164:	681b      	ldr	r3, [r3, #0]
 8003166:	221c      	movs	r2, #28
 8003168:	601a      	str	r2, [r3, #0]

        /* Process unlocked */
        /* Unlock before starting ADC conversions: in case of potential         */
        /* interruption, to let the process to ADC IRQ Handler.                 */
        __HAL_UNLOCK(hadc);
 800316a:	68fb      	ldr	r3, [r7, #12]
 800316c:	2200      	movs	r2, #0
 800316e:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50

        /* With DMA, overrun event is always considered as an error even if
           hadc->Init.Overrun is set to ADC_OVR_DATA_OVERWRITTEN. Therefore,
           ADC_IT_OVR is enabled. */
        __HAL_ADC_ENABLE_IT(hadc, ADC_IT_OVR);
 8003172:	68fb      	ldr	r3, [r7, #12]
 8003174:	681b      	ldr	r3, [r3, #0]
 8003176:	685a      	ldr	r2, [r3, #4]
 8003178:	68fb      	ldr	r3, [r7, #12]
 800317a:	681b      	ldr	r3, [r3, #0]
 800317c:	f042 0210 	orr.w	r2, r2, #16
 8003180:	605a      	str	r2, [r3, #4]
        {
          LL_ADC_REG_SetDataTransferMode(hadc->Instance, ADC_CFGR_DMACONTREQ((uint32_t)hadc->Init.ConversionDataManagement));
        }

#else
        LL_ADC_REG_SetDataTransferMode(hadc->Instance, (uint32_t)hadc->Init.ConversionDataManagement);
 8003182:	68fb      	ldr	r3, [r7, #12]
 8003184:	681a      	ldr	r2, [r3, #0]
 8003186:	68fb      	ldr	r3, [r7, #12]
 8003188:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800318a:	4619      	mov	r1, r3
 800318c:	4610      	mov	r0, r2
 800318e:	f7ff fcde 	bl	8002b4e <LL_ADC_REG_SetDataTransferMode>
#endif


        /* Start the DMA channel */
        tmp_hal_status = HAL_DMA_Start_IT(hadc->DMA_Handle, (uint32_t)&hadc->Instance->DR, (uint32_t)pData, Length);
 8003192:	68fb      	ldr	r3, [r7, #12]
 8003194:	6cd8      	ldr	r0, [r3, #76]	@ 0x4c
 8003196:	68fb      	ldr	r3, [r7, #12]
 8003198:	681b      	ldr	r3, [r3, #0]
 800319a:	3340      	adds	r3, #64	@ 0x40
 800319c:	4619      	mov	r1, r3
 800319e:	68ba      	ldr	r2, [r7, #8]
 80031a0:	687b      	ldr	r3, [r7, #4]
 80031a2:	f001 fbd5 	bl	8004950 <HAL_DMA_Start_IT>
 80031a6:	4603      	mov	r3, r0
 80031a8:	75fb      	strb	r3, [r7, #23]
        /* Enable conversion of regular group.                                  */
        /* If software start has been selected, conversion starts immediately.  */
        /* If external trigger has been selected, conversion will start at next */
        /* trigger event.                                                       */
        /* Start ADC group regular conversion */
        LL_ADC_REG_StartConversion(hadc->Instance);
 80031aa:	68fb      	ldr	r3, [r7, #12]
 80031ac:	681b      	ldr	r3, [r3, #0]
 80031ae:	4618      	mov	r0, r3
 80031b0:	f7ff fdda 	bl	8002d68 <LL_ADC_REG_StartConversion>
      if (tmp_hal_status == HAL_OK)
 80031b4:	e00d      	b.n	80031d2 <HAL_ADC_Start_DMA+0x142>
      }
      else
      {
        /* Process unlocked */
        __HAL_UNLOCK(hadc);
 80031b6:	68fb      	ldr	r3, [r7, #12]
 80031b8:	2200      	movs	r2, #0
 80031ba:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50
      if (tmp_hal_status == HAL_OK)
 80031be:	e008      	b.n	80031d2 <HAL_ADC_Start_DMA+0x142>
      }

    }
    else
    {
      tmp_hal_status = HAL_ERROR;
 80031c0:	2301      	movs	r3, #1
 80031c2:	75fb      	strb	r3, [r7, #23]
      /* Process unlocked */
      __HAL_UNLOCK(hadc);
 80031c4:	68fb      	ldr	r3, [r7, #12]
 80031c6:	2200      	movs	r2, #0
 80031c8:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50
 80031cc:	e001      	b.n	80031d2 <HAL_ADC_Start_DMA+0x142>
    }
  }
  else
  {
    tmp_hal_status = HAL_BUSY;
 80031ce:	2302      	movs	r3, #2
 80031d0:	75fb      	strb	r3, [r7, #23]
  }

  /* Return function status */
  return tmp_hal_status;
 80031d2:	7dfb      	ldrb	r3, [r7, #23]
}
 80031d4:	4618      	mov	r0, r3
 80031d6:	3718      	adds	r7, #24
 80031d8:	46bd      	mov	sp, r7
 80031da:	bd80      	pop	{r7, pc}
 80031dc:	40022300 	.word	0x40022300
 80031e0:	fffff0fe 	.word	0xfffff0fe
 80031e4:	40022100 	.word	0x40022100
 80031e8:	40022000 	.word	0x40022000
 80031ec:	080039ab 	.word	0x080039ab
 80031f0:	08003a83 	.word	0x08003a83
 80031f4:	08003a9f 	.word	0x08003a9f

080031f8 <HAL_ADC_ConvHalfCpltCallback>:
  * @brief  Conversion DMA half-transfer callback in non-blocking mode.
  * @param hadc ADC handle
  * @retval None
  */
__weak void HAL_ADC_ConvHalfCpltCallback(ADC_HandleTypeDef *hadc)
{
 80031f8:	b480      	push	{r7}
 80031fa:	b083      	sub	sp, #12
 80031fc:	af00      	add	r7, sp, #0
 80031fe:	6078      	str	r0, [r7, #4]
  UNUSED(hadc);

  /* NOTE : This function should not be modified. When the callback is needed,
            function HAL_ADC_ConvHalfCpltCallback must be implemented in the user file.
  */
}
 8003200:	bf00      	nop
 8003202:	370c      	adds	r7, #12
 8003204:	46bd      	mov	sp, r7
 8003206:	f85d 7b04 	ldr.w	r7, [sp], #4
 800320a:	4770      	bx	lr

0800320c <HAL_ADC_ErrorCallback>:
  *           (this function is also clearing overrun flag)
  * @param hadc ADC handle
  * @retval None
  */
__weak void HAL_ADC_ErrorCallback(ADC_HandleTypeDef *hadc)
{
 800320c:	b480      	push	{r7}
 800320e:	b083      	sub	sp, #12
 8003210:	af00      	add	r7, sp, #0
 8003212:	6078      	str	r0, [r7, #4]
  UNUSED(hadc);

  /* NOTE : This function should not be modified. When the callback is needed,
            function HAL_ADC_ErrorCallback must be implemented in the user file.
  */
}
 8003214:	bf00      	nop
 8003216:	370c      	adds	r7, #12
 8003218:	46bd      	mov	sp, r7
 800321a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800321e:	4770      	bx	lr

08003220 <HAL_ADC_ConfigChannel>:
  * @param hadc ADC handle
  * @param sConfig Structure of ADC channel assigned to ADC group regular.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_ConfigChannel(ADC_HandleTypeDef *hadc, ADC_ChannelConfTypeDef *sConfig)
{
 8003220:	b590      	push	{r4, r7, lr}
 8003222:	b0a1      	sub	sp, #132	@ 0x84
 8003224:	af00      	add	r7, sp, #0
 8003226:	6078      	str	r0, [r7, #4]
 8003228:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 800322a:	2300      	movs	r3, #0
 800322c:	f887 307f 	strb.w	r3, [r7, #127]	@ 0x7f
  uint32_t tmpOffsetShifted;
  uint32_t tmp_config_internal_channel;
  __IO uint32_t wait_loop_index = 0;
 8003230:	2300      	movs	r3, #0
 8003232:	60bb      	str	r3, [r7, #8]
  /* if ROVSE is set, the value of the OFFSETy_EN bit in ADCx_OFRy register is
     ignored (considered as reset) */
  assert_param(!((sConfig->OffsetNumber != ADC_OFFSET_NONE) && (hadc->Init.OversamplingMode == ENABLE)));

  /* Verification of channel number */
  if (sConfig->SingleDiff != ADC_DIFFERENTIAL_ENDED)
 8003234:	683b      	ldr	r3, [r7, #0]
 8003236:	68db      	ldr	r3, [r3, #12]
 8003238:	4a95      	ldr	r2, [pc, #596]	@ (8003490 <HAL_ADC_ConfigChannel+0x270>)
 800323a:	4293      	cmp	r3, r2
    }
#endif
  }

  /* Process locked */
  __HAL_LOCK(hadc);
 800323c:	687b      	ldr	r3, [r7, #4]
 800323e:	f893 3050 	ldrb.w	r3, [r3, #80]	@ 0x50
 8003242:	2b01      	cmp	r3, #1
 8003244:	d101      	bne.n	800324a <HAL_ADC_ConfigChannel+0x2a>
 8003246:	2302      	movs	r3, #2
 8003248:	e2c0      	b.n	80037cc <HAL_ADC_ConfigChannel+0x5ac>
 800324a:	687b      	ldr	r3, [r7, #4]
 800324c:	2201      	movs	r2, #1
 800324e:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50
  /* Parameters update conditioned to ADC state:                              */
  /* Parameters that can be updated when ADC is disabled or enabled without   */
  /* conversion on going on regular group:                                    */
  /*  - Channel number                                                        */
  /*  - Channel rank                                                          */
  if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 0UL)
 8003252:	687b      	ldr	r3, [r7, #4]
 8003254:	681b      	ldr	r3, [r3, #0]
 8003256:	4618      	mov	r0, r3
 8003258:	f7ff fd9a 	bl	8002d90 <LL_ADC_REG_IsConversionOngoing>
 800325c:	4603      	mov	r3, r0
 800325e:	2b00      	cmp	r3, #0
 8003260:	f040 82a5 	bne.w	80037ae <HAL_ADC_ConfigChannel+0x58e>
  {
    if (!(__LL_ADC_IS_CHANNEL_INTERNAL(sConfig->Channel)))
 8003264:	683b      	ldr	r3, [r7, #0]
 8003266:	681b      	ldr	r3, [r3, #0]
 8003268:	2b00      	cmp	r3, #0
 800326a:	db2c      	blt.n	80032c6 <HAL_ADC_ConfigChannel+0xa6>
        /* ADC channels preselection */
        hadc->Instance->PCSEL_RES0 |= (1UL << (__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) & 0x1FUL));
      }
#else
      /* ADC channels preselection */
      hadc->Instance->PCSEL |= (1UL << (__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) & 0x1FUL));
 800326c:	683b      	ldr	r3, [r7, #0]
 800326e:	681b      	ldr	r3, [r3, #0]
 8003270:	f3c3 0313 	ubfx	r3, r3, #0, #20
 8003274:	2b00      	cmp	r3, #0
 8003276:	d108      	bne.n	800328a <HAL_ADC_ConfigChannel+0x6a>
 8003278:	683b      	ldr	r3, [r7, #0]
 800327a:	681b      	ldr	r3, [r3, #0]
 800327c:	0e9b      	lsrs	r3, r3, #26
 800327e:	f003 031f 	and.w	r3, r3, #31
 8003282:	2201      	movs	r2, #1
 8003284:	fa02 f303 	lsl.w	r3, r2, r3
 8003288:	e016      	b.n	80032b8 <HAL_ADC_ConfigChannel+0x98>
 800328a:	683b      	ldr	r3, [r7, #0]
 800328c:	681b      	ldr	r3, [r3, #0]
 800328e:	667b      	str	r3, [r7, #100]	@ 0x64
  uint32_t result;

#if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
     (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
     (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8003290:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8003292:	fa93 f3a3 	rbit	r3, r3
 8003296:	663b      	str	r3, [r7, #96]	@ 0x60
    result |= value & 1U;
    s--;
  }
  result <<= s;                        /* shift when v's highest bits are zero */
#endif
  return result;
 8003298:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 800329a:	66bb      	str	r3, [r7, #104]	@ 0x68
     optimisations using the logic "value was passed to __builtin_clz, so it
     is non-zero".
     ARM GCC 7.3 and possibly earlier will optimise this test away, leaving a
     single CLZ instruction.
   */
  if (value == 0U)
 800329c:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 800329e:	2b00      	cmp	r3, #0
 80032a0:	d101      	bne.n	80032a6 <HAL_ADC_ConfigChannel+0x86>
  {
    return 32U;
 80032a2:	2320      	movs	r3, #32
 80032a4:	e003      	b.n	80032ae <HAL_ADC_ConfigChannel+0x8e>
  }
  return __builtin_clz(value);
 80032a6:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 80032a8:	fab3 f383 	clz	r3, r3
 80032ac:	b2db      	uxtb	r3, r3
 80032ae:	f003 031f 	and.w	r3, r3, #31
 80032b2:	2201      	movs	r2, #1
 80032b4:	fa02 f303 	lsl.w	r3, r2, r3
 80032b8:	687a      	ldr	r2, [r7, #4]
 80032ba:	6812      	ldr	r2, [r2, #0]
 80032bc:	69d1      	ldr	r1, [r2, #28]
 80032be:	687a      	ldr	r2, [r7, #4]
 80032c0:	6812      	ldr	r2, [r2, #0]
 80032c2:	430b      	orrs	r3, r1
 80032c4:	61d3      	str	r3, [r2, #28]
#endif /* ADC_VER_V5_V90 */
    }

    /* Set ADC group regular sequence: channel on the selected scan sequence rank */
    LL_ADC_REG_SetSequencerRanks(hadc->Instance, sConfig->Rank, sConfig->Channel);
 80032c6:	687b      	ldr	r3, [r7, #4]
 80032c8:	6818      	ldr	r0, [r3, #0]
 80032ca:	683b      	ldr	r3, [r7, #0]
 80032cc:	6859      	ldr	r1, [r3, #4]
 80032ce:	683b      	ldr	r3, [r7, #0]
 80032d0:	681b      	ldr	r3, [r3, #0]
 80032d2:	461a      	mov	r2, r3
 80032d4:	f7ff fc0f 	bl	8002af6 <LL_ADC_REG_SetSequencerRanks>
    /* Parameters update conditioned to ADC state:                              */
    /* Parameters that can be updated when ADC is disabled or enabled without   */
    /* conversion on going on regular group:                                    */
    /*  - Channel sampling time                                                 */
    /*  - Channel offset                                                        */
    tmp_adc_is_conversion_on_going_regular = LL_ADC_REG_IsConversionOngoing(hadc->Instance);
 80032d8:	687b      	ldr	r3, [r7, #4]
 80032da:	681b      	ldr	r3, [r3, #0]
 80032dc:	4618      	mov	r0, r3
 80032de:	f7ff fd57 	bl	8002d90 <LL_ADC_REG_IsConversionOngoing>
 80032e2:	67b8      	str	r0, [r7, #120]	@ 0x78
    tmp_adc_is_conversion_on_going_injected = LL_ADC_INJ_IsConversionOngoing(hadc->Instance);
 80032e4:	687b      	ldr	r3, [r7, #4]
 80032e6:	681b      	ldr	r3, [r3, #0]
 80032e8:	4618      	mov	r0, r3
 80032ea:	f7ff fd64 	bl	8002db6 <LL_ADC_INJ_IsConversionOngoing>
 80032ee:	6778      	str	r0, [r7, #116]	@ 0x74
    if ((tmp_adc_is_conversion_on_going_regular == 0UL)
 80032f0:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 80032f2:	2b00      	cmp	r3, #0
 80032f4:	f040 80a0 	bne.w	8003438 <HAL_ADC_ConfigChannel+0x218>
        && (tmp_adc_is_conversion_on_going_injected == 0UL)
 80032f8:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 80032fa:	2b00      	cmp	r3, #0
 80032fc:	f040 809c 	bne.w	8003438 <HAL_ADC_ConfigChannel+0x218>
       )
    {
      /* Set sampling time of the selected ADC channel */
      LL_ADC_SetChannelSamplingTime(hadc->Instance, sConfig->Channel, sConfig->SamplingTime);
 8003300:	687b      	ldr	r3, [r7, #4]
 8003302:	6818      	ldr	r0, [r3, #0]
 8003304:	683b      	ldr	r3, [r7, #0]
 8003306:	6819      	ldr	r1, [r3, #0]
 8003308:	683b      	ldr	r3, [r7, #0]
 800330a:	689b      	ldr	r3, [r3, #8]
 800330c:	461a      	mov	r2, r3
 800330e:	f7ff fc31 	bl	8002b74 <LL_ADC_SetChannelSamplingTime>
        tmpOffsetShifted = ADC3_OFFSET_SHIFT_RESOLUTION(hadc, (uint32_t)sConfig->Offset);
      }
      else
#endif /* ADC_VER_V5_V90 */
      {
        tmpOffsetShifted = ADC_OFFSET_SHIFT_RESOLUTION(hadc, (uint32_t)sConfig->Offset);
 8003312:	687b      	ldr	r3, [r7, #4]
 8003314:	681b      	ldr	r3, [r3, #0]
 8003316:	68db      	ldr	r3, [r3, #12]
 8003318:	f003 0310 	and.w	r3, r3, #16
 800331c:	2b00      	cmp	r3, #0
 800331e:	d10b      	bne.n	8003338 <HAL_ADC_ConfigChannel+0x118>
 8003320:	683b      	ldr	r3, [r7, #0]
 8003322:	695a      	ldr	r2, [r3, #20]
 8003324:	687b      	ldr	r3, [r7, #4]
 8003326:	681b      	ldr	r3, [r3, #0]
 8003328:	68db      	ldr	r3, [r3, #12]
 800332a:	089b      	lsrs	r3, r3, #2
 800332c:	f003 0307 	and.w	r3, r3, #7
 8003330:	005b      	lsls	r3, r3, #1
 8003332:	fa02 f303 	lsl.w	r3, r2, r3
 8003336:	e00a      	b.n	800334e <HAL_ADC_ConfigChannel+0x12e>
 8003338:	683b      	ldr	r3, [r7, #0]
 800333a:	695a      	ldr	r2, [r3, #20]
 800333c:	687b      	ldr	r3, [r7, #4]
 800333e:	681b      	ldr	r3, [r3, #0]
 8003340:	68db      	ldr	r3, [r3, #12]
 8003342:	089b      	lsrs	r3, r3, #2
 8003344:	f003 0304 	and.w	r3, r3, #4
 8003348:	005b      	lsls	r3, r3, #1
 800334a:	fa02 f303 	lsl.w	r3, r2, r3
 800334e:	673b      	str	r3, [r7, #112]	@ 0x70
      }
      
      if (sConfig->OffsetNumber != ADC_OFFSET_NONE)
 8003350:	683b      	ldr	r3, [r7, #0]
 8003352:	691b      	ldr	r3, [r3, #16]
 8003354:	2b04      	cmp	r3, #4
 8003356:	d027      	beq.n	80033a8 <HAL_ADC_ConfigChannel+0x188>
      {
        /* Set ADC selected offset number */
        LL_ADC_SetOffset(hadc->Instance, sConfig->OffsetNumber, sConfig->Channel, tmpOffsetShifted);
 8003358:	687b      	ldr	r3, [r7, #4]
 800335a:	6818      	ldr	r0, [r3, #0]
 800335c:	683b      	ldr	r3, [r7, #0]
 800335e:	6919      	ldr	r1, [r3, #16]
 8003360:	683b      	ldr	r3, [r7, #0]
 8003362:	681a      	ldr	r2, [r3, #0]
 8003364:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 8003366:	f7ff fb5f 	bl	8002a28 <LL_ADC_SetOffset>
        else
#endif /* ADC_VER_V5_V90 */
        {
          assert_param(IS_FUNCTIONAL_STATE(sConfig->OffsetSignedSaturation));
          /* Set ADC selected offset signed saturation */
          LL_ADC_SetOffsetSignedSaturation(hadc->Instance, sConfig->OffsetNumber, (sConfig->OffsetSignedSaturation == ENABLE) ? LL_ADC_OFFSET_SIGNED_SATURATION_ENABLE : LL_ADC_OFFSET_SIGNED_SATURATION_DISABLE);
 800336a:	687b      	ldr	r3, [r7, #4]
 800336c:	6818      	ldr	r0, [r3, #0]
 800336e:	683b      	ldr	r3, [r7, #0]
 8003370:	6919      	ldr	r1, [r3, #16]
 8003372:	683b      	ldr	r3, [r7, #0]
 8003374:	7e5b      	ldrb	r3, [r3, #25]
 8003376:	2b01      	cmp	r3, #1
 8003378:	d102      	bne.n	8003380 <HAL_ADC_ConfigChannel+0x160>
 800337a:	f04f 4300 	mov.w	r3, #2147483648	@ 0x80000000
 800337e:	e000      	b.n	8003382 <HAL_ADC_ConfigChannel+0x162>
 8003380:	2300      	movs	r3, #0
 8003382:	461a      	mov	r2, r3
 8003384:	f7ff fb89 	bl	8002a9a <LL_ADC_SetOffsetSignedSaturation>

          assert_param(IS_FUNCTIONAL_STATE(sConfig->OffsetRightShift));
          /* Set ADC selected offset right shift */
          LL_ADC_SetDataRightShift(hadc->Instance, sConfig->OffsetNumber, (sConfig->OffsetRightShift == ENABLE) ? LL_ADC_OFFSET_RSHIFT_ENABLE : LL_ADC_OFFSET_RSHIFT_DISABLE);
 8003388:	687b      	ldr	r3, [r7, #4]
 800338a:	6818      	ldr	r0, [r3, #0]
 800338c:	683b      	ldr	r3, [r7, #0]
 800338e:	6919      	ldr	r1, [r3, #16]
 8003390:	683b      	ldr	r3, [r7, #0]
 8003392:	7e1b      	ldrb	r3, [r3, #24]
 8003394:	2b01      	cmp	r3, #1
 8003396:	d102      	bne.n	800339e <HAL_ADC_ConfigChannel+0x17e>
 8003398:	f44f 6300 	mov.w	r3, #2048	@ 0x800
 800339c:	e000      	b.n	80033a0 <HAL_ADC_ConfigChannel+0x180>
 800339e:	2300      	movs	r3, #0
 80033a0:	461a      	mov	r2, r3
 80033a2:	f7ff fb61 	bl	8002a68 <LL_ADC_SetDataRightShift>
 80033a6:	e047      	b.n	8003438 <HAL_ADC_ConfigChannel+0x218>
          }
        }
        else
#endif /* ADC_VER_V5_V90 */
        {
          if (((hadc->Instance->OFR1) & ADC_OFR1_OFFSET1_CH) == ADC_OFR_CHANNEL(sConfig->Channel))
 80033a8:	687b      	ldr	r3, [r7, #4]
 80033aa:	681b      	ldr	r3, [r3, #0]
 80033ac:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 80033ae:	f003 42f8 	and.w	r2, r3, #2080374784	@ 0x7c000000
 80033b2:	683b      	ldr	r3, [r7, #0]
 80033b4:	681b      	ldr	r3, [r3, #0]
 80033b6:	069b      	lsls	r3, r3, #26
 80033b8:	429a      	cmp	r2, r3
 80033ba:	d107      	bne.n	80033cc <HAL_ADC_ConfigChannel+0x1ac>
          {
            CLEAR_BIT(hadc->Instance->OFR1, ADC_OFR1_SSATE);
 80033bc:	687b      	ldr	r3, [r7, #4]
 80033be:	681b      	ldr	r3, [r3, #0]
 80033c0:	6e1a      	ldr	r2, [r3, #96]	@ 0x60
 80033c2:	687b      	ldr	r3, [r7, #4]
 80033c4:	681b      	ldr	r3, [r3, #0]
 80033c6:	f022 4200 	bic.w	r2, r2, #2147483648	@ 0x80000000
 80033ca:	661a      	str	r2, [r3, #96]	@ 0x60
          }
          if (((hadc->Instance->OFR2) & ADC_OFR2_OFFSET2_CH) == ADC_OFR_CHANNEL(sConfig->Channel))
 80033cc:	687b      	ldr	r3, [r7, #4]
 80033ce:	681b      	ldr	r3, [r3, #0]
 80033d0:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 80033d2:	f003 42f8 	and.w	r2, r3, #2080374784	@ 0x7c000000
 80033d6:	683b      	ldr	r3, [r7, #0]
 80033d8:	681b      	ldr	r3, [r3, #0]
 80033da:	069b      	lsls	r3, r3, #26
 80033dc:	429a      	cmp	r2, r3
 80033de:	d107      	bne.n	80033f0 <HAL_ADC_ConfigChannel+0x1d0>
          {
            CLEAR_BIT(hadc->Instance->OFR2, ADC_OFR2_SSATE);
 80033e0:	687b      	ldr	r3, [r7, #4]
 80033e2:	681b      	ldr	r3, [r3, #0]
 80033e4:	6e5a      	ldr	r2, [r3, #100]	@ 0x64
 80033e6:	687b      	ldr	r3, [r7, #4]
 80033e8:	681b      	ldr	r3, [r3, #0]
 80033ea:	f022 4200 	bic.w	r2, r2, #2147483648	@ 0x80000000
 80033ee:	665a      	str	r2, [r3, #100]	@ 0x64
          }
          if (((hadc->Instance->OFR3) & ADC_OFR3_OFFSET3_CH) == ADC_OFR_CHANNEL(sConfig->Channel))
 80033f0:	687b      	ldr	r3, [r7, #4]
 80033f2:	681b      	ldr	r3, [r3, #0]
 80033f4:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 80033f6:	f003 42f8 	and.w	r2, r3, #2080374784	@ 0x7c000000
 80033fa:	683b      	ldr	r3, [r7, #0]
 80033fc:	681b      	ldr	r3, [r3, #0]
 80033fe:	069b      	lsls	r3, r3, #26
 8003400:	429a      	cmp	r2, r3
 8003402:	d107      	bne.n	8003414 <HAL_ADC_ConfigChannel+0x1f4>
          {
            CLEAR_BIT(hadc->Instance->OFR3, ADC_OFR3_SSATE);
 8003404:	687b      	ldr	r3, [r7, #4]
 8003406:	681b      	ldr	r3, [r3, #0]
 8003408:	6e9a      	ldr	r2, [r3, #104]	@ 0x68
 800340a:	687b      	ldr	r3, [r7, #4]
 800340c:	681b      	ldr	r3, [r3, #0]
 800340e:	f022 4200 	bic.w	r2, r2, #2147483648	@ 0x80000000
 8003412:	669a      	str	r2, [r3, #104]	@ 0x68
          }
          if (((hadc->Instance->OFR4) & ADC_OFR4_OFFSET4_CH) == ADC_OFR_CHANNEL(sConfig->Channel))
 8003414:	687b      	ldr	r3, [r7, #4]
 8003416:	681b      	ldr	r3, [r3, #0]
 8003418:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 800341a:	f003 42f8 	and.w	r2, r3, #2080374784	@ 0x7c000000
 800341e:	683b      	ldr	r3, [r7, #0]
 8003420:	681b      	ldr	r3, [r3, #0]
 8003422:	069b      	lsls	r3, r3, #26
 8003424:	429a      	cmp	r2, r3
 8003426:	d107      	bne.n	8003438 <HAL_ADC_ConfigChannel+0x218>
          {
            CLEAR_BIT(hadc->Instance->OFR4, ADC_OFR4_SSATE);
 8003428:	687b      	ldr	r3, [r7, #4]
 800342a:	681b      	ldr	r3, [r3, #0]
 800342c:	6eda      	ldr	r2, [r3, #108]	@ 0x6c
 800342e:	687b      	ldr	r3, [r7, #4]
 8003430:	681b      	ldr	r3, [r3, #0]
 8003432:	f022 4200 	bic.w	r2, r2, #2147483648	@ 0x80000000
 8003436:	66da      	str	r2, [r3, #108]	@ 0x6c

    /* Parameters update conditioned to ADC state:                              */
    /* Parameters that can be updated only when ADC is disabled:                */
    /*  - Single or differential mode                                           */
    /*  - Internal measurement channels: Vbat/VrefInt/TempSensor                */
    if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
 8003438:	687b      	ldr	r3, [r7, #4]
 800343a:	681b      	ldr	r3, [r3, #0]
 800343c:	4618      	mov	r0, r3
 800343e:	f7ff fc6d 	bl	8002d1c <LL_ADC_IsEnabled>
 8003442:	4603      	mov	r3, r0
 8003444:	2b00      	cmp	r3, #0
 8003446:	f040 81bb 	bne.w	80037c0 <HAL_ADC_ConfigChannel+0x5a0>
    {
      /* Set mode single-ended or differential input of the selected ADC channel */
      LL_ADC_SetChannelSingleDiff(hadc->Instance, sConfig->Channel, sConfig->SingleDiff);
 800344a:	687b      	ldr	r3, [r7, #4]
 800344c:	6818      	ldr	r0, [r3, #0]
 800344e:	683b      	ldr	r3, [r7, #0]
 8003450:	6819      	ldr	r1, [r3, #0]
 8003452:	683b      	ldr	r3, [r7, #0]
 8003454:	68db      	ldr	r3, [r3, #12]
 8003456:	461a      	mov	r2, r3
 8003458:	f7ff fbb8 	bl	8002bcc <LL_ADC_SetChannelSingleDiff>

      /* Configuration of differential mode */
      if (sConfig->SingleDiff == ADC_DIFFERENTIAL_ENDED)
 800345c:	683b      	ldr	r3, [r7, #0]
 800345e:	68db      	ldr	r3, [r3, #12]
 8003460:	4a0b      	ldr	r2, [pc, #44]	@ (8003490 <HAL_ADC_ConfigChannel+0x270>)
 8003462:	4293      	cmp	r3, r2
 8003464:	f040 8130 	bne.w	80036c8 <HAL_ADC_ConfigChannel+0x4a8>
      {
        /* Set sampling time of the selected ADC channel */
        /* Note: ADC channel number masked with value "0x1F" to ensure shift value within 32 bits range */
        LL_ADC_SetChannelSamplingTime(hadc->Instance,
 8003468:	687b      	ldr	r3, [r7, #4]
 800346a:	6818      	ldr	r0, [r3, #0]
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) + 1UL) & 0x1FUL)),
 800346c:	683b      	ldr	r3, [r7, #0]
 800346e:	681b      	ldr	r3, [r3, #0]
 8003470:	f3c3 0313 	ubfx	r3, r3, #0, #20
 8003474:	2b00      	cmp	r3, #0
 8003476:	d10d      	bne.n	8003494 <HAL_ADC_ConfigChannel+0x274>
 8003478:	683b      	ldr	r3, [r7, #0]
 800347a:	681b      	ldr	r3, [r3, #0]
 800347c:	0e9b      	lsrs	r3, r3, #26
 800347e:	3301      	adds	r3, #1
 8003480:	f003 031f 	and.w	r3, r3, #31
 8003484:	2b09      	cmp	r3, #9
 8003486:	bf94      	ite	ls
 8003488:	2301      	movls	r3, #1
 800348a:	2300      	movhi	r3, #0
 800348c:	b2db      	uxtb	r3, r3
 800348e:	e01b      	b.n	80034c8 <HAL_ADC_ConfigChannel+0x2a8>
 8003490:	47ff0000 	.word	0x47ff0000
 8003494:	683b      	ldr	r3, [r7, #0]
 8003496:	681b      	ldr	r3, [r3, #0]
 8003498:	65bb      	str	r3, [r7, #88]	@ 0x58
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800349a:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 800349c:	fa93 f3a3 	rbit	r3, r3
 80034a0:	657b      	str	r3, [r7, #84]	@ 0x54
  return result;
 80034a2:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80034a4:	65fb      	str	r3, [r7, #92]	@ 0x5c
  if (value == 0U)
 80034a6:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80034a8:	2b00      	cmp	r3, #0
 80034aa:	d101      	bne.n	80034b0 <HAL_ADC_ConfigChannel+0x290>
    return 32U;
 80034ac:	2320      	movs	r3, #32
 80034ae:	e003      	b.n	80034b8 <HAL_ADC_ConfigChannel+0x298>
  return __builtin_clz(value);
 80034b0:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80034b2:	fab3 f383 	clz	r3, r3
 80034b6:	b2db      	uxtb	r3, r3
 80034b8:	3301      	adds	r3, #1
 80034ba:	f003 031f 	and.w	r3, r3, #31
 80034be:	2b09      	cmp	r3, #9
 80034c0:	bf94      	ite	ls
 80034c2:	2301      	movls	r3, #1
 80034c4:	2300      	movhi	r3, #0
 80034c6:	b2db      	uxtb	r3, r3
        LL_ADC_SetChannelSamplingTime(hadc->Instance,
 80034c8:	2b00      	cmp	r3, #0
 80034ca:	d079      	beq.n	80035c0 <HAL_ADC_ConfigChannel+0x3a0>
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) + 1UL) & 0x1FUL)),
 80034cc:	683b      	ldr	r3, [r7, #0]
 80034ce:	681b      	ldr	r3, [r3, #0]
 80034d0:	f3c3 0313 	ubfx	r3, r3, #0, #20
 80034d4:	2b00      	cmp	r3, #0
 80034d6:	d107      	bne.n	80034e8 <HAL_ADC_ConfigChannel+0x2c8>
 80034d8:	683b      	ldr	r3, [r7, #0]
 80034da:	681b      	ldr	r3, [r3, #0]
 80034dc:	0e9b      	lsrs	r3, r3, #26
 80034de:	3301      	adds	r3, #1
 80034e0:	069b      	lsls	r3, r3, #26
 80034e2:	f003 42f8 	and.w	r2, r3, #2080374784	@ 0x7c000000
 80034e6:	e015      	b.n	8003514 <HAL_ADC_ConfigChannel+0x2f4>
 80034e8:	683b      	ldr	r3, [r7, #0]
 80034ea:	681b      	ldr	r3, [r3, #0]
 80034ec:	64fb      	str	r3, [r7, #76]	@ 0x4c
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80034ee:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80034f0:	fa93 f3a3 	rbit	r3, r3
 80034f4:	64bb      	str	r3, [r7, #72]	@ 0x48
  return result;
 80034f6:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 80034f8:	653b      	str	r3, [r7, #80]	@ 0x50
  if (value == 0U)
 80034fa:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80034fc:	2b00      	cmp	r3, #0
 80034fe:	d101      	bne.n	8003504 <HAL_ADC_ConfigChannel+0x2e4>
    return 32U;
 8003500:	2320      	movs	r3, #32
 8003502:	e003      	b.n	800350c <HAL_ADC_ConfigChannel+0x2ec>
  return __builtin_clz(value);
 8003504:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8003506:	fab3 f383 	clz	r3, r3
 800350a:	b2db      	uxtb	r3, r3
 800350c:	3301      	adds	r3, #1
 800350e:	069b      	lsls	r3, r3, #26
 8003510:	f003 42f8 	and.w	r2, r3, #2080374784	@ 0x7c000000
 8003514:	683b      	ldr	r3, [r7, #0]
 8003516:	681b      	ldr	r3, [r3, #0]
 8003518:	f3c3 0313 	ubfx	r3, r3, #0, #20
 800351c:	2b00      	cmp	r3, #0
 800351e:	d109      	bne.n	8003534 <HAL_ADC_ConfigChannel+0x314>
 8003520:	683b      	ldr	r3, [r7, #0]
 8003522:	681b      	ldr	r3, [r3, #0]
 8003524:	0e9b      	lsrs	r3, r3, #26
 8003526:	3301      	adds	r3, #1
 8003528:	f003 031f 	and.w	r3, r3, #31
 800352c:	2101      	movs	r1, #1
 800352e:	fa01 f303 	lsl.w	r3, r1, r3
 8003532:	e017      	b.n	8003564 <HAL_ADC_ConfigChannel+0x344>
 8003534:	683b      	ldr	r3, [r7, #0]
 8003536:	681b      	ldr	r3, [r3, #0]
 8003538:	643b      	str	r3, [r7, #64]	@ 0x40
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800353a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800353c:	fa93 f3a3 	rbit	r3, r3
 8003540:	63fb      	str	r3, [r7, #60]	@ 0x3c
  return result;
 8003542:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8003544:	647b      	str	r3, [r7, #68]	@ 0x44
  if (value == 0U)
 8003546:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8003548:	2b00      	cmp	r3, #0
 800354a:	d101      	bne.n	8003550 <HAL_ADC_ConfigChannel+0x330>
    return 32U;
 800354c:	2320      	movs	r3, #32
 800354e:	e003      	b.n	8003558 <HAL_ADC_ConfigChannel+0x338>
  return __builtin_clz(value);
 8003550:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8003552:	fab3 f383 	clz	r3, r3
 8003556:	b2db      	uxtb	r3, r3
 8003558:	3301      	adds	r3, #1
 800355a:	f003 031f 	and.w	r3, r3, #31
 800355e:	2101      	movs	r1, #1
 8003560:	fa01 f303 	lsl.w	r3, r1, r3
 8003564:	ea42 0103 	orr.w	r1, r2, r3
 8003568:	683b      	ldr	r3, [r7, #0]
 800356a:	681b      	ldr	r3, [r3, #0]
 800356c:	f3c3 0313 	ubfx	r3, r3, #0, #20
 8003570:	2b00      	cmp	r3, #0
 8003572:	d10a      	bne.n	800358a <HAL_ADC_ConfigChannel+0x36a>
 8003574:	683b      	ldr	r3, [r7, #0]
 8003576:	681b      	ldr	r3, [r3, #0]
 8003578:	0e9b      	lsrs	r3, r3, #26
 800357a:	3301      	adds	r3, #1
 800357c:	f003 021f 	and.w	r2, r3, #31
 8003580:	4613      	mov	r3, r2
 8003582:	005b      	lsls	r3, r3, #1
 8003584:	4413      	add	r3, r2
 8003586:	051b      	lsls	r3, r3, #20
 8003588:	e018      	b.n	80035bc <HAL_ADC_ConfigChannel+0x39c>
 800358a:	683b      	ldr	r3, [r7, #0]
 800358c:	681b      	ldr	r3, [r3, #0]
 800358e:	637b      	str	r3, [r7, #52]	@ 0x34
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8003590:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8003592:	fa93 f3a3 	rbit	r3, r3
 8003596:	633b      	str	r3, [r7, #48]	@ 0x30
  return result;
 8003598:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800359a:	63bb      	str	r3, [r7, #56]	@ 0x38
  if (value == 0U)
 800359c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800359e:	2b00      	cmp	r3, #0
 80035a0:	d101      	bne.n	80035a6 <HAL_ADC_ConfigChannel+0x386>
    return 32U;
 80035a2:	2320      	movs	r3, #32
 80035a4:	e003      	b.n	80035ae <HAL_ADC_ConfigChannel+0x38e>
  return __builtin_clz(value);
 80035a6:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80035a8:	fab3 f383 	clz	r3, r3
 80035ac:	b2db      	uxtb	r3, r3
 80035ae:	3301      	adds	r3, #1
 80035b0:	f003 021f 	and.w	r2, r3, #31
 80035b4:	4613      	mov	r3, r2
 80035b6:	005b      	lsls	r3, r3, #1
 80035b8:	4413      	add	r3, r2
 80035ba:	051b      	lsls	r3, r3, #20
        LL_ADC_SetChannelSamplingTime(hadc->Instance,
 80035bc:	430b      	orrs	r3, r1
 80035be:	e07e      	b.n	80036be <HAL_ADC_ConfigChannel+0x49e>
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) + 1UL) & 0x1FUL)),
 80035c0:	683b      	ldr	r3, [r7, #0]
 80035c2:	681b      	ldr	r3, [r3, #0]
 80035c4:	f3c3 0313 	ubfx	r3, r3, #0, #20
 80035c8:	2b00      	cmp	r3, #0
 80035ca:	d107      	bne.n	80035dc <HAL_ADC_ConfigChannel+0x3bc>
 80035cc:	683b      	ldr	r3, [r7, #0]
 80035ce:	681b      	ldr	r3, [r3, #0]
 80035d0:	0e9b      	lsrs	r3, r3, #26
 80035d2:	3301      	adds	r3, #1
 80035d4:	069b      	lsls	r3, r3, #26
 80035d6:	f003 42f8 	and.w	r2, r3, #2080374784	@ 0x7c000000
 80035da:	e015      	b.n	8003608 <HAL_ADC_ConfigChannel+0x3e8>
 80035dc:	683b      	ldr	r3, [r7, #0]
 80035de:	681b      	ldr	r3, [r3, #0]
 80035e0:	62bb      	str	r3, [r7, #40]	@ 0x28
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80035e2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80035e4:	fa93 f3a3 	rbit	r3, r3
 80035e8:	627b      	str	r3, [r7, #36]	@ 0x24
  return result;
 80035ea:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80035ec:	62fb      	str	r3, [r7, #44]	@ 0x2c
  if (value == 0U)
 80035ee:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80035f0:	2b00      	cmp	r3, #0
 80035f2:	d101      	bne.n	80035f8 <HAL_ADC_ConfigChannel+0x3d8>
    return 32U;
 80035f4:	2320      	movs	r3, #32
 80035f6:	e003      	b.n	8003600 <HAL_ADC_ConfigChannel+0x3e0>
  return __builtin_clz(value);
 80035f8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80035fa:	fab3 f383 	clz	r3, r3
 80035fe:	b2db      	uxtb	r3, r3
 8003600:	3301      	adds	r3, #1
 8003602:	069b      	lsls	r3, r3, #26
 8003604:	f003 42f8 	and.w	r2, r3, #2080374784	@ 0x7c000000
 8003608:	683b      	ldr	r3, [r7, #0]
 800360a:	681b      	ldr	r3, [r3, #0]
 800360c:	f3c3 0313 	ubfx	r3, r3, #0, #20
 8003610:	2b00      	cmp	r3, #0
 8003612:	d109      	bne.n	8003628 <HAL_ADC_ConfigChannel+0x408>
 8003614:	683b      	ldr	r3, [r7, #0]
 8003616:	681b      	ldr	r3, [r3, #0]
 8003618:	0e9b      	lsrs	r3, r3, #26
 800361a:	3301      	adds	r3, #1
 800361c:	f003 031f 	and.w	r3, r3, #31
 8003620:	2101      	movs	r1, #1
 8003622:	fa01 f303 	lsl.w	r3, r1, r3
 8003626:	e017      	b.n	8003658 <HAL_ADC_ConfigChannel+0x438>
 8003628:	683b      	ldr	r3, [r7, #0]
 800362a:	681b      	ldr	r3, [r3, #0]
 800362c:	61fb      	str	r3, [r7, #28]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800362e:	69fb      	ldr	r3, [r7, #28]
 8003630:	fa93 f3a3 	rbit	r3, r3
 8003634:	61bb      	str	r3, [r7, #24]
  return result;
 8003636:	69bb      	ldr	r3, [r7, #24]
 8003638:	623b      	str	r3, [r7, #32]
  if (value == 0U)
 800363a:	6a3b      	ldr	r3, [r7, #32]
 800363c:	2b00      	cmp	r3, #0
 800363e:	d101      	bne.n	8003644 <HAL_ADC_ConfigChannel+0x424>
    return 32U;
 8003640:	2320      	movs	r3, #32
 8003642:	e003      	b.n	800364c <HAL_ADC_ConfigChannel+0x42c>
  return __builtin_clz(value);
 8003644:	6a3b      	ldr	r3, [r7, #32]
 8003646:	fab3 f383 	clz	r3, r3
 800364a:	b2db      	uxtb	r3, r3
 800364c:	3301      	adds	r3, #1
 800364e:	f003 031f 	and.w	r3, r3, #31
 8003652:	2101      	movs	r1, #1
 8003654:	fa01 f303 	lsl.w	r3, r1, r3
 8003658:	ea42 0103 	orr.w	r1, r2, r3
 800365c:	683b      	ldr	r3, [r7, #0]
 800365e:	681b      	ldr	r3, [r3, #0]
 8003660:	f3c3 0313 	ubfx	r3, r3, #0, #20
 8003664:	2b00      	cmp	r3, #0
 8003666:	d10d      	bne.n	8003684 <HAL_ADC_ConfigChannel+0x464>
 8003668:	683b      	ldr	r3, [r7, #0]
 800366a:	681b      	ldr	r3, [r3, #0]
 800366c:	0e9b      	lsrs	r3, r3, #26
 800366e:	3301      	adds	r3, #1
 8003670:	f003 021f 	and.w	r2, r3, #31
 8003674:	4613      	mov	r3, r2
 8003676:	005b      	lsls	r3, r3, #1
 8003678:	4413      	add	r3, r2
 800367a:	3b1e      	subs	r3, #30
 800367c:	051b      	lsls	r3, r3, #20
 800367e:	f043 7300 	orr.w	r3, r3, #33554432	@ 0x2000000
 8003682:	e01b      	b.n	80036bc <HAL_ADC_ConfigChannel+0x49c>
 8003684:	683b      	ldr	r3, [r7, #0]
 8003686:	681b      	ldr	r3, [r3, #0]
 8003688:	613b      	str	r3, [r7, #16]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800368a:	693b      	ldr	r3, [r7, #16]
 800368c:	fa93 f3a3 	rbit	r3, r3
 8003690:	60fb      	str	r3, [r7, #12]
  return result;
 8003692:	68fb      	ldr	r3, [r7, #12]
 8003694:	617b      	str	r3, [r7, #20]
  if (value == 0U)
 8003696:	697b      	ldr	r3, [r7, #20]
 8003698:	2b00      	cmp	r3, #0
 800369a:	d101      	bne.n	80036a0 <HAL_ADC_ConfigChannel+0x480>
    return 32U;
 800369c:	2320      	movs	r3, #32
 800369e:	e003      	b.n	80036a8 <HAL_ADC_ConfigChannel+0x488>
  return __builtin_clz(value);
 80036a0:	697b      	ldr	r3, [r7, #20]
 80036a2:	fab3 f383 	clz	r3, r3
 80036a6:	b2db      	uxtb	r3, r3
 80036a8:	3301      	adds	r3, #1
 80036aa:	f003 021f 	and.w	r2, r3, #31
 80036ae:	4613      	mov	r3, r2
 80036b0:	005b      	lsls	r3, r3, #1
 80036b2:	4413      	add	r3, r2
 80036b4:	3b1e      	subs	r3, #30
 80036b6:	051b      	lsls	r3, r3, #20
 80036b8:	f043 7300 	orr.w	r3, r3, #33554432	@ 0x2000000
        LL_ADC_SetChannelSamplingTime(hadc->Instance,
 80036bc:	430b      	orrs	r3, r1
 80036be:	683a      	ldr	r2, [r7, #0]
 80036c0:	6892      	ldr	r2, [r2, #8]
 80036c2:	4619      	mov	r1, r3
 80036c4:	f7ff fa56 	bl	8002b74 <LL_ADC_SetChannelSamplingTime>
      /* If internal channel selected, enable dedicated internal buffers and    */
      /* paths.                                                                 */
      /* Note: these internal measurement paths can be disabled using           */
      /* HAL_ADC_DeInit().                                                      */

      if (__LL_ADC_IS_CHANNEL_INTERNAL(sConfig->Channel))
 80036c8:	683b      	ldr	r3, [r7, #0]
 80036ca:	681b      	ldr	r3, [r3, #0]
 80036cc:	2b00      	cmp	r3, #0
 80036ce:	da77      	bge.n	80037c0 <HAL_ADC_ConfigChannel+0x5a0>
      {
        /* Configuration of common ADC parameters                                 */

        tmp_config_internal_channel = LL_ADC_GetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
 80036d0:	4840      	ldr	r0, [pc, #256]	@ (80037d4 <HAL_ADC_ConfigChannel+0x5b4>)
 80036d2:	f7ff f99b 	bl	8002a0c <LL_ADC_GetCommonPathInternalCh>
 80036d6:	66f8      	str	r0, [r7, #108]	@ 0x6c

        /* Software is allowed to change common parameters only when all ADCs   */
        /* of the common group are disabled.                                    */
        if (__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) == 0UL)
 80036d8:	483f      	ldr	r0, [pc, #252]	@ (80037d8 <HAL_ADC_ConfigChannel+0x5b8>)
 80036da:	f7ff fb1f 	bl	8002d1c <LL_ADC_IsEnabled>
 80036de:	4604      	mov	r4, r0
 80036e0:	483e      	ldr	r0, [pc, #248]	@ (80037dc <HAL_ADC_ConfigChannel+0x5bc>)
 80036e2:	f7ff fb1b 	bl	8002d1c <LL_ADC_IsEnabled>
 80036e6:	4603      	mov	r3, r0
 80036e8:	4323      	orrs	r3, r4
 80036ea:	2b00      	cmp	r3, #0
 80036ec:	d155      	bne.n	800379a <HAL_ADC_ConfigChannel+0x57a>
        {
          /* If the requested internal measurement path has already been enabled, */
          /* bypass the configuration processing.                                 */
          if ((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR) && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_TEMPSENSOR) == 0UL))
 80036ee:	683b      	ldr	r3, [r7, #0]
 80036f0:	681b      	ldr	r3, [r3, #0]
 80036f2:	4a3b      	ldr	r2, [pc, #236]	@ (80037e0 <HAL_ADC_ConfigChannel+0x5c0>)
 80036f4:	4293      	cmp	r3, r2
 80036f6:	d122      	bne.n	800373e <HAL_ADC_ConfigChannel+0x51e>
 80036f8:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 80036fa:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
 80036fe:	2b00      	cmp	r3, #0
 8003700:	d11d      	bne.n	800373e <HAL_ADC_ConfigChannel+0x51e>
          {
            if (ADC_TEMPERATURE_SENSOR_INSTANCE(hadc))
 8003702:	687b      	ldr	r3, [r7, #4]
 8003704:	681b      	ldr	r3, [r3, #0]
 8003706:	4a35      	ldr	r2, [pc, #212]	@ (80037dc <HAL_ADC_ConfigChannel+0x5bc>)
 8003708:	4293      	cmp	r3, r2
 800370a:	d159      	bne.n	80037c0 <HAL_ADC_ConfigChannel+0x5a0>
            {
              LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance), LL_ADC_PATH_INTERNAL_TEMPSENSOR | tmp_config_internal_channel);
 800370c:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 800370e:	f443 0300 	orr.w	r3, r3, #8388608	@ 0x800000
 8003712:	4619      	mov	r1, r3
 8003714:	482f      	ldr	r0, [pc, #188]	@ (80037d4 <HAL_ADC_ConfigChannel+0x5b4>)
 8003716:	f7ff f966 	bl	80029e6 <LL_ADC_SetCommonPathInternalCh>
              /* Delay for temperature sensor stabilization time */
              /* Wait loop initialization and execution */
              /* Note: Variable divided by 2 to compensate partially              */
              /*       CPU processing cycles, scaling in us split to not          */
              /*       exceed 32 bits register capacity and handle low frequency. */
              wait_loop_index = ((LL_ADC_DELAY_TEMPSENSOR_STAB_US / 10UL) * ((SystemCoreClock / (100000UL * 2UL)) + 1UL));
 800371a:	4b32      	ldr	r3, [pc, #200]	@ (80037e4 <HAL_ADC_ConfigChannel+0x5c4>)
 800371c:	681b      	ldr	r3, [r3, #0]
 800371e:	099b      	lsrs	r3, r3, #6
 8003720:	4a31      	ldr	r2, [pc, #196]	@ (80037e8 <HAL_ADC_ConfigChannel+0x5c8>)
 8003722:	fba2 2303 	umull	r2, r3, r2, r3
 8003726:	099b      	lsrs	r3, r3, #6
 8003728:	3301      	adds	r3, #1
 800372a:	005b      	lsls	r3, r3, #1
 800372c:	60bb      	str	r3, [r7, #8]
              while (wait_loop_index != 0UL)
 800372e:	e002      	b.n	8003736 <HAL_ADC_ConfigChannel+0x516>
              {
                wait_loop_index--;
 8003730:	68bb      	ldr	r3, [r7, #8]
 8003732:	3b01      	subs	r3, #1
 8003734:	60bb      	str	r3, [r7, #8]
              while (wait_loop_index != 0UL)
 8003736:	68bb      	ldr	r3, [r7, #8]
 8003738:	2b00      	cmp	r3, #0
 800373a:	d1f9      	bne.n	8003730 <HAL_ADC_ConfigChannel+0x510>
            if (ADC_TEMPERATURE_SENSOR_INSTANCE(hadc))
 800373c:	e040      	b.n	80037c0 <HAL_ADC_ConfigChannel+0x5a0>
              }
            }
          }
          else if ((sConfig->Channel == ADC_CHANNEL_VBAT) && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_VBAT) == 0UL))
 800373e:	683b      	ldr	r3, [r7, #0]
 8003740:	681b      	ldr	r3, [r3, #0]
 8003742:	4a2a      	ldr	r2, [pc, #168]	@ (80037ec <HAL_ADC_ConfigChannel+0x5cc>)
 8003744:	4293      	cmp	r3, r2
 8003746:	d111      	bne.n	800376c <HAL_ADC_ConfigChannel+0x54c>
 8003748:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 800374a:	f003 7380 	and.w	r3, r3, #16777216	@ 0x1000000
 800374e:	2b00      	cmp	r3, #0
 8003750:	d10c      	bne.n	800376c <HAL_ADC_ConfigChannel+0x54c>
          {
            if (ADC_BATTERY_VOLTAGE_INSTANCE(hadc))
 8003752:	687b      	ldr	r3, [r7, #4]
 8003754:	681b      	ldr	r3, [r3, #0]
 8003756:	4a21      	ldr	r2, [pc, #132]	@ (80037dc <HAL_ADC_ConfigChannel+0x5bc>)
 8003758:	4293      	cmp	r3, r2
 800375a:	d131      	bne.n	80037c0 <HAL_ADC_ConfigChannel+0x5a0>
            {
              LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance), LL_ADC_PATH_INTERNAL_VBAT | tmp_config_internal_channel);
 800375c:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 800375e:	f043 7380 	orr.w	r3, r3, #16777216	@ 0x1000000
 8003762:	4619      	mov	r1, r3
 8003764:	481b      	ldr	r0, [pc, #108]	@ (80037d4 <HAL_ADC_ConfigChannel+0x5b4>)
 8003766:	f7ff f93e 	bl	80029e6 <LL_ADC_SetCommonPathInternalCh>
            if (ADC_BATTERY_VOLTAGE_INSTANCE(hadc))
 800376a:	e029      	b.n	80037c0 <HAL_ADC_ConfigChannel+0x5a0>
            }
          }
          else if ((sConfig->Channel == ADC_CHANNEL_VREFINT) && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_VREFINT) == 0UL))
 800376c:	683b      	ldr	r3, [r7, #0]
 800376e:	681b      	ldr	r3, [r3, #0]
 8003770:	4a1f      	ldr	r2, [pc, #124]	@ (80037f0 <HAL_ADC_ConfigChannel+0x5d0>)
 8003772:	4293      	cmp	r3, r2
 8003774:	d124      	bne.n	80037c0 <HAL_ADC_ConfigChannel+0x5a0>
 8003776:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8003778:	f403 0380 	and.w	r3, r3, #4194304	@ 0x400000
 800377c:	2b00      	cmp	r3, #0
 800377e:	d11f      	bne.n	80037c0 <HAL_ADC_ConfigChannel+0x5a0>
          {
            if (ADC_VREFINT_INSTANCE(hadc))
 8003780:	687b      	ldr	r3, [r7, #4]
 8003782:	681b      	ldr	r3, [r3, #0]
 8003784:	4a15      	ldr	r2, [pc, #84]	@ (80037dc <HAL_ADC_ConfigChannel+0x5bc>)
 8003786:	4293      	cmp	r3, r2
 8003788:	d11a      	bne.n	80037c0 <HAL_ADC_ConfigChannel+0x5a0>
            {
              LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance), LL_ADC_PATH_INTERNAL_VREFINT | tmp_config_internal_channel);
 800378a:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 800378c:	f443 0380 	orr.w	r3, r3, #4194304	@ 0x400000
 8003790:	4619      	mov	r1, r3
 8003792:	4810      	ldr	r0, [pc, #64]	@ (80037d4 <HAL_ADC_ConfigChannel+0x5b4>)
 8003794:	f7ff f927 	bl	80029e6 <LL_ADC_SetCommonPathInternalCh>
 8003798:	e012      	b.n	80037c0 <HAL_ADC_ConfigChannel+0x5a0>
        /* enabled and other ADC of the common group are enabled, internal      */
        /* measurement paths cannot be enabled.                                 */
        else
        {
          /* Update ADC state machine to error */
          SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 800379a:	687b      	ldr	r3, [r7, #4]
 800379c:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 800379e:	f043 0220 	orr.w	r2, r3, #32
 80037a2:	687b      	ldr	r3, [r7, #4]
 80037a4:	655a      	str	r2, [r3, #84]	@ 0x54

          tmp_hal_status = HAL_ERROR;
 80037a6:	2301      	movs	r3, #1
 80037a8:	f887 307f 	strb.w	r3, [r7, #127]	@ 0x7f
 80037ac:	e008      	b.n	80037c0 <HAL_ADC_ConfigChannel+0x5a0>
  /* channel could be done on neither of the channel configuration structure  */
  /* parameters.                                                              */
  else
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 80037ae:	687b      	ldr	r3, [r7, #4]
 80037b0:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 80037b2:	f043 0220 	orr.w	r2, r3, #32
 80037b6:	687b      	ldr	r3, [r7, #4]
 80037b8:	655a      	str	r2, [r3, #84]	@ 0x54

    tmp_hal_status = HAL_ERROR;
 80037ba:	2301      	movs	r3, #1
 80037bc:	f887 307f 	strb.w	r3, [r7, #127]	@ 0x7f
  }

  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 80037c0:	687b      	ldr	r3, [r7, #4]
 80037c2:	2200      	movs	r2, #0
 80037c4:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50

  /* Return function status */
  return tmp_hal_status;
 80037c8:	f897 307f 	ldrb.w	r3, [r7, #127]	@ 0x7f
}
 80037cc:	4618      	mov	r0, r3
 80037ce:	3784      	adds	r7, #132	@ 0x84
 80037d0:	46bd      	mov	sp, r7
 80037d2:	bd90      	pop	{r4, r7, pc}
 80037d4:	40022300 	.word	0x40022300
 80037d8:	40022000 	.word	0x40022000
 80037dc:	40022100 	.word	0x40022100
 80037e0:	cb840000 	.word	0xcb840000
 80037e4:	2400011c 	.word	0x2400011c
 80037e8:	053e2d63 	.word	0x053e2d63
 80037ec:	bac04000 	.word	0xbac04000
 80037f0:	cfb80000 	.word	0xcfb80000

080037f4 <ADC_Enable>:
  *         and voltage regulator must be enabled (done into HAL_ADC_Init()).
  * @param hadc ADC handle
  * @retval HAL status.
  */
HAL_StatusTypeDef ADC_Enable(ADC_HandleTypeDef *hadc)
{
 80037f4:	b580      	push	{r7, lr}
 80037f6:	b084      	sub	sp, #16
 80037f8:	af00      	add	r7, sp, #0
 80037fa:	6078      	str	r0, [r7, #4]

  /* ADC enable and wait for ADC ready (in case of ADC is disabled or         */
  /* enabling phase not yet completed: flag ADC ready not yet set).           */
  /* Timeout implemented to not be stuck if ADC cannot be enabled (possible   */
  /* causes: ADC clock not running, ...).                                     */
  if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
 80037fc:	687b      	ldr	r3, [r7, #4]
 80037fe:	681b      	ldr	r3, [r3, #0]
 8003800:	4618      	mov	r0, r3
 8003802:	f7ff fa8b 	bl	8002d1c <LL_ADC_IsEnabled>
 8003806:	4603      	mov	r3, r0
 8003808:	2b00      	cmp	r3, #0
 800380a:	d161      	bne.n	80038d0 <ADC_Enable+0xdc>
  {
    /* Check if conditions to enable the ADC are fulfilled */
    if ((hadc->Instance->CR & (ADC_CR_ADCAL | ADC_CR_JADSTP | ADC_CR_ADSTP | ADC_CR_JADSTART | ADC_CR_ADSTART | ADC_CR_ADDIS | ADC_CR_ADEN)) != 0UL)
 800380c:	687b      	ldr	r3, [r7, #4]
 800380e:	681b      	ldr	r3, [r3, #0]
 8003810:	689a      	ldr	r2, [r3, #8]
 8003812:	4b32      	ldr	r3, [pc, #200]	@ (80038dc <ADC_Enable+0xe8>)
 8003814:	4013      	ands	r3, r2
 8003816:	2b00      	cmp	r3, #0
 8003818:	d00d      	beq.n	8003836 <ADC_Enable+0x42>
    {
      /* Update ADC state machine to error */
      SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 800381a:	687b      	ldr	r3, [r7, #4]
 800381c:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 800381e:	f043 0210 	orr.w	r2, r3, #16
 8003822:	687b      	ldr	r3, [r7, #4]
 8003824:	655a      	str	r2, [r3, #84]	@ 0x54

      /* Set ADC error code to ADC peripheral internal error */
      SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8003826:	687b      	ldr	r3, [r7, #4]
 8003828:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 800382a:	f043 0201 	orr.w	r2, r3, #1
 800382e:	687b      	ldr	r3, [r7, #4]
 8003830:	659a      	str	r2, [r3, #88]	@ 0x58

      return HAL_ERROR;
 8003832:	2301      	movs	r3, #1
 8003834:	e04d      	b.n	80038d2 <ADC_Enable+0xde>
    }

    /* Enable the ADC peripheral */
    LL_ADC_Enable(hadc->Instance);
 8003836:	687b      	ldr	r3, [r7, #4]
 8003838:	681b      	ldr	r3, [r3, #0]
 800383a:	4618      	mov	r0, r3
 800383c:	f7ff fa46 	bl	8002ccc <LL_ADC_Enable>

    /* Wait for ADC effectively enabled */
    tickstart = HAL_GetTick();
 8003840:	f7ff f88e 	bl	8002960 <HAL_GetTick>
 8003844:	60f8      	str	r0, [r7, #12]

    /* Poll for ADC ready flag raised except case of multimode enabled
       and ADC slave selected. */
    uint32_t tmp_multimode_config = LL_ADC_GetMultimode(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
 8003846:	4826      	ldr	r0, [pc, #152]	@ (80038e0 <ADC_Enable+0xec>)
 8003848:	f7ff f9e4 	bl	8002c14 <LL_ADC_GetMultimode>
 800384c:	60b8      	str	r0, [r7, #8]
    if ((__LL_ADC_MULTI_INSTANCE_MASTER(hadc->Instance) == hadc->Instance)
 800384e:	687b      	ldr	r3, [r7, #4]
 8003850:	681b      	ldr	r3, [r3, #0]
 8003852:	4a24      	ldr	r2, [pc, #144]	@ (80038e4 <ADC_Enable+0xf0>)
 8003854:	4293      	cmp	r3, r2
 8003856:	d002      	beq.n	800385e <ADC_Enable+0x6a>
 8003858:	687b      	ldr	r3, [r7, #4]
 800385a:	681b      	ldr	r3, [r3, #0]
 800385c:	e000      	b.n	8003860 <ADC_Enable+0x6c>
 800385e:	4b22      	ldr	r3, [pc, #136]	@ (80038e8 <ADC_Enable+0xf4>)
 8003860:	687a      	ldr	r2, [r7, #4]
 8003862:	6812      	ldr	r2, [r2, #0]
 8003864:	4293      	cmp	r3, r2
 8003866:	d02c      	beq.n	80038c2 <ADC_Enable+0xce>
        || (tmp_multimode_config == LL_ADC_MULTI_INDEPENDENT)
 8003868:	68bb      	ldr	r3, [r7, #8]
 800386a:	2b00      	cmp	r3, #0
 800386c:	d130      	bne.n	80038d0 <ADC_Enable+0xdc>
       )
    {
      while (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_RDY) == 0UL)
 800386e:	e028      	b.n	80038c2 <ADC_Enable+0xce>
            The workaround is to continue setting ADEN until ADRDY is becomes 1.
            Additionally, ADC_ENABLE_TIMEOUT is defined to encompass this
            4 ADC clock cycle duration */
        /* Note: Test of ADC enabled required due to hardware constraint to     */
        /*       not enable ADC if already enabled.                             */
        if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
 8003870:	687b      	ldr	r3, [r7, #4]
 8003872:	681b      	ldr	r3, [r3, #0]
 8003874:	4618      	mov	r0, r3
 8003876:	f7ff fa51 	bl	8002d1c <LL_ADC_IsEnabled>
 800387a:	4603      	mov	r3, r0
 800387c:	2b00      	cmp	r3, #0
 800387e:	d104      	bne.n	800388a <ADC_Enable+0x96>
        {
          LL_ADC_Enable(hadc->Instance);
 8003880:	687b      	ldr	r3, [r7, #4]
 8003882:	681b      	ldr	r3, [r3, #0]
 8003884:	4618      	mov	r0, r3
 8003886:	f7ff fa21 	bl	8002ccc <LL_ADC_Enable>
        }

        if ((HAL_GetTick() - tickstart) > ADC_ENABLE_TIMEOUT)
 800388a:	f7ff f869 	bl	8002960 <HAL_GetTick>
 800388e:	4602      	mov	r2, r0
 8003890:	68fb      	ldr	r3, [r7, #12]
 8003892:	1ad3      	subs	r3, r2, r3
 8003894:	2b02      	cmp	r3, #2
 8003896:	d914      	bls.n	80038c2 <ADC_Enable+0xce>
        {
          /* New check to avoid false timeout detection in case of preemption */
          if (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_RDY) == 0UL)
 8003898:	687b      	ldr	r3, [r7, #4]
 800389a:	681b      	ldr	r3, [r3, #0]
 800389c:	681b      	ldr	r3, [r3, #0]
 800389e:	f003 0301 	and.w	r3, r3, #1
 80038a2:	2b01      	cmp	r3, #1
 80038a4:	d00d      	beq.n	80038c2 <ADC_Enable+0xce>
          {
            /* Update ADC state machine to error */
            SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 80038a6:	687b      	ldr	r3, [r7, #4]
 80038a8:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 80038aa:	f043 0210 	orr.w	r2, r3, #16
 80038ae:	687b      	ldr	r3, [r7, #4]
 80038b0:	655a      	str	r2, [r3, #84]	@ 0x54

            /* Set ADC error code to ADC peripheral internal error */
            SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 80038b2:	687b      	ldr	r3, [r7, #4]
 80038b4:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 80038b6:	f043 0201 	orr.w	r2, r3, #1
 80038ba:	687b      	ldr	r3, [r7, #4]
 80038bc:	659a      	str	r2, [r3, #88]	@ 0x58

            return HAL_ERROR;
 80038be:	2301      	movs	r3, #1
 80038c0:	e007      	b.n	80038d2 <ADC_Enable+0xde>
      while (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_RDY) == 0UL)
 80038c2:	687b      	ldr	r3, [r7, #4]
 80038c4:	681b      	ldr	r3, [r3, #0]
 80038c6:	681b      	ldr	r3, [r3, #0]
 80038c8:	f003 0301 	and.w	r3, r3, #1
 80038cc:	2b01      	cmp	r3, #1
 80038ce:	d1cf      	bne.n	8003870 <ADC_Enable+0x7c>
      }
    }
  }

  /* Return HAL status */
  return HAL_OK;
 80038d0:	2300      	movs	r3, #0
}
 80038d2:	4618      	mov	r0, r3
 80038d4:	3710      	adds	r7, #16
 80038d6:	46bd      	mov	sp, r7
 80038d8:	bd80      	pop	{r7, pc}
 80038da:	bf00      	nop
 80038dc:	8000003f 	.word	0x8000003f
 80038e0:	40022300 	.word	0x40022300
 80038e4:	40022100 	.word	0x40022100
 80038e8:	40022000 	.word	0x40022000

080038ec <ADC_Disable>:
  *         stopped.
  * @param hadc ADC handle
  * @retval HAL status.
  */
HAL_StatusTypeDef ADC_Disable(ADC_HandleTypeDef *hadc)
{
 80038ec:	b580      	push	{r7, lr}
 80038ee:	b084      	sub	sp, #16
 80038f0:	af00      	add	r7, sp, #0
 80038f2:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;
  const uint32_t tmp_adc_is_disable_on_going = LL_ADC_IsDisableOngoing(hadc->Instance);
 80038f4:	687b      	ldr	r3, [r7, #4]
 80038f6:	681b      	ldr	r3, [r3, #0]
 80038f8:	4618      	mov	r0, r3
 80038fa:	f7ff fa22 	bl	8002d42 <LL_ADC_IsDisableOngoing>
 80038fe:	60f8      	str	r0, [r7, #12]

  /* Verification if ADC is not already disabled:                             */
  /* Note: forbidden to disable ADC (set bit ADC_CR_ADDIS) if ADC is already  */
  /*       disabled.                                                          */
  if ((LL_ADC_IsEnabled(hadc->Instance) != 0UL)
 8003900:	687b      	ldr	r3, [r7, #4]
 8003902:	681b      	ldr	r3, [r3, #0]
 8003904:	4618      	mov	r0, r3
 8003906:	f7ff fa09 	bl	8002d1c <LL_ADC_IsEnabled>
 800390a:	4603      	mov	r3, r0
 800390c:	2b00      	cmp	r3, #0
 800390e:	d047      	beq.n	80039a0 <ADC_Disable+0xb4>
      && (tmp_adc_is_disable_on_going == 0UL)
 8003910:	68fb      	ldr	r3, [r7, #12]
 8003912:	2b00      	cmp	r3, #0
 8003914:	d144      	bne.n	80039a0 <ADC_Disable+0xb4>
     )
  {
    /* Check if conditions to disable the ADC are fulfilled */
    if ((hadc->Instance->CR & (ADC_CR_JADSTART | ADC_CR_ADSTART | ADC_CR_ADEN)) == ADC_CR_ADEN)
 8003916:	687b      	ldr	r3, [r7, #4]
 8003918:	681b      	ldr	r3, [r3, #0]
 800391a:	689b      	ldr	r3, [r3, #8]
 800391c:	f003 030d 	and.w	r3, r3, #13
 8003920:	2b01      	cmp	r3, #1
 8003922:	d10c      	bne.n	800393e <ADC_Disable+0x52>
    {
      /* Disable the ADC peripheral */
      LL_ADC_Disable(hadc->Instance);
 8003924:	687b      	ldr	r3, [r7, #4]
 8003926:	681b      	ldr	r3, [r3, #0]
 8003928:	4618      	mov	r0, r3
 800392a:	f7ff f9e3 	bl	8002cf4 <LL_ADC_Disable>
      __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOSMP | ADC_FLAG_RDY));
 800392e:	687b      	ldr	r3, [r7, #4]
 8003930:	681b      	ldr	r3, [r3, #0]
 8003932:	2203      	movs	r2, #3
 8003934:	601a      	str	r2, [r3, #0]
      return HAL_ERROR;
    }

    /* Wait for ADC effectively disabled */
    /* Get tick count */
    tickstart = HAL_GetTick();
 8003936:	f7ff f813 	bl	8002960 <HAL_GetTick>
 800393a:	60b8      	str	r0, [r7, #8]

    while ((hadc->Instance->CR & ADC_CR_ADEN) != 0UL)
 800393c:	e029      	b.n	8003992 <ADC_Disable+0xa6>
      SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 800393e:	687b      	ldr	r3, [r7, #4]
 8003940:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8003942:	f043 0210 	orr.w	r2, r3, #16
 8003946:	687b      	ldr	r3, [r7, #4]
 8003948:	655a      	str	r2, [r3, #84]	@ 0x54
      SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 800394a:	687b      	ldr	r3, [r7, #4]
 800394c:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 800394e:	f043 0201 	orr.w	r2, r3, #1
 8003952:	687b      	ldr	r3, [r7, #4]
 8003954:	659a      	str	r2, [r3, #88]	@ 0x58
      return HAL_ERROR;
 8003956:	2301      	movs	r3, #1
 8003958:	e023      	b.n	80039a2 <ADC_Disable+0xb6>
    {
      if ((HAL_GetTick() - tickstart) > ADC_DISABLE_TIMEOUT)
 800395a:	f7ff f801 	bl	8002960 <HAL_GetTick>
 800395e:	4602      	mov	r2, r0
 8003960:	68bb      	ldr	r3, [r7, #8]
 8003962:	1ad3      	subs	r3, r2, r3
 8003964:	2b02      	cmp	r3, #2
 8003966:	d914      	bls.n	8003992 <ADC_Disable+0xa6>
      {
        /* New check to avoid false timeout detection in case of preemption */
        if ((hadc->Instance->CR & ADC_CR_ADEN) != 0UL)
 8003968:	687b      	ldr	r3, [r7, #4]
 800396a:	681b      	ldr	r3, [r3, #0]
 800396c:	689b      	ldr	r3, [r3, #8]
 800396e:	f003 0301 	and.w	r3, r3, #1
 8003972:	2b00      	cmp	r3, #0
 8003974:	d00d      	beq.n	8003992 <ADC_Disable+0xa6>
        {
          /* Update ADC state machine to error */
          SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8003976:	687b      	ldr	r3, [r7, #4]
 8003978:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 800397a:	f043 0210 	orr.w	r2, r3, #16
 800397e:	687b      	ldr	r3, [r7, #4]
 8003980:	655a      	str	r2, [r3, #84]	@ 0x54

          /* Set ADC error code to ADC peripheral internal error */
          SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8003982:	687b      	ldr	r3, [r7, #4]
 8003984:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8003986:	f043 0201 	orr.w	r2, r3, #1
 800398a:	687b      	ldr	r3, [r7, #4]
 800398c:	659a      	str	r2, [r3, #88]	@ 0x58

          return HAL_ERROR;
 800398e:	2301      	movs	r3, #1
 8003990:	e007      	b.n	80039a2 <ADC_Disable+0xb6>
    while ((hadc->Instance->CR & ADC_CR_ADEN) != 0UL)
 8003992:	687b      	ldr	r3, [r7, #4]
 8003994:	681b      	ldr	r3, [r3, #0]
 8003996:	689b      	ldr	r3, [r3, #8]
 8003998:	f003 0301 	and.w	r3, r3, #1
 800399c:	2b00      	cmp	r3, #0
 800399e:	d1dc      	bne.n	800395a <ADC_Disable+0x6e>
      }
    }
  }

  /* Return HAL status */
  return HAL_OK;
 80039a0:	2300      	movs	r3, #0
}
 80039a2:	4618      	mov	r0, r3
 80039a4:	3710      	adds	r7, #16
 80039a6:	46bd      	mov	sp, r7
 80039a8:	bd80      	pop	{r7, pc}

080039aa <ADC_DMAConvCplt>:
  * @brief  DMA transfer complete callback.
  * @param hdma pointer to DMA handle.
  * @retval None
  */
void ADC_DMAConvCplt(DMA_HandleTypeDef *hdma)
{
 80039aa:	b580      	push	{r7, lr}
 80039ac:	b084      	sub	sp, #16
 80039ae:	af00      	add	r7, sp, #0
 80039b0:	6078      	str	r0, [r7, #4]
  /* Retrieve ADC handle corresponding to current DMA handle */
  ADC_HandleTypeDef *hadc = (ADC_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 80039b2:	687b      	ldr	r3, [r7, #4]
 80039b4:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 80039b6:	60fb      	str	r3, [r7, #12]

  /* Update state machine on conversion status if not in error state */
  if ((hadc->State & (HAL_ADC_STATE_ERROR_INTERNAL | HAL_ADC_STATE_ERROR_DMA)) == 0UL)
 80039b8:	68fb      	ldr	r3, [r7, #12]
 80039ba:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 80039bc:	f003 0350 	and.w	r3, r3, #80	@ 0x50
 80039c0:	2b00      	cmp	r3, #0
 80039c2:	d14b      	bne.n	8003a5c <ADC_DMAConvCplt+0xb2>
  {
    /* Set ADC state */
    SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC);
 80039c4:	68fb      	ldr	r3, [r7, #12]
 80039c6:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 80039c8:	f443 7200 	orr.w	r2, r3, #512	@ 0x200
 80039cc:	68fb      	ldr	r3, [r7, #12]
 80039ce:	655a      	str	r2, [r3, #84]	@ 0x54

    /* Determine whether any further conversion upcoming on group regular     */
    /* by external trigger, continuous mode or scan sequence on going         */
    /* to disable interruption.                                               */
    /* Is it the end of the regular sequence ? */
    if ((hadc->Instance->ISR & ADC_FLAG_EOS) != 0UL)
 80039d0:	68fb      	ldr	r3, [r7, #12]
 80039d2:	681b      	ldr	r3, [r3, #0]
 80039d4:	681b      	ldr	r3, [r3, #0]
 80039d6:	f003 0308 	and.w	r3, r3, #8
 80039da:	2b00      	cmp	r3, #0
 80039dc:	d021      	beq.n	8003a22 <ADC_DMAConvCplt+0x78>
    {
      /* Are conversions software-triggered ? */
      if (LL_ADC_REG_IsTriggerSourceSWStart(hadc->Instance) != 0UL)
 80039de:	68fb      	ldr	r3, [r7, #12]
 80039e0:	681b      	ldr	r3, [r3, #0]
 80039e2:	4618      	mov	r0, r3
 80039e4:	f7ff f874 	bl	8002ad0 <LL_ADC_REG_IsTriggerSourceSWStart>
 80039e8:	4603      	mov	r3, r0
 80039ea:	2b00      	cmp	r3, #0
 80039ec:	d032      	beq.n	8003a54 <ADC_DMAConvCplt+0xaa>
      {
        /* Is CONT bit set ? */
        if (READ_BIT(hadc->Instance->CFGR, ADC_CFGR_CONT) == 0UL)
 80039ee:	68fb      	ldr	r3, [r7, #12]
 80039f0:	681b      	ldr	r3, [r3, #0]
 80039f2:	68db      	ldr	r3, [r3, #12]
 80039f4:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
 80039f8:	2b00      	cmp	r3, #0
 80039fa:	d12b      	bne.n	8003a54 <ADC_DMAConvCplt+0xaa>
        {
          /* CONT bit is not set, no more conversions expected */
          CLEAR_BIT(hadc->State, HAL_ADC_STATE_REG_BUSY);
 80039fc:	68fb      	ldr	r3, [r7, #12]
 80039fe:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8003a00:	f423 7280 	bic.w	r2, r3, #256	@ 0x100
 8003a04:	68fb      	ldr	r3, [r7, #12]
 8003a06:	655a      	str	r2, [r3, #84]	@ 0x54
          if ((hadc->State & HAL_ADC_STATE_INJ_BUSY) == 0UL)
 8003a08:	68fb      	ldr	r3, [r7, #12]
 8003a0a:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8003a0c:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
 8003a10:	2b00      	cmp	r3, #0
 8003a12:	d11f      	bne.n	8003a54 <ADC_DMAConvCplt+0xaa>
          {
            SET_BIT(hadc->State, HAL_ADC_STATE_READY);
 8003a14:	68fb      	ldr	r3, [r7, #12]
 8003a16:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8003a18:	f043 0201 	orr.w	r2, r3, #1
 8003a1c:	68fb      	ldr	r3, [r7, #12]
 8003a1e:	655a      	str	r2, [r3, #84]	@ 0x54
 8003a20:	e018      	b.n	8003a54 <ADC_DMAConvCplt+0xaa>
    }
    else
    {
      /* DMA End of Transfer interrupt was triggered but conversions sequence
         is not over. If DMACFG is set to 0, conversions are stopped. */
      if (READ_BIT(hadc->Instance->CFGR, ADC_CFGR_DMNGT) == 0UL)
 8003a22:	68fb      	ldr	r3, [r7, #12]
 8003a24:	681b      	ldr	r3, [r3, #0]
 8003a26:	68db      	ldr	r3, [r3, #12]
 8003a28:	f003 0303 	and.w	r3, r3, #3
 8003a2c:	2b00      	cmp	r3, #0
 8003a2e:	d111      	bne.n	8003a54 <ADC_DMAConvCplt+0xaa>
      {
        /* DMACFG bit is not set, conversions are stopped. */
        CLEAR_BIT(hadc->State, HAL_ADC_STATE_REG_BUSY);
 8003a30:	68fb      	ldr	r3, [r7, #12]
 8003a32:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8003a34:	f423 7280 	bic.w	r2, r3, #256	@ 0x100
 8003a38:	68fb      	ldr	r3, [r7, #12]
 8003a3a:	655a      	str	r2, [r3, #84]	@ 0x54
        if ((hadc->State & HAL_ADC_STATE_INJ_BUSY) == 0UL)
 8003a3c:	68fb      	ldr	r3, [r7, #12]
 8003a3e:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8003a40:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
 8003a44:	2b00      	cmp	r3, #0
 8003a46:	d105      	bne.n	8003a54 <ADC_DMAConvCplt+0xaa>
        {
          SET_BIT(hadc->State, HAL_ADC_STATE_READY);
 8003a48:	68fb      	ldr	r3, [r7, #12]
 8003a4a:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8003a4c:	f043 0201 	orr.w	r2, r3, #1
 8003a50:	68fb      	ldr	r3, [r7, #12]
 8003a52:	655a      	str	r2, [r3, #84]	@ 0x54

    /* Conversion complete callback */
#if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
    hadc->ConvCpltCallback(hadc);
#else
    HAL_ADC_ConvCpltCallback(hadc);
 8003a54:	68f8      	ldr	r0, [r7, #12]
 8003a56:	f7fd f91b 	bl	8000c90 <HAL_ADC_ConvCpltCallback>
    {
      /* Call ADC DMA error callback */
      hadc->DMA_Handle->XferErrorCallback(hdma);
    }
  }
}
 8003a5a:	e00e      	b.n	8003a7a <ADC_DMAConvCplt+0xd0>
    if ((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) != 0UL)
 8003a5c:	68fb      	ldr	r3, [r7, #12]
 8003a5e:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8003a60:	f003 0310 	and.w	r3, r3, #16
 8003a64:	2b00      	cmp	r3, #0
 8003a66:	d003      	beq.n	8003a70 <ADC_DMAConvCplt+0xc6>
      HAL_ADC_ErrorCallback(hadc);
 8003a68:	68f8      	ldr	r0, [r7, #12]
 8003a6a:	f7ff fbcf 	bl	800320c <HAL_ADC_ErrorCallback>
}
 8003a6e:	e004      	b.n	8003a7a <ADC_DMAConvCplt+0xd0>
      hadc->DMA_Handle->XferErrorCallback(hdma);
 8003a70:	68fb      	ldr	r3, [r7, #12]
 8003a72:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 8003a74:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 8003a76:	6878      	ldr	r0, [r7, #4]
 8003a78:	4798      	blx	r3
}
 8003a7a:	bf00      	nop
 8003a7c:	3710      	adds	r7, #16
 8003a7e:	46bd      	mov	sp, r7
 8003a80:	bd80      	pop	{r7, pc}

08003a82 <ADC_DMAHalfConvCplt>:
  * @brief  DMA half transfer complete callback.
  * @param hdma pointer to DMA handle.
  * @retval None
  */
void ADC_DMAHalfConvCplt(DMA_HandleTypeDef *hdma)
{
 8003a82:	b580      	push	{r7, lr}
 8003a84:	b084      	sub	sp, #16
 8003a86:	af00      	add	r7, sp, #0
 8003a88:	6078      	str	r0, [r7, #4]
  /* Retrieve ADC handle corresponding to current DMA handle */
  ADC_HandleTypeDef *hadc = (ADC_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 8003a8a:	687b      	ldr	r3, [r7, #4]
 8003a8c:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8003a8e:	60fb      	str	r3, [r7, #12]

  /* Half conversion callback */
#if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
  hadc->ConvHalfCpltCallback(hadc);
#else
  HAL_ADC_ConvHalfCpltCallback(hadc);
 8003a90:	68f8      	ldr	r0, [r7, #12]
 8003a92:	f7ff fbb1 	bl	80031f8 <HAL_ADC_ConvHalfCpltCallback>
#endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
}
 8003a96:	bf00      	nop
 8003a98:	3710      	adds	r7, #16
 8003a9a:	46bd      	mov	sp, r7
 8003a9c:	bd80      	pop	{r7, pc}

08003a9e <ADC_DMAError>:
  * @brief  DMA error callback.
  * @param hdma pointer to DMA handle.
  * @retval None
  */
void ADC_DMAError(DMA_HandleTypeDef *hdma)
{
 8003a9e:	b580      	push	{r7, lr}
 8003aa0:	b084      	sub	sp, #16
 8003aa2:	af00      	add	r7, sp, #0
 8003aa4:	6078      	str	r0, [r7, #4]
  /* Retrieve ADC handle corresponding to current DMA handle */
  ADC_HandleTypeDef *hadc = (ADC_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 8003aa6:	687b      	ldr	r3, [r7, #4]
 8003aa8:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8003aaa:	60fb      	str	r3, [r7, #12]

  /* Set ADC state */
  SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_DMA);
 8003aac:	68fb      	ldr	r3, [r7, #12]
 8003aae:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8003ab0:	f043 0240 	orr.w	r2, r3, #64	@ 0x40
 8003ab4:	68fb      	ldr	r3, [r7, #12]
 8003ab6:	655a      	str	r2, [r3, #84]	@ 0x54

  /* Set ADC error code to DMA error */
  SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_DMA);
 8003ab8:	68fb      	ldr	r3, [r7, #12]
 8003aba:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8003abc:	f043 0204 	orr.w	r2, r3, #4
 8003ac0:	68fb      	ldr	r3, [r7, #12]
 8003ac2:	659a      	str	r2, [r3, #88]	@ 0x58

  /* Error callback */
#if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
  hadc->ErrorCallback(hadc);
#else
  HAL_ADC_ErrorCallback(hadc);
 8003ac4:	68f8      	ldr	r0, [r7, #12]
 8003ac6:	f7ff fba1 	bl	800320c <HAL_ADC_ErrorCallback>
#endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
}
 8003aca:	bf00      	nop
 8003acc:	3710      	adds	r7, #16
 8003ace:	46bd      	mov	sp, r7
 8003ad0:	bd80      	pop	{r7, pc}
	...

08003ad4 <ADC_ConfigureBoostMode>:
  *         stopped.
  * @param  hadc ADC handle
  * @retval None.
  */
void ADC_ConfigureBoostMode(ADC_HandleTypeDef *hadc)
{
 8003ad4:	b580      	push	{r7, lr}
 8003ad6:	b084      	sub	sp, #16
 8003ad8:	af00      	add	r7, sp, #0
 8003ada:	6078      	str	r0, [r7, #4]
  uint32_t freq;
  if (ADC_IS_SYNCHRONOUS_CLOCK_MODE(hadc))
 8003adc:	4b60      	ldr	r3, [pc, #384]	@ (8003c60 <ADC_ConfigureBoostMode+0x18c>)
 8003ade:	689b      	ldr	r3, [r3, #8]
 8003ae0:	f403 3340 	and.w	r3, r3, #196608	@ 0x30000
 8003ae4:	2b00      	cmp	r3, #0
 8003ae6:	d01c      	beq.n	8003b22 <ADC_ConfigureBoostMode+0x4e>
  {
    freq = HAL_RCC_GetHCLKFreq();
 8003ae8:	f006 fe3a 	bl	800a760 <HAL_RCC_GetHCLKFreq>
 8003aec:	60f8      	str	r0, [r7, #12]
    switch (hadc->Init.ClockPrescaler)
 8003aee:	687b      	ldr	r3, [r7, #4]
 8003af0:	685b      	ldr	r3, [r3, #4]
 8003af2:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
 8003af6:	d010      	beq.n	8003b1a <ADC_ConfigureBoostMode+0x46>
 8003af8:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
 8003afc:	d873      	bhi.n	8003be6 <ADC_ConfigureBoostMode+0x112>
 8003afe:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 8003b02:	d002      	beq.n	8003b0a <ADC_ConfigureBoostMode+0x36>
 8003b04:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 8003b08:	d16d      	bne.n	8003be6 <ADC_ConfigureBoostMode+0x112>
    {
      case ADC_CLOCK_SYNC_PCLK_DIV1:
      case ADC_CLOCK_SYNC_PCLK_DIV2:
        freq /= (hadc->Init.ClockPrescaler >> ADC_CCR_CKMODE_Pos);
 8003b0a:	687b      	ldr	r3, [r7, #4]
 8003b0c:	685b      	ldr	r3, [r3, #4]
 8003b0e:	0c1b      	lsrs	r3, r3, #16
 8003b10:	68fa      	ldr	r2, [r7, #12]
 8003b12:	fbb2 f3f3 	udiv	r3, r2, r3
 8003b16:	60fb      	str	r3, [r7, #12]
        break;
 8003b18:	e068      	b.n	8003bec <ADC_ConfigureBoostMode+0x118>
      case ADC_CLOCK_SYNC_PCLK_DIV4:
        freq /= 4UL;
 8003b1a:	68fb      	ldr	r3, [r7, #12]
 8003b1c:	089b      	lsrs	r3, r3, #2
 8003b1e:	60fb      	str	r3, [r7, #12]
        break;
 8003b20:	e064      	b.n	8003bec <ADC_ConfigureBoostMode+0x118>
        break;
    }
  }
  else
  {
    freq = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_ADC);
 8003b22:	f44f 2000 	mov.w	r0, #524288	@ 0x80000
 8003b26:	f04f 0100 	mov.w	r1, #0
 8003b2a:	f008 f81d 	bl	800bb68 <HAL_RCCEx_GetPeriphCLKFreq>
 8003b2e:	60f8      	str	r0, [r7, #12]
    switch (hadc->Init.ClockPrescaler)
 8003b30:	687b      	ldr	r3, [r7, #4]
 8003b32:	685b      	ldr	r3, [r3, #4]
 8003b34:	f5b3 1f30 	cmp.w	r3, #2883584	@ 0x2c0000
 8003b38:	d051      	beq.n	8003bde <ADC_ConfigureBoostMode+0x10a>
 8003b3a:	f5b3 1f30 	cmp.w	r3, #2883584	@ 0x2c0000
 8003b3e:	d854      	bhi.n	8003bea <ADC_ConfigureBoostMode+0x116>
 8003b40:	f5b3 1f20 	cmp.w	r3, #2621440	@ 0x280000
 8003b44:	d047      	beq.n	8003bd6 <ADC_ConfigureBoostMode+0x102>
 8003b46:	f5b3 1f20 	cmp.w	r3, #2621440	@ 0x280000
 8003b4a:	d84e      	bhi.n	8003bea <ADC_ConfigureBoostMode+0x116>
 8003b4c:	f5b3 1f10 	cmp.w	r3, #2359296	@ 0x240000
 8003b50:	d03d      	beq.n	8003bce <ADC_ConfigureBoostMode+0xfa>
 8003b52:	f5b3 1f10 	cmp.w	r3, #2359296	@ 0x240000
 8003b56:	d848      	bhi.n	8003bea <ADC_ConfigureBoostMode+0x116>
 8003b58:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
 8003b5c:	d033      	beq.n	8003bc6 <ADC_ConfigureBoostMode+0xf2>
 8003b5e:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
 8003b62:	d842      	bhi.n	8003bea <ADC_ConfigureBoostMode+0x116>
 8003b64:	f5b3 1fe0 	cmp.w	r3, #1835008	@ 0x1c0000
 8003b68:	d029      	beq.n	8003bbe <ADC_ConfigureBoostMode+0xea>
 8003b6a:	f5b3 1fe0 	cmp.w	r3, #1835008	@ 0x1c0000
 8003b6e:	d83c      	bhi.n	8003bea <ADC_ConfigureBoostMode+0x116>
 8003b70:	f5b3 1fc0 	cmp.w	r3, #1572864	@ 0x180000
 8003b74:	d01a      	beq.n	8003bac <ADC_ConfigureBoostMode+0xd8>
 8003b76:	f5b3 1fc0 	cmp.w	r3, #1572864	@ 0x180000
 8003b7a:	d836      	bhi.n	8003bea <ADC_ConfigureBoostMode+0x116>
 8003b7c:	f5b3 1fa0 	cmp.w	r3, #1310720	@ 0x140000
 8003b80:	d014      	beq.n	8003bac <ADC_ConfigureBoostMode+0xd8>
 8003b82:	f5b3 1fa0 	cmp.w	r3, #1310720	@ 0x140000
 8003b86:	d830      	bhi.n	8003bea <ADC_ConfigureBoostMode+0x116>
 8003b88:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
 8003b8c:	d00e      	beq.n	8003bac <ADC_ConfigureBoostMode+0xd8>
 8003b8e:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
 8003b92:	d82a      	bhi.n	8003bea <ADC_ConfigureBoostMode+0x116>
 8003b94:	f5b3 2f40 	cmp.w	r3, #786432	@ 0xc0000
 8003b98:	d008      	beq.n	8003bac <ADC_ConfigureBoostMode+0xd8>
 8003b9a:	f5b3 2f40 	cmp.w	r3, #786432	@ 0xc0000
 8003b9e:	d824      	bhi.n	8003bea <ADC_ConfigureBoostMode+0x116>
 8003ba0:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
 8003ba4:	d002      	beq.n	8003bac <ADC_ConfigureBoostMode+0xd8>
 8003ba6:	f5b3 2f00 	cmp.w	r3, #524288	@ 0x80000
 8003baa:	d11e      	bne.n	8003bea <ADC_ConfigureBoostMode+0x116>
      case ADC_CLOCK_ASYNC_DIV4:
      case ADC_CLOCK_ASYNC_DIV6:
      case ADC_CLOCK_ASYNC_DIV8:
      case ADC_CLOCK_ASYNC_DIV10:
      case ADC_CLOCK_ASYNC_DIV12:
        freq /= ((hadc->Init.ClockPrescaler >> ADC_CCR_PRESC_Pos) << 1UL);
 8003bac:	687b      	ldr	r3, [r7, #4]
 8003bae:	685b      	ldr	r3, [r3, #4]
 8003bb0:	0c9b      	lsrs	r3, r3, #18
 8003bb2:	005b      	lsls	r3, r3, #1
 8003bb4:	68fa      	ldr	r2, [r7, #12]
 8003bb6:	fbb2 f3f3 	udiv	r3, r2, r3
 8003bba:	60fb      	str	r3, [r7, #12]
        break;
 8003bbc:	e016      	b.n	8003bec <ADC_ConfigureBoostMode+0x118>
      case ADC_CLOCK_ASYNC_DIV16:
        freq /= 16UL;
 8003bbe:	68fb      	ldr	r3, [r7, #12]
 8003bc0:	091b      	lsrs	r3, r3, #4
 8003bc2:	60fb      	str	r3, [r7, #12]
        break;
 8003bc4:	e012      	b.n	8003bec <ADC_ConfigureBoostMode+0x118>
      case ADC_CLOCK_ASYNC_DIV32:
        freq /= 32UL;
 8003bc6:	68fb      	ldr	r3, [r7, #12]
 8003bc8:	095b      	lsrs	r3, r3, #5
 8003bca:	60fb      	str	r3, [r7, #12]
        break;
 8003bcc:	e00e      	b.n	8003bec <ADC_ConfigureBoostMode+0x118>
      case ADC_CLOCK_ASYNC_DIV64:
        freq /= 64UL;
 8003bce:	68fb      	ldr	r3, [r7, #12]
 8003bd0:	099b      	lsrs	r3, r3, #6
 8003bd2:	60fb      	str	r3, [r7, #12]
        break;
 8003bd4:	e00a      	b.n	8003bec <ADC_ConfigureBoostMode+0x118>
      case ADC_CLOCK_ASYNC_DIV128:
        freq /= 128UL;
 8003bd6:	68fb      	ldr	r3, [r7, #12]
 8003bd8:	09db      	lsrs	r3, r3, #7
 8003bda:	60fb      	str	r3, [r7, #12]
        break;
 8003bdc:	e006      	b.n	8003bec <ADC_ConfigureBoostMode+0x118>
      case ADC_CLOCK_ASYNC_DIV256:
        freq /= 256UL;
 8003bde:	68fb      	ldr	r3, [r7, #12]
 8003be0:	0a1b      	lsrs	r3, r3, #8
 8003be2:	60fb      	str	r3, [r7, #12]
        break;
 8003be4:	e002      	b.n	8003bec <ADC_ConfigureBoostMode+0x118>
        break;
 8003be6:	bf00      	nop
 8003be8:	e000      	b.n	8003bec <ADC_ConfigureBoostMode+0x118>
      default:
        break;
 8003bea:	bf00      	nop
    }
  }

#if defined(ADC_VER_V5_3) || defined(ADC_VER_V5_V90)
  freq /= 2U;
 8003bec:	68fb      	ldr	r3, [r7, #12]
 8003bee:	085b      	lsrs	r3, r3, #1
 8003bf0:	60fb      	str	r3, [r7, #12]
  if (freq <= 6250000UL)
 8003bf2:	68fb      	ldr	r3, [r7, #12]
 8003bf4:	4a1b      	ldr	r2, [pc, #108]	@ (8003c64 <ADC_ConfigureBoostMode+0x190>)
 8003bf6:	4293      	cmp	r3, r2
 8003bf8:	d808      	bhi.n	8003c0c <ADC_ConfigureBoostMode+0x138>
  {
    MODIFY_REG(hadc->Instance->CR, ADC_CR_BOOST, 0UL);
 8003bfa:	687b      	ldr	r3, [r7, #4]
 8003bfc:	681b      	ldr	r3, [r3, #0]
 8003bfe:	689a      	ldr	r2, [r3, #8]
 8003c00:	687b      	ldr	r3, [r7, #4]
 8003c02:	681b      	ldr	r3, [r3, #0]
 8003c04:	f422 7240 	bic.w	r2, r2, #768	@ 0x300
 8003c08:	609a      	str	r2, [r3, #8]
    {
      MODIFY_REG(hadc->Instance->CR, ADC_CR_BOOST, ADC_CR_BOOST_1 | ADC_CR_BOOST_0);
    }
  }
#endif /* ADC_VER_V5_3 */
}
 8003c0a:	e025      	b.n	8003c58 <ADC_ConfigureBoostMode+0x184>
  else if (freq <= 12500000UL)
 8003c0c:	68fb      	ldr	r3, [r7, #12]
 8003c0e:	4a16      	ldr	r2, [pc, #88]	@ (8003c68 <ADC_ConfigureBoostMode+0x194>)
 8003c10:	4293      	cmp	r3, r2
 8003c12:	d80a      	bhi.n	8003c2a <ADC_ConfigureBoostMode+0x156>
    MODIFY_REG(hadc->Instance->CR, ADC_CR_BOOST, ADC_CR_BOOST_0);
 8003c14:	687b      	ldr	r3, [r7, #4]
 8003c16:	681b      	ldr	r3, [r3, #0]
 8003c18:	689b      	ldr	r3, [r3, #8]
 8003c1a:	f423 7240 	bic.w	r2, r3, #768	@ 0x300
 8003c1e:	687b      	ldr	r3, [r7, #4]
 8003c20:	681b      	ldr	r3, [r3, #0]
 8003c22:	f442 7280 	orr.w	r2, r2, #256	@ 0x100
 8003c26:	609a      	str	r2, [r3, #8]
}
 8003c28:	e016      	b.n	8003c58 <ADC_ConfigureBoostMode+0x184>
  else if (freq <= 25000000UL)
 8003c2a:	68fb      	ldr	r3, [r7, #12]
 8003c2c:	4a0f      	ldr	r2, [pc, #60]	@ (8003c6c <ADC_ConfigureBoostMode+0x198>)
 8003c2e:	4293      	cmp	r3, r2
 8003c30:	d80a      	bhi.n	8003c48 <ADC_ConfigureBoostMode+0x174>
    MODIFY_REG(hadc->Instance->CR, ADC_CR_BOOST, ADC_CR_BOOST_1);
 8003c32:	687b      	ldr	r3, [r7, #4]
 8003c34:	681b      	ldr	r3, [r3, #0]
 8003c36:	689b      	ldr	r3, [r3, #8]
 8003c38:	f423 7240 	bic.w	r2, r3, #768	@ 0x300
 8003c3c:	687b      	ldr	r3, [r7, #4]
 8003c3e:	681b      	ldr	r3, [r3, #0]
 8003c40:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
 8003c44:	609a      	str	r2, [r3, #8]
}
 8003c46:	e007      	b.n	8003c58 <ADC_ConfigureBoostMode+0x184>
    MODIFY_REG(hadc->Instance->CR, ADC_CR_BOOST, ADC_CR_BOOST_1 | ADC_CR_BOOST_0);
 8003c48:	687b      	ldr	r3, [r7, #4]
 8003c4a:	681b      	ldr	r3, [r3, #0]
 8003c4c:	689a      	ldr	r2, [r3, #8]
 8003c4e:	687b      	ldr	r3, [r7, #4]
 8003c50:	681b      	ldr	r3, [r3, #0]
 8003c52:	f442 7240 	orr.w	r2, r2, #768	@ 0x300
 8003c56:	609a      	str	r2, [r3, #8]
}
 8003c58:	bf00      	nop
 8003c5a:	3710      	adds	r7, #16
 8003c5c:	46bd      	mov	sp, r7
 8003c5e:	bd80      	pop	{r7, pc}
 8003c60:	40022300 	.word	0x40022300
 8003c64:	005f5e10 	.word	0x005f5e10
 8003c68:	00bebc20 	.word	0x00bebc20
 8003c6c:	017d7840 	.word	0x017d7840

08003c70 <LL_ADC_IsEnabled>:
{
 8003c70:	b480      	push	{r7}
 8003c72:	b083      	sub	sp, #12
 8003c74:	af00      	add	r7, sp, #0
 8003c76:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 8003c78:	687b      	ldr	r3, [r7, #4]
 8003c7a:	689b      	ldr	r3, [r3, #8]
 8003c7c:	f003 0301 	and.w	r3, r3, #1
 8003c80:	2b01      	cmp	r3, #1
 8003c82:	d101      	bne.n	8003c88 <LL_ADC_IsEnabled+0x18>
 8003c84:	2301      	movs	r3, #1
 8003c86:	e000      	b.n	8003c8a <LL_ADC_IsEnabled+0x1a>
 8003c88:	2300      	movs	r3, #0
}
 8003c8a:	4618      	mov	r0, r3
 8003c8c:	370c      	adds	r7, #12
 8003c8e:	46bd      	mov	sp, r7
 8003c90:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003c94:	4770      	bx	lr
	...

08003c98 <LL_ADC_StartCalibration>:
{
 8003c98:	b480      	push	{r7}
 8003c9a:	b085      	sub	sp, #20
 8003c9c:	af00      	add	r7, sp, #0
 8003c9e:	60f8      	str	r0, [r7, #12]
 8003ca0:	60b9      	str	r1, [r7, #8]
 8003ca2:	607a      	str	r2, [r7, #4]
  MODIFY_REG(ADCx->CR,
 8003ca4:	68fb      	ldr	r3, [r7, #12]
 8003ca6:	689a      	ldr	r2, [r3, #8]
 8003ca8:	4b09      	ldr	r3, [pc, #36]	@ (8003cd0 <LL_ADC_StartCalibration+0x38>)
 8003caa:	4013      	ands	r3, r2
 8003cac:	68ba      	ldr	r2, [r7, #8]
 8003cae:	f402 3180 	and.w	r1, r2, #65536	@ 0x10000
 8003cb2:	687a      	ldr	r2, [r7, #4]
 8003cb4:	f002 4280 	and.w	r2, r2, #1073741824	@ 0x40000000
 8003cb8:	430a      	orrs	r2, r1
 8003cba:	4313      	orrs	r3, r2
 8003cbc:	f043 4200 	orr.w	r2, r3, #2147483648	@ 0x80000000
 8003cc0:	68fb      	ldr	r3, [r7, #12]
 8003cc2:	609a      	str	r2, [r3, #8]
}
 8003cc4:	bf00      	nop
 8003cc6:	3714      	adds	r7, #20
 8003cc8:	46bd      	mov	sp, r7
 8003cca:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003cce:	4770      	bx	lr
 8003cd0:	3ffeffc0 	.word	0x3ffeffc0

08003cd4 <LL_ADC_IsCalibrationOnGoing>:
{
 8003cd4:	b480      	push	{r7}
 8003cd6:	b083      	sub	sp, #12
 8003cd8:	af00      	add	r7, sp, #0
 8003cda:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADCAL) == (ADC_CR_ADCAL)) ? 1UL : 0UL);
 8003cdc:	687b      	ldr	r3, [r7, #4]
 8003cde:	689b      	ldr	r3, [r3, #8]
 8003ce0:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
 8003ce4:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 8003ce8:	d101      	bne.n	8003cee <LL_ADC_IsCalibrationOnGoing+0x1a>
 8003cea:	2301      	movs	r3, #1
 8003cec:	e000      	b.n	8003cf0 <LL_ADC_IsCalibrationOnGoing+0x1c>
 8003cee:	2300      	movs	r3, #0
}
 8003cf0:	4618      	mov	r0, r3
 8003cf2:	370c      	adds	r7, #12
 8003cf4:	46bd      	mov	sp, r7
 8003cf6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003cfa:	4770      	bx	lr

08003cfc <LL_ADC_REG_IsConversionOngoing>:
{
 8003cfc:	b480      	push	{r7}
 8003cfe:	b083      	sub	sp, #12
 8003d00:	af00      	add	r7, sp, #0
 8003d02:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 8003d04:	687b      	ldr	r3, [r7, #4]
 8003d06:	689b      	ldr	r3, [r3, #8]
 8003d08:	f003 0304 	and.w	r3, r3, #4
 8003d0c:	2b04      	cmp	r3, #4
 8003d0e:	d101      	bne.n	8003d14 <LL_ADC_REG_IsConversionOngoing+0x18>
 8003d10:	2301      	movs	r3, #1
 8003d12:	e000      	b.n	8003d16 <LL_ADC_REG_IsConversionOngoing+0x1a>
 8003d14:	2300      	movs	r3, #0
}
 8003d16:	4618      	mov	r0, r3
 8003d18:	370c      	adds	r7, #12
 8003d1a:	46bd      	mov	sp, r7
 8003d1c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003d20:	4770      	bx	lr
	...

08003d24 <HAL_ADCEx_Calibration_Start>:
  *           @arg @ref ADC_SINGLE_ENDED       Channel in mode input single ended
  *           @arg @ref ADC_DIFFERENTIAL_ENDED Channel in mode input differential ended
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADCEx_Calibration_Start(ADC_HandleTypeDef *hadc, uint32_t CalibrationMode, uint32_t SingleDiff)
{
 8003d24:	b580      	push	{r7, lr}
 8003d26:	b086      	sub	sp, #24
 8003d28:	af00      	add	r7, sp, #0
 8003d2a:	60f8      	str	r0, [r7, #12]
 8003d2c:	60b9      	str	r1, [r7, #8]
 8003d2e:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef tmp_hal_status;
  __IO uint32_t wait_loop_index = 0UL;
 8003d30:	2300      	movs	r3, #0
 8003d32:	613b      	str	r3, [r7, #16]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
  assert_param(IS_ADC_SINGLE_DIFFERENTIAL(SingleDiff));

  /* Process locked */
  __HAL_LOCK(hadc);
 8003d34:	68fb      	ldr	r3, [r7, #12]
 8003d36:	f893 3050 	ldrb.w	r3, [r3, #80]	@ 0x50
 8003d3a:	2b01      	cmp	r3, #1
 8003d3c:	d101      	bne.n	8003d42 <HAL_ADCEx_Calibration_Start+0x1e>
 8003d3e:	2302      	movs	r3, #2
 8003d40:	e04c      	b.n	8003ddc <HAL_ADCEx_Calibration_Start+0xb8>
 8003d42:	68fb      	ldr	r3, [r7, #12]
 8003d44:	2201      	movs	r2, #1
 8003d46:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50

  /* Calibration prerequisite: ADC must be disabled. */

  /* Disable the ADC (if not already disabled) */
  tmp_hal_status = ADC_Disable(hadc);
 8003d4a:	68f8      	ldr	r0, [r7, #12]
 8003d4c:	f7ff fdce 	bl	80038ec <ADC_Disable>
 8003d50:	4603      	mov	r3, r0
 8003d52:	75fb      	strb	r3, [r7, #23]

  /* Check if ADC is effectively disabled */
  if (tmp_hal_status == HAL_OK)
 8003d54:	7dfb      	ldrb	r3, [r7, #23]
 8003d56:	2b00      	cmp	r3, #0
 8003d58:	d135      	bne.n	8003dc6 <HAL_ADCEx_Calibration_Start+0xa2>
  {
    /* Set ADC state */
    ADC_STATE_CLR_SET(hadc->State,
 8003d5a:	68fb      	ldr	r3, [r7, #12]
 8003d5c:	6d5a      	ldr	r2, [r3, #84]	@ 0x54
 8003d5e:	4b21      	ldr	r3, [pc, #132]	@ (8003de4 <HAL_ADCEx_Calibration_Start+0xc0>)
 8003d60:	4013      	ands	r3, r2
 8003d62:	f043 0202 	orr.w	r2, r3, #2
 8003d66:	68fb      	ldr	r3, [r7, #12]
 8003d68:	655a      	str	r2, [r3, #84]	@ 0x54
                      HAL_ADC_STATE_REG_BUSY | HAL_ADC_STATE_INJ_BUSY,
                      HAL_ADC_STATE_BUSY_INTERNAL);

    /* Start ADC calibration in mode single-ended or differential */
    LL_ADC_StartCalibration(hadc->Instance, CalibrationMode, SingleDiff);
 8003d6a:	68fb      	ldr	r3, [r7, #12]
 8003d6c:	681b      	ldr	r3, [r3, #0]
 8003d6e:	687a      	ldr	r2, [r7, #4]
 8003d70:	68b9      	ldr	r1, [r7, #8]
 8003d72:	4618      	mov	r0, r3
 8003d74:	f7ff ff90 	bl	8003c98 <LL_ADC_StartCalibration>

    /* Wait for calibration completion */
    while (LL_ADC_IsCalibrationOnGoing(hadc->Instance) != 0UL)
 8003d78:	e014      	b.n	8003da4 <HAL_ADCEx_Calibration_Start+0x80>
    {
      wait_loop_index++;
 8003d7a:	693b      	ldr	r3, [r7, #16]
 8003d7c:	3301      	adds	r3, #1
 8003d7e:	613b      	str	r3, [r7, #16]
      if (wait_loop_index >= ADC_CALIBRATION_TIMEOUT)
 8003d80:	693b      	ldr	r3, [r7, #16]
 8003d82:	4a19      	ldr	r2, [pc, #100]	@ (8003de8 <HAL_ADCEx_Calibration_Start+0xc4>)
 8003d84:	4293      	cmp	r3, r2
 8003d86:	d30d      	bcc.n	8003da4 <HAL_ADCEx_Calibration_Start+0x80>
      {
        /* Update ADC state machine to error */
        ADC_STATE_CLR_SET(hadc->State,
 8003d88:	68fb      	ldr	r3, [r7, #12]
 8003d8a:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8003d8c:	f023 0312 	bic.w	r3, r3, #18
 8003d90:	f043 0210 	orr.w	r2, r3, #16
 8003d94:	68fb      	ldr	r3, [r7, #12]
 8003d96:	655a      	str	r2, [r3, #84]	@ 0x54
                          HAL_ADC_STATE_BUSY_INTERNAL,
                          HAL_ADC_STATE_ERROR_INTERNAL);

        /* Process unlocked */
        __HAL_UNLOCK(hadc);
 8003d98:	68fb      	ldr	r3, [r7, #12]
 8003d9a:	2200      	movs	r2, #0
 8003d9c:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50

        return HAL_ERROR;
 8003da0:	2301      	movs	r3, #1
 8003da2:	e01b      	b.n	8003ddc <HAL_ADCEx_Calibration_Start+0xb8>
    while (LL_ADC_IsCalibrationOnGoing(hadc->Instance) != 0UL)
 8003da4:	68fb      	ldr	r3, [r7, #12]
 8003da6:	681b      	ldr	r3, [r3, #0]
 8003da8:	4618      	mov	r0, r3
 8003daa:	f7ff ff93 	bl	8003cd4 <LL_ADC_IsCalibrationOnGoing>
 8003dae:	4603      	mov	r3, r0
 8003db0:	2b00      	cmp	r3, #0
 8003db2:	d1e2      	bne.n	8003d7a <HAL_ADCEx_Calibration_Start+0x56>
      }
    }

    /* Set ADC state */
    ADC_STATE_CLR_SET(hadc->State,
 8003db4:	68fb      	ldr	r3, [r7, #12]
 8003db6:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8003db8:	f023 0303 	bic.w	r3, r3, #3
 8003dbc:	f043 0201 	orr.w	r2, r3, #1
 8003dc0:	68fb      	ldr	r3, [r7, #12]
 8003dc2:	655a      	str	r2, [r3, #84]	@ 0x54
 8003dc4:	e005      	b.n	8003dd2 <HAL_ADCEx_Calibration_Start+0xae>
                      HAL_ADC_STATE_BUSY_INTERNAL,
                      HAL_ADC_STATE_READY);
  }
  else
  {
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8003dc6:	68fb      	ldr	r3, [r7, #12]
 8003dc8:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8003dca:	f043 0210 	orr.w	r2, r3, #16
 8003dce:	68fb      	ldr	r3, [r7, #12]
 8003dd0:	655a      	str	r2, [r3, #84]	@ 0x54
    /* Note: No need to update variable "tmp_hal_status" here: already set    */
    /*       to state "HAL_ERROR" by function disabling the ADC.              */
  }

  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 8003dd2:	68fb      	ldr	r3, [r7, #12]
 8003dd4:	2200      	movs	r2, #0
 8003dd6:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50

  /* Return function status */
  return tmp_hal_status;
 8003dda:	7dfb      	ldrb	r3, [r7, #23]
}
 8003ddc:	4618      	mov	r0, r3
 8003dde:	3718      	adds	r7, #24
 8003de0:	46bd      	mov	sp, r7
 8003de2:	bd80      	pop	{r7, pc}
 8003de4:	ffffeefd 	.word	0xffffeefd
 8003de8:	25c3f800 	.word	0x25c3f800

08003dec <HAL_ADCEx_MultiModeConfigChannel>:
  * @param hadc Master ADC handle
  * @param multimode Structure of ADC multimode configuration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADCEx_MultiModeConfigChannel(ADC_HandleTypeDef *hadc, ADC_MultiModeTypeDef *multimode)
{
 8003dec:	b590      	push	{r4, r7, lr}
 8003dee:	b09f      	sub	sp, #124	@ 0x7c
 8003df0:	af00      	add	r7, sp, #0
 8003df2:	6078      	str	r0, [r7, #4]
 8003df4:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 8003df6:	2300      	movs	r3, #0
 8003df8:	f887 3077 	strb.w	r3, [r7, #119]	@ 0x77
    assert_param(IS_ADC_DUAL_DATA_MODE(multimode->DualModeData));
    assert_param(IS_ADC_SAMPLING_DELAY(multimode->TwoSamplingDelay));
  }

  /* Process locked */
  __HAL_LOCK(hadc);
 8003dfc:	687b      	ldr	r3, [r7, #4]
 8003dfe:	f893 3050 	ldrb.w	r3, [r3, #80]	@ 0x50
 8003e02:	2b01      	cmp	r3, #1
 8003e04:	d101      	bne.n	8003e0a <HAL_ADCEx_MultiModeConfigChannel+0x1e>
 8003e06:	2302      	movs	r3, #2
 8003e08:	e080      	b.n	8003f0c <HAL_ADCEx_MultiModeConfigChannel+0x120>
 8003e0a:	687b      	ldr	r3, [r7, #4]
 8003e0c:	2201      	movs	r2, #1
 8003e0e:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50

  tmphadcSlave.State = HAL_ADC_STATE_RESET;
 8003e12:	2300      	movs	r3, #0
 8003e14:	65fb      	str	r3, [r7, #92]	@ 0x5c
  tmphadcSlave.ErrorCode = HAL_ADC_ERROR_NONE;
 8003e16:	2300      	movs	r3, #0
 8003e18:	663b      	str	r3, [r7, #96]	@ 0x60

  ADC_MULTI_SLAVE(hadc, &tmphadcSlave);
 8003e1a:	687b      	ldr	r3, [r7, #4]
 8003e1c:	681b      	ldr	r3, [r3, #0]
 8003e1e:	4a3d      	ldr	r2, [pc, #244]	@ (8003f14 <HAL_ADCEx_MultiModeConfigChannel+0x128>)
 8003e20:	4293      	cmp	r3, r2
 8003e22:	d102      	bne.n	8003e2a <HAL_ADCEx_MultiModeConfigChannel+0x3e>
 8003e24:	4b3c      	ldr	r3, [pc, #240]	@ (8003f18 <HAL_ADCEx_MultiModeConfigChannel+0x12c>)
 8003e26:	60bb      	str	r3, [r7, #8]
 8003e28:	e001      	b.n	8003e2e <HAL_ADCEx_MultiModeConfigChannel+0x42>
 8003e2a:	2300      	movs	r3, #0
 8003e2c:	60bb      	str	r3, [r7, #8]

  if (tmphadcSlave.Instance == NULL)
 8003e2e:	68bb      	ldr	r3, [r7, #8]
 8003e30:	2b00      	cmp	r3, #0
 8003e32:	d10b      	bne.n	8003e4c <HAL_ADCEx_MultiModeConfigChannel+0x60>
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8003e34:	687b      	ldr	r3, [r7, #4]
 8003e36:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8003e38:	f043 0220 	orr.w	r2, r3, #32
 8003e3c:	687b      	ldr	r3, [r7, #4]
 8003e3e:	655a      	str	r2, [r3, #84]	@ 0x54

    /* Process unlocked */
    __HAL_UNLOCK(hadc);
 8003e40:	687b      	ldr	r3, [r7, #4]
 8003e42:	2200      	movs	r2, #0
 8003e44:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50

    return HAL_ERROR;
 8003e48:	2301      	movs	r3, #1
 8003e4a:	e05f      	b.n	8003f0c <HAL_ADCEx_MultiModeConfigChannel+0x120>

  /* Parameters update conditioned to ADC state:                              */
  /* Parameters that can be updated when ADC is disabled or enabled without   */
  /* conversion on going on regular group:                                    */
  /*  - Multimode DATA Format configuration                                   */
  tmphadcSlave_conversion_on_going = LL_ADC_REG_IsConversionOngoing((&tmphadcSlave)->Instance);
 8003e4c:	68bb      	ldr	r3, [r7, #8]
 8003e4e:	4618      	mov	r0, r3
 8003e50:	f7ff ff54 	bl	8003cfc <LL_ADC_REG_IsConversionOngoing>
 8003e54:	6738      	str	r0, [r7, #112]	@ 0x70
  if ((LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 0UL)
 8003e56:	687b      	ldr	r3, [r7, #4]
 8003e58:	681b      	ldr	r3, [r3, #0]
 8003e5a:	4618      	mov	r0, r3
 8003e5c:	f7ff ff4e 	bl	8003cfc <LL_ADC_REG_IsConversionOngoing>
 8003e60:	4603      	mov	r3, r0
 8003e62:	2b00      	cmp	r3, #0
 8003e64:	d141      	bne.n	8003eea <HAL_ADCEx_MultiModeConfigChannel+0xfe>
      && (tmphadcSlave_conversion_on_going == 0UL))
 8003e66:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 8003e68:	2b00      	cmp	r3, #0
 8003e6a:	d13e      	bne.n	8003eea <HAL_ADCEx_MultiModeConfigChannel+0xfe>
  {
    /* Pointer to the common control register */
    tmpADC_Common = __LL_ADC_COMMON_INSTANCE(hadc->Instance);
 8003e6c:	4b2b      	ldr	r3, [pc, #172]	@ (8003f1c <HAL_ADCEx_MultiModeConfigChannel+0x130>)
 8003e6e:	66fb      	str	r3, [r7, #108]	@ 0x6c

    /* If multimode is selected, configure all multimode parameters.          */
    /* Otherwise, reset multimode parameters (can be used in case of          */
    /* transition from multimode to independent mode).                        */
    if (multimode->Mode != ADC_MODE_INDEPENDENT)
 8003e70:	683b      	ldr	r3, [r7, #0]
 8003e72:	681b      	ldr	r3, [r3, #0]
 8003e74:	2b00      	cmp	r3, #0
 8003e76:	d020      	beq.n	8003eba <HAL_ADCEx_MultiModeConfigChannel+0xce>
    {
      MODIFY_REG(tmpADC_Common->CCR, ADC_CCR_DAMDF, multimode->DualModeData);
 8003e78:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8003e7a:	689b      	ldr	r3, [r3, #8]
 8003e7c:	f423 4240 	bic.w	r2, r3, #49152	@ 0xc000
 8003e80:	683b      	ldr	r3, [r7, #0]
 8003e82:	685b      	ldr	r3, [r3, #4]
 8003e84:	431a      	orrs	r2, r3
 8003e86:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8003e88:	609a      	str	r2, [r3, #8]
      /*      from 1 to 8 clock cycles for 12 bits                              */
      /*      from 1 to 6 clock cycles for 10 and 8 bits                        */
      /*    If a higher delay is selected, it will be clipped to maximum delay  */
      /*    range                                                               */

      if (__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) == 0UL)
 8003e8a:	4822      	ldr	r0, [pc, #136]	@ (8003f14 <HAL_ADCEx_MultiModeConfigChannel+0x128>)
 8003e8c:	f7ff fef0 	bl	8003c70 <LL_ADC_IsEnabled>
 8003e90:	4604      	mov	r4, r0
 8003e92:	4821      	ldr	r0, [pc, #132]	@ (8003f18 <HAL_ADCEx_MultiModeConfigChannel+0x12c>)
 8003e94:	f7ff feec 	bl	8003c70 <LL_ADC_IsEnabled>
 8003e98:	4603      	mov	r3, r0
 8003e9a:	4323      	orrs	r3, r4
 8003e9c:	2b00      	cmp	r3, #0
 8003e9e:	d12e      	bne.n	8003efe <HAL_ADCEx_MultiModeConfigChannel+0x112>
      {
        MODIFY_REG(tmpADC_Common->CCR,
 8003ea0:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8003ea2:	689a      	ldr	r2, [r3, #8]
 8003ea4:	4b1e      	ldr	r3, [pc, #120]	@ (8003f20 <HAL_ADCEx_MultiModeConfigChannel+0x134>)
 8003ea6:	4013      	ands	r3, r2
 8003ea8:	683a      	ldr	r2, [r7, #0]
 8003eaa:	6811      	ldr	r1, [r2, #0]
 8003eac:	683a      	ldr	r2, [r7, #0]
 8003eae:	6892      	ldr	r2, [r2, #8]
 8003eb0:	430a      	orrs	r2, r1
 8003eb2:	431a      	orrs	r2, r3
 8003eb4:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8003eb6:	609a      	str	r2, [r3, #8]
    if (multimode->Mode != ADC_MODE_INDEPENDENT)
 8003eb8:	e021      	b.n	8003efe <HAL_ADCEx_MultiModeConfigChannel+0x112>
                  );
      }
    }
    else /* ADC_MODE_INDEPENDENT */
    {
      CLEAR_BIT(tmpADC_Common->CCR, ADC_CCR_DAMDF);
 8003eba:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8003ebc:	689b      	ldr	r3, [r3, #8]
 8003ebe:	f423 4240 	bic.w	r2, r3, #49152	@ 0xc000
 8003ec2:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8003ec4:	609a      	str	r2, [r3, #8]

      /* Parameters that can be updated only when ADC is disabled:                */
      /*  - Multimode mode selection                                              */
      /*  - Multimode delay                                                       */
      if (__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) == 0UL)
 8003ec6:	4813      	ldr	r0, [pc, #76]	@ (8003f14 <HAL_ADCEx_MultiModeConfigChannel+0x128>)
 8003ec8:	f7ff fed2 	bl	8003c70 <LL_ADC_IsEnabled>
 8003ecc:	4604      	mov	r4, r0
 8003ece:	4812      	ldr	r0, [pc, #72]	@ (8003f18 <HAL_ADCEx_MultiModeConfigChannel+0x12c>)
 8003ed0:	f7ff fece 	bl	8003c70 <LL_ADC_IsEnabled>
 8003ed4:	4603      	mov	r3, r0
 8003ed6:	4323      	orrs	r3, r4
 8003ed8:	2b00      	cmp	r3, #0
 8003eda:	d110      	bne.n	8003efe <HAL_ADCEx_MultiModeConfigChannel+0x112>
      {
        CLEAR_BIT(tmpADC_Common->CCR, ADC_CCR_DUAL | ADC_CCR_DELAY);
 8003edc:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8003ede:	689a      	ldr	r2, [r3, #8]
 8003ee0:	4b0f      	ldr	r3, [pc, #60]	@ (8003f20 <HAL_ADCEx_MultiModeConfigChannel+0x134>)
 8003ee2:	4013      	ands	r3, r2
 8003ee4:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 8003ee6:	6093      	str	r3, [r2, #8]
    if (multimode->Mode != ADC_MODE_INDEPENDENT)
 8003ee8:	e009      	b.n	8003efe <HAL_ADCEx_MultiModeConfigChannel+0x112>
  /* If one of the ADC sharing the same common group is enabled, no update    */
  /* could be done on neither of the multimode structure parameters.          */
  else
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8003eea:	687b      	ldr	r3, [r7, #4]
 8003eec:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8003eee:	f043 0220 	orr.w	r2, r3, #32
 8003ef2:	687b      	ldr	r3, [r7, #4]
 8003ef4:	655a      	str	r2, [r3, #84]	@ 0x54

    tmp_hal_status = HAL_ERROR;
 8003ef6:	2301      	movs	r3, #1
 8003ef8:	f887 3077 	strb.w	r3, [r7, #119]	@ 0x77
 8003efc:	e000      	b.n	8003f00 <HAL_ADCEx_MultiModeConfigChannel+0x114>
    if (multimode->Mode != ADC_MODE_INDEPENDENT)
 8003efe:	bf00      	nop
  }

  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 8003f00:	687b      	ldr	r3, [r7, #4]
 8003f02:	2200      	movs	r2, #0
 8003f04:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50

  /* Return function status */
  return tmp_hal_status;
 8003f08:	f897 3077 	ldrb.w	r3, [r7, #119]	@ 0x77
}
 8003f0c:	4618      	mov	r0, r3
 8003f0e:	377c      	adds	r7, #124	@ 0x7c
 8003f10:	46bd      	mov	sp, r7
 8003f12:	bd90      	pop	{r4, r7, pc}
 8003f14:	40022000 	.word	0x40022000
 8003f18:	40022100 	.word	0x40022100
 8003f1c:	40022300 	.word	0x40022300
 8003f20:	fffff0e0 	.word	0xfffff0e0

08003f24 <__NVIC_SetPriorityGrouping>:
{
 8003f24:	b480      	push	{r7}
 8003f26:	b085      	sub	sp, #20
 8003f28:	af00      	add	r7, sp, #0
 8003f2a:	6078      	str	r0, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 8003f2c:	687b      	ldr	r3, [r7, #4]
 8003f2e:	f003 0307 	and.w	r3, r3, #7
 8003f32:	60fb      	str	r3, [r7, #12]
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8003f34:	4b0b      	ldr	r3, [pc, #44]	@ (8003f64 <__NVIC_SetPriorityGrouping+0x40>)
 8003f36:	68db      	ldr	r3, [r3, #12]
 8003f38:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8003f3a:	68ba      	ldr	r2, [r7, #8]
 8003f3c:	f64f 03ff 	movw	r3, #63743	@ 0xf8ff
 8003f40:	4013      	ands	r3, r2
 8003f42:	60bb      	str	r3, [r7, #8]
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 8003f44:	68fb      	ldr	r3, [r7, #12]
 8003f46:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 8003f48:	68bb      	ldr	r3, [r7, #8]
 8003f4a:	431a      	orrs	r2, r3
  reg_value  =  (reg_value                                   |
 8003f4c:	4b06      	ldr	r3, [pc, #24]	@ (8003f68 <__NVIC_SetPriorityGrouping+0x44>)
 8003f4e:	4313      	orrs	r3, r2
 8003f50:	60bb      	str	r3, [r7, #8]
  SCB->AIRCR =  reg_value;
 8003f52:	4a04      	ldr	r2, [pc, #16]	@ (8003f64 <__NVIC_SetPriorityGrouping+0x40>)
 8003f54:	68bb      	ldr	r3, [r7, #8]
 8003f56:	60d3      	str	r3, [r2, #12]
}
 8003f58:	bf00      	nop
 8003f5a:	3714      	adds	r7, #20
 8003f5c:	46bd      	mov	sp, r7
 8003f5e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003f62:	4770      	bx	lr
 8003f64:	e000ed00 	.word	0xe000ed00
 8003f68:	05fa0000 	.word	0x05fa0000

08003f6c <__NVIC_GetPriorityGrouping>:
{
 8003f6c:	b480      	push	{r7}
 8003f6e:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8003f70:	4b04      	ldr	r3, [pc, #16]	@ (8003f84 <__NVIC_GetPriorityGrouping+0x18>)
 8003f72:	68db      	ldr	r3, [r3, #12]
 8003f74:	0a1b      	lsrs	r3, r3, #8
 8003f76:	f003 0307 	and.w	r3, r3, #7
}
 8003f7a:	4618      	mov	r0, r3
 8003f7c:	46bd      	mov	sp, r7
 8003f7e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003f82:	4770      	bx	lr
 8003f84:	e000ed00 	.word	0xe000ed00

08003f88 <__NVIC_EnableIRQ>:
{
 8003f88:	b480      	push	{r7}
 8003f8a:	b083      	sub	sp, #12
 8003f8c:	af00      	add	r7, sp, #0
 8003f8e:	4603      	mov	r3, r0
 8003f90:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
 8003f92:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8003f96:	2b00      	cmp	r3, #0
 8003f98:	db0b      	blt.n	8003fb2 <__NVIC_EnableIRQ+0x2a>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8003f9a:	88fb      	ldrh	r3, [r7, #6]
 8003f9c:	f003 021f 	and.w	r2, r3, #31
 8003fa0:	4907      	ldr	r1, [pc, #28]	@ (8003fc0 <__NVIC_EnableIRQ+0x38>)
 8003fa2:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8003fa6:	095b      	lsrs	r3, r3, #5
 8003fa8:	2001      	movs	r0, #1
 8003faa:	fa00 f202 	lsl.w	r2, r0, r2
 8003fae:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
 8003fb2:	bf00      	nop
 8003fb4:	370c      	adds	r7, #12
 8003fb6:	46bd      	mov	sp, r7
 8003fb8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003fbc:	4770      	bx	lr
 8003fbe:	bf00      	nop
 8003fc0:	e000e100 	.word	0xe000e100

08003fc4 <__NVIC_SetPriority>:
{
 8003fc4:	b480      	push	{r7}
 8003fc6:	b083      	sub	sp, #12
 8003fc8:	af00      	add	r7, sp, #0
 8003fca:	4603      	mov	r3, r0
 8003fcc:	6039      	str	r1, [r7, #0]
 8003fce:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
 8003fd0:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8003fd4:	2b00      	cmp	r3, #0
 8003fd6:	db0a      	blt.n	8003fee <__NVIC_SetPriority+0x2a>
    NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8003fd8:	683b      	ldr	r3, [r7, #0]
 8003fda:	b2da      	uxtb	r2, r3
 8003fdc:	490c      	ldr	r1, [pc, #48]	@ (8004010 <__NVIC_SetPriority+0x4c>)
 8003fde:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8003fe2:	0112      	lsls	r2, r2, #4
 8003fe4:	b2d2      	uxtb	r2, r2
 8003fe6:	440b      	add	r3, r1
 8003fe8:	f883 2300 	strb.w	r2, [r3, #768]	@ 0x300
}
 8003fec:	e00a      	b.n	8004004 <__NVIC_SetPriority+0x40>
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8003fee:	683b      	ldr	r3, [r7, #0]
 8003ff0:	b2da      	uxtb	r2, r3
 8003ff2:	4908      	ldr	r1, [pc, #32]	@ (8004014 <__NVIC_SetPriority+0x50>)
 8003ff4:	88fb      	ldrh	r3, [r7, #6]
 8003ff6:	f003 030f 	and.w	r3, r3, #15
 8003ffa:	3b04      	subs	r3, #4
 8003ffc:	0112      	lsls	r2, r2, #4
 8003ffe:	b2d2      	uxtb	r2, r2
 8004000:	440b      	add	r3, r1
 8004002:	761a      	strb	r2, [r3, #24]
}
 8004004:	bf00      	nop
 8004006:	370c      	adds	r7, #12
 8004008:	46bd      	mov	sp, r7
 800400a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800400e:	4770      	bx	lr
 8004010:	e000e100 	.word	0xe000e100
 8004014:	e000ed00 	.word	0xe000ed00

08004018 <NVIC_EncodePriority>:
{
 8004018:	b480      	push	{r7}
 800401a:	b089      	sub	sp, #36	@ 0x24
 800401c:	af00      	add	r7, sp, #0
 800401e:	60f8      	str	r0, [r7, #12]
 8004020:	60b9      	str	r1, [r7, #8]
 8004022:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 8004024:	68fb      	ldr	r3, [r7, #12]
 8004026:	f003 0307 	and.w	r3, r3, #7
 800402a:	61fb      	str	r3, [r7, #28]
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 800402c:	69fb      	ldr	r3, [r7, #28]
 800402e:	f1c3 0307 	rsb	r3, r3, #7
 8004032:	2b04      	cmp	r3, #4
 8004034:	bf28      	it	cs
 8004036:	2304      	movcs	r3, #4
 8004038:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800403a:	69fb      	ldr	r3, [r7, #28]
 800403c:	3304      	adds	r3, #4
 800403e:	2b06      	cmp	r3, #6
 8004040:	d902      	bls.n	8004048 <NVIC_EncodePriority+0x30>
 8004042:	69fb      	ldr	r3, [r7, #28]
 8004044:	3b03      	subs	r3, #3
 8004046:	e000      	b.n	800404a <NVIC_EncodePriority+0x32>
 8004048:	2300      	movs	r3, #0
 800404a:	617b      	str	r3, [r7, #20]
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800404c:	f04f 32ff 	mov.w	r2, #4294967295
 8004050:	69bb      	ldr	r3, [r7, #24]
 8004052:	fa02 f303 	lsl.w	r3, r2, r3
 8004056:	43da      	mvns	r2, r3
 8004058:	68bb      	ldr	r3, [r7, #8]
 800405a:	401a      	ands	r2, r3
 800405c:	697b      	ldr	r3, [r7, #20]
 800405e:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 8004060:	f04f 31ff 	mov.w	r1, #4294967295
 8004064:	697b      	ldr	r3, [r7, #20]
 8004066:	fa01 f303 	lsl.w	r3, r1, r3
 800406a:	43d9      	mvns	r1, r3
 800406c:	687b      	ldr	r3, [r7, #4]
 800406e:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8004070:	4313      	orrs	r3, r2
}
 8004072:	4618      	mov	r0, r3
 8004074:	3724      	adds	r7, #36	@ 0x24
 8004076:	46bd      	mov	sp, r7
 8004078:	f85d 7b04 	ldr.w	r7, [sp], #4
 800407c:	4770      	bx	lr
	...

08004080 <SysTick_Config>:
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
 8004080:	b580      	push	{r7, lr}
 8004082:	b082      	sub	sp, #8
 8004084:	af00      	add	r7, sp, #0
 8004086:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 8004088:	687b      	ldr	r3, [r7, #4]
 800408a:	3b01      	subs	r3, #1
 800408c:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
 8004090:	d301      	bcc.n	8004096 <SysTick_Config+0x16>
  {
    return (1UL);                                                   /* Reload value impossible */
 8004092:	2301      	movs	r3, #1
 8004094:	e00f      	b.n	80040b6 <SysTick_Config+0x36>
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8004096:	4a0a      	ldr	r2, [pc, #40]	@ (80040c0 <SysTick_Config+0x40>)
 8004098:	687b      	ldr	r3, [r7, #4]
 800409a:	3b01      	subs	r3, #1
 800409c:	6053      	str	r3, [r2, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
 800409e:	210f      	movs	r1, #15
 80040a0:	f04f 30ff 	mov.w	r0, #4294967295
 80040a4:	f7ff ff8e 	bl	8003fc4 <__NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 80040a8:	4b05      	ldr	r3, [pc, #20]	@ (80040c0 <SysTick_Config+0x40>)
 80040aa:	2200      	movs	r2, #0
 80040ac:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 80040ae:	4b04      	ldr	r3, [pc, #16]	@ (80040c0 <SysTick_Config+0x40>)
 80040b0:	2207      	movs	r2, #7
 80040b2:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 80040b4:	2300      	movs	r3, #0
}
 80040b6:	4618      	mov	r0, r3
 80040b8:	3708      	adds	r7, #8
 80040ba:	46bd      	mov	sp, r7
 80040bc:	bd80      	pop	{r7, pc}
 80040be:	bf00      	nop
 80040c0:	e000e010 	.word	0xe000e010

080040c4 <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ preemption is no more possible.
  *         The pending IRQ priority will be managed only by the subpriority.
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 80040c4:	b580      	push	{r7, lr}
 80040c6:	b082      	sub	sp, #8
 80040c8:	af00      	add	r7, sp, #0
 80040ca:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
 80040cc:	6878      	ldr	r0, [r7, #4]
 80040ce:	f7ff ff29 	bl	8003f24 <__NVIC_SetPriorityGrouping>
}
 80040d2:	bf00      	nop
 80040d4:	3708      	adds	r7, #8
 80040d6:	46bd      	mov	sp, r7
 80040d8:	bd80      	pop	{r7, pc}

080040da <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 80040da:	b580      	push	{r7, lr}
 80040dc:	b086      	sub	sp, #24
 80040de:	af00      	add	r7, sp, #0
 80040e0:	4603      	mov	r3, r0
 80040e2:	60b9      	str	r1, [r7, #8]
 80040e4:	607a      	str	r2, [r7, #4]
 80040e6:	81fb      	strh	r3, [r7, #14]

  /* Check the parameters */
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));

  prioritygroup = NVIC_GetPriorityGrouping();
 80040e8:	f7ff ff40 	bl	8003f6c <__NVIC_GetPriorityGrouping>
 80040ec:	6178      	str	r0, [r7, #20]

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
 80040ee:	687a      	ldr	r2, [r7, #4]
 80040f0:	68b9      	ldr	r1, [r7, #8]
 80040f2:	6978      	ldr	r0, [r7, #20]
 80040f4:	f7ff ff90 	bl	8004018 <NVIC_EncodePriority>
 80040f8:	4602      	mov	r2, r0
 80040fa:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 80040fe:	4611      	mov	r1, r2
 8004100:	4618      	mov	r0, r3
 8004102:	f7ff ff5f 	bl	8003fc4 <__NVIC_SetPriority>
}
 8004106:	bf00      	nop
 8004108:	3718      	adds	r7, #24
 800410a:	46bd      	mov	sp, r7
 800410c:	bd80      	pop	{r7, pc}

0800410e <HAL_NVIC_EnableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32h7xxxx.h))
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
 800410e:	b580      	push	{r7, lr}
 8004110:	b082      	sub	sp, #8
 8004112:	af00      	add	r7, sp, #0
 8004114:	4603      	mov	r3, r0
 8004116:	80fb      	strh	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
 8004118:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 800411c:	4618      	mov	r0, r3
 800411e:	f7ff ff33 	bl	8003f88 <__NVIC_EnableIRQ>
}
 8004122:	bf00      	nop
 8004124:	3708      	adds	r7, #8
 8004126:	46bd      	mov	sp, r7
 8004128:	bd80      	pop	{r7, pc}

0800412a <HAL_SYSTICK_Config>:
  * @param  TicksNumb Specifies the ticks Number of ticks between two interrupts.
  * @retval status   - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
 800412a:	b580      	push	{r7, lr}
 800412c:	b082      	sub	sp, #8
 800412e:	af00      	add	r7, sp, #0
 8004130:	6078      	str	r0, [r7, #4]
   return SysTick_Config(TicksNumb);
 8004132:	6878      	ldr	r0, [r7, #4]
 8004134:	f7ff ffa4 	bl	8004080 <SysTick_Config>
 8004138:	4603      	mov	r3, r0
}
 800413a:	4618      	mov	r0, r3
 800413c:	3708      	adds	r7, #8
 800413e:	46bd      	mov	sp, r7
 8004140:	bd80      	pop	{r7, pc}
	...

08004144 <HAL_MPU_Disable>:
/**
  * @brief  Disables the MPU
  * @retval None
  */
void HAL_MPU_Disable(void)
{
 8004144:	b480      	push	{r7}
 8004146:	af00      	add	r7, sp, #0
  __ASM volatile ("dmb 0xF":::"memory");
 8004148:	f3bf 8f5f 	dmb	sy
}
 800414c:	bf00      	nop
  /* Make sure outstanding transfers are done */
  __DMB();

  /* Disable fault exceptions */
  SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTENA_Msk;
 800414e:	4b07      	ldr	r3, [pc, #28]	@ (800416c <HAL_MPU_Disable+0x28>)
 8004150:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8004152:	4a06      	ldr	r2, [pc, #24]	@ (800416c <HAL_MPU_Disable+0x28>)
 8004154:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
 8004158:	6253      	str	r3, [r2, #36]	@ 0x24

  /* Disable the MPU and clear the control register*/
  MPU->CTRL = 0;
 800415a:	4b05      	ldr	r3, [pc, #20]	@ (8004170 <HAL_MPU_Disable+0x2c>)
 800415c:	2200      	movs	r2, #0
 800415e:	605a      	str	r2, [r3, #4]
}
 8004160:	bf00      	nop
 8004162:	46bd      	mov	sp, r7
 8004164:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004168:	4770      	bx	lr
 800416a:	bf00      	nop
 800416c:	e000ed00 	.word	0xe000ed00
 8004170:	e000ed90 	.word	0xe000ed90

08004174 <HAL_MPU_Enable>:
  *            @arg MPU_PRIVILEGED_DEFAULT
  *            @arg MPU_HFNMI_PRIVDEF
  * @retval None
  */
void HAL_MPU_Enable(uint32_t MPU_Control)
{
 8004174:	b480      	push	{r7}
 8004176:	b083      	sub	sp, #12
 8004178:	af00      	add	r7, sp, #0
 800417a:	6078      	str	r0, [r7, #4]
  /* Enable the MPU */
  MPU->CTRL = MPU_Control | MPU_CTRL_ENABLE_Msk;
 800417c:	4a0b      	ldr	r2, [pc, #44]	@ (80041ac <HAL_MPU_Enable+0x38>)
 800417e:	687b      	ldr	r3, [r7, #4]
 8004180:	f043 0301 	orr.w	r3, r3, #1
 8004184:	6053      	str	r3, [r2, #4]

  /* Enable fault exceptions */
  SCB->SHCSR |= SCB_SHCSR_MEMFAULTENA_Msk;
 8004186:	4b0a      	ldr	r3, [pc, #40]	@ (80041b0 <HAL_MPU_Enable+0x3c>)
 8004188:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800418a:	4a09      	ldr	r2, [pc, #36]	@ (80041b0 <HAL_MPU_Enable+0x3c>)
 800418c:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 8004190:	6253      	str	r3, [r2, #36]	@ 0x24
  __ASM volatile ("dsb 0xF":::"memory");
 8004192:	f3bf 8f4f 	dsb	sy
}
 8004196:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
 8004198:	f3bf 8f6f 	isb	sy
}
 800419c:	bf00      	nop

  /* Ensure MPU setting take effects */
  __DSB();
  __ISB();
}
 800419e:	bf00      	nop
 80041a0:	370c      	adds	r7, #12
 80041a2:	46bd      	mov	sp, r7
 80041a4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80041a8:	4770      	bx	lr
 80041aa:	bf00      	nop
 80041ac:	e000ed90 	.word	0xe000ed90
 80041b0:	e000ed00 	.word	0xe000ed00

080041b4 <HAL_MPU_ConfigRegion>:
  * @param MPU_Init Pointer to a MPU_Region_InitTypeDef structure that contains
  *                the initialization and configuration information.
  * @retval None
  */
void HAL_MPU_ConfigRegion(MPU_Region_InitTypeDef *MPU_Init)
{
 80041b4:	b480      	push	{r7}
 80041b6:	b083      	sub	sp, #12
 80041b8:	af00      	add	r7, sp, #0
 80041ba:	6078      	str	r0, [r7, #4]
  assert_param(IS_MPU_ACCESS_BUFFERABLE(MPU_Init->IsBufferable));
  assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));
  assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));

  /* Set the Region number */
  MPU->RNR = MPU_Init->Number;
 80041bc:	687b      	ldr	r3, [r7, #4]
 80041be:	785a      	ldrb	r2, [r3, #1]
 80041c0:	4b1b      	ldr	r3, [pc, #108]	@ (8004230 <HAL_MPU_ConfigRegion+0x7c>)
 80041c2:	609a      	str	r2, [r3, #8]

  /* Disable the Region */
  CLEAR_BIT(MPU->RASR, MPU_RASR_ENABLE_Msk);
 80041c4:	4b1a      	ldr	r3, [pc, #104]	@ (8004230 <HAL_MPU_ConfigRegion+0x7c>)
 80041c6:	691b      	ldr	r3, [r3, #16]
 80041c8:	4a19      	ldr	r2, [pc, #100]	@ (8004230 <HAL_MPU_ConfigRegion+0x7c>)
 80041ca:	f023 0301 	bic.w	r3, r3, #1
 80041ce:	6113      	str	r3, [r2, #16]

  /* Apply configuration */
  MPU->RBAR = MPU_Init->BaseAddress;
 80041d0:	4a17      	ldr	r2, [pc, #92]	@ (8004230 <HAL_MPU_ConfigRegion+0x7c>)
 80041d2:	687b      	ldr	r3, [r7, #4]
 80041d4:	685b      	ldr	r3, [r3, #4]
 80041d6:	60d3      	str	r3, [r2, #12]
  MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
 80041d8:	687b      	ldr	r3, [r7, #4]
 80041da:	7b1b      	ldrb	r3, [r3, #12]
 80041dc:	071a      	lsls	r2, r3, #28
              ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
 80041de:	687b      	ldr	r3, [r7, #4]
 80041e0:	7adb      	ldrb	r3, [r3, #11]
 80041e2:	061b      	lsls	r3, r3, #24
  MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
 80041e4:	431a      	orrs	r2, r3
              ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
 80041e6:	687b      	ldr	r3, [r7, #4]
 80041e8:	7a9b      	ldrb	r3, [r3, #10]
 80041ea:	04db      	lsls	r3, r3, #19
              ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
 80041ec:	431a      	orrs	r2, r3
              ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
 80041ee:	687b      	ldr	r3, [r7, #4]
 80041f0:	7b5b      	ldrb	r3, [r3, #13]
 80041f2:	049b      	lsls	r3, r3, #18
              ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
 80041f4:	431a      	orrs	r2, r3
              ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |
 80041f6:	687b      	ldr	r3, [r7, #4]
 80041f8:	7b9b      	ldrb	r3, [r3, #14]
 80041fa:	045b      	lsls	r3, r3, #17
              ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
 80041fc:	431a      	orrs	r2, r3
              ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |
 80041fe:	687b      	ldr	r3, [r7, #4]
 8004200:	7bdb      	ldrb	r3, [r3, #15]
 8004202:	041b      	lsls	r3, r3, #16
              ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |
 8004204:	431a      	orrs	r2, r3
              ((uint32_t)MPU_Init->SubRegionDisable        << MPU_RASR_SRD_Pos)  |
 8004206:	687b      	ldr	r3, [r7, #4]
 8004208:	7a5b      	ldrb	r3, [r3, #9]
 800420a:	021b      	lsls	r3, r3, #8
              ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |
 800420c:	431a      	orrs	r2, r3
              ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
 800420e:	687b      	ldr	r3, [r7, #4]
 8004210:	7a1b      	ldrb	r3, [r3, #8]
 8004212:	005b      	lsls	r3, r3, #1
              ((uint32_t)MPU_Init->SubRegionDisable        << MPU_RASR_SRD_Pos)  |
 8004214:	4313      	orrs	r3, r2
              ((uint32_t)MPU_Init->Enable                  << MPU_RASR_ENABLE_Pos);
 8004216:	687a      	ldr	r2, [r7, #4]
 8004218:	7812      	ldrb	r2, [r2, #0]
 800421a:	4611      	mov	r1, r2
  MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
 800421c:	4a04      	ldr	r2, [pc, #16]	@ (8004230 <HAL_MPU_ConfigRegion+0x7c>)
              ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
 800421e:	430b      	orrs	r3, r1
  MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
 8004220:	6113      	str	r3, [r2, #16]
}
 8004222:	bf00      	nop
 8004224:	370c      	adds	r7, #12
 8004226:	46bd      	mov	sp, r7
 8004228:	f85d 7b04 	ldr.w	r7, [sp], #4
 800422c:	4770      	bx	lr
 800422e:	bf00      	nop
 8004230:	e000ed90 	.word	0xe000ed90

08004234 <HAL_DMA_Init>:
  * @param  hdma: Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
{
 8004234:	b580      	push	{r7, lr}
 8004236:	b086      	sub	sp, #24
 8004238:	af00      	add	r7, sp, #0
 800423a:	6078      	str	r0, [r7, #4]
  uint32_t registerValue;
  uint32_t tickstart = HAL_GetTick();
 800423c:	f7fe fb90 	bl	8002960 <HAL_GetTick>
 8004240:	6138      	str	r0, [r7, #16]
  DMA_Base_Registers *regs_dma;
  BDMA_Base_Registers *regs_bdma;

  /* Check the DMA peripheral handle */
  if(hdma == NULL)
 8004242:	687b      	ldr	r3, [r7, #4]
 8004244:	2b00      	cmp	r3, #0
 8004246:	d101      	bne.n	800424c <HAL_DMA_Init+0x18>
  {
    return HAL_ERROR;
 8004248:	2301      	movs	r3, #1
 800424a:	e37d      	b.n	8004948 <HAL_DMA_Init+0x714>
  assert_param(IS_DMA_PERIPHERAL_DATA_SIZE(hdma->Init.PeriphDataAlignment));
  assert_param(IS_DMA_MEMORY_DATA_SIZE(hdma->Init.MemDataAlignment));
  assert_param(IS_DMA_MODE(hdma->Init.Mode));
  assert_param(IS_DMA_PRIORITY(hdma->Init.Priority));

  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
 800424c:	687b      	ldr	r3, [r7, #4]
 800424e:	681b      	ldr	r3, [r3, #0]
 8004250:	4a66      	ldr	r2, [pc, #408]	@ (80043ec <HAL_DMA_Init+0x1b8>)
 8004252:	4293      	cmp	r3, r2
 8004254:	d04a      	beq.n	80042ec <HAL_DMA_Init+0xb8>
 8004256:	687b      	ldr	r3, [r7, #4]
 8004258:	681b      	ldr	r3, [r3, #0]
 800425a:	4a65      	ldr	r2, [pc, #404]	@ (80043f0 <HAL_DMA_Init+0x1bc>)
 800425c:	4293      	cmp	r3, r2
 800425e:	d045      	beq.n	80042ec <HAL_DMA_Init+0xb8>
 8004260:	687b      	ldr	r3, [r7, #4]
 8004262:	681b      	ldr	r3, [r3, #0]
 8004264:	4a63      	ldr	r2, [pc, #396]	@ (80043f4 <HAL_DMA_Init+0x1c0>)
 8004266:	4293      	cmp	r3, r2
 8004268:	d040      	beq.n	80042ec <HAL_DMA_Init+0xb8>
 800426a:	687b      	ldr	r3, [r7, #4]
 800426c:	681b      	ldr	r3, [r3, #0]
 800426e:	4a62      	ldr	r2, [pc, #392]	@ (80043f8 <HAL_DMA_Init+0x1c4>)
 8004270:	4293      	cmp	r3, r2
 8004272:	d03b      	beq.n	80042ec <HAL_DMA_Init+0xb8>
 8004274:	687b      	ldr	r3, [r7, #4]
 8004276:	681b      	ldr	r3, [r3, #0]
 8004278:	4a60      	ldr	r2, [pc, #384]	@ (80043fc <HAL_DMA_Init+0x1c8>)
 800427a:	4293      	cmp	r3, r2
 800427c:	d036      	beq.n	80042ec <HAL_DMA_Init+0xb8>
 800427e:	687b      	ldr	r3, [r7, #4]
 8004280:	681b      	ldr	r3, [r3, #0]
 8004282:	4a5f      	ldr	r2, [pc, #380]	@ (8004400 <HAL_DMA_Init+0x1cc>)
 8004284:	4293      	cmp	r3, r2
 8004286:	d031      	beq.n	80042ec <HAL_DMA_Init+0xb8>
 8004288:	687b      	ldr	r3, [r7, #4]
 800428a:	681b      	ldr	r3, [r3, #0]
 800428c:	4a5d      	ldr	r2, [pc, #372]	@ (8004404 <HAL_DMA_Init+0x1d0>)
 800428e:	4293      	cmp	r3, r2
 8004290:	d02c      	beq.n	80042ec <HAL_DMA_Init+0xb8>
 8004292:	687b      	ldr	r3, [r7, #4]
 8004294:	681b      	ldr	r3, [r3, #0]
 8004296:	4a5c      	ldr	r2, [pc, #368]	@ (8004408 <HAL_DMA_Init+0x1d4>)
 8004298:	4293      	cmp	r3, r2
 800429a:	d027      	beq.n	80042ec <HAL_DMA_Init+0xb8>
 800429c:	687b      	ldr	r3, [r7, #4]
 800429e:	681b      	ldr	r3, [r3, #0]
 80042a0:	4a5a      	ldr	r2, [pc, #360]	@ (800440c <HAL_DMA_Init+0x1d8>)
 80042a2:	4293      	cmp	r3, r2
 80042a4:	d022      	beq.n	80042ec <HAL_DMA_Init+0xb8>
 80042a6:	687b      	ldr	r3, [r7, #4]
 80042a8:	681b      	ldr	r3, [r3, #0]
 80042aa:	4a59      	ldr	r2, [pc, #356]	@ (8004410 <HAL_DMA_Init+0x1dc>)
 80042ac:	4293      	cmp	r3, r2
 80042ae:	d01d      	beq.n	80042ec <HAL_DMA_Init+0xb8>
 80042b0:	687b      	ldr	r3, [r7, #4]
 80042b2:	681b      	ldr	r3, [r3, #0]
 80042b4:	4a57      	ldr	r2, [pc, #348]	@ (8004414 <HAL_DMA_Init+0x1e0>)
 80042b6:	4293      	cmp	r3, r2
 80042b8:	d018      	beq.n	80042ec <HAL_DMA_Init+0xb8>
 80042ba:	687b      	ldr	r3, [r7, #4]
 80042bc:	681b      	ldr	r3, [r3, #0]
 80042be:	4a56      	ldr	r2, [pc, #344]	@ (8004418 <HAL_DMA_Init+0x1e4>)
 80042c0:	4293      	cmp	r3, r2
 80042c2:	d013      	beq.n	80042ec <HAL_DMA_Init+0xb8>
 80042c4:	687b      	ldr	r3, [r7, #4]
 80042c6:	681b      	ldr	r3, [r3, #0]
 80042c8:	4a54      	ldr	r2, [pc, #336]	@ (800441c <HAL_DMA_Init+0x1e8>)
 80042ca:	4293      	cmp	r3, r2
 80042cc:	d00e      	beq.n	80042ec <HAL_DMA_Init+0xb8>
 80042ce:	687b      	ldr	r3, [r7, #4]
 80042d0:	681b      	ldr	r3, [r3, #0]
 80042d2:	4a53      	ldr	r2, [pc, #332]	@ (8004420 <HAL_DMA_Init+0x1ec>)
 80042d4:	4293      	cmp	r3, r2
 80042d6:	d009      	beq.n	80042ec <HAL_DMA_Init+0xb8>
 80042d8:	687b      	ldr	r3, [r7, #4]
 80042da:	681b      	ldr	r3, [r3, #0]
 80042dc:	4a51      	ldr	r2, [pc, #324]	@ (8004424 <HAL_DMA_Init+0x1f0>)
 80042de:	4293      	cmp	r3, r2
 80042e0:	d004      	beq.n	80042ec <HAL_DMA_Init+0xb8>
 80042e2:	687b      	ldr	r3, [r7, #4]
 80042e4:	681b      	ldr	r3, [r3, #0]
 80042e6:	4a50      	ldr	r2, [pc, #320]	@ (8004428 <HAL_DMA_Init+0x1f4>)
 80042e8:	4293      	cmp	r3, r2
 80042ea:	d101      	bne.n	80042f0 <HAL_DMA_Init+0xbc>
 80042ec:	2301      	movs	r3, #1
 80042ee:	e000      	b.n	80042f2 <HAL_DMA_Init+0xbe>
 80042f0:	2300      	movs	r3, #0
 80042f2:	2b00      	cmp	r3, #0
 80042f4:	f000 813c 	beq.w	8004570 <HAL_DMA_Init+0x33c>
      assert_param(IS_DMA_MEMORY_BURST(hdma->Init.MemBurst));
      assert_param(IS_DMA_PERIPHERAL_BURST(hdma->Init.PeriphBurst));
    }

    /* Change DMA peripheral state */
    hdma->State = HAL_DMA_STATE_BUSY;
 80042f8:	687b      	ldr	r3, [r7, #4]
 80042fa:	2202      	movs	r2, #2
 80042fc:	f883 2035 	strb.w	r2, [r3, #53]	@ 0x35

    /* Allocate lock resource */
    __HAL_UNLOCK(hdma);
 8004300:	687b      	ldr	r3, [r7, #4]
 8004302:	2200      	movs	r2, #0
 8004304:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34

    /* Disable the peripheral */
    __HAL_DMA_DISABLE(hdma);
 8004308:	687b      	ldr	r3, [r7, #4]
 800430a:	681b      	ldr	r3, [r3, #0]
 800430c:	4a37      	ldr	r2, [pc, #220]	@ (80043ec <HAL_DMA_Init+0x1b8>)
 800430e:	4293      	cmp	r3, r2
 8004310:	d04a      	beq.n	80043a8 <HAL_DMA_Init+0x174>
 8004312:	687b      	ldr	r3, [r7, #4]
 8004314:	681b      	ldr	r3, [r3, #0]
 8004316:	4a36      	ldr	r2, [pc, #216]	@ (80043f0 <HAL_DMA_Init+0x1bc>)
 8004318:	4293      	cmp	r3, r2
 800431a:	d045      	beq.n	80043a8 <HAL_DMA_Init+0x174>
 800431c:	687b      	ldr	r3, [r7, #4]
 800431e:	681b      	ldr	r3, [r3, #0]
 8004320:	4a34      	ldr	r2, [pc, #208]	@ (80043f4 <HAL_DMA_Init+0x1c0>)
 8004322:	4293      	cmp	r3, r2
 8004324:	d040      	beq.n	80043a8 <HAL_DMA_Init+0x174>
 8004326:	687b      	ldr	r3, [r7, #4]
 8004328:	681b      	ldr	r3, [r3, #0]
 800432a:	4a33      	ldr	r2, [pc, #204]	@ (80043f8 <HAL_DMA_Init+0x1c4>)
 800432c:	4293      	cmp	r3, r2
 800432e:	d03b      	beq.n	80043a8 <HAL_DMA_Init+0x174>
 8004330:	687b      	ldr	r3, [r7, #4]
 8004332:	681b      	ldr	r3, [r3, #0]
 8004334:	4a31      	ldr	r2, [pc, #196]	@ (80043fc <HAL_DMA_Init+0x1c8>)
 8004336:	4293      	cmp	r3, r2
 8004338:	d036      	beq.n	80043a8 <HAL_DMA_Init+0x174>
 800433a:	687b      	ldr	r3, [r7, #4]
 800433c:	681b      	ldr	r3, [r3, #0]
 800433e:	4a30      	ldr	r2, [pc, #192]	@ (8004400 <HAL_DMA_Init+0x1cc>)
 8004340:	4293      	cmp	r3, r2
 8004342:	d031      	beq.n	80043a8 <HAL_DMA_Init+0x174>
 8004344:	687b      	ldr	r3, [r7, #4]
 8004346:	681b      	ldr	r3, [r3, #0]
 8004348:	4a2e      	ldr	r2, [pc, #184]	@ (8004404 <HAL_DMA_Init+0x1d0>)
 800434a:	4293      	cmp	r3, r2
 800434c:	d02c      	beq.n	80043a8 <HAL_DMA_Init+0x174>
 800434e:	687b      	ldr	r3, [r7, #4]
 8004350:	681b      	ldr	r3, [r3, #0]
 8004352:	4a2d      	ldr	r2, [pc, #180]	@ (8004408 <HAL_DMA_Init+0x1d4>)
 8004354:	4293      	cmp	r3, r2
 8004356:	d027      	beq.n	80043a8 <HAL_DMA_Init+0x174>
 8004358:	687b      	ldr	r3, [r7, #4]
 800435a:	681b      	ldr	r3, [r3, #0]
 800435c:	4a2b      	ldr	r2, [pc, #172]	@ (800440c <HAL_DMA_Init+0x1d8>)
 800435e:	4293      	cmp	r3, r2
 8004360:	d022      	beq.n	80043a8 <HAL_DMA_Init+0x174>
 8004362:	687b      	ldr	r3, [r7, #4]
 8004364:	681b      	ldr	r3, [r3, #0]
 8004366:	4a2a      	ldr	r2, [pc, #168]	@ (8004410 <HAL_DMA_Init+0x1dc>)
 8004368:	4293      	cmp	r3, r2
 800436a:	d01d      	beq.n	80043a8 <HAL_DMA_Init+0x174>
 800436c:	687b      	ldr	r3, [r7, #4]
 800436e:	681b      	ldr	r3, [r3, #0]
 8004370:	4a28      	ldr	r2, [pc, #160]	@ (8004414 <HAL_DMA_Init+0x1e0>)
 8004372:	4293      	cmp	r3, r2
 8004374:	d018      	beq.n	80043a8 <HAL_DMA_Init+0x174>
 8004376:	687b      	ldr	r3, [r7, #4]
 8004378:	681b      	ldr	r3, [r3, #0]
 800437a:	4a27      	ldr	r2, [pc, #156]	@ (8004418 <HAL_DMA_Init+0x1e4>)
 800437c:	4293      	cmp	r3, r2
 800437e:	d013      	beq.n	80043a8 <HAL_DMA_Init+0x174>
 8004380:	687b      	ldr	r3, [r7, #4]
 8004382:	681b      	ldr	r3, [r3, #0]
 8004384:	4a25      	ldr	r2, [pc, #148]	@ (800441c <HAL_DMA_Init+0x1e8>)
 8004386:	4293      	cmp	r3, r2
 8004388:	d00e      	beq.n	80043a8 <HAL_DMA_Init+0x174>
 800438a:	687b      	ldr	r3, [r7, #4]
 800438c:	681b      	ldr	r3, [r3, #0]
 800438e:	4a24      	ldr	r2, [pc, #144]	@ (8004420 <HAL_DMA_Init+0x1ec>)
 8004390:	4293      	cmp	r3, r2
 8004392:	d009      	beq.n	80043a8 <HAL_DMA_Init+0x174>
 8004394:	687b      	ldr	r3, [r7, #4]
 8004396:	681b      	ldr	r3, [r3, #0]
 8004398:	4a22      	ldr	r2, [pc, #136]	@ (8004424 <HAL_DMA_Init+0x1f0>)
 800439a:	4293      	cmp	r3, r2
 800439c:	d004      	beq.n	80043a8 <HAL_DMA_Init+0x174>
 800439e:	687b      	ldr	r3, [r7, #4]
 80043a0:	681b      	ldr	r3, [r3, #0]
 80043a2:	4a21      	ldr	r2, [pc, #132]	@ (8004428 <HAL_DMA_Init+0x1f4>)
 80043a4:	4293      	cmp	r3, r2
 80043a6:	d108      	bne.n	80043ba <HAL_DMA_Init+0x186>
 80043a8:	687b      	ldr	r3, [r7, #4]
 80043aa:	681b      	ldr	r3, [r3, #0]
 80043ac:	681a      	ldr	r2, [r3, #0]
 80043ae:	687b      	ldr	r3, [r7, #4]
 80043b0:	681b      	ldr	r3, [r3, #0]
 80043b2:	f022 0201 	bic.w	r2, r2, #1
 80043b6:	601a      	str	r2, [r3, #0]
 80043b8:	e007      	b.n	80043ca <HAL_DMA_Init+0x196>
 80043ba:	687b      	ldr	r3, [r7, #4]
 80043bc:	681b      	ldr	r3, [r3, #0]
 80043be:	681a      	ldr	r2, [r3, #0]
 80043c0:	687b      	ldr	r3, [r7, #4]
 80043c2:	681b      	ldr	r3, [r3, #0]
 80043c4:	f022 0201 	bic.w	r2, r2, #1
 80043c8:	601a      	str	r2, [r3, #0]

    /* Check if the DMA Stream is effectively disabled */
    while((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_EN) != 0U)
 80043ca:	e02f      	b.n	800442c <HAL_DMA_Init+0x1f8>
    {
      /* Check for the Timeout */
      if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
 80043cc:	f7fe fac8 	bl	8002960 <HAL_GetTick>
 80043d0:	4602      	mov	r2, r0
 80043d2:	693b      	ldr	r3, [r7, #16]
 80043d4:	1ad3      	subs	r3, r2, r3
 80043d6:	2b05      	cmp	r3, #5
 80043d8:	d928      	bls.n	800442c <HAL_DMA_Init+0x1f8>
      {
        /* Update error code */
        hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
 80043da:	687b      	ldr	r3, [r7, #4]
 80043dc:	2220      	movs	r2, #32
 80043de:	655a      	str	r2, [r3, #84]	@ 0x54

        /* Change the DMA state */
        hdma->State = HAL_DMA_STATE_ERROR;
 80043e0:	687b      	ldr	r3, [r7, #4]
 80043e2:	2203      	movs	r2, #3
 80043e4:	f883 2035 	strb.w	r2, [r3, #53]	@ 0x35

        return HAL_ERROR;
 80043e8:	2301      	movs	r3, #1
 80043ea:	e2ad      	b.n	8004948 <HAL_DMA_Init+0x714>
 80043ec:	40020010 	.word	0x40020010
 80043f0:	40020028 	.word	0x40020028
 80043f4:	40020040 	.word	0x40020040
 80043f8:	40020058 	.word	0x40020058
 80043fc:	40020070 	.word	0x40020070
 8004400:	40020088 	.word	0x40020088
 8004404:	400200a0 	.word	0x400200a0
 8004408:	400200b8 	.word	0x400200b8
 800440c:	40020410 	.word	0x40020410
 8004410:	40020428 	.word	0x40020428
 8004414:	40020440 	.word	0x40020440
 8004418:	40020458 	.word	0x40020458
 800441c:	40020470 	.word	0x40020470
 8004420:	40020488 	.word	0x40020488
 8004424:	400204a0 	.word	0x400204a0
 8004428:	400204b8 	.word	0x400204b8
    while((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_EN) != 0U)
 800442c:	687b      	ldr	r3, [r7, #4]
 800442e:	681b      	ldr	r3, [r3, #0]
 8004430:	681b      	ldr	r3, [r3, #0]
 8004432:	f003 0301 	and.w	r3, r3, #1
 8004436:	2b00      	cmp	r3, #0
 8004438:	d1c8      	bne.n	80043cc <HAL_DMA_Init+0x198>
      }
    }

    /* Get the CR register value */
    registerValue = ((DMA_Stream_TypeDef   *)hdma->Instance)->CR;
 800443a:	687b      	ldr	r3, [r7, #4]
 800443c:	681b      	ldr	r3, [r3, #0]
 800443e:	681b      	ldr	r3, [r3, #0]
 8004440:	617b      	str	r3, [r7, #20]

    /* Clear CHSEL, MBURST, PBURST, PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR, CT and DBM bits */
    registerValue &= ((uint32_t)~(DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
 8004442:	697a      	ldr	r2, [r7, #20]
 8004444:	4b73      	ldr	r3, [pc, #460]	@ (8004614 <HAL_DMA_Init+0x3e0>)
 8004446:	4013      	ands	r3, r2
 8004448:	617b      	str	r3, [r7, #20]
                        DMA_SxCR_PL    | DMA_SxCR_MSIZE  | DMA_SxCR_PSIZE  | \
                        DMA_SxCR_MINC  | DMA_SxCR_PINC   | DMA_SxCR_CIRC   | \
                        DMA_SxCR_DIR   | DMA_SxCR_CT     | DMA_SxCR_DBM));

    /* Prepare the DMA Stream configuration */
    registerValue |=  hdma->Init.Direction           |
 800444a:	687b      	ldr	r3, [r7, #4]
 800444c:	689a      	ldr	r2, [r3, #8]
            hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 800444e:	687b      	ldr	r3, [r7, #4]
 8004450:	68db      	ldr	r3, [r3, #12]
    registerValue |=  hdma->Init.Direction           |
 8004452:	431a      	orrs	r2, r3
            hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8004454:	687b      	ldr	r3, [r7, #4]
 8004456:	691b      	ldr	r3, [r3, #16]
 8004458:	431a      	orrs	r2, r3
            hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 800445a:	687b      	ldr	r3, [r7, #4]
 800445c:	695b      	ldr	r3, [r3, #20]
            hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 800445e:	431a      	orrs	r2, r3
            hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8004460:	687b      	ldr	r3, [r7, #4]
 8004462:	699b      	ldr	r3, [r3, #24]
 8004464:	431a      	orrs	r2, r3
            hdma->Init.Mode                | hdma->Init.Priority;
 8004466:	687b      	ldr	r3, [r7, #4]
 8004468:	69db      	ldr	r3, [r3, #28]
            hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 800446a:	431a      	orrs	r2, r3
            hdma->Init.Mode                | hdma->Init.Priority;
 800446c:	687b      	ldr	r3, [r7, #4]
 800446e:	6a1b      	ldr	r3, [r3, #32]
 8004470:	4313      	orrs	r3, r2
    registerValue |=  hdma->Init.Direction           |
 8004472:	697a      	ldr	r2, [r7, #20]
 8004474:	4313      	orrs	r3, r2
 8004476:	617b      	str	r3, [r7, #20]

    /* the Memory burst and peripheral burst are not used when the FIFO is disabled */
    if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 8004478:	687b      	ldr	r3, [r7, #4]
 800447a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800447c:	2b04      	cmp	r3, #4
 800447e:	d107      	bne.n	8004490 <HAL_DMA_Init+0x25c>
    {
      /* Get memory burst and peripheral burst */
      registerValue |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
 8004480:	687b      	ldr	r3, [r7, #4]
 8004482:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 8004484:	687b      	ldr	r3, [r7, #4]
 8004486:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8004488:	4313      	orrs	r3, r2
 800448a:	697a      	ldr	r2, [r7, #20]
 800448c:	4313      	orrs	r3, r2
 800448e:	617b      	str	r3, [r7, #20]
                                    lock when transferring data to/from USART/UART */
#if (STM32H7_DEV_ID == 0x450UL)
    if((DBGMCU->IDCODE & 0xFFFF0000U) >= 0x20000000U)
    {
#endif /* STM32H7_DEV_ID == 0x450UL */
      if(IS_DMA_UART_USART_REQUEST(hdma->Init.Request) != 0U)
 8004490:	687b      	ldr	r3, [r7, #4]
 8004492:	685b      	ldr	r3, [r3, #4]
 8004494:	2b28      	cmp	r3, #40	@ 0x28
 8004496:	d903      	bls.n	80044a0 <HAL_DMA_Init+0x26c>
 8004498:	687b      	ldr	r3, [r7, #4]
 800449a:	685b      	ldr	r3, [r3, #4]
 800449c:	2b2e      	cmp	r3, #46	@ 0x2e
 800449e:	d91f      	bls.n	80044e0 <HAL_DMA_Init+0x2ac>
 80044a0:	687b      	ldr	r3, [r7, #4]
 80044a2:	685b      	ldr	r3, [r3, #4]
 80044a4:	2b3e      	cmp	r3, #62	@ 0x3e
 80044a6:	d903      	bls.n	80044b0 <HAL_DMA_Init+0x27c>
 80044a8:	687b      	ldr	r3, [r7, #4]
 80044aa:	685b      	ldr	r3, [r3, #4]
 80044ac:	2b42      	cmp	r3, #66	@ 0x42
 80044ae:	d917      	bls.n	80044e0 <HAL_DMA_Init+0x2ac>
 80044b0:	687b      	ldr	r3, [r7, #4]
 80044b2:	685b      	ldr	r3, [r3, #4]
 80044b4:	2b46      	cmp	r3, #70	@ 0x46
 80044b6:	d903      	bls.n	80044c0 <HAL_DMA_Init+0x28c>
 80044b8:	687b      	ldr	r3, [r7, #4]
 80044ba:	685b      	ldr	r3, [r3, #4]
 80044bc:	2b48      	cmp	r3, #72	@ 0x48
 80044be:	d90f      	bls.n	80044e0 <HAL_DMA_Init+0x2ac>
 80044c0:	687b      	ldr	r3, [r7, #4]
 80044c2:	685b      	ldr	r3, [r3, #4]
 80044c4:	2b4e      	cmp	r3, #78	@ 0x4e
 80044c6:	d903      	bls.n	80044d0 <HAL_DMA_Init+0x29c>
 80044c8:	687b      	ldr	r3, [r7, #4]
 80044ca:	685b      	ldr	r3, [r3, #4]
 80044cc:	2b52      	cmp	r3, #82	@ 0x52
 80044ce:	d907      	bls.n	80044e0 <HAL_DMA_Init+0x2ac>
 80044d0:	687b      	ldr	r3, [r7, #4]
 80044d2:	685b      	ldr	r3, [r3, #4]
 80044d4:	2b73      	cmp	r3, #115	@ 0x73
 80044d6:	d905      	bls.n	80044e4 <HAL_DMA_Init+0x2b0>
 80044d8:	687b      	ldr	r3, [r7, #4]
 80044da:	685b      	ldr	r3, [r3, #4]
 80044dc:	2b77      	cmp	r3, #119	@ 0x77
 80044de:	d801      	bhi.n	80044e4 <HAL_DMA_Init+0x2b0>
 80044e0:	2301      	movs	r3, #1
 80044e2:	e000      	b.n	80044e6 <HAL_DMA_Init+0x2b2>
 80044e4:	2300      	movs	r3, #0
 80044e6:	2b00      	cmp	r3, #0
 80044e8:	d003      	beq.n	80044f2 <HAL_DMA_Init+0x2be>
      {
        registerValue |= DMA_SxCR_TRBUFF;
 80044ea:	697b      	ldr	r3, [r7, #20]
 80044ec:	f443 1380 	orr.w	r3, r3, #1048576	@ 0x100000
 80044f0:	617b      	str	r3, [r7, #20]
#if (STM32H7_DEV_ID == 0x450UL)
    }
#endif /* STM32H7_DEV_ID == 0x450UL */

    /* Write to DMA Stream CR register */
    ((DMA_Stream_TypeDef   *)hdma->Instance)->CR = registerValue;
 80044f2:	687b      	ldr	r3, [r7, #4]
 80044f4:	681b      	ldr	r3, [r3, #0]
 80044f6:	697a      	ldr	r2, [r7, #20]
 80044f8:	601a      	str	r2, [r3, #0]

    /* Get the FCR register value */
    registerValue = ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR;
 80044fa:	687b      	ldr	r3, [r7, #4]
 80044fc:	681b      	ldr	r3, [r3, #0]
 80044fe:	695b      	ldr	r3, [r3, #20]
 8004500:	617b      	str	r3, [r7, #20]

    /* Clear Direct mode and FIFO threshold bits */
    registerValue &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
 8004502:	697b      	ldr	r3, [r7, #20]
 8004504:	f023 0307 	bic.w	r3, r3, #7
 8004508:	617b      	str	r3, [r7, #20]

    /* Prepare the DMA Stream FIFO configuration */
    registerValue |= hdma->Init.FIFOMode;
 800450a:	687b      	ldr	r3, [r7, #4]
 800450c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800450e:	697a      	ldr	r2, [r7, #20]
 8004510:	4313      	orrs	r3, r2
 8004512:	617b      	str	r3, [r7, #20]

    /* the FIFO threshold is not used when the FIFO mode is disabled */
    if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 8004514:	687b      	ldr	r3, [r7, #4]
 8004516:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8004518:	2b04      	cmp	r3, #4
 800451a:	d117      	bne.n	800454c <HAL_DMA_Init+0x318>
    {
      /* Get the FIFO threshold */
      registerValue |= hdma->Init.FIFOThreshold;
 800451c:	687b      	ldr	r3, [r7, #4]
 800451e:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8004520:	697a      	ldr	r2, [r7, #20]
 8004522:	4313      	orrs	r3, r2
 8004524:	617b      	str	r3, [r7, #20]

      /* Check compatibility between FIFO threshold level and size of the memory burst */
      /* for INCR4, INCR8, INCR16 */
      if(hdma->Init.MemBurst != DMA_MBURST_SINGLE)
 8004526:	687b      	ldr	r3, [r7, #4]
 8004528:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800452a:	2b00      	cmp	r3, #0
 800452c:	d00e      	beq.n	800454c <HAL_DMA_Init+0x318>
      {
        if (DMA_CheckFifoParam(hdma) != HAL_OK)
 800452e:	6878      	ldr	r0, [r7, #4]
 8004530:	f001 fe7c 	bl	800622c <DMA_CheckFifoParam>
 8004534:	4603      	mov	r3, r0
 8004536:	2b00      	cmp	r3, #0
 8004538:	d008      	beq.n	800454c <HAL_DMA_Init+0x318>
        {
          /* Update error code */
          hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
 800453a:	687b      	ldr	r3, [r7, #4]
 800453c:	2240      	movs	r2, #64	@ 0x40
 800453e:	655a      	str	r2, [r3, #84]	@ 0x54

          /* Change the DMA state */
          hdma->State = HAL_DMA_STATE_READY;
 8004540:	687b      	ldr	r3, [r7, #4]
 8004542:	2201      	movs	r2, #1
 8004544:	f883 2035 	strb.w	r2, [r3, #53]	@ 0x35

          return HAL_ERROR;
 8004548:	2301      	movs	r3, #1
 800454a:	e1fd      	b.n	8004948 <HAL_DMA_Init+0x714>
        }
      }
    }

    /* Write to DMA Stream FCR */
    ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR = registerValue;
 800454c:	687b      	ldr	r3, [r7, #4]
 800454e:	681b      	ldr	r3, [r3, #0]
 8004550:	697a      	ldr	r2, [r7, #20]
 8004552:	615a      	str	r2, [r3, #20]

    /* Initialize StreamBaseAddress and StreamIndex parameters to be used to calculate
       DMA steam Base Address needed by HAL_DMA_IRQHandler() and HAL_DMA_PollForTransfer() */
    regs_dma = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
 8004554:	6878      	ldr	r0, [r7, #4]
 8004556:	f001 fdb7 	bl	80060c8 <DMA_CalcBaseAndBitshift>
 800455a:	4603      	mov	r3, r0
 800455c:	60bb      	str	r3, [r7, #8]

    /* Clear all interrupt flags */
    regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);
 800455e:	687b      	ldr	r3, [r7, #4]
 8004560:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 8004562:	f003 031f 	and.w	r3, r3, #31
 8004566:	223f      	movs	r2, #63	@ 0x3f
 8004568:	409a      	lsls	r2, r3
 800456a:	68bb      	ldr	r3, [r7, #8]
 800456c:	609a      	str	r2, [r3, #8]
 800456e:	e0fd      	b.n	800476c <HAL_DMA_Init+0x538>
  }
  else if(IS_BDMA_CHANNEL_INSTANCE(hdma->Instance) != 0U) /* BDMA instance(s) */
 8004570:	687b      	ldr	r3, [r7, #4]
 8004572:	681b      	ldr	r3, [r3, #0]
 8004574:	4a28      	ldr	r2, [pc, #160]	@ (8004618 <HAL_DMA_Init+0x3e4>)
 8004576:	4293      	cmp	r3, r2
 8004578:	d04a      	beq.n	8004610 <HAL_DMA_Init+0x3dc>
 800457a:	687b      	ldr	r3, [r7, #4]
 800457c:	681b      	ldr	r3, [r3, #0]
 800457e:	4a27      	ldr	r2, [pc, #156]	@ (800461c <HAL_DMA_Init+0x3e8>)
 8004580:	4293      	cmp	r3, r2
 8004582:	d045      	beq.n	8004610 <HAL_DMA_Init+0x3dc>
 8004584:	687b      	ldr	r3, [r7, #4]
 8004586:	681b      	ldr	r3, [r3, #0]
 8004588:	4a25      	ldr	r2, [pc, #148]	@ (8004620 <HAL_DMA_Init+0x3ec>)
 800458a:	4293      	cmp	r3, r2
 800458c:	d040      	beq.n	8004610 <HAL_DMA_Init+0x3dc>
 800458e:	687b      	ldr	r3, [r7, #4]
 8004590:	681b      	ldr	r3, [r3, #0]
 8004592:	4a24      	ldr	r2, [pc, #144]	@ (8004624 <HAL_DMA_Init+0x3f0>)
 8004594:	4293      	cmp	r3, r2
 8004596:	d03b      	beq.n	8004610 <HAL_DMA_Init+0x3dc>
 8004598:	687b      	ldr	r3, [r7, #4]
 800459a:	681b      	ldr	r3, [r3, #0]
 800459c:	4a22      	ldr	r2, [pc, #136]	@ (8004628 <HAL_DMA_Init+0x3f4>)
 800459e:	4293      	cmp	r3, r2
 80045a0:	d036      	beq.n	8004610 <HAL_DMA_Init+0x3dc>
 80045a2:	687b      	ldr	r3, [r7, #4]
 80045a4:	681b      	ldr	r3, [r3, #0]
 80045a6:	4a21      	ldr	r2, [pc, #132]	@ (800462c <HAL_DMA_Init+0x3f8>)
 80045a8:	4293      	cmp	r3, r2
 80045aa:	d031      	beq.n	8004610 <HAL_DMA_Init+0x3dc>
 80045ac:	687b      	ldr	r3, [r7, #4]
 80045ae:	681b      	ldr	r3, [r3, #0]
 80045b0:	4a1f      	ldr	r2, [pc, #124]	@ (8004630 <HAL_DMA_Init+0x3fc>)
 80045b2:	4293      	cmp	r3, r2
 80045b4:	d02c      	beq.n	8004610 <HAL_DMA_Init+0x3dc>
 80045b6:	687b      	ldr	r3, [r7, #4]
 80045b8:	681b      	ldr	r3, [r3, #0]
 80045ba:	4a1e      	ldr	r2, [pc, #120]	@ (8004634 <HAL_DMA_Init+0x400>)
 80045bc:	4293      	cmp	r3, r2
 80045be:	d027      	beq.n	8004610 <HAL_DMA_Init+0x3dc>
 80045c0:	687b      	ldr	r3, [r7, #4]
 80045c2:	681b      	ldr	r3, [r3, #0]
 80045c4:	4a1c      	ldr	r2, [pc, #112]	@ (8004638 <HAL_DMA_Init+0x404>)
 80045c6:	4293      	cmp	r3, r2
 80045c8:	d022      	beq.n	8004610 <HAL_DMA_Init+0x3dc>
 80045ca:	687b      	ldr	r3, [r7, #4]
 80045cc:	681b      	ldr	r3, [r3, #0]
 80045ce:	4a1b      	ldr	r2, [pc, #108]	@ (800463c <HAL_DMA_Init+0x408>)
 80045d0:	4293      	cmp	r3, r2
 80045d2:	d01d      	beq.n	8004610 <HAL_DMA_Init+0x3dc>
 80045d4:	687b      	ldr	r3, [r7, #4]
 80045d6:	681b      	ldr	r3, [r3, #0]
 80045d8:	4a19      	ldr	r2, [pc, #100]	@ (8004640 <HAL_DMA_Init+0x40c>)
 80045da:	4293      	cmp	r3, r2
 80045dc:	d018      	beq.n	8004610 <HAL_DMA_Init+0x3dc>
 80045de:	687b      	ldr	r3, [r7, #4]
 80045e0:	681b      	ldr	r3, [r3, #0]
 80045e2:	4a18      	ldr	r2, [pc, #96]	@ (8004644 <HAL_DMA_Init+0x410>)
 80045e4:	4293      	cmp	r3, r2
 80045e6:	d013      	beq.n	8004610 <HAL_DMA_Init+0x3dc>
 80045e8:	687b      	ldr	r3, [r7, #4]
 80045ea:	681b      	ldr	r3, [r3, #0]
 80045ec:	4a16      	ldr	r2, [pc, #88]	@ (8004648 <HAL_DMA_Init+0x414>)
 80045ee:	4293      	cmp	r3, r2
 80045f0:	d00e      	beq.n	8004610 <HAL_DMA_Init+0x3dc>
 80045f2:	687b      	ldr	r3, [r7, #4]
 80045f4:	681b      	ldr	r3, [r3, #0]
 80045f6:	4a15      	ldr	r2, [pc, #84]	@ (800464c <HAL_DMA_Init+0x418>)
 80045f8:	4293      	cmp	r3, r2
 80045fa:	d009      	beq.n	8004610 <HAL_DMA_Init+0x3dc>
 80045fc:	687b      	ldr	r3, [r7, #4]
 80045fe:	681b      	ldr	r3, [r3, #0]
 8004600:	4a13      	ldr	r2, [pc, #76]	@ (8004650 <HAL_DMA_Init+0x41c>)
 8004602:	4293      	cmp	r3, r2
 8004604:	d004      	beq.n	8004610 <HAL_DMA_Init+0x3dc>
 8004606:	687b      	ldr	r3, [r7, #4]
 8004608:	681b      	ldr	r3, [r3, #0]
 800460a:	4a12      	ldr	r2, [pc, #72]	@ (8004654 <HAL_DMA_Init+0x420>)
 800460c:	4293      	cmp	r3, r2
 800460e:	d123      	bne.n	8004658 <HAL_DMA_Init+0x424>
 8004610:	2301      	movs	r3, #1
 8004612:	e022      	b.n	800465a <HAL_DMA_Init+0x426>
 8004614:	fe10803f 	.word	0xfe10803f
 8004618:	48022c08 	.word	0x48022c08
 800461c:	48022c1c 	.word	0x48022c1c
 8004620:	48022c30 	.word	0x48022c30
 8004624:	48022c44 	.word	0x48022c44
 8004628:	48022c58 	.word	0x48022c58
 800462c:	48022c6c 	.word	0x48022c6c
 8004630:	48022c80 	.word	0x48022c80
 8004634:	48022c94 	.word	0x48022c94
 8004638:	58025408 	.word	0x58025408
 800463c:	5802541c 	.word	0x5802541c
 8004640:	58025430 	.word	0x58025430
 8004644:	58025444 	.word	0x58025444
 8004648:	58025458 	.word	0x58025458
 800464c:	5802546c 	.word	0x5802546c
 8004650:	58025480 	.word	0x58025480
 8004654:	58025494 	.word	0x58025494
 8004658:	2300      	movs	r3, #0
 800465a:	2b00      	cmp	r3, #0
 800465c:	d07d      	beq.n	800475a <HAL_DMA_Init+0x526>
  {
    if(IS_BDMA_CHANNEL_DMAMUX_INSTANCE(hdma->Instance) != 0U)
 800465e:	687b      	ldr	r3, [r7, #4]
 8004660:	681b      	ldr	r3, [r3, #0]
 8004662:	4a7f      	ldr	r2, [pc, #508]	@ (8004860 <HAL_DMA_Init+0x62c>)
 8004664:	4293      	cmp	r3, r2
 8004666:	d021      	beq.n	80046ac <HAL_DMA_Init+0x478>
 8004668:	687b      	ldr	r3, [r7, #4]
 800466a:	681b      	ldr	r3, [r3, #0]
 800466c:	4a7d      	ldr	r2, [pc, #500]	@ (8004864 <HAL_DMA_Init+0x630>)
 800466e:	4293      	cmp	r3, r2
 8004670:	d01c      	beq.n	80046ac <HAL_DMA_Init+0x478>
 8004672:	687b      	ldr	r3, [r7, #4]
 8004674:	681b      	ldr	r3, [r3, #0]
 8004676:	4a7c      	ldr	r2, [pc, #496]	@ (8004868 <HAL_DMA_Init+0x634>)
 8004678:	4293      	cmp	r3, r2
 800467a:	d017      	beq.n	80046ac <HAL_DMA_Init+0x478>
 800467c:	687b      	ldr	r3, [r7, #4]
 800467e:	681b      	ldr	r3, [r3, #0]
 8004680:	4a7a      	ldr	r2, [pc, #488]	@ (800486c <HAL_DMA_Init+0x638>)
 8004682:	4293      	cmp	r3, r2
 8004684:	d012      	beq.n	80046ac <HAL_DMA_Init+0x478>
 8004686:	687b      	ldr	r3, [r7, #4]
 8004688:	681b      	ldr	r3, [r3, #0]
 800468a:	4a79      	ldr	r2, [pc, #484]	@ (8004870 <HAL_DMA_Init+0x63c>)
 800468c:	4293      	cmp	r3, r2
 800468e:	d00d      	beq.n	80046ac <HAL_DMA_Init+0x478>
 8004690:	687b      	ldr	r3, [r7, #4]
 8004692:	681b      	ldr	r3, [r3, #0]
 8004694:	4a77      	ldr	r2, [pc, #476]	@ (8004874 <HAL_DMA_Init+0x640>)
 8004696:	4293      	cmp	r3, r2
 8004698:	d008      	beq.n	80046ac <HAL_DMA_Init+0x478>
 800469a:	687b      	ldr	r3, [r7, #4]
 800469c:	681b      	ldr	r3, [r3, #0]
 800469e:	4a76      	ldr	r2, [pc, #472]	@ (8004878 <HAL_DMA_Init+0x644>)
 80046a0:	4293      	cmp	r3, r2
 80046a2:	d003      	beq.n	80046ac <HAL_DMA_Init+0x478>
 80046a4:	687b      	ldr	r3, [r7, #4]
 80046a6:	681b      	ldr	r3, [r3, #0]
 80046a8:	4a74      	ldr	r2, [pc, #464]	@ (800487c <HAL_DMA_Init+0x648>)
 80046aa:	4293      	cmp	r3, r2
      /* Check the request parameter */
      assert_param(IS_BDMA_REQUEST(hdma->Init.Request));
    }

    /* Change DMA peripheral state */
    hdma->State = HAL_DMA_STATE_BUSY;
 80046ac:	687b      	ldr	r3, [r7, #4]
 80046ae:	2202      	movs	r2, #2
 80046b0:	f883 2035 	strb.w	r2, [r3, #53]	@ 0x35

    /* Allocate lock resource */
    __HAL_UNLOCK(hdma);
 80046b4:	687b      	ldr	r3, [r7, #4]
 80046b6:	2200      	movs	r2, #0
 80046b8:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34

    /* Get the CR register value */
    registerValue = ((BDMA_Channel_TypeDef *)hdma->Instance)->CCR;
 80046bc:	687b      	ldr	r3, [r7, #4]
 80046be:	681b      	ldr	r3, [r3, #0]
 80046c0:	681b      	ldr	r3, [r3, #0]
 80046c2:	617b      	str	r3, [r7, #20]

    /* Clear PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR, MEM2MEM, DBM and CT bits */
    registerValue &= ((uint32_t)~(BDMA_CCR_PL    | BDMA_CCR_MSIZE   | BDMA_CCR_PSIZE  | \
 80046c4:	697a      	ldr	r2, [r7, #20]
 80046c6:	4b6e      	ldr	r3, [pc, #440]	@ (8004880 <HAL_DMA_Init+0x64c>)
 80046c8:	4013      	ands	r3, r2
 80046ca:	617b      	str	r3, [r7, #20]
                                  BDMA_CCR_MINC  | BDMA_CCR_PINC    | BDMA_CCR_CIRC   | \
                                  BDMA_CCR_DIR   | BDMA_CCR_MEM2MEM | BDMA_CCR_DBM    | \
                                  BDMA_CCR_CT));

    /* Prepare the DMA Channel configuration */
    registerValue |=  DMA_TO_BDMA_DIRECTION(hdma->Init.Direction)            |
 80046cc:	687b      	ldr	r3, [r7, #4]
 80046ce:	689b      	ldr	r3, [r3, #8]
 80046d0:	2b40      	cmp	r3, #64	@ 0x40
 80046d2:	d008      	beq.n	80046e6 <HAL_DMA_Init+0x4b2>
 80046d4:	687b      	ldr	r3, [r7, #4]
 80046d6:	689b      	ldr	r3, [r3, #8]
 80046d8:	2b80      	cmp	r3, #128	@ 0x80
 80046da:	d102      	bne.n	80046e2 <HAL_DMA_Init+0x4ae>
 80046dc:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
 80046e0:	e002      	b.n	80046e8 <HAL_DMA_Init+0x4b4>
 80046e2:	2300      	movs	r3, #0
 80046e4:	e000      	b.n	80046e8 <HAL_DMA_Init+0x4b4>
 80046e6:	2310      	movs	r3, #16
                      DMA_TO_BDMA_PERIPHERAL_INC(hdma->Init.PeriphInc)       |
 80046e8:	687a      	ldr	r2, [r7, #4]
 80046ea:	68d2      	ldr	r2, [r2, #12]
 80046ec:	08d2      	lsrs	r2, r2, #3
    registerValue |=  DMA_TO_BDMA_DIRECTION(hdma->Init.Direction)            |
 80046ee:	431a      	orrs	r2, r3
                      DMA_TO_BDMA_MEMORY_INC(hdma->Init.MemInc)              |
 80046f0:	687b      	ldr	r3, [r7, #4]
 80046f2:	691b      	ldr	r3, [r3, #16]
 80046f4:	08db      	lsrs	r3, r3, #3
                      DMA_TO_BDMA_PERIPHERAL_INC(hdma->Init.PeriphInc)       |
 80046f6:	431a      	orrs	r2, r3
                      DMA_TO_BDMA_PDATA_SIZE(hdma->Init.PeriphDataAlignment) |
 80046f8:	687b      	ldr	r3, [r7, #4]
 80046fa:	695b      	ldr	r3, [r3, #20]
 80046fc:	08db      	lsrs	r3, r3, #3
                      DMA_TO_BDMA_MEMORY_INC(hdma->Init.MemInc)              |
 80046fe:	431a      	orrs	r2, r3
                      DMA_TO_BDMA_MDATA_SIZE(hdma->Init.MemDataAlignment)    |
 8004700:	687b      	ldr	r3, [r7, #4]
 8004702:	699b      	ldr	r3, [r3, #24]
 8004704:	08db      	lsrs	r3, r3, #3
                      DMA_TO_BDMA_PDATA_SIZE(hdma->Init.PeriphDataAlignment) |
 8004706:	431a      	orrs	r2, r3
                      DMA_TO_BDMA_MODE(hdma->Init.Mode)                      |
 8004708:	687b      	ldr	r3, [r7, #4]
 800470a:	69db      	ldr	r3, [r3, #28]
 800470c:	08db      	lsrs	r3, r3, #3
                      DMA_TO_BDMA_MDATA_SIZE(hdma->Init.MemDataAlignment)    |
 800470e:	431a      	orrs	r2, r3
                      DMA_TO_BDMA_PRIORITY(hdma->Init.Priority);
 8004710:	687b      	ldr	r3, [r7, #4]
 8004712:	6a1b      	ldr	r3, [r3, #32]
 8004714:	091b      	lsrs	r3, r3, #4
                      DMA_TO_BDMA_MODE(hdma->Init.Mode)                      |
 8004716:	4313      	orrs	r3, r2
    registerValue |=  DMA_TO_BDMA_DIRECTION(hdma->Init.Direction)            |
 8004718:	697a      	ldr	r2, [r7, #20]
 800471a:	4313      	orrs	r3, r2
 800471c:	617b      	str	r3, [r7, #20]

    /* Write to DMA Channel CR register */
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CCR = registerValue;
 800471e:	687b      	ldr	r3, [r7, #4]
 8004720:	681b      	ldr	r3, [r3, #0]
 8004722:	697a      	ldr	r2, [r7, #20]
 8004724:	601a      	str	r2, [r3, #0]

    /* calculation of the channel index */
    hdma->StreamIndex = (((uint32_t)((uint32_t*)hdma->Instance) - (uint32_t)BDMA_Channel0) / ((uint32_t)BDMA_Channel1 - (uint32_t)BDMA_Channel0)) << 2U;
 8004726:	687b      	ldr	r3, [r7, #4]
 8004728:	681b      	ldr	r3, [r3, #0]
 800472a:	461a      	mov	r2, r3
 800472c:	4b55      	ldr	r3, [pc, #340]	@ (8004884 <HAL_DMA_Init+0x650>)
 800472e:	4413      	add	r3, r2
 8004730:	4a55      	ldr	r2, [pc, #340]	@ (8004888 <HAL_DMA_Init+0x654>)
 8004732:	fba2 2303 	umull	r2, r3, r2, r3
 8004736:	091b      	lsrs	r3, r3, #4
 8004738:	009a      	lsls	r2, r3, #2
 800473a:	687b      	ldr	r3, [r7, #4]
 800473c:	65da      	str	r2, [r3, #92]	@ 0x5c

    /* Initialize StreamBaseAddress and StreamIndex parameters to be used to calculate
    DMA steam Base Address needed by HAL_DMA_IRQHandler() and HAL_DMA_PollForTransfer() */
    regs_bdma = (BDMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
 800473e:	6878      	ldr	r0, [r7, #4]
 8004740:	f001 fcc2 	bl	80060c8 <DMA_CalcBaseAndBitshift>
 8004744:	4603      	mov	r3, r0
 8004746:	60fb      	str	r3, [r7, #12]

    /* Clear all interrupt flags */
    regs_bdma->IFCR = ((BDMA_IFCR_CGIF0) << (hdma->StreamIndex & 0x1FU));
 8004748:	687b      	ldr	r3, [r7, #4]
 800474a:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 800474c:	f003 031f 	and.w	r3, r3, #31
 8004750:	2201      	movs	r2, #1
 8004752:	409a      	lsls	r2, r3
 8004754:	68fb      	ldr	r3, [r7, #12]
 8004756:	605a      	str	r2, [r3, #4]
 8004758:	e008      	b.n	800476c <HAL_DMA_Init+0x538>
  }
  else
  {
    hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
 800475a:	687b      	ldr	r3, [r7, #4]
 800475c:	2240      	movs	r2, #64	@ 0x40
 800475e:	655a      	str	r2, [r3, #84]	@ 0x54
    hdma->State     = HAL_DMA_STATE_ERROR;
 8004760:	687b      	ldr	r3, [r7, #4]
 8004762:	2203      	movs	r2, #3
 8004764:	f883 2035 	strb.w	r2, [r3, #53]	@ 0x35

    return HAL_ERROR;
 8004768:	2301      	movs	r3, #1
 800476a:	e0ed      	b.n	8004948 <HAL_DMA_Init+0x714>
  }

  if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
 800476c:	687b      	ldr	r3, [r7, #4]
 800476e:	681b      	ldr	r3, [r3, #0]
 8004770:	4a46      	ldr	r2, [pc, #280]	@ (800488c <HAL_DMA_Init+0x658>)
 8004772:	4293      	cmp	r3, r2
 8004774:	d072      	beq.n	800485c <HAL_DMA_Init+0x628>
 8004776:	687b      	ldr	r3, [r7, #4]
 8004778:	681b      	ldr	r3, [r3, #0]
 800477a:	4a45      	ldr	r2, [pc, #276]	@ (8004890 <HAL_DMA_Init+0x65c>)
 800477c:	4293      	cmp	r3, r2
 800477e:	d06d      	beq.n	800485c <HAL_DMA_Init+0x628>
 8004780:	687b      	ldr	r3, [r7, #4]
 8004782:	681b      	ldr	r3, [r3, #0]
 8004784:	4a43      	ldr	r2, [pc, #268]	@ (8004894 <HAL_DMA_Init+0x660>)
 8004786:	4293      	cmp	r3, r2
 8004788:	d068      	beq.n	800485c <HAL_DMA_Init+0x628>
 800478a:	687b      	ldr	r3, [r7, #4]
 800478c:	681b      	ldr	r3, [r3, #0]
 800478e:	4a42      	ldr	r2, [pc, #264]	@ (8004898 <HAL_DMA_Init+0x664>)
 8004790:	4293      	cmp	r3, r2
 8004792:	d063      	beq.n	800485c <HAL_DMA_Init+0x628>
 8004794:	687b      	ldr	r3, [r7, #4]
 8004796:	681b      	ldr	r3, [r3, #0]
 8004798:	4a40      	ldr	r2, [pc, #256]	@ (800489c <HAL_DMA_Init+0x668>)
 800479a:	4293      	cmp	r3, r2
 800479c:	d05e      	beq.n	800485c <HAL_DMA_Init+0x628>
 800479e:	687b      	ldr	r3, [r7, #4]
 80047a0:	681b      	ldr	r3, [r3, #0]
 80047a2:	4a3f      	ldr	r2, [pc, #252]	@ (80048a0 <HAL_DMA_Init+0x66c>)
 80047a4:	4293      	cmp	r3, r2
 80047a6:	d059      	beq.n	800485c <HAL_DMA_Init+0x628>
 80047a8:	687b      	ldr	r3, [r7, #4]
 80047aa:	681b      	ldr	r3, [r3, #0]
 80047ac:	4a3d      	ldr	r2, [pc, #244]	@ (80048a4 <HAL_DMA_Init+0x670>)
 80047ae:	4293      	cmp	r3, r2
 80047b0:	d054      	beq.n	800485c <HAL_DMA_Init+0x628>
 80047b2:	687b      	ldr	r3, [r7, #4]
 80047b4:	681b      	ldr	r3, [r3, #0]
 80047b6:	4a3c      	ldr	r2, [pc, #240]	@ (80048a8 <HAL_DMA_Init+0x674>)
 80047b8:	4293      	cmp	r3, r2
 80047ba:	d04f      	beq.n	800485c <HAL_DMA_Init+0x628>
 80047bc:	687b      	ldr	r3, [r7, #4]
 80047be:	681b      	ldr	r3, [r3, #0]
 80047c0:	4a3a      	ldr	r2, [pc, #232]	@ (80048ac <HAL_DMA_Init+0x678>)
 80047c2:	4293      	cmp	r3, r2
 80047c4:	d04a      	beq.n	800485c <HAL_DMA_Init+0x628>
 80047c6:	687b      	ldr	r3, [r7, #4]
 80047c8:	681b      	ldr	r3, [r3, #0]
 80047ca:	4a39      	ldr	r2, [pc, #228]	@ (80048b0 <HAL_DMA_Init+0x67c>)
 80047cc:	4293      	cmp	r3, r2
 80047ce:	d045      	beq.n	800485c <HAL_DMA_Init+0x628>
 80047d0:	687b      	ldr	r3, [r7, #4]
 80047d2:	681b      	ldr	r3, [r3, #0]
 80047d4:	4a37      	ldr	r2, [pc, #220]	@ (80048b4 <HAL_DMA_Init+0x680>)
 80047d6:	4293      	cmp	r3, r2
 80047d8:	d040      	beq.n	800485c <HAL_DMA_Init+0x628>
 80047da:	687b      	ldr	r3, [r7, #4]
 80047dc:	681b      	ldr	r3, [r3, #0]
 80047de:	4a36      	ldr	r2, [pc, #216]	@ (80048b8 <HAL_DMA_Init+0x684>)
 80047e0:	4293      	cmp	r3, r2
 80047e2:	d03b      	beq.n	800485c <HAL_DMA_Init+0x628>
 80047e4:	687b      	ldr	r3, [r7, #4]
 80047e6:	681b      	ldr	r3, [r3, #0]
 80047e8:	4a34      	ldr	r2, [pc, #208]	@ (80048bc <HAL_DMA_Init+0x688>)
 80047ea:	4293      	cmp	r3, r2
 80047ec:	d036      	beq.n	800485c <HAL_DMA_Init+0x628>
 80047ee:	687b      	ldr	r3, [r7, #4]
 80047f0:	681b      	ldr	r3, [r3, #0]
 80047f2:	4a33      	ldr	r2, [pc, #204]	@ (80048c0 <HAL_DMA_Init+0x68c>)
 80047f4:	4293      	cmp	r3, r2
 80047f6:	d031      	beq.n	800485c <HAL_DMA_Init+0x628>
 80047f8:	687b      	ldr	r3, [r7, #4]
 80047fa:	681b      	ldr	r3, [r3, #0]
 80047fc:	4a31      	ldr	r2, [pc, #196]	@ (80048c4 <HAL_DMA_Init+0x690>)
 80047fe:	4293      	cmp	r3, r2
 8004800:	d02c      	beq.n	800485c <HAL_DMA_Init+0x628>
 8004802:	687b      	ldr	r3, [r7, #4]
 8004804:	681b      	ldr	r3, [r3, #0]
 8004806:	4a30      	ldr	r2, [pc, #192]	@ (80048c8 <HAL_DMA_Init+0x694>)
 8004808:	4293      	cmp	r3, r2
 800480a:	d027      	beq.n	800485c <HAL_DMA_Init+0x628>
 800480c:	687b      	ldr	r3, [r7, #4]
 800480e:	681b      	ldr	r3, [r3, #0]
 8004810:	4a13      	ldr	r2, [pc, #76]	@ (8004860 <HAL_DMA_Init+0x62c>)
 8004812:	4293      	cmp	r3, r2
 8004814:	d022      	beq.n	800485c <HAL_DMA_Init+0x628>
 8004816:	687b      	ldr	r3, [r7, #4]
 8004818:	681b      	ldr	r3, [r3, #0]
 800481a:	4a12      	ldr	r2, [pc, #72]	@ (8004864 <HAL_DMA_Init+0x630>)
 800481c:	4293      	cmp	r3, r2
 800481e:	d01d      	beq.n	800485c <HAL_DMA_Init+0x628>
 8004820:	687b      	ldr	r3, [r7, #4]
 8004822:	681b      	ldr	r3, [r3, #0]
 8004824:	4a10      	ldr	r2, [pc, #64]	@ (8004868 <HAL_DMA_Init+0x634>)
 8004826:	4293      	cmp	r3, r2
 8004828:	d018      	beq.n	800485c <HAL_DMA_Init+0x628>
 800482a:	687b      	ldr	r3, [r7, #4]
 800482c:	681b      	ldr	r3, [r3, #0]
 800482e:	4a0f      	ldr	r2, [pc, #60]	@ (800486c <HAL_DMA_Init+0x638>)
 8004830:	4293      	cmp	r3, r2
 8004832:	d013      	beq.n	800485c <HAL_DMA_Init+0x628>
 8004834:	687b      	ldr	r3, [r7, #4]
 8004836:	681b      	ldr	r3, [r3, #0]
 8004838:	4a0d      	ldr	r2, [pc, #52]	@ (8004870 <HAL_DMA_Init+0x63c>)
 800483a:	4293      	cmp	r3, r2
 800483c:	d00e      	beq.n	800485c <HAL_DMA_Init+0x628>
 800483e:	687b      	ldr	r3, [r7, #4]
 8004840:	681b      	ldr	r3, [r3, #0]
 8004842:	4a0c      	ldr	r2, [pc, #48]	@ (8004874 <HAL_DMA_Init+0x640>)
 8004844:	4293      	cmp	r3, r2
 8004846:	d009      	beq.n	800485c <HAL_DMA_Init+0x628>
 8004848:	687b      	ldr	r3, [r7, #4]
 800484a:	681b      	ldr	r3, [r3, #0]
 800484c:	4a0a      	ldr	r2, [pc, #40]	@ (8004878 <HAL_DMA_Init+0x644>)
 800484e:	4293      	cmp	r3, r2
 8004850:	d004      	beq.n	800485c <HAL_DMA_Init+0x628>
 8004852:	687b      	ldr	r3, [r7, #4]
 8004854:	681b      	ldr	r3, [r3, #0]
 8004856:	4a09      	ldr	r2, [pc, #36]	@ (800487c <HAL_DMA_Init+0x648>)
 8004858:	4293      	cmp	r3, r2
 800485a:	d137      	bne.n	80048cc <HAL_DMA_Init+0x698>
 800485c:	2301      	movs	r3, #1
 800485e:	e036      	b.n	80048ce <HAL_DMA_Init+0x69a>
 8004860:	58025408 	.word	0x58025408
 8004864:	5802541c 	.word	0x5802541c
 8004868:	58025430 	.word	0x58025430
 800486c:	58025444 	.word	0x58025444
 8004870:	58025458 	.word	0x58025458
 8004874:	5802546c 	.word	0x5802546c
 8004878:	58025480 	.word	0x58025480
 800487c:	58025494 	.word	0x58025494
 8004880:	fffe000f 	.word	0xfffe000f
 8004884:	a7fdabf8 	.word	0xa7fdabf8
 8004888:	cccccccd 	.word	0xcccccccd
 800488c:	40020010 	.word	0x40020010
 8004890:	40020028 	.word	0x40020028
 8004894:	40020040 	.word	0x40020040
 8004898:	40020058 	.word	0x40020058
 800489c:	40020070 	.word	0x40020070
 80048a0:	40020088 	.word	0x40020088
 80048a4:	400200a0 	.word	0x400200a0
 80048a8:	400200b8 	.word	0x400200b8
 80048ac:	40020410 	.word	0x40020410
 80048b0:	40020428 	.word	0x40020428
 80048b4:	40020440 	.word	0x40020440
 80048b8:	40020458 	.word	0x40020458
 80048bc:	40020470 	.word	0x40020470
 80048c0:	40020488 	.word	0x40020488
 80048c4:	400204a0 	.word	0x400204a0
 80048c8:	400204b8 	.word	0x400204b8
 80048cc:	2300      	movs	r3, #0
 80048ce:	2b00      	cmp	r3, #0
 80048d0:	d032      	beq.n	8004938 <HAL_DMA_Init+0x704>
  {
    /* Initialize parameters for DMAMUX channel :
    DMAmuxChannel, DMAmuxChannelStatus and DMAmuxChannelStatusMask
    */
    DMA_CalcDMAMUXChannelBaseAndMask(hdma);
 80048d2:	6878      	ldr	r0, [r7, #4]
 80048d4:	f001 fd26 	bl	8006324 <DMA_CalcDMAMUXChannelBaseAndMask>

    if(hdma->Init.Direction == DMA_MEMORY_TO_MEMORY)
 80048d8:	687b      	ldr	r3, [r7, #4]
 80048da:	689b      	ldr	r3, [r3, #8]
 80048dc:	2b80      	cmp	r3, #128	@ 0x80
 80048de:	d102      	bne.n	80048e6 <HAL_DMA_Init+0x6b2>
    {
      /* if memory to memory force the request to 0*/
      hdma->Init.Request = DMA_REQUEST_MEM2MEM;
 80048e0:	687b      	ldr	r3, [r7, #4]
 80048e2:	2200      	movs	r2, #0
 80048e4:	605a      	str	r2, [r3, #4]
    }

    /* Set peripheral request  to DMAMUX channel */
    hdma->DMAmuxChannel->CCR = (hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID);
 80048e6:	687b      	ldr	r3, [r7, #4]
 80048e8:	685a      	ldr	r2, [r3, #4]
 80048ea:	687b      	ldr	r3, [r7, #4]
 80048ec:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 80048ee:	b2d2      	uxtb	r2, r2
 80048f0:	601a      	str	r2, [r3, #0]

    /* Clear the DMAMUX synchro overrun flag */
    hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 80048f2:	687b      	ldr	r3, [r7, #4]
 80048f4:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 80048f6:	687a      	ldr	r2, [r7, #4]
 80048f8:	6e92      	ldr	r2, [r2, #104]	@ 0x68
 80048fa:	605a      	str	r2, [r3, #4]

    /* Initialize parameters for DMAMUX request generator :
    if the DMA request is DMA_REQUEST_GENERATOR0 to DMA_REQUEST_GENERATOR7
    */
    if((hdma->Init.Request >= DMA_REQUEST_GENERATOR0) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR7))
 80048fc:	687b      	ldr	r3, [r7, #4]
 80048fe:	685b      	ldr	r3, [r3, #4]
 8004900:	2b00      	cmp	r3, #0
 8004902:	d010      	beq.n	8004926 <HAL_DMA_Init+0x6f2>
 8004904:	687b      	ldr	r3, [r7, #4]
 8004906:	685b      	ldr	r3, [r3, #4]
 8004908:	2b08      	cmp	r3, #8
 800490a:	d80c      	bhi.n	8004926 <HAL_DMA_Init+0x6f2>
    {
      /* Initialize parameters for DMAMUX request generator :
      DMAmuxRequestGen, DMAmuxRequestGenStatus and DMAmuxRequestGenStatusMask */
      DMA_CalcDMAMUXRequestGenBaseAndMask(hdma);
 800490c:	6878      	ldr	r0, [r7, #4]
 800490e:	f001 fda3 	bl	8006458 <DMA_CalcDMAMUXRequestGenBaseAndMask>

      /* Reset the DMAMUX request generator register */
      hdma->DMAmuxRequestGen->RGCR = 0U;
 8004912:	687b      	ldr	r3, [r7, #4]
 8004914:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 8004916:	2200      	movs	r2, #0
 8004918:	601a      	str	r2, [r3, #0]

      /* Clear the DMAMUX request generator overrun flag */
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 800491a:	687b      	ldr	r3, [r7, #4]
 800491c:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 800491e:	687a      	ldr	r2, [r7, #4]
 8004920:	6f52      	ldr	r2, [r2, #116]	@ 0x74
 8004922:	605a      	str	r2, [r3, #4]
 8004924:	e008      	b.n	8004938 <HAL_DMA_Init+0x704>
    }
    else
    {
      hdma->DMAmuxRequestGen = 0U;
 8004926:	687b      	ldr	r3, [r7, #4]
 8004928:	2200      	movs	r2, #0
 800492a:	66da      	str	r2, [r3, #108]	@ 0x6c
      hdma->DMAmuxRequestGenStatus = 0U;
 800492c:	687b      	ldr	r3, [r7, #4]
 800492e:	2200      	movs	r2, #0
 8004930:	671a      	str	r2, [r3, #112]	@ 0x70
      hdma->DMAmuxRequestGenStatusMask = 0U;
 8004932:	687b      	ldr	r3, [r7, #4]
 8004934:	2200      	movs	r2, #0
 8004936:	675a      	str	r2, [r3, #116]	@ 0x74
    }
  }

  /* Initialize the error code */
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8004938:	687b      	ldr	r3, [r7, #4]
 800493a:	2200      	movs	r2, #0
 800493c:	655a      	str	r2, [r3, #84]	@ 0x54

  /* Initialize the DMA state */
  hdma->State = HAL_DMA_STATE_READY;
 800493e:	687b      	ldr	r3, [r7, #4]
 8004940:	2201      	movs	r2, #1
 8004942:	f883 2035 	strb.w	r2, [r3, #53]	@ 0x35

  return HAL_OK;
 8004946:	2300      	movs	r3, #0
}
 8004948:	4618      	mov	r0, r3
 800494a:	3718      	adds	r7, #24
 800494c:	46bd      	mov	sp, r7
 800494e:	bd80      	pop	{r7, pc}

08004950 <HAL_DMA_Start_IT>:
  * @param  DstAddress: The destination memory Buffer address
  * @param  DataLength: The length of data to be transferred from source to destination
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Start_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
 8004950:	b580      	push	{r7, lr}
 8004952:	b086      	sub	sp, #24
 8004954:	af00      	add	r7, sp, #0
 8004956:	60f8      	str	r0, [r7, #12]
 8004958:	60b9      	str	r1, [r7, #8]
 800495a:	607a      	str	r2, [r7, #4]
 800495c:	603b      	str	r3, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
 800495e:	2300      	movs	r3, #0
 8004960:	75fb      	strb	r3, [r7, #23]

  /* Check the parameters */
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));

  /* Check the DMA peripheral handle */
  if(hdma == NULL)
 8004962:	68fb      	ldr	r3, [r7, #12]
 8004964:	2b00      	cmp	r3, #0
 8004966:	d101      	bne.n	800496c <HAL_DMA_Start_IT+0x1c>
  {
    return HAL_ERROR;
 8004968:	2301      	movs	r3, #1
 800496a:	e226      	b.n	8004dba <HAL_DMA_Start_IT+0x46a>
  }

  /* Process locked */
  __HAL_LOCK(hdma);
 800496c:	68fb      	ldr	r3, [r7, #12]
 800496e:	f893 3034 	ldrb.w	r3, [r3, #52]	@ 0x34
 8004972:	2b01      	cmp	r3, #1
 8004974:	d101      	bne.n	800497a <HAL_DMA_Start_IT+0x2a>
 8004976:	2302      	movs	r3, #2
 8004978:	e21f      	b.n	8004dba <HAL_DMA_Start_IT+0x46a>
 800497a:	68fb      	ldr	r3, [r7, #12]
 800497c:	2201      	movs	r2, #1
 800497e:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34

  if(HAL_DMA_STATE_READY == hdma->State)
 8004982:	68fb      	ldr	r3, [r7, #12]
 8004984:	f893 3035 	ldrb.w	r3, [r3, #53]	@ 0x35
 8004988:	b2db      	uxtb	r3, r3
 800498a:	2b01      	cmp	r3, #1
 800498c:	f040 820a 	bne.w	8004da4 <HAL_DMA_Start_IT+0x454>
  {
    /* Change DMA peripheral state */
    hdma->State = HAL_DMA_STATE_BUSY;
 8004990:	68fb      	ldr	r3, [r7, #12]
 8004992:	2202      	movs	r2, #2
 8004994:	f883 2035 	strb.w	r2, [r3, #53]	@ 0x35

    /* Initialize the error code */
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8004998:	68fb      	ldr	r3, [r7, #12]
 800499a:	2200      	movs	r2, #0
 800499c:	655a      	str	r2, [r3, #84]	@ 0x54

    /* Disable the peripheral */
    __HAL_DMA_DISABLE(hdma);
 800499e:	68fb      	ldr	r3, [r7, #12]
 80049a0:	681b      	ldr	r3, [r3, #0]
 80049a2:	4a68      	ldr	r2, [pc, #416]	@ (8004b44 <HAL_DMA_Start_IT+0x1f4>)
 80049a4:	4293      	cmp	r3, r2
 80049a6:	d04a      	beq.n	8004a3e <HAL_DMA_Start_IT+0xee>
 80049a8:	68fb      	ldr	r3, [r7, #12]
 80049aa:	681b      	ldr	r3, [r3, #0]
 80049ac:	4a66      	ldr	r2, [pc, #408]	@ (8004b48 <HAL_DMA_Start_IT+0x1f8>)
 80049ae:	4293      	cmp	r3, r2
 80049b0:	d045      	beq.n	8004a3e <HAL_DMA_Start_IT+0xee>
 80049b2:	68fb      	ldr	r3, [r7, #12]
 80049b4:	681b      	ldr	r3, [r3, #0]
 80049b6:	4a65      	ldr	r2, [pc, #404]	@ (8004b4c <HAL_DMA_Start_IT+0x1fc>)
 80049b8:	4293      	cmp	r3, r2
 80049ba:	d040      	beq.n	8004a3e <HAL_DMA_Start_IT+0xee>
 80049bc:	68fb      	ldr	r3, [r7, #12]
 80049be:	681b      	ldr	r3, [r3, #0]
 80049c0:	4a63      	ldr	r2, [pc, #396]	@ (8004b50 <HAL_DMA_Start_IT+0x200>)
 80049c2:	4293      	cmp	r3, r2
 80049c4:	d03b      	beq.n	8004a3e <HAL_DMA_Start_IT+0xee>
 80049c6:	68fb      	ldr	r3, [r7, #12]
 80049c8:	681b      	ldr	r3, [r3, #0]
 80049ca:	4a62      	ldr	r2, [pc, #392]	@ (8004b54 <HAL_DMA_Start_IT+0x204>)
 80049cc:	4293      	cmp	r3, r2
 80049ce:	d036      	beq.n	8004a3e <HAL_DMA_Start_IT+0xee>
 80049d0:	68fb      	ldr	r3, [r7, #12]
 80049d2:	681b      	ldr	r3, [r3, #0]
 80049d4:	4a60      	ldr	r2, [pc, #384]	@ (8004b58 <HAL_DMA_Start_IT+0x208>)
 80049d6:	4293      	cmp	r3, r2
 80049d8:	d031      	beq.n	8004a3e <HAL_DMA_Start_IT+0xee>
 80049da:	68fb      	ldr	r3, [r7, #12]
 80049dc:	681b      	ldr	r3, [r3, #0]
 80049de:	4a5f      	ldr	r2, [pc, #380]	@ (8004b5c <HAL_DMA_Start_IT+0x20c>)
 80049e0:	4293      	cmp	r3, r2
 80049e2:	d02c      	beq.n	8004a3e <HAL_DMA_Start_IT+0xee>
 80049e4:	68fb      	ldr	r3, [r7, #12]
 80049e6:	681b      	ldr	r3, [r3, #0]
 80049e8:	4a5d      	ldr	r2, [pc, #372]	@ (8004b60 <HAL_DMA_Start_IT+0x210>)
 80049ea:	4293      	cmp	r3, r2
 80049ec:	d027      	beq.n	8004a3e <HAL_DMA_Start_IT+0xee>
 80049ee:	68fb      	ldr	r3, [r7, #12]
 80049f0:	681b      	ldr	r3, [r3, #0]
 80049f2:	4a5c      	ldr	r2, [pc, #368]	@ (8004b64 <HAL_DMA_Start_IT+0x214>)
 80049f4:	4293      	cmp	r3, r2
 80049f6:	d022      	beq.n	8004a3e <HAL_DMA_Start_IT+0xee>
 80049f8:	68fb      	ldr	r3, [r7, #12]
 80049fa:	681b      	ldr	r3, [r3, #0]
 80049fc:	4a5a      	ldr	r2, [pc, #360]	@ (8004b68 <HAL_DMA_Start_IT+0x218>)
 80049fe:	4293      	cmp	r3, r2
 8004a00:	d01d      	beq.n	8004a3e <HAL_DMA_Start_IT+0xee>
 8004a02:	68fb      	ldr	r3, [r7, #12]
 8004a04:	681b      	ldr	r3, [r3, #0]
 8004a06:	4a59      	ldr	r2, [pc, #356]	@ (8004b6c <HAL_DMA_Start_IT+0x21c>)
 8004a08:	4293      	cmp	r3, r2
 8004a0a:	d018      	beq.n	8004a3e <HAL_DMA_Start_IT+0xee>
 8004a0c:	68fb      	ldr	r3, [r7, #12]
 8004a0e:	681b      	ldr	r3, [r3, #0]
 8004a10:	4a57      	ldr	r2, [pc, #348]	@ (8004b70 <HAL_DMA_Start_IT+0x220>)
 8004a12:	4293      	cmp	r3, r2
 8004a14:	d013      	beq.n	8004a3e <HAL_DMA_Start_IT+0xee>
 8004a16:	68fb      	ldr	r3, [r7, #12]
 8004a18:	681b      	ldr	r3, [r3, #0]
 8004a1a:	4a56      	ldr	r2, [pc, #344]	@ (8004b74 <HAL_DMA_Start_IT+0x224>)
 8004a1c:	4293      	cmp	r3, r2
 8004a1e:	d00e      	beq.n	8004a3e <HAL_DMA_Start_IT+0xee>
 8004a20:	68fb      	ldr	r3, [r7, #12]
 8004a22:	681b      	ldr	r3, [r3, #0]
 8004a24:	4a54      	ldr	r2, [pc, #336]	@ (8004b78 <HAL_DMA_Start_IT+0x228>)
 8004a26:	4293      	cmp	r3, r2
 8004a28:	d009      	beq.n	8004a3e <HAL_DMA_Start_IT+0xee>
 8004a2a:	68fb      	ldr	r3, [r7, #12]
 8004a2c:	681b      	ldr	r3, [r3, #0]
 8004a2e:	4a53      	ldr	r2, [pc, #332]	@ (8004b7c <HAL_DMA_Start_IT+0x22c>)
 8004a30:	4293      	cmp	r3, r2
 8004a32:	d004      	beq.n	8004a3e <HAL_DMA_Start_IT+0xee>
 8004a34:	68fb      	ldr	r3, [r7, #12]
 8004a36:	681b      	ldr	r3, [r3, #0]
 8004a38:	4a51      	ldr	r2, [pc, #324]	@ (8004b80 <HAL_DMA_Start_IT+0x230>)
 8004a3a:	4293      	cmp	r3, r2
 8004a3c:	d108      	bne.n	8004a50 <HAL_DMA_Start_IT+0x100>
 8004a3e:	68fb      	ldr	r3, [r7, #12]
 8004a40:	681b      	ldr	r3, [r3, #0]
 8004a42:	681a      	ldr	r2, [r3, #0]
 8004a44:	68fb      	ldr	r3, [r7, #12]
 8004a46:	681b      	ldr	r3, [r3, #0]
 8004a48:	f022 0201 	bic.w	r2, r2, #1
 8004a4c:	601a      	str	r2, [r3, #0]
 8004a4e:	e007      	b.n	8004a60 <HAL_DMA_Start_IT+0x110>
 8004a50:	68fb      	ldr	r3, [r7, #12]
 8004a52:	681b      	ldr	r3, [r3, #0]
 8004a54:	681a      	ldr	r2, [r3, #0]
 8004a56:	68fb      	ldr	r3, [r7, #12]
 8004a58:	681b      	ldr	r3, [r3, #0]
 8004a5a:	f022 0201 	bic.w	r2, r2, #1
 8004a5e:	601a      	str	r2, [r3, #0]

    /* Configure the source, destination address and the data length */
    DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
 8004a60:	683b      	ldr	r3, [r7, #0]
 8004a62:	687a      	ldr	r2, [r7, #4]
 8004a64:	68b9      	ldr	r1, [r7, #8]
 8004a66:	68f8      	ldr	r0, [r7, #12]
 8004a68:	f001 f94a 	bl	8005d00 <DMA_SetConfig>

    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
 8004a6c:	68fb      	ldr	r3, [r7, #12]
 8004a6e:	681b      	ldr	r3, [r3, #0]
 8004a70:	4a34      	ldr	r2, [pc, #208]	@ (8004b44 <HAL_DMA_Start_IT+0x1f4>)
 8004a72:	4293      	cmp	r3, r2
 8004a74:	d04a      	beq.n	8004b0c <HAL_DMA_Start_IT+0x1bc>
 8004a76:	68fb      	ldr	r3, [r7, #12]
 8004a78:	681b      	ldr	r3, [r3, #0]
 8004a7a:	4a33      	ldr	r2, [pc, #204]	@ (8004b48 <HAL_DMA_Start_IT+0x1f8>)
 8004a7c:	4293      	cmp	r3, r2
 8004a7e:	d045      	beq.n	8004b0c <HAL_DMA_Start_IT+0x1bc>
 8004a80:	68fb      	ldr	r3, [r7, #12]
 8004a82:	681b      	ldr	r3, [r3, #0]
 8004a84:	4a31      	ldr	r2, [pc, #196]	@ (8004b4c <HAL_DMA_Start_IT+0x1fc>)
 8004a86:	4293      	cmp	r3, r2
 8004a88:	d040      	beq.n	8004b0c <HAL_DMA_Start_IT+0x1bc>
 8004a8a:	68fb      	ldr	r3, [r7, #12]
 8004a8c:	681b      	ldr	r3, [r3, #0]
 8004a8e:	4a30      	ldr	r2, [pc, #192]	@ (8004b50 <HAL_DMA_Start_IT+0x200>)
 8004a90:	4293      	cmp	r3, r2
 8004a92:	d03b      	beq.n	8004b0c <HAL_DMA_Start_IT+0x1bc>
 8004a94:	68fb      	ldr	r3, [r7, #12]
 8004a96:	681b      	ldr	r3, [r3, #0]
 8004a98:	4a2e      	ldr	r2, [pc, #184]	@ (8004b54 <HAL_DMA_Start_IT+0x204>)
 8004a9a:	4293      	cmp	r3, r2
 8004a9c:	d036      	beq.n	8004b0c <HAL_DMA_Start_IT+0x1bc>
 8004a9e:	68fb      	ldr	r3, [r7, #12]
 8004aa0:	681b      	ldr	r3, [r3, #0]
 8004aa2:	4a2d      	ldr	r2, [pc, #180]	@ (8004b58 <HAL_DMA_Start_IT+0x208>)
 8004aa4:	4293      	cmp	r3, r2
 8004aa6:	d031      	beq.n	8004b0c <HAL_DMA_Start_IT+0x1bc>
 8004aa8:	68fb      	ldr	r3, [r7, #12]
 8004aaa:	681b      	ldr	r3, [r3, #0]
 8004aac:	4a2b      	ldr	r2, [pc, #172]	@ (8004b5c <HAL_DMA_Start_IT+0x20c>)
 8004aae:	4293      	cmp	r3, r2
 8004ab0:	d02c      	beq.n	8004b0c <HAL_DMA_Start_IT+0x1bc>
 8004ab2:	68fb      	ldr	r3, [r7, #12]
 8004ab4:	681b      	ldr	r3, [r3, #0]
 8004ab6:	4a2a      	ldr	r2, [pc, #168]	@ (8004b60 <HAL_DMA_Start_IT+0x210>)
 8004ab8:	4293      	cmp	r3, r2
 8004aba:	d027      	beq.n	8004b0c <HAL_DMA_Start_IT+0x1bc>
 8004abc:	68fb      	ldr	r3, [r7, #12]
 8004abe:	681b      	ldr	r3, [r3, #0]
 8004ac0:	4a28      	ldr	r2, [pc, #160]	@ (8004b64 <HAL_DMA_Start_IT+0x214>)
 8004ac2:	4293      	cmp	r3, r2
 8004ac4:	d022      	beq.n	8004b0c <HAL_DMA_Start_IT+0x1bc>
 8004ac6:	68fb      	ldr	r3, [r7, #12]
 8004ac8:	681b      	ldr	r3, [r3, #0]
 8004aca:	4a27      	ldr	r2, [pc, #156]	@ (8004b68 <HAL_DMA_Start_IT+0x218>)
 8004acc:	4293      	cmp	r3, r2
 8004ace:	d01d      	beq.n	8004b0c <HAL_DMA_Start_IT+0x1bc>
 8004ad0:	68fb      	ldr	r3, [r7, #12]
 8004ad2:	681b      	ldr	r3, [r3, #0]
 8004ad4:	4a25      	ldr	r2, [pc, #148]	@ (8004b6c <HAL_DMA_Start_IT+0x21c>)
 8004ad6:	4293      	cmp	r3, r2
 8004ad8:	d018      	beq.n	8004b0c <HAL_DMA_Start_IT+0x1bc>
 8004ada:	68fb      	ldr	r3, [r7, #12]
 8004adc:	681b      	ldr	r3, [r3, #0]
 8004ade:	4a24      	ldr	r2, [pc, #144]	@ (8004b70 <HAL_DMA_Start_IT+0x220>)
 8004ae0:	4293      	cmp	r3, r2
 8004ae2:	d013      	beq.n	8004b0c <HAL_DMA_Start_IT+0x1bc>
 8004ae4:	68fb      	ldr	r3, [r7, #12]
 8004ae6:	681b      	ldr	r3, [r3, #0]
 8004ae8:	4a22      	ldr	r2, [pc, #136]	@ (8004b74 <HAL_DMA_Start_IT+0x224>)
 8004aea:	4293      	cmp	r3, r2
 8004aec:	d00e      	beq.n	8004b0c <HAL_DMA_Start_IT+0x1bc>
 8004aee:	68fb      	ldr	r3, [r7, #12]
 8004af0:	681b      	ldr	r3, [r3, #0]
 8004af2:	4a21      	ldr	r2, [pc, #132]	@ (8004b78 <HAL_DMA_Start_IT+0x228>)
 8004af4:	4293      	cmp	r3, r2
 8004af6:	d009      	beq.n	8004b0c <HAL_DMA_Start_IT+0x1bc>
 8004af8:	68fb      	ldr	r3, [r7, #12]
 8004afa:	681b      	ldr	r3, [r3, #0]
 8004afc:	4a1f      	ldr	r2, [pc, #124]	@ (8004b7c <HAL_DMA_Start_IT+0x22c>)
 8004afe:	4293      	cmp	r3, r2
 8004b00:	d004      	beq.n	8004b0c <HAL_DMA_Start_IT+0x1bc>
 8004b02:	68fb      	ldr	r3, [r7, #12]
 8004b04:	681b      	ldr	r3, [r3, #0]
 8004b06:	4a1e      	ldr	r2, [pc, #120]	@ (8004b80 <HAL_DMA_Start_IT+0x230>)
 8004b08:	4293      	cmp	r3, r2
 8004b0a:	d101      	bne.n	8004b10 <HAL_DMA_Start_IT+0x1c0>
 8004b0c:	2301      	movs	r3, #1
 8004b0e:	e000      	b.n	8004b12 <HAL_DMA_Start_IT+0x1c2>
 8004b10:	2300      	movs	r3, #0
 8004b12:	2b00      	cmp	r3, #0
 8004b14:	d036      	beq.n	8004b84 <HAL_DMA_Start_IT+0x234>
    {
      /* Enable Common interrupts*/
      MODIFY_REG(((DMA_Stream_TypeDef   *)hdma->Instance)->CR, (DMA_IT_TC | DMA_IT_TE | DMA_IT_DME | DMA_IT_HT), (DMA_IT_TC | DMA_IT_TE | DMA_IT_DME));
 8004b16:	68fb      	ldr	r3, [r7, #12]
 8004b18:	681b      	ldr	r3, [r3, #0]
 8004b1a:	681b      	ldr	r3, [r3, #0]
 8004b1c:	f023 021e 	bic.w	r2, r3, #30
 8004b20:	68fb      	ldr	r3, [r7, #12]
 8004b22:	681b      	ldr	r3, [r3, #0]
 8004b24:	f042 0216 	orr.w	r2, r2, #22
 8004b28:	601a      	str	r2, [r3, #0]

      if(hdma->XferHalfCpltCallback != NULL)
 8004b2a:	68fb      	ldr	r3, [r7, #12]
 8004b2c:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8004b2e:	2b00      	cmp	r3, #0
 8004b30:	d03e      	beq.n	8004bb0 <HAL_DMA_Start_IT+0x260>
      {
        /* Enable Half Transfer IT if corresponding Callback is set */
        ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  |= DMA_IT_HT;
 8004b32:	68fb      	ldr	r3, [r7, #12]
 8004b34:	681b      	ldr	r3, [r3, #0]
 8004b36:	681a      	ldr	r2, [r3, #0]
 8004b38:	68fb      	ldr	r3, [r7, #12]
 8004b3a:	681b      	ldr	r3, [r3, #0]
 8004b3c:	f042 0208 	orr.w	r2, r2, #8
 8004b40:	601a      	str	r2, [r3, #0]
 8004b42:	e035      	b.n	8004bb0 <HAL_DMA_Start_IT+0x260>
 8004b44:	40020010 	.word	0x40020010
 8004b48:	40020028 	.word	0x40020028
 8004b4c:	40020040 	.word	0x40020040
 8004b50:	40020058 	.word	0x40020058
 8004b54:	40020070 	.word	0x40020070
 8004b58:	40020088 	.word	0x40020088
 8004b5c:	400200a0 	.word	0x400200a0
 8004b60:	400200b8 	.word	0x400200b8
 8004b64:	40020410 	.word	0x40020410
 8004b68:	40020428 	.word	0x40020428
 8004b6c:	40020440 	.word	0x40020440
 8004b70:	40020458 	.word	0x40020458
 8004b74:	40020470 	.word	0x40020470
 8004b78:	40020488 	.word	0x40020488
 8004b7c:	400204a0 	.word	0x400204a0
 8004b80:	400204b8 	.word	0x400204b8
      }
    }
    else /* BDMA channel */
    {
      /* Enable Common interrupts */
      MODIFY_REG(((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR, (BDMA_CCR_TCIE | BDMA_CCR_HTIE | BDMA_CCR_TEIE), (BDMA_CCR_TCIE | BDMA_CCR_TEIE));
 8004b84:	68fb      	ldr	r3, [r7, #12]
 8004b86:	681b      	ldr	r3, [r3, #0]
 8004b88:	681b      	ldr	r3, [r3, #0]
 8004b8a:	f023 020e 	bic.w	r2, r3, #14
 8004b8e:	68fb      	ldr	r3, [r7, #12]
 8004b90:	681b      	ldr	r3, [r3, #0]
 8004b92:	f042 020a 	orr.w	r2, r2, #10
 8004b96:	601a      	str	r2, [r3, #0]

      if(hdma->XferHalfCpltCallback != NULL)
 8004b98:	68fb      	ldr	r3, [r7, #12]
 8004b9a:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8004b9c:	2b00      	cmp	r3, #0
 8004b9e:	d007      	beq.n	8004bb0 <HAL_DMA_Start_IT+0x260>
      {
        /*Enable Half Transfer IT if corresponding Callback is set */
        ((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR  |= BDMA_CCR_HTIE;
 8004ba0:	68fb      	ldr	r3, [r7, #12]
 8004ba2:	681b      	ldr	r3, [r3, #0]
 8004ba4:	681a      	ldr	r2, [r3, #0]
 8004ba6:	68fb      	ldr	r3, [r7, #12]
 8004ba8:	681b      	ldr	r3, [r3, #0]
 8004baa:	f042 0204 	orr.w	r2, r2, #4
 8004bae:	601a      	str	r2, [r3, #0]
      }
    }

    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
 8004bb0:	68fb      	ldr	r3, [r7, #12]
 8004bb2:	681b      	ldr	r3, [r3, #0]
 8004bb4:	4a83      	ldr	r2, [pc, #524]	@ (8004dc4 <HAL_DMA_Start_IT+0x474>)
 8004bb6:	4293      	cmp	r3, r2
 8004bb8:	d072      	beq.n	8004ca0 <HAL_DMA_Start_IT+0x350>
 8004bba:	68fb      	ldr	r3, [r7, #12]
 8004bbc:	681b      	ldr	r3, [r3, #0]
 8004bbe:	4a82      	ldr	r2, [pc, #520]	@ (8004dc8 <HAL_DMA_Start_IT+0x478>)
 8004bc0:	4293      	cmp	r3, r2
 8004bc2:	d06d      	beq.n	8004ca0 <HAL_DMA_Start_IT+0x350>
 8004bc4:	68fb      	ldr	r3, [r7, #12]
 8004bc6:	681b      	ldr	r3, [r3, #0]
 8004bc8:	4a80      	ldr	r2, [pc, #512]	@ (8004dcc <HAL_DMA_Start_IT+0x47c>)
 8004bca:	4293      	cmp	r3, r2
 8004bcc:	d068      	beq.n	8004ca0 <HAL_DMA_Start_IT+0x350>
 8004bce:	68fb      	ldr	r3, [r7, #12]
 8004bd0:	681b      	ldr	r3, [r3, #0]
 8004bd2:	4a7f      	ldr	r2, [pc, #508]	@ (8004dd0 <HAL_DMA_Start_IT+0x480>)
 8004bd4:	4293      	cmp	r3, r2
 8004bd6:	d063      	beq.n	8004ca0 <HAL_DMA_Start_IT+0x350>
 8004bd8:	68fb      	ldr	r3, [r7, #12]
 8004bda:	681b      	ldr	r3, [r3, #0]
 8004bdc:	4a7d      	ldr	r2, [pc, #500]	@ (8004dd4 <HAL_DMA_Start_IT+0x484>)
 8004bde:	4293      	cmp	r3, r2
 8004be0:	d05e      	beq.n	8004ca0 <HAL_DMA_Start_IT+0x350>
 8004be2:	68fb      	ldr	r3, [r7, #12]
 8004be4:	681b      	ldr	r3, [r3, #0]
 8004be6:	4a7c      	ldr	r2, [pc, #496]	@ (8004dd8 <HAL_DMA_Start_IT+0x488>)
 8004be8:	4293      	cmp	r3, r2
 8004bea:	d059      	beq.n	8004ca0 <HAL_DMA_Start_IT+0x350>
 8004bec:	68fb      	ldr	r3, [r7, #12]
 8004bee:	681b      	ldr	r3, [r3, #0]
 8004bf0:	4a7a      	ldr	r2, [pc, #488]	@ (8004ddc <HAL_DMA_Start_IT+0x48c>)
 8004bf2:	4293      	cmp	r3, r2
 8004bf4:	d054      	beq.n	8004ca0 <HAL_DMA_Start_IT+0x350>
 8004bf6:	68fb      	ldr	r3, [r7, #12]
 8004bf8:	681b      	ldr	r3, [r3, #0]
 8004bfa:	4a79      	ldr	r2, [pc, #484]	@ (8004de0 <HAL_DMA_Start_IT+0x490>)
 8004bfc:	4293      	cmp	r3, r2
 8004bfe:	d04f      	beq.n	8004ca0 <HAL_DMA_Start_IT+0x350>
 8004c00:	68fb      	ldr	r3, [r7, #12]
 8004c02:	681b      	ldr	r3, [r3, #0]
 8004c04:	4a77      	ldr	r2, [pc, #476]	@ (8004de4 <HAL_DMA_Start_IT+0x494>)
 8004c06:	4293      	cmp	r3, r2
 8004c08:	d04a      	beq.n	8004ca0 <HAL_DMA_Start_IT+0x350>
 8004c0a:	68fb      	ldr	r3, [r7, #12]
 8004c0c:	681b      	ldr	r3, [r3, #0]
 8004c0e:	4a76      	ldr	r2, [pc, #472]	@ (8004de8 <HAL_DMA_Start_IT+0x498>)
 8004c10:	4293      	cmp	r3, r2
 8004c12:	d045      	beq.n	8004ca0 <HAL_DMA_Start_IT+0x350>
 8004c14:	68fb      	ldr	r3, [r7, #12]
 8004c16:	681b      	ldr	r3, [r3, #0]
 8004c18:	4a74      	ldr	r2, [pc, #464]	@ (8004dec <HAL_DMA_Start_IT+0x49c>)
 8004c1a:	4293      	cmp	r3, r2
 8004c1c:	d040      	beq.n	8004ca0 <HAL_DMA_Start_IT+0x350>
 8004c1e:	68fb      	ldr	r3, [r7, #12]
 8004c20:	681b      	ldr	r3, [r3, #0]
 8004c22:	4a73      	ldr	r2, [pc, #460]	@ (8004df0 <HAL_DMA_Start_IT+0x4a0>)
 8004c24:	4293      	cmp	r3, r2
 8004c26:	d03b      	beq.n	8004ca0 <HAL_DMA_Start_IT+0x350>
 8004c28:	68fb      	ldr	r3, [r7, #12]
 8004c2a:	681b      	ldr	r3, [r3, #0]
 8004c2c:	4a71      	ldr	r2, [pc, #452]	@ (8004df4 <HAL_DMA_Start_IT+0x4a4>)
 8004c2e:	4293      	cmp	r3, r2
 8004c30:	d036      	beq.n	8004ca0 <HAL_DMA_Start_IT+0x350>
 8004c32:	68fb      	ldr	r3, [r7, #12]
 8004c34:	681b      	ldr	r3, [r3, #0]
 8004c36:	4a70      	ldr	r2, [pc, #448]	@ (8004df8 <HAL_DMA_Start_IT+0x4a8>)
 8004c38:	4293      	cmp	r3, r2
 8004c3a:	d031      	beq.n	8004ca0 <HAL_DMA_Start_IT+0x350>
 8004c3c:	68fb      	ldr	r3, [r7, #12]
 8004c3e:	681b      	ldr	r3, [r3, #0]
 8004c40:	4a6e      	ldr	r2, [pc, #440]	@ (8004dfc <HAL_DMA_Start_IT+0x4ac>)
 8004c42:	4293      	cmp	r3, r2
 8004c44:	d02c      	beq.n	8004ca0 <HAL_DMA_Start_IT+0x350>
 8004c46:	68fb      	ldr	r3, [r7, #12]
 8004c48:	681b      	ldr	r3, [r3, #0]
 8004c4a:	4a6d      	ldr	r2, [pc, #436]	@ (8004e00 <HAL_DMA_Start_IT+0x4b0>)
 8004c4c:	4293      	cmp	r3, r2
 8004c4e:	d027      	beq.n	8004ca0 <HAL_DMA_Start_IT+0x350>
 8004c50:	68fb      	ldr	r3, [r7, #12]
 8004c52:	681b      	ldr	r3, [r3, #0]
 8004c54:	4a6b      	ldr	r2, [pc, #428]	@ (8004e04 <HAL_DMA_Start_IT+0x4b4>)
 8004c56:	4293      	cmp	r3, r2
 8004c58:	d022      	beq.n	8004ca0 <HAL_DMA_Start_IT+0x350>
 8004c5a:	68fb      	ldr	r3, [r7, #12]
 8004c5c:	681b      	ldr	r3, [r3, #0]
 8004c5e:	4a6a      	ldr	r2, [pc, #424]	@ (8004e08 <HAL_DMA_Start_IT+0x4b8>)
 8004c60:	4293      	cmp	r3, r2
 8004c62:	d01d      	beq.n	8004ca0 <HAL_DMA_Start_IT+0x350>
 8004c64:	68fb      	ldr	r3, [r7, #12]
 8004c66:	681b      	ldr	r3, [r3, #0]
 8004c68:	4a68      	ldr	r2, [pc, #416]	@ (8004e0c <HAL_DMA_Start_IT+0x4bc>)
 8004c6a:	4293      	cmp	r3, r2
 8004c6c:	d018      	beq.n	8004ca0 <HAL_DMA_Start_IT+0x350>
 8004c6e:	68fb      	ldr	r3, [r7, #12]
 8004c70:	681b      	ldr	r3, [r3, #0]
 8004c72:	4a67      	ldr	r2, [pc, #412]	@ (8004e10 <HAL_DMA_Start_IT+0x4c0>)
 8004c74:	4293      	cmp	r3, r2
 8004c76:	d013      	beq.n	8004ca0 <HAL_DMA_Start_IT+0x350>
 8004c78:	68fb      	ldr	r3, [r7, #12]
 8004c7a:	681b      	ldr	r3, [r3, #0]
 8004c7c:	4a65      	ldr	r2, [pc, #404]	@ (8004e14 <HAL_DMA_Start_IT+0x4c4>)
 8004c7e:	4293      	cmp	r3, r2
 8004c80:	d00e      	beq.n	8004ca0 <HAL_DMA_Start_IT+0x350>
 8004c82:	68fb      	ldr	r3, [r7, #12]
 8004c84:	681b      	ldr	r3, [r3, #0]
 8004c86:	4a64      	ldr	r2, [pc, #400]	@ (8004e18 <HAL_DMA_Start_IT+0x4c8>)
 8004c88:	4293      	cmp	r3, r2
 8004c8a:	d009      	beq.n	8004ca0 <HAL_DMA_Start_IT+0x350>
 8004c8c:	68fb      	ldr	r3, [r7, #12]
 8004c8e:	681b      	ldr	r3, [r3, #0]
 8004c90:	4a62      	ldr	r2, [pc, #392]	@ (8004e1c <HAL_DMA_Start_IT+0x4cc>)
 8004c92:	4293      	cmp	r3, r2
 8004c94:	d004      	beq.n	8004ca0 <HAL_DMA_Start_IT+0x350>
 8004c96:	68fb      	ldr	r3, [r7, #12]
 8004c98:	681b      	ldr	r3, [r3, #0]
 8004c9a:	4a61      	ldr	r2, [pc, #388]	@ (8004e20 <HAL_DMA_Start_IT+0x4d0>)
 8004c9c:	4293      	cmp	r3, r2
 8004c9e:	d101      	bne.n	8004ca4 <HAL_DMA_Start_IT+0x354>
 8004ca0:	2301      	movs	r3, #1
 8004ca2:	e000      	b.n	8004ca6 <HAL_DMA_Start_IT+0x356>
 8004ca4:	2300      	movs	r3, #0
 8004ca6:	2b00      	cmp	r3, #0
 8004ca8:	d01a      	beq.n	8004ce0 <HAL_DMA_Start_IT+0x390>
    {
      /* Check if DMAMUX Synchronization is enabled */
      if((hdma->DMAmuxChannel->CCR & DMAMUX_CxCR_SE) != 0U)
 8004caa:	68fb      	ldr	r3, [r7, #12]
 8004cac:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 8004cae:	681b      	ldr	r3, [r3, #0]
 8004cb0:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 8004cb4:	2b00      	cmp	r3, #0
 8004cb6:	d007      	beq.n	8004cc8 <HAL_DMA_Start_IT+0x378>
      {
        /* Enable DMAMUX sync overrun IT*/
        hdma->DMAmuxChannel->CCR |= DMAMUX_CxCR_SOIE;
 8004cb8:	68fb      	ldr	r3, [r7, #12]
 8004cba:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 8004cbc:	681a      	ldr	r2, [r3, #0]
 8004cbe:	68fb      	ldr	r3, [r7, #12]
 8004cc0:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 8004cc2:	f442 7280 	orr.w	r2, r2, #256	@ 0x100
 8004cc6:	601a      	str	r2, [r3, #0]
      }

      if(hdma->DMAmuxRequestGen != 0U)
 8004cc8:	68fb      	ldr	r3, [r7, #12]
 8004cca:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 8004ccc:	2b00      	cmp	r3, #0
 8004cce:	d007      	beq.n	8004ce0 <HAL_DMA_Start_IT+0x390>
      {
        /* if using DMAMUX request generator, enable the DMAMUX request generator overrun IT*/
        /* enable the request gen overrun IT */
        hdma->DMAmuxRequestGen->RGCR |= DMAMUX_RGxCR_OIE;
 8004cd0:	68fb      	ldr	r3, [r7, #12]
 8004cd2:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 8004cd4:	681a      	ldr	r2, [r3, #0]
 8004cd6:	68fb      	ldr	r3, [r7, #12]
 8004cd8:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 8004cda:	f442 7280 	orr.w	r2, r2, #256	@ 0x100
 8004cde:	601a      	str	r2, [r3, #0]
      }
    }

    /* Enable the Peripheral */
    __HAL_DMA_ENABLE(hdma);
 8004ce0:	68fb      	ldr	r3, [r7, #12]
 8004ce2:	681b      	ldr	r3, [r3, #0]
 8004ce4:	4a37      	ldr	r2, [pc, #220]	@ (8004dc4 <HAL_DMA_Start_IT+0x474>)
 8004ce6:	4293      	cmp	r3, r2
 8004ce8:	d04a      	beq.n	8004d80 <HAL_DMA_Start_IT+0x430>
 8004cea:	68fb      	ldr	r3, [r7, #12]
 8004cec:	681b      	ldr	r3, [r3, #0]
 8004cee:	4a36      	ldr	r2, [pc, #216]	@ (8004dc8 <HAL_DMA_Start_IT+0x478>)
 8004cf0:	4293      	cmp	r3, r2
 8004cf2:	d045      	beq.n	8004d80 <HAL_DMA_Start_IT+0x430>
 8004cf4:	68fb      	ldr	r3, [r7, #12]
 8004cf6:	681b      	ldr	r3, [r3, #0]
 8004cf8:	4a34      	ldr	r2, [pc, #208]	@ (8004dcc <HAL_DMA_Start_IT+0x47c>)
 8004cfa:	4293      	cmp	r3, r2
 8004cfc:	d040      	beq.n	8004d80 <HAL_DMA_Start_IT+0x430>
 8004cfe:	68fb      	ldr	r3, [r7, #12]
 8004d00:	681b      	ldr	r3, [r3, #0]
 8004d02:	4a33      	ldr	r2, [pc, #204]	@ (8004dd0 <HAL_DMA_Start_IT+0x480>)
 8004d04:	4293      	cmp	r3, r2
 8004d06:	d03b      	beq.n	8004d80 <HAL_DMA_Start_IT+0x430>
 8004d08:	68fb      	ldr	r3, [r7, #12]
 8004d0a:	681b      	ldr	r3, [r3, #0]
 8004d0c:	4a31      	ldr	r2, [pc, #196]	@ (8004dd4 <HAL_DMA_Start_IT+0x484>)
 8004d0e:	4293      	cmp	r3, r2
 8004d10:	d036      	beq.n	8004d80 <HAL_DMA_Start_IT+0x430>
 8004d12:	68fb      	ldr	r3, [r7, #12]
 8004d14:	681b      	ldr	r3, [r3, #0]
 8004d16:	4a30      	ldr	r2, [pc, #192]	@ (8004dd8 <HAL_DMA_Start_IT+0x488>)
 8004d18:	4293      	cmp	r3, r2
 8004d1a:	d031      	beq.n	8004d80 <HAL_DMA_Start_IT+0x430>
 8004d1c:	68fb      	ldr	r3, [r7, #12]
 8004d1e:	681b      	ldr	r3, [r3, #0]
 8004d20:	4a2e      	ldr	r2, [pc, #184]	@ (8004ddc <HAL_DMA_Start_IT+0x48c>)
 8004d22:	4293      	cmp	r3, r2
 8004d24:	d02c      	beq.n	8004d80 <HAL_DMA_Start_IT+0x430>
 8004d26:	68fb      	ldr	r3, [r7, #12]
 8004d28:	681b      	ldr	r3, [r3, #0]
 8004d2a:	4a2d      	ldr	r2, [pc, #180]	@ (8004de0 <HAL_DMA_Start_IT+0x490>)
 8004d2c:	4293      	cmp	r3, r2
 8004d2e:	d027      	beq.n	8004d80 <HAL_DMA_Start_IT+0x430>
 8004d30:	68fb      	ldr	r3, [r7, #12]
 8004d32:	681b      	ldr	r3, [r3, #0]
 8004d34:	4a2b      	ldr	r2, [pc, #172]	@ (8004de4 <HAL_DMA_Start_IT+0x494>)
 8004d36:	4293      	cmp	r3, r2
 8004d38:	d022      	beq.n	8004d80 <HAL_DMA_Start_IT+0x430>
 8004d3a:	68fb      	ldr	r3, [r7, #12]
 8004d3c:	681b      	ldr	r3, [r3, #0]
 8004d3e:	4a2a      	ldr	r2, [pc, #168]	@ (8004de8 <HAL_DMA_Start_IT+0x498>)
 8004d40:	4293      	cmp	r3, r2
 8004d42:	d01d      	beq.n	8004d80 <HAL_DMA_Start_IT+0x430>
 8004d44:	68fb      	ldr	r3, [r7, #12]
 8004d46:	681b      	ldr	r3, [r3, #0]
 8004d48:	4a28      	ldr	r2, [pc, #160]	@ (8004dec <HAL_DMA_Start_IT+0x49c>)
 8004d4a:	4293      	cmp	r3, r2
 8004d4c:	d018      	beq.n	8004d80 <HAL_DMA_Start_IT+0x430>
 8004d4e:	68fb      	ldr	r3, [r7, #12]
 8004d50:	681b      	ldr	r3, [r3, #0]
 8004d52:	4a27      	ldr	r2, [pc, #156]	@ (8004df0 <HAL_DMA_Start_IT+0x4a0>)
 8004d54:	4293      	cmp	r3, r2
 8004d56:	d013      	beq.n	8004d80 <HAL_DMA_Start_IT+0x430>
 8004d58:	68fb      	ldr	r3, [r7, #12]
 8004d5a:	681b      	ldr	r3, [r3, #0]
 8004d5c:	4a25      	ldr	r2, [pc, #148]	@ (8004df4 <HAL_DMA_Start_IT+0x4a4>)
 8004d5e:	4293      	cmp	r3, r2
 8004d60:	d00e      	beq.n	8004d80 <HAL_DMA_Start_IT+0x430>
 8004d62:	68fb      	ldr	r3, [r7, #12]
 8004d64:	681b      	ldr	r3, [r3, #0]
 8004d66:	4a24      	ldr	r2, [pc, #144]	@ (8004df8 <HAL_DMA_Start_IT+0x4a8>)
 8004d68:	4293      	cmp	r3, r2
 8004d6a:	d009      	beq.n	8004d80 <HAL_DMA_Start_IT+0x430>
 8004d6c:	68fb      	ldr	r3, [r7, #12]
 8004d6e:	681b      	ldr	r3, [r3, #0]
 8004d70:	4a22      	ldr	r2, [pc, #136]	@ (8004dfc <HAL_DMA_Start_IT+0x4ac>)
 8004d72:	4293      	cmp	r3, r2
 8004d74:	d004      	beq.n	8004d80 <HAL_DMA_Start_IT+0x430>
 8004d76:	68fb      	ldr	r3, [r7, #12]
 8004d78:	681b      	ldr	r3, [r3, #0]
 8004d7a:	4a21      	ldr	r2, [pc, #132]	@ (8004e00 <HAL_DMA_Start_IT+0x4b0>)
 8004d7c:	4293      	cmp	r3, r2
 8004d7e:	d108      	bne.n	8004d92 <HAL_DMA_Start_IT+0x442>
 8004d80:	68fb      	ldr	r3, [r7, #12]
 8004d82:	681b      	ldr	r3, [r3, #0]
 8004d84:	681a      	ldr	r2, [r3, #0]
 8004d86:	68fb      	ldr	r3, [r7, #12]
 8004d88:	681b      	ldr	r3, [r3, #0]
 8004d8a:	f042 0201 	orr.w	r2, r2, #1
 8004d8e:	601a      	str	r2, [r3, #0]
 8004d90:	e012      	b.n	8004db8 <HAL_DMA_Start_IT+0x468>
 8004d92:	68fb      	ldr	r3, [r7, #12]
 8004d94:	681b      	ldr	r3, [r3, #0]
 8004d96:	681a      	ldr	r2, [r3, #0]
 8004d98:	68fb      	ldr	r3, [r7, #12]
 8004d9a:	681b      	ldr	r3, [r3, #0]
 8004d9c:	f042 0201 	orr.w	r2, r2, #1
 8004da0:	601a      	str	r2, [r3, #0]
 8004da2:	e009      	b.n	8004db8 <HAL_DMA_Start_IT+0x468>
  }
  else
  {
    /* Set the error code to busy */
    hdma->ErrorCode = HAL_DMA_ERROR_BUSY;
 8004da4:	68fb      	ldr	r3, [r7, #12]
 8004da6:	f44f 6200 	mov.w	r2, #2048	@ 0x800
 8004daa:	655a      	str	r2, [r3, #84]	@ 0x54

    /* Process unlocked */
    __HAL_UNLOCK(hdma);
 8004dac:	68fb      	ldr	r3, [r7, #12]
 8004dae:	2200      	movs	r2, #0
 8004db0:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34

    /* Return error status */
    status = HAL_ERROR;
 8004db4:	2301      	movs	r3, #1
 8004db6:	75fb      	strb	r3, [r7, #23]
  }

  return status;
 8004db8:	7dfb      	ldrb	r3, [r7, #23]
}
 8004dba:	4618      	mov	r0, r3
 8004dbc:	3718      	adds	r7, #24
 8004dbe:	46bd      	mov	sp, r7
 8004dc0:	bd80      	pop	{r7, pc}
 8004dc2:	bf00      	nop
 8004dc4:	40020010 	.word	0x40020010
 8004dc8:	40020028 	.word	0x40020028
 8004dcc:	40020040 	.word	0x40020040
 8004dd0:	40020058 	.word	0x40020058
 8004dd4:	40020070 	.word	0x40020070
 8004dd8:	40020088 	.word	0x40020088
 8004ddc:	400200a0 	.word	0x400200a0
 8004de0:	400200b8 	.word	0x400200b8
 8004de4:	40020410 	.word	0x40020410
 8004de8:	40020428 	.word	0x40020428
 8004dec:	40020440 	.word	0x40020440
 8004df0:	40020458 	.word	0x40020458
 8004df4:	40020470 	.word	0x40020470
 8004df8:	40020488 	.word	0x40020488
 8004dfc:	400204a0 	.word	0x400204a0
 8004e00:	400204b8 	.word	0x400204b8
 8004e04:	58025408 	.word	0x58025408
 8004e08:	5802541c 	.word	0x5802541c
 8004e0c:	58025430 	.word	0x58025430
 8004e10:	58025444 	.word	0x58025444
 8004e14:	58025458 	.word	0x58025458
 8004e18:	5802546c 	.word	0x5802546c
 8004e1c:	58025480 	.word	0x58025480
 8004e20:	58025494 	.word	0x58025494

08004e24 <HAL_DMA_IRQHandler>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.
  * @retval None
  */
void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
{
 8004e24:	b580      	push	{r7, lr}
 8004e26:	b08a      	sub	sp, #40	@ 0x28
 8004e28:	af00      	add	r7, sp, #0
 8004e2a:	6078      	str	r0, [r7, #4]
  uint32_t tmpisr_dma, tmpisr_bdma;
  uint32_t ccr_reg;
  __IO uint32_t count = 0U;
 8004e2c:	2300      	movs	r3, #0
 8004e2e:	60fb      	str	r3, [r7, #12]
  uint32_t timeout = SystemCoreClock / 9600U;
 8004e30:	4b67      	ldr	r3, [pc, #412]	@ (8004fd0 <HAL_DMA_IRQHandler+0x1ac>)
 8004e32:	681b      	ldr	r3, [r3, #0]
 8004e34:	4a67      	ldr	r2, [pc, #412]	@ (8004fd4 <HAL_DMA_IRQHandler+0x1b0>)
 8004e36:	fba2 2303 	umull	r2, r3, r2, r3
 8004e3a:	0a9b      	lsrs	r3, r3, #10
 8004e3c:	627b      	str	r3, [r7, #36]	@ 0x24

  /* calculate DMA base and stream number */
  DMA_Base_Registers  *regs_dma  = (DMA_Base_Registers *)hdma->StreamBaseAddress;
 8004e3e:	687b      	ldr	r3, [r7, #4]
 8004e40:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8004e42:	623b      	str	r3, [r7, #32]
  BDMA_Base_Registers *regs_bdma = (BDMA_Base_Registers *)hdma->StreamBaseAddress;
 8004e44:	687b      	ldr	r3, [r7, #4]
 8004e46:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8004e48:	61fb      	str	r3, [r7, #28]

  tmpisr_dma  = regs_dma->ISR;
 8004e4a:	6a3b      	ldr	r3, [r7, #32]
 8004e4c:	681b      	ldr	r3, [r3, #0]
 8004e4e:	61bb      	str	r3, [r7, #24]
  tmpisr_bdma = regs_bdma->ISR;
 8004e50:	69fb      	ldr	r3, [r7, #28]
 8004e52:	681b      	ldr	r3, [r3, #0]
 8004e54:	617b      	str	r3, [r7, #20]

  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U)  /* DMA1 or DMA2 instance */
 8004e56:	687b      	ldr	r3, [r7, #4]
 8004e58:	681b      	ldr	r3, [r3, #0]
 8004e5a:	4a5f      	ldr	r2, [pc, #380]	@ (8004fd8 <HAL_DMA_IRQHandler+0x1b4>)
 8004e5c:	4293      	cmp	r3, r2
 8004e5e:	d04a      	beq.n	8004ef6 <HAL_DMA_IRQHandler+0xd2>
 8004e60:	687b      	ldr	r3, [r7, #4]
 8004e62:	681b      	ldr	r3, [r3, #0]
 8004e64:	4a5d      	ldr	r2, [pc, #372]	@ (8004fdc <HAL_DMA_IRQHandler+0x1b8>)
 8004e66:	4293      	cmp	r3, r2
 8004e68:	d045      	beq.n	8004ef6 <HAL_DMA_IRQHandler+0xd2>
 8004e6a:	687b      	ldr	r3, [r7, #4]
 8004e6c:	681b      	ldr	r3, [r3, #0]
 8004e6e:	4a5c      	ldr	r2, [pc, #368]	@ (8004fe0 <HAL_DMA_IRQHandler+0x1bc>)
 8004e70:	4293      	cmp	r3, r2
 8004e72:	d040      	beq.n	8004ef6 <HAL_DMA_IRQHandler+0xd2>
 8004e74:	687b      	ldr	r3, [r7, #4]
 8004e76:	681b      	ldr	r3, [r3, #0]
 8004e78:	4a5a      	ldr	r2, [pc, #360]	@ (8004fe4 <HAL_DMA_IRQHandler+0x1c0>)
 8004e7a:	4293      	cmp	r3, r2
 8004e7c:	d03b      	beq.n	8004ef6 <HAL_DMA_IRQHandler+0xd2>
 8004e7e:	687b      	ldr	r3, [r7, #4]
 8004e80:	681b      	ldr	r3, [r3, #0]
 8004e82:	4a59      	ldr	r2, [pc, #356]	@ (8004fe8 <HAL_DMA_IRQHandler+0x1c4>)
 8004e84:	4293      	cmp	r3, r2
 8004e86:	d036      	beq.n	8004ef6 <HAL_DMA_IRQHandler+0xd2>
 8004e88:	687b      	ldr	r3, [r7, #4]
 8004e8a:	681b      	ldr	r3, [r3, #0]
 8004e8c:	4a57      	ldr	r2, [pc, #348]	@ (8004fec <HAL_DMA_IRQHandler+0x1c8>)
 8004e8e:	4293      	cmp	r3, r2
 8004e90:	d031      	beq.n	8004ef6 <HAL_DMA_IRQHandler+0xd2>
 8004e92:	687b      	ldr	r3, [r7, #4]
 8004e94:	681b      	ldr	r3, [r3, #0]
 8004e96:	4a56      	ldr	r2, [pc, #344]	@ (8004ff0 <HAL_DMA_IRQHandler+0x1cc>)
 8004e98:	4293      	cmp	r3, r2
 8004e9a:	d02c      	beq.n	8004ef6 <HAL_DMA_IRQHandler+0xd2>
 8004e9c:	687b      	ldr	r3, [r7, #4]
 8004e9e:	681b      	ldr	r3, [r3, #0]
 8004ea0:	4a54      	ldr	r2, [pc, #336]	@ (8004ff4 <HAL_DMA_IRQHandler+0x1d0>)
 8004ea2:	4293      	cmp	r3, r2
 8004ea4:	d027      	beq.n	8004ef6 <HAL_DMA_IRQHandler+0xd2>
 8004ea6:	687b      	ldr	r3, [r7, #4]
 8004ea8:	681b      	ldr	r3, [r3, #0]
 8004eaa:	4a53      	ldr	r2, [pc, #332]	@ (8004ff8 <HAL_DMA_IRQHandler+0x1d4>)
 8004eac:	4293      	cmp	r3, r2
 8004eae:	d022      	beq.n	8004ef6 <HAL_DMA_IRQHandler+0xd2>
 8004eb0:	687b      	ldr	r3, [r7, #4]
 8004eb2:	681b      	ldr	r3, [r3, #0]
 8004eb4:	4a51      	ldr	r2, [pc, #324]	@ (8004ffc <HAL_DMA_IRQHandler+0x1d8>)
 8004eb6:	4293      	cmp	r3, r2
 8004eb8:	d01d      	beq.n	8004ef6 <HAL_DMA_IRQHandler+0xd2>
 8004eba:	687b      	ldr	r3, [r7, #4]
 8004ebc:	681b      	ldr	r3, [r3, #0]
 8004ebe:	4a50      	ldr	r2, [pc, #320]	@ (8005000 <HAL_DMA_IRQHandler+0x1dc>)
 8004ec0:	4293      	cmp	r3, r2
 8004ec2:	d018      	beq.n	8004ef6 <HAL_DMA_IRQHandler+0xd2>
 8004ec4:	687b      	ldr	r3, [r7, #4]
 8004ec6:	681b      	ldr	r3, [r3, #0]
 8004ec8:	4a4e      	ldr	r2, [pc, #312]	@ (8005004 <HAL_DMA_IRQHandler+0x1e0>)
 8004eca:	4293      	cmp	r3, r2
 8004ecc:	d013      	beq.n	8004ef6 <HAL_DMA_IRQHandler+0xd2>
 8004ece:	687b      	ldr	r3, [r7, #4]
 8004ed0:	681b      	ldr	r3, [r3, #0]
 8004ed2:	4a4d      	ldr	r2, [pc, #308]	@ (8005008 <HAL_DMA_IRQHandler+0x1e4>)
 8004ed4:	4293      	cmp	r3, r2
 8004ed6:	d00e      	beq.n	8004ef6 <HAL_DMA_IRQHandler+0xd2>
 8004ed8:	687b      	ldr	r3, [r7, #4]
 8004eda:	681b      	ldr	r3, [r3, #0]
 8004edc:	4a4b      	ldr	r2, [pc, #300]	@ (800500c <HAL_DMA_IRQHandler+0x1e8>)
 8004ede:	4293      	cmp	r3, r2
 8004ee0:	d009      	beq.n	8004ef6 <HAL_DMA_IRQHandler+0xd2>
 8004ee2:	687b      	ldr	r3, [r7, #4]
 8004ee4:	681b      	ldr	r3, [r3, #0]
 8004ee6:	4a4a      	ldr	r2, [pc, #296]	@ (8005010 <HAL_DMA_IRQHandler+0x1ec>)
 8004ee8:	4293      	cmp	r3, r2
 8004eea:	d004      	beq.n	8004ef6 <HAL_DMA_IRQHandler+0xd2>
 8004eec:	687b      	ldr	r3, [r7, #4]
 8004eee:	681b      	ldr	r3, [r3, #0]
 8004ef0:	4a48      	ldr	r2, [pc, #288]	@ (8005014 <HAL_DMA_IRQHandler+0x1f0>)
 8004ef2:	4293      	cmp	r3, r2
 8004ef4:	d101      	bne.n	8004efa <HAL_DMA_IRQHandler+0xd6>
 8004ef6:	2301      	movs	r3, #1
 8004ef8:	e000      	b.n	8004efc <HAL_DMA_IRQHandler+0xd8>
 8004efa:	2300      	movs	r3, #0
 8004efc:	2b00      	cmp	r3, #0
 8004efe:	f000 842b 	beq.w	8005758 <HAL_DMA_IRQHandler+0x934>
  {
    /* Transfer Error Interrupt management ***************************************/
    if ((tmpisr_dma & (DMA_FLAG_TEIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
 8004f02:	687b      	ldr	r3, [r7, #4]
 8004f04:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 8004f06:	f003 031f 	and.w	r3, r3, #31
 8004f0a:	2208      	movs	r2, #8
 8004f0c:	409a      	lsls	r2, r3
 8004f0e:	69bb      	ldr	r3, [r7, #24]
 8004f10:	4013      	ands	r3, r2
 8004f12:	2b00      	cmp	r3, #0
 8004f14:	f000 80a2 	beq.w	800505c <HAL_DMA_IRQHandler+0x238>
    {
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != 0U)
 8004f18:	687b      	ldr	r3, [r7, #4]
 8004f1a:	681b      	ldr	r3, [r3, #0]
 8004f1c:	4a2e      	ldr	r2, [pc, #184]	@ (8004fd8 <HAL_DMA_IRQHandler+0x1b4>)
 8004f1e:	4293      	cmp	r3, r2
 8004f20:	d04a      	beq.n	8004fb8 <HAL_DMA_IRQHandler+0x194>
 8004f22:	687b      	ldr	r3, [r7, #4]
 8004f24:	681b      	ldr	r3, [r3, #0]
 8004f26:	4a2d      	ldr	r2, [pc, #180]	@ (8004fdc <HAL_DMA_IRQHandler+0x1b8>)
 8004f28:	4293      	cmp	r3, r2
 8004f2a:	d045      	beq.n	8004fb8 <HAL_DMA_IRQHandler+0x194>
 8004f2c:	687b      	ldr	r3, [r7, #4]
 8004f2e:	681b      	ldr	r3, [r3, #0]
 8004f30:	4a2b      	ldr	r2, [pc, #172]	@ (8004fe0 <HAL_DMA_IRQHandler+0x1bc>)
 8004f32:	4293      	cmp	r3, r2
 8004f34:	d040      	beq.n	8004fb8 <HAL_DMA_IRQHandler+0x194>
 8004f36:	687b      	ldr	r3, [r7, #4]
 8004f38:	681b      	ldr	r3, [r3, #0]
 8004f3a:	4a2a      	ldr	r2, [pc, #168]	@ (8004fe4 <HAL_DMA_IRQHandler+0x1c0>)
 8004f3c:	4293      	cmp	r3, r2
 8004f3e:	d03b      	beq.n	8004fb8 <HAL_DMA_IRQHandler+0x194>
 8004f40:	687b      	ldr	r3, [r7, #4]
 8004f42:	681b      	ldr	r3, [r3, #0]
 8004f44:	4a28      	ldr	r2, [pc, #160]	@ (8004fe8 <HAL_DMA_IRQHandler+0x1c4>)
 8004f46:	4293      	cmp	r3, r2
 8004f48:	d036      	beq.n	8004fb8 <HAL_DMA_IRQHandler+0x194>
 8004f4a:	687b      	ldr	r3, [r7, #4]
 8004f4c:	681b      	ldr	r3, [r3, #0]
 8004f4e:	4a27      	ldr	r2, [pc, #156]	@ (8004fec <HAL_DMA_IRQHandler+0x1c8>)
 8004f50:	4293      	cmp	r3, r2
 8004f52:	d031      	beq.n	8004fb8 <HAL_DMA_IRQHandler+0x194>
 8004f54:	687b      	ldr	r3, [r7, #4]
 8004f56:	681b      	ldr	r3, [r3, #0]
 8004f58:	4a25      	ldr	r2, [pc, #148]	@ (8004ff0 <HAL_DMA_IRQHandler+0x1cc>)
 8004f5a:	4293      	cmp	r3, r2
 8004f5c:	d02c      	beq.n	8004fb8 <HAL_DMA_IRQHandler+0x194>
 8004f5e:	687b      	ldr	r3, [r7, #4]
 8004f60:	681b      	ldr	r3, [r3, #0]
 8004f62:	4a24      	ldr	r2, [pc, #144]	@ (8004ff4 <HAL_DMA_IRQHandler+0x1d0>)
 8004f64:	4293      	cmp	r3, r2
 8004f66:	d027      	beq.n	8004fb8 <HAL_DMA_IRQHandler+0x194>
 8004f68:	687b      	ldr	r3, [r7, #4]
 8004f6a:	681b      	ldr	r3, [r3, #0]
 8004f6c:	4a22      	ldr	r2, [pc, #136]	@ (8004ff8 <HAL_DMA_IRQHandler+0x1d4>)
 8004f6e:	4293      	cmp	r3, r2
 8004f70:	d022      	beq.n	8004fb8 <HAL_DMA_IRQHandler+0x194>
 8004f72:	687b      	ldr	r3, [r7, #4]
 8004f74:	681b      	ldr	r3, [r3, #0]
 8004f76:	4a21      	ldr	r2, [pc, #132]	@ (8004ffc <HAL_DMA_IRQHandler+0x1d8>)
 8004f78:	4293      	cmp	r3, r2
 8004f7a:	d01d      	beq.n	8004fb8 <HAL_DMA_IRQHandler+0x194>
 8004f7c:	687b      	ldr	r3, [r7, #4]
 8004f7e:	681b      	ldr	r3, [r3, #0]
 8004f80:	4a1f      	ldr	r2, [pc, #124]	@ (8005000 <HAL_DMA_IRQHandler+0x1dc>)
 8004f82:	4293      	cmp	r3, r2
 8004f84:	d018      	beq.n	8004fb8 <HAL_DMA_IRQHandler+0x194>
 8004f86:	687b      	ldr	r3, [r7, #4]
 8004f88:	681b      	ldr	r3, [r3, #0]
 8004f8a:	4a1e      	ldr	r2, [pc, #120]	@ (8005004 <HAL_DMA_IRQHandler+0x1e0>)
 8004f8c:	4293      	cmp	r3, r2
 8004f8e:	d013      	beq.n	8004fb8 <HAL_DMA_IRQHandler+0x194>
 8004f90:	687b      	ldr	r3, [r7, #4]
 8004f92:	681b      	ldr	r3, [r3, #0]
 8004f94:	4a1c      	ldr	r2, [pc, #112]	@ (8005008 <HAL_DMA_IRQHandler+0x1e4>)
 8004f96:	4293      	cmp	r3, r2
 8004f98:	d00e      	beq.n	8004fb8 <HAL_DMA_IRQHandler+0x194>
 8004f9a:	687b      	ldr	r3, [r7, #4]
 8004f9c:	681b      	ldr	r3, [r3, #0]
 8004f9e:	4a1b      	ldr	r2, [pc, #108]	@ (800500c <HAL_DMA_IRQHandler+0x1e8>)
 8004fa0:	4293      	cmp	r3, r2
 8004fa2:	d009      	beq.n	8004fb8 <HAL_DMA_IRQHandler+0x194>
 8004fa4:	687b      	ldr	r3, [r7, #4]
 8004fa6:	681b      	ldr	r3, [r3, #0]
 8004fa8:	4a19      	ldr	r2, [pc, #100]	@ (8005010 <HAL_DMA_IRQHandler+0x1ec>)
 8004faa:	4293      	cmp	r3, r2
 8004fac:	d004      	beq.n	8004fb8 <HAL_DMA_IRQHandler+0x194>
 8004fae:	687b      	ldr	r3, [r7, #4]
 8004fb0:	681b      	ldr	r3, [r3, #0]
 8004fb2:	4a18      	ldr	r2, [pc, #96]	@ (8005014 <HAL_DMA_IRQHandler+0x1f0>)
 8004fb4:	4293      	cmp	r3, r2
 8004fb6:	d12f      	bne.n	8005018 <HAL_DMA_IRQHandler+0x1f4>
 8004fb8:	687b      	ldr	r3, [r7, #4]
 8004fba:	681b      	ldr	r3, [r3, #0]
 8004fbc:	681b      	ldr	r3, [r3, #0]
 8004fbe:	f003 0304 	and.w	r3, r3, #4
 8004fc2:	2b00      	cmp	r3, #0
 8004fc4:	bf14      	ite	ne
 8004fc6:	2301      	movne	r3, #1
 8004fc8:	2300      	moveq	r3, #0
 8004fca:	b2db      	uxtb	r3, r3
 8004fcc:	e02e      	b.n	800502c <HAL_DMA_IRQHandler+0x208>
 8004fce:	bf00      	nop
 8004fd0:	2400011c 	.word	0x2400011c
 8004fd4:	1b4e81b5 	.word	0x1b4e81b5
 8004fd8:	40020010 	.word	0x40020010
 8004fdc:	40020028 	.word	0x40020028
 8004fe0:	40020040 	.word	0x40020040
 8004fe4:	40020058 	.word	0x40020058
 8004fe8:	40020070 	.word	0x40020070
 8004fec:	40020088 	.word	0x40020088
 8004ff0:	400200a0 	.word	0x400200a0
 8004ff4:	400200b8 	.word	0x400200b8
 8004ff8:	40020410 	.word	0x40020410
 8004ffc:	40020428 	.word	0x40020428
 8005000:	40020440 	.word	0x40020440
 8005004:	40020458 	.word	0x40020458
 8005008:	40020470 	.word	0x40020470
 800500c:	40020488 	.word	0x40020488
 8005010:	400204a0 	.word	0x400204a0
 8005014:	400204b8 	.word	0x400204b8
 8005018:	687b      	ldr	r3, [r7, #4]
 800501a:	681b      	ldr	r3, [r3, #0]
 800501c:	681b      	ldr	r3, [r3, #0]
 800501e:	f003 0308 	and.w	r3, r3, #8
 8005022:	2b00      	cmp	r3, #0
 8005024:	bf14      	ite	ne
 8005026:	2301      	movne	r3, #1
 8005028:	2300      	moveq	r3, #0
 800502a:	b2db      	uxtb	r3, r3
 800502c:	2b00      	cmp	r3, #0
 800502e:	d015      	beq.n	800505c <HAL_DMA_IRQHandler+0x238>
      {
        /* Disable the transfer error interrupt */
        ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_TE);
 8005030:	687b      	ldr	r3, [r7, #4]
 8005032:	681b      	ldr	r3, [r3, #0]
 8005034:	681a      	ldr	r2, [r3, #0]
 8005036:	687b      	ldr	r3, [r7, #4]
 8005038:	681b      	ldr	r3, [r3, #0]
 800503a:	f022 0204 	bic.w	r2, r2, #4
 800503e:	601a      	str	r2, [r3, #0]

        /* Clear the transfer error flag */
        regs_dma->IFCR = DMA_FLAG_TEIF0_4 << (hdma->StreamIndex & 0x1FU);
 8005040:	687b      	ldr	r3, [r7, #4]
 8005042:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 8005044:	f003 031f 	and.w	r3, r3, #31
 8005048:	2208      	movs	r2, #8
 800504a:	409a      	lsls	r2, r3
 800504c:	6a3b      	ldr	r3, [r7, #32]
 800504e:	609a      	str	r2, [r3, #8]

        /* Update error code */
        hdma->ErrorCode |= HAL_DMA_ERROR_TE;
 8005050:	687b      	ldr	r3, [r7, #4]
 8005052:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8005054:	f043 0201 	orr.w	r2, r3, #1
 8005058:	687b      	ldr	r3, [r7, #4]
 800505a:	655a      	str	r2, [r3, #84]	@ 0x54
      }
    }
    /* FIFO Error Interrupt management ******************************************/
    if ((tmpisr_dma & (DMA_FLAG_FEIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
 800505c:	687b      	ldr	r3, [r7, #4]
 800505e:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 8005060:	f003 031f 	and.w	r3, r3, #31
 8005064:	69ba      	ldr	r2, [r7, #24]
 8005066:	fa22 f303 	lsr.w	r3, r2, r3
 800506a:	f003 0301 	and.w	r3, r3, #1
 800506e:	2b00      	cmp	r3, #0
 8005070:	d06e      	beq.n	8005150 <HAL_DMA_IRQHandler+0x32c>
    {
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_FE) != 0U)
 8005072:	687b      	ldr	r3, [r7, #4]
 8005074:	681b      	ldr	r3, [r3, #0]
 8005076:	4a69      	ldr	r2, [pc, #420]	@ (800521c <HAL_DMA_IRQHandler+0x3f8>)
 8005078:	4293      	cmp	r3, r2
 800507a:	d04a      	beq.n	8005112 <HAL_DMA_IRQHandler+0x2ee>
 800507c:	687b      	ldr	r3, [r7, #4]
 800507e:	681b      	ldr	r3, [r3, #0]
 8005080:	4a67      	ldr	r2, [pc, #412]	@ (8005220 <HAL_DMA_IRQHandler+0x3fc>)
 8005082:	4293      	cmp	r3, r2
 8005084:	d045      	beq.n	8005112 <HAL_DMA_IRQHandler+0x2ee>
 8005086:	687b      	ldr	r3, [r7, #4]
 8005088:	681b      	ldr	r3, [r3, #0]
 800508a:	4a66      	ldr	r2, [pc, #408]	@ (8005224 <HAL_DMA_IRQHandler+0x400>)
 800508c:	4293      	cmp	r3, r2
 800508e:	d040      	beq.n	8005112 <HAL_DMA_IRQHandler+0x2ee>
 8005090:	687b      	ldr	r3, [r7, #4]
 8005092:	681b      	ldr	r3, [r3, #0]
 8005094:	4a64      	ldr	r2, [pc, #400]	@ (8005228 <HAL_DMA_IRQHandler+0x404>)
 8005096:	4293      	cmp	r3, r2
 8005098:	d03b      	beq.n	8005112 <HAL_DMA_IRQHandler+0x2ee>
 800509a:	687b      	ldr	r3, [r7, #4]
 800509c:	681b      	ldr	r3, [r3, #0]
 800509e:	4a63      	ldr	r2, [pc, #396]	@ (800522c <HAL_DMA_IRQHandler+0x408>)
 80050a0:	4293      	cmp	r3, r2
 80050a2:	d036      	beq.n	8005112 <HAL_DMA_IRQHandler+0x2ee>
 80050a4:	687b      	ldr	r3, [r7, #4]
 80050a6:	681b      	ldr	r3, [r3, #0]
 80050a8:	4a61      	ldr	r2, [pc, #388]	@ (8005230 <HAL_DMA_IRQHandler+0x40c>)
 80050aa:	4293      	cmp	r3, r2
 80050ac:	d031      	beq.n	8005112 <HAL_DMA_IRQHandler+0x2ee>
 80050ae:	687b      	ldr	r3, [r7, #4]
 80050b0:	681b      	ldr	r3, [r3, #0]
 80050b2:	4a60      	ldr	r2, [pc, #384]	@ (8005234 <HAL_DMA_IRQHandler+0x410>)
 80050b4:	4293      	cmp	r3, r2
 80050b6:	d02c      	beq.n	8005112 <HAL_DMA_IRQHandler+0x2ee>
 80050b8:	687b      	ldr	r3, [r7, #4]
 80050ba:	681b      	ldr	r3, [r3, #0]
 80050bc:	4a5e      	ldr	r2, [pc, #376]	@ (8005238 <HAL_DMA_IRQHandler+0x414>)
 80050be:	4293      	cmp	r3, r2
 80050c0:	d027      	beq.n	8005112 <HAL_DMA_IRQHandler+0x2ee>
 80050c2:	687b      	ldr	r3, [r7, #4]
 80050c4:	681b      	ldr	r3, [r3, #0]
 80050c6:	4a5d      	ldr	r2, [pc, #372]	@ (800523c <HAL_DMA_IRQHandler+0x418>)
 80050c8:	4293      	cmp	r3, r2
 80050ca:	d022      	beq.n	8005112 <HAL_DMA_IRQHandler+0x2ee>
 80050cc:	687b      	ldr	r3, [r7, #4]
 80050ce:	681b      	ldr	r3, [r3, #0]
 80050d0:	4a5b      	ldr	r2, [pc, #364]	@ (8005240 <HAL_DMA_IRQHandler+0x41c>)
 80050d2:	4293      	cmp	r3, r2
 80050d4:	d01d      	beq.n	8005112 <HAL_DMA_IRQHandler+0x2ee>
 80050d6:	687b      	ldr	r3, [r7, #4]
 80050d8:	681b      	ldr	r3, [r3, #0]
 80050da:	4a5a      	ldr	r2, [pc, #360]	@ (8005244 <HAL_DMA_IRQHandler+0x420>)
 80050dc:	4293      	cmp	r3, r2
 80050de:	d018      	beq.n	8005112 <HAL_DMA_IRQHandler+0x2ee>
 80050e0:	687b      	ldr	r3, [r7, #4]
 80050e2:	681b      	ldr	r3, [r3, #0]
 80050e4:	4a58      	ldr	r2, [pc, #352]	@ (8005248 <HAL_DMA_IRQHandler+0x424>)
 80050e6:	4293      	cmp	r3, r2
 80050e8:	d013      	beq.n	8005112 <HAL_DMA_IRQHandler+0x2ee>
 80050ea:	687b      	ldr	r3, [r7, #4]
 80050ec:	681b      	ldr	r3, [r3, #0]
 80050ee:	4a57      	ldr	r2, [pc, #348]	@ (800524c <HAL_DMA_IRQHandler+0x428>)
 80050f0:	4293      	cmp	r3, r2
 80050f2:	d00e      	beq.n	8005112 <HAL_DMA_IRQHandler+0x2ee>
 80050f4:	687b      	ldr	r3, [r7, #4]
 80050f6:	681b      	ldr	r3, [r3, #0]
 80050f8:	4a55      	ldr	r2, [pc, #340]	@ (8005250 <HAL_DMA_IRQHandler+0x42c>)
 80050fa:	4293      	cmp	r3, r2
 80050fc:	d009      	beq.n	8005112 <HAL_DMA_IRQHandler+0x2ee>
 80050fe:	687b      	ldr	r3, [r7, #4]
 8005100:	681b      	ldr	r3, [r3, #0]
 8005102:	4a54      	ldr	r2, [pc, #336]	@ (8005254 <HAL_DMA_IRQHandler+0x430>)
 8005104:	4293      	cmp	r3, r2
 8005106:	d004      	beq.n	8005112 <HAL_DMA_IRQHandler+0x2ee>
 8005108:	687b      	ldr	r3, [r7, #4]
 800510a:	681b      	ldr	r3, [r3, #0]
 800510c:	4a52      	ldr	r2, [pc, #328]	@ (8005258 <HAL_DMA_IRQHandler+0x434>)
 800510e:	4293      	cmp	r3, r2
 8005110:	d10a      	bne.n	8005128 <HAL_DMA_IRQHandler+0x304>
 8005112:	687b      	ldr	r3, [r7, #4]
 8005114:	681b      	ldr	r3, [r3, #0]
 8005116:	695b      	ldr	r3, [r3, #20]
 8005118:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 800511c:	2b00      	cmp	r3, #0
 800511e:	bf14      	ite	ne
 8005120:	2301      	movne	r3, #1
 8005122:	2300      	moveq	r3, #0
 8005124:	b2db      	uxtb	r3, r3
 8005126:	e003      	b.n	8005130 <HAL_DMA_IRQHandler+0x30c>
 8005128:	687b      	ldr	r3, [r7, #4]
 800512a:	681b      	ldr	r3, [r3, #0]
 800512c:	681b      	ldr	r3, [r3, #0]
 800512e:	2300      	movs	r3, #0
 8005130:	2b00      	cmp	r3, #0
 8005132:	d00d      	beq.n	8005150 <HAL_DMA_IRQHandler+0x32c>
      {
        /* Clear the FIFO error flag */
        regs_dma->IFCR = DMA_FLAG_FEIF0_4 << (hdma->StreamIndex & 0x1FU);
 8005134:	687b      	ldr	r3, [r7, #4]
 8005136:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 8005138:	f003 031f 	and.w	r3, r3, #31
 800513c:	2201      	movs	r2, #1
 800513e:	409a      	lsls	r2, r3
 8005140:	6a3b      	ldr	r3, [r7, #32]
 8005142:	609a      	str	r2, [r3, #8]

        /* Update error code */
        hdma->ErrorCode |= HAL_DMA_ERROR_FE;
 8005144:	687b      	ldr	r3, [r7, #4]
 8005146:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8005148:	f043 0202 	orr.w	r2, r3, #2
 800514c:	687b      	ldr	r3, [r7, #4]
 800514e:	655a      	str	r2, [r3, #84]	@ 0x54
      }
    }
    /* Direct Mode Error Interrupt management ***********************************/
    if ((tmpisr_dma & (DMA_FLAG_DMEIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
 8005150:	687b      	ldr	r3, [r7, #4]
 8005152:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 8005154:	f003 031f 	and.w	r3, r3, #31
 8005158:	2204      	movs	r2, #4
 800515a:	409a      	lsls	r2, r3
 800515c:	69bb      	ldr	r3, [r7, #24]
 800515e:	4013      	ands	r3, r2
 8005160:	2b00      	cmp	r3, #0
 8005162:	f000 808f 	beq.w	8005284 <HAL_DMA_IRQHandler+0x460>
    {
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_DME) != 0U)
 8005166:	687b      	ldr	r3, [r7, #4]
 8005168:	681b      	ldr	r3, [r3, #0]
 800516a:	4a2c      	ldr	r2, [pc, #176]	@ (800521c <HAL_DMA_IRQHandler+0x3f8>)
 800516c:	4293      	cmp	r3, r2
 800516e:	d04a      	beq.n	8005206 <HAL_DMA_IRQHandler+0x3e2>
 8005170:	687b      	ldr	r3, [r7, #4]
 8005172:	681b      	ldr	r3, [r3, #0]
 8005174:	4a2a      	ldr	r2, [pc, #168]	@ (8005220 <HAL_DMA_IRQHandler+0x3fc>)
 8005176:	4293      	cmp	r3, r2
 8005178:	d045      	beq.n	8005206 <HAL_DMA_IRQHandler+0x3e2>
 800517a:	687b      	ldr	r3, [r7, #4]
 800517c:	681b      	ldr	r3, [r3, #0]
 800517e:	4a29      	ldr	r2, [pc, #164]	@ (8005224 <HAL_DMA_IRQHandler+0x400>)
 8005180:	4293      	cmp	r3, r2
 8005182:	d040      	beq.n	8005206 <HAL_DMA_IRQHandler+0x3e2>
 8005184:	687b      	ldr	r3, [r7, #4]
 8005186:	681b      	ldr	r3, [r3, #0]
 8005188:	4a27      	ldr	r2, [pc, #156]	@ (8005228 <HAL_DMA_IRQHandler+0x404>)
 800518a:	4293      	cmp	r3, r2
 800518c:	d03b      	beq.n	8005206 <HAL_DMA_IRQHandler+0x3e2>
 800518e:	687b      	ldr	r3, [r7, #4]
 8005190:	681b      	ldr	r3, [r3, #0]
 8005192:	4a26      	ldr	r2, [pc, #152]	@ (800522c <HAL_DMA_IRQHandler+0x408>)
 8005194:	4293      	cmp	r3, r2
 8005196:	d036      	beq.n	8005206 <HAL_DMA_IRQHandler+0x3e2>
 8005198:	687b      	ldr	r3, [r7, #4]
 800519a:	681b      	ldr	r3, [r3, #0]
 800519c:	4a24      	ldr	r2, [pc, #144]	@ (8005230 <HAL_DMA_IRQHandler+0x40c>)
 800519e:	4293      	cmp	r3, r2
 80051a0:	d031      	beq.n	8005206 <HAL_DMA_IRQHandler+0x3e2>
 80051a2:	687b      	ldr	r3, [r7, #4]
 80051a4:	681b      	ldr	r3, [r3, #0]
 80051a6:	4a23      	ldr	r2, [pc, #140]	@ (8005234 <HAL_DMA_IRQHandler+0x410>)
 80051a8:	4293      	cmp	r3, r2
 80051aa:	d02c      	beq.n	8005206 <HAL_DMA_IRQHandler+0x3e2>
 80051ac:	687b      	ldr	r3, [r7, #4]
 80051ae:	681b      	ldr	r3, [r3, #0]
 80051b0:	4a21      	ldr	r2, [pc, #132]	@ (8005238 <HAL_DMA_IRQHandler+0x414>)
 80051b2:	4293      	cmp	r3, r2
 80051b4:	d027      	beq.n	8005206 <HAL_DMA_IRQHandler+0x3e2>
 80051b6:	687b      	ldr	r3, [r7, #4]
 80051b8:	681b      	ldr	r3, [r3, #0]
 80051ba:	4a20      	ldr	r2, [pc, #128]	@ (800523c <HAL_DMA_IRQHandler+0x418>)
 80051bc:	4293      	cmp	r3, r2
 80051be:	d022      	beq.n	8005206 <HAL_DMA_IRQHandler+0x3e2>
 80051c0:	687b      	ldr	r3, [r7, #4]
 80051c2:	681b      	ldr	r3, [r3, #0]
 80051c4:	4a1e      	ldr	r2, [pc, #120]	@ (8005240 <HAL_DMA_IRQHandler+0x41c>)
 80051c6:	4293      	cmp	r3, r2
 80051c8:	d01d      	beq.n	8005206 <HAL_DMA_IRQHandler+0x3e2>
 80051ca:	687b      	ldr	r3, [r7, #4]
 80051cc:	681b      	ldr	r3, [r3, #0]
 80051ce:	4a1d      	ldr	r2, [pc, #116]	@ (8005244 <HAL_DMA_IRQHandler+0x420>)
 80051d0:	4293      	cmp	r3, r2
 80051d2:	d018      	beq.n	8005206 <HAL_DMA_IRQHandler+0x3e2>
 80051d4:	687b      	ldr	r3, [r7, #4]
 80051d6:	681b      	ldr	r3, [r3, #0]
 80051d8:	4a1b      	ldr	r2, [pc, #108]	@ (8005248 <HAL_DMA_IRQHandler+0x424>)
 80051da:	4293      	cmp	r3, r2
 80051dc:	d013      	beq.n	8005206 <HAL_DMA_IRQHandler+0x3e2>
 80051de:	687b      	ldr	r3, [r7, #4]
 80051e0:	681b      	ldr	r3, [r3, #0]
 80051e2:	4a1a      	ldr	r2, [pc, #104]	@ (800524c <HAL_DMA_IRQHandler+0x428>)
 80051e4:	4293      	cmp	r3, r2
 80051e6:	d00e      	beq.n	8005206 <HAL_DMA_IRQHandler+0x3e2>
 80051e8:	687b      	ldr	r3, [r7, #4]
 80051ea:	681b      	ldr	r3, [r3, #0]
 80051ec:	4a18      	ldr	r2, [pc, #96]	@ (8005250 <HAL_DMA_IRQHandler+0x42c>)
 80051ee:	4293      	cmp	r3, r2
 80051f0:	d009      	beq.n	8005206 <HAL_DMA_IRQHandler+0x3e2>
 80051f2:	687b      	ldr	r3, [r7, #4]
 80051f4:	681b      	ldr	r3, [r3, #0]
 80051f6:	4a17      	ldr	r2, [pc, #92]	@ (8005254 <HAL_DMA_IRQHandler+0x430>)
 80051f8:	4293      	cmp	r3, r2
 80051fa:	d004      	beq.n	8005206 <HAL_DMA_IRQHandler+0x3e2>
 80051fc:	687b      	ldr	r3, [r7, #4]
 80051fe:	681b      	ldr	r3, [r3, #0]
 8005200:	4a15      	ldr	r2, [pc, #84]	@ (8005258 <HAL_DMA_IRQHandler+0x434>)
 8005202:	4293      	cmp	r3, r2
 8005204:	d12a      	bne.n	800525c <HAL_DMA_IRQHandler+0x438>
 8005206:	687b      	ldr	r3, [r7, #4]
 8005208:	681b      	ldr	r3, [r3, #0]
 800520a:	681b      	ldr	r3, [r3, #0]
 800520c:	f003 0302 	and.w	r3, r3, #2
 8005210:	2b00      	cmp	r3, #0
 8005212:	bf14      	ite	ne
 8005214:	2301      	movne	r3, #1
 8005216:	2300      	moveq	r3, #0
 8005218:	b2db      	uxtb	r3, r3
 800521a:	e023      	b.n	8005264 <HAL_DMA_IRQHandler+0x440>
 800521c:	40020010 	.word	0x40020010
 8005220:	40020028 	.word	0x40020028
 8005224:	40020040 	.word	0x40020040
 8005228:	40020058 	.word	0x40020058
 800522c:	40020070 	.word	0x40020070
 8005230:	40020088 	.word	0x40020088
 8005234:	400200a0 	.word	0x400200a0
 8005238:	400200b8 	.word	0x400200b8
 800523c:	40020410 	.word	0x40020410
 8005240:	40020428 	.word	0x40020428
 8005244:	40020440 	.word	0x40020440
 8005248:	40020458 	.word	0x40020458
 800524c:	40020470 	.word	0x40020470
 8005250:	40020488 	.word	0x40020488
 8005254:	400204a0 	.word	0x400204a0
 8005258:	400204b8 	.word	0x400204b8
 800525c:	687b      	ldr	r3, [r7, #4]
 800525e:	681b      	ldr	r3, [r3, #0]
 8005260:	681b      	ldr	r3, [r3, #0]
 8005262:	2300      	movs	r3, #0
 8005264:	2b00      	cmp	r3, #0
 8005266:	d00d      	beq.n	8005284 <HAL_DMA_IRQHandler+0x460>
      {
        /* Clear the direct mode error flag */
        regs_dma->IFCR = DMA_FLAG_DMEIF0_4 << (hdma->StreamIndex & 0x1FU);
 8005268:	687b      	ldr	r3, [r7, #4]
 800526a:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 800526c:	f003 031f 	and.w	r3, r3, #31
 8005270:	2204      	movs	r2, #4
 8005272:	409a      	lsls	r2, r3
 8005274:	6a3b      	ldr	r3, [r7, #32]
 8005276:	609a      	str	r2, [r3, #8]

        /* Update error code */
        hdma->ErrorCode |= HAL_DMA_ERROR_DME;
 8005278:	687b      	ldr	r3, [r7, #4]
 800527a:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 800527c:	f043 0204 	orr.w	r2, r3, #4
 8005280:	687b      	ldr	r3, [r7, #4]
 8005282:	655a      	str	r2, [r3, #84]	@ 0x54
      }
    }
    /* Half Transfer Complete Interrupt management ******************************/
    if ((tmpisr_dma & (DMA_FLAG_HTIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
 8005284:	687b      	ldr	r3, [r7, #4]
 8005286:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 8005288:	f003 031f 	and.w	r3, r3, #31
 800528c:	2210      	movs	r2, #16
 800528e:	409a      	lsls	r2, r3
 8005290:	69bb      	ldr	r3, [r7, #24]
 8005292:	4013      	ands	r3, r2
 8005294:	2b00      	cmp	r3, #0
 8005296:	f000 80a6 	beq.w	80053e6 <HAL_DMA_IRQHandler+0x5c2>
    {
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != 0U)
 800529a:	687b      	ldr	r3, [r7, #4]
 800529c:	681b      	ldr	r3, [r3, #0]
 800529e:	4a85      	ldr	r2, [pc, #532]	@ (80054b4 <HAL_DMA_IRQHandler+0x690>)
 80052a0:	4293      	cmp	r3, r2
 80052a2:	d04a      	beq.n	800533a <HAL_DMA_IRQHandler+0x516>
 80052a4:	687b      	ldr	r3, [r7, #4]
 80052a6:	681b      	ldr	r3, [r3, #0]
 80052a8:	4a83      	ldr	r2, [pc, #524]	@ (80054b8 <HAL_DMA_IRQHandler+0x694>)
 80052aa:	4293      	cmp	r3, r2
 80052ac:	d045      	beq.n	800533a <HAL_DMA_IRQHandler+0x516>
 80052ae:	687b      	ldr	r3, [r7, #4]
 80052b0:	681b      	ldr	r3, [r3, #0]
 80052b2:	4a82      	ldr	r2, [pc, #520]	@ (80054bc <HAL_DMA_IRQHandler+0x698>)
 80052b4:	4293      	cmp	r3, r2
 80052b6:	d040      	beq.n	800533a <HAL_DMA_IRQHandler+0x516>
 80052b8:	687b      	ldr	r3, [r7, #4]
 80052ba:	681b      	ldr	r3, [r3, #0]
 80052bc:	4a80      	ldr	r2, [pc, #512]	@ (80054c0 <HAL_DMA_IRQHandler+0x69c>)
 80052be:	4293      	cmp	r3, r2
 80052c0:	d03b      	beq.n	800533a <HAL_DMA_IRQHandler+0x516>
 80052c2:	687b      	ldr	r3, [r7, #4]
 80052c4:	681b      	ldr	r3, [r3, #0]
 80052c6:	4a7f      	ldr	r2, [pc, #508]	@ (80054c4 <HAL_DMA_IRQHandler+0x6a0>)
 80052c8:	4293      	cmp	r3, r2
 80052ca:	d036      	beq.n	800533a <HAL_DMA_IRQHandler+0x516>
 80052cc:	687b      	ldr	r3, [r7, #4]
 80052ce:	681b      	ldr	r3, [r3, #0]
 80052d0:	4a7d      	ldr	r2, [pc, #500]	@ (80054c8 <HAL_DMA_IRQHandler+0x6a4>)
 80052d2:	4293      	cmp	r3, r2
 80052d4:	d031      	beq.n	800533a <HAL_DMA_IRQHandler+0x516>
 80052d6:	687b      	ldr	r3, [r7, #4]
 80052d8:	681b      	ldr	r3, [r3, #0]
 80052da:	4a7c      	ldr	r2, [pc, #496]	@ (80054cc <HAL_DMA_IRQHandler+0x6a8>)
 80052dc:	4293      	cmp	r3, r2
 80052de:	d02c      	beq.n	800533a <HAL_DMA_IRQHandler+0x516>
 80052e0:	687b      	ldr	r3, [r7, #4]
 80052e2:	681b      	ldr	r3, [r3, #0]
 80052e4:	4a7a      	ldr	r2, [pc, #488]	@ (80054d0 <HAL_DMA_IRQHandler+0x6ac>)
 80052e6:	4293      	cmp	r3, r2
 80052e8:	d027      	beq.n	800533a <HAL_DMA_IRQHandler+0x516>
 80052ea:	687b      	ldr	r3, [r7, #4]
 80052ec:	681b      	ldr	r3, [r3, #0]
 80052ee:	4a79      	ldr	r2, [pc, #484]	@ (80054d4 <HAL_DMA_IRQHandler+0x6b0>)
 80052f0:	4293      	cmp	r3, r2
 80052f2:	d022      	beq.n	800533a <HAL_DMA_IRQHandler+0x516>
 80052f4:	687b      	ldr	r3, [r7, #4]
 80052f6:	681b      	ldr	r3, [r3, #0]
 80052f8:	4a77      	ldr	r2, [pc, #476]	@ (80054d8 <HAL_DMA_IRQHandler+0x6b4>)
 80052fa:	4293      	cmp	r3, r2
 80052fc:	d01d      	beq.n	800533a <HAL_DMA_IRQHandler+0x516>
 80052fe:	687b      	ldr	r3, [r7, #4]
 8005300:	681b      	ldr	r3, [r3, #0]
 8005302:	4a76      	ldr	r2, [pc, #472]	@ (80054dc <HAL_DMA_IRQHandler+0x6b8>)
 8005304:	4293      	cmp	r3, r2
 8005306:	d018      	beq.n	800533a <HAL_DMA_IRQHandler+0x516>
 8005308:	687b      	ldr	r3, [r7, #4]
 800530a:	681b      	ldr	r3, [r3, #0]
 800530c:	4a74      	ldr	r2, [pc, #464]	@ (80054e0 <HAL_DMA_IRQHandler+0x6bc>)
 800530e:	4293      	cmp	r3, r2
 8005310:	d013      	beq.n	800533a <HAL_DMA_IRQHandler+0x516>
 8005312:	687b      	ldr	r3, [r7, #4]
 8005314:	681b      	ldr	r3, [r3, #0]
 8005316:	4a73      	ldr	r2, [pc, #460]	@ (80054e4 <HAL_DMA_IRQHandler+0x6c0>)
 8005318:	4293      	cmp	r3, r2
 800531a:	d00e      	beq.n	800533a <HAL_DMA_IRQHandler+0x516>
 800531c:	687b      	ldr	r3, [r7, #4]
 800531e:	681b      	ldr	r3, [r3, #0]
 8005320:	4a71      	ldr	r2, [pc, #452]	@ (80054e8 <HAL_DMA_IRQHandler+0x6c4>)
 8005322:	4293      	cmp	r3, r2
 8005324:	d009      	beq.n	800533a <HAL_DMA_IRQHandler+0x516>
 8005326:	687b      	ldr	r3, [r7, #4]
 8005328:	681b      	ldr	r3, [r3, #0]
 800532a:	4a70      	ldr	r2, [pc, #448]	@ (80054ec <HAL_DMA_IRQHandler+0x6c8>)
 800532c:	4293      	cmp	r3, r2
 800532e:	d004      	beq.n	800533a <HAL_DMA_IRQHandler+0x516>
 8005330:	687b      	ldr	r3, [r7, #4]
 8005332:	681b      	ldr	r3, [r3, #0]
 8005334:	4a6e      	ldr	r2, [pc, #440]	@ (80054f0 <HAL_DMA_IRQHandler+0x6cc>)
 8005336:	4293      	cmp	r3, r2
 8005338:	d10a      	bne.n	8005350 <HAL_DMA_IRQHandler+0x52c>
 800533a:	687b      	ldr	r3, [r7, #4]
 800533c:	681b      	ldr	r3, [r3, #0]
 800533e:	681b      	ldr	r3, [r3, #0]
 8005340:	f003 0308 	and.w	r3, r3, #8
 8005344:	2b00      	cmp	r3, #0
 8005346:	bf14      	ite	ne
 8005348:	2301      	movne	r3, #1
 800534a:	2300      	moveq	r3, #0
 800534c:	b2db      	uxtb	r3, r3
 800534e:	e009      	b.n	8005364 <HAL_DMA_IRQHandler+0x540>
 8005350:	687b      	ldr	r3, [r7, #4]
 8005352:	681b      	ldr	r3, [r3, #0]
 8005354:	681b      	ldr	r3, [r3, #0]
 8005356:	f003 0304 	and.w	r3, r3, #4
 800535a:	2b00      	cmp	r3, #0
 800535c:	bf14      	ite	ne
 800535e:	2301      	movne	r3, #1
 8005360:	2300      	moveq	r3, #0
 8005362:	b2db      	uxtb	r3, r3
 8005364:	2b00      	cmp	r3, #0
 8005366:	d03e      	beq.n	80053e6 <HAL_DMA_IRQHandler+0x5c2>
      {
        /* Clear the half transfer complete flag */
        regs_dma->IFCR = DMA_FLAG_HTIF0_4 << (hdma->StreamIndex & 0x1FU);
 8005368:	687b      	ldr	r3, [r7, #4]
 800536a:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 800536c:	f003 031f 	and.w	r3, r3, #31
 8005370:	2210      	movs	r2, #16
 8005372:	409a      	lsls	r2, r3
 8005374:	6a3b      	ldr	r3, [r7, #32]
 8005376:	609a      	str	r2, [r3, #8]

        /* Multi_Buffering mode enabled */
        if(((((DMA_Stream_TypeDef   *)hdma->Instance)->CR) & (uint32_t)(DMA_SxCR_DBM)) != 0U)
 8005378:	687b      	ldr	r3, [r7, #4]
 800537a:	681b      	ldr	r3, [r3, #0]
 800537c:	681b      	ldr	r3, [r3, #0]
 800537e:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
 8005382:	2b00      	cmp	r3, #0
 8005384:	d018      	beq.n	80053b8 <HAL_DMA_IRQHandler+0x594>
        {
          /* Current memory buffer used is Memory 0 */
          if((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_CT) == 0U)
 8005386:	687b      	ldr	r3, [r7, #4]
 8005388:	681b      	ldr	r3, [r3, #0]
 800538a:	681b      	ldr	r3, [r3, #0]
 800538c:	f403 2300 	and.w	r3, r3, #524288	@ 0x80000
 8005390:	2b00      	cmp	r3, #0
 8005392:	d108      	bne.n	80053a6 <HAL_DMA_IRQHandler+0x582>
          {
            if(hdma->XferHalfCpltCallback != NULL)
 8005394:	687b      	ldr	r3, [r7, #4]
 8005396:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8005398:	2b00      	cmp	r3, #0
 800539a:	d024      	beq.n	80053e6 <HAL_DMA_IRQHandler+0x5c2>
            {
              /* Half transfer callback */
              hdma->XferHalfCpltCallback(hdma);
 800539c:	687b      	ldr	r3, [r7, #4]
 800539e:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 80053a0:	6878      	ldr	r0, [r7, #4]
 80053a2:	4798      	blx	r3
 80053a4:	e01f      	b.n	80053e6 <HAL_DMA_IRQHandler+0x5c2>
            }
          }
          /* Current memory buffer used is Memory 1 */
          else
          {
            if(hdma->XferM1HalfCpltCallback != NULL)
 80053a6:	687b      	ldr	r3, [r7, #4]
 80053a8:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 80053aa:	2b00      	cmp	r3, #0
 80053ac:	d01b      	beq.n	80053e6 <HAL_DMA_IRQHandler+0x5c2>
            {
              /* Half transfer callback */
              hdma->XferM1HalfCpltCallback(hdma);
 80053ae:	687b      	ldr	r3, [r7, #4]
 80053b0:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 80053b2:	6878      	ldr	r0, [r7, #4]
 80053b4:	4798      	blx	r3
 80053b6:	e016      	b.n	80053e6 <HAL_DMA_IRQHandler+0x5c2>
          }
        }
        else
        {
          /* Disable the half transfer interrupt if the DMA mode is not CIRCULAR */
          if((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_CIRC) == 0U)
 80053b8:	687b      	ldr	r3, [r7, #4]
 80053ba:	681b      	ldr	r3, [r3, #0]
 80053bc:	681b      	ldr	r3, [r3, #0]
 80053be:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 80053c2:	2b00      	cmp	r3, #0
 80053c4:	d107      	bne.n	80053d6 <HAL_DMA_IRQHandler+0x5b2>
          {
            /* Disable the half transfer interrupt */
            ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_HT);
 80053c6:	687b      	ldr	r3, [r7, #4]
 80053c8:	681b      	ldr	r3, [r3, #0]
 80053ca:	681a      	ldr	r2, [r3, #0]
 80053cc:	687b      	ldr	r3, [r7, #4]
 80053ce:	681b      	ldr	r3, [r3, #0]
 80053d0:	f022 0208 	bic.w	r2, r2, #8
 80053d4:	601a      	str	r2, [r3, #0]
          }

          if(hdma->XferHalfCpltCallback != NULL)
 80053d6:	687b      	ldr	r3, [r7, #4]
 80053d8:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 80053da:	2b00      	cmp	r3, #0
 80053dc:	d003      	beq.n	80053e6 <HAL_DMA_IRQHandler+0x5c2>
          {
            /* Half transfer callback */
            hdma->XferHalfCpltCallback(hdma);
 80053de:	687b      	ldr	r3, [r7, #4]
 80053e0:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 80053e2:	6878      	ldr	r0, [r7, #4]
 80053e4:	4798      	blx	r3
          }
        }
      }
    }
    /* Transfer Complete Interrupt management ***********************************/
    if ((tmpisr_dma & (DMA_FLAG_TCIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
 80053e6:	687b      	ldr	r3, [r7, #4]
 80053e8:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 80053ea:	f003 031f 	and.w	r3, r3, #31
 80053ee:	2220      	movs	r2, #32
 80053f0:	409a      	lsls	r2, r3
 80053f2:	69bb      	ldr	r3, [r7, #24]
 80053f4:	4013      	ands	r3, r2
 80053f6:	2b00      	cmp	r3, #0
 80053f8:	f000 8110 	beq.w	800561c <HAL_DMA_IRQHandler+0x7f8>
    {
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TC) != 0U)
 80053fc:	687b      	ldr	r3, [r7, #4]
 80053fe:	681b      	ldr	r3, [r3, #0]
 8005400:	4a2c      	ldr	r2, [pc, #176]	@ (80054b4 <HAL_DMA_IRQHandler+0x690>)
 8005402:	4293      	cmp	r3, r2
 8005404:	d04a      	beq.n	800549c <HAL_DMA_IRQHandler+0x678>
 8005406:	687b      	ldr	r3, [r7, #4]
 8005408:	681b      	ldr	r3, [r3, #0]
 800540a:	4a2b      	ldr	r2, [pc, #172]	@ (80054b8 <HAL_DMA_IRQHandler+0x694>)
 800540c:	4293      	cmp	r3, r2
 800540e:	d045      	beq.n	800549c <HAL_DMA_IRQHandler+0x678>
 8005410:	687b      	ldr	r3, [r7, #4]
 8005412:	681b      	ldr	r3, [r3, #0]
 8005414:	4a29      	ldr	r2, [pc, #164]	@ (80054bc <HAL_DMA_IRQHandler+0x698>)
 8005416:	4293      	cmp	r3, r2
 8005418:	d040      	beq.n	800549c <HAL_DMA_IRQHandler+0x678>
 800541a:	687b      	ldr	r3, [r7, #4]
 800541c:	681b      	ldr	r3, [r3, #0]
 800541e:	4a28      	ldr	r2, [pc, #160]	@ (80054c0 <HAL_DMA_IRQHandler+0x69c>)
 8005420:	4293      	cmp	r3, r2
 8005422:	d03b      	beq.n	800549c <HAL_DMA_IRQHandler+0x678>
 8005424:	687b      	ldr	r3, [r7, #4]
 8005426:	681b      	ldr	r3, [r3, #0]
 8005428:	4a26      	ldr	r2, [pc, #152]	@ (80054c4 <HAL_DMA_IRQHandler+0x6a0>)
 800542a:	4293      	cmp	r3, r2
 800542c:	d036      	beq.n	800549c <HAL_DMA_IRQHandler+0x678>
 800542e:	687b      	ldr	r3, [r7, #4]
 8005430:	681b      	ldr	r3, [r3, #0]
 8005432:	4a25      	ldr	r2, [pc, #148]	@ (80054c8 <HAL_DMA_IRQHandler+0x6a4>)
 8005434:	4293      	cmp	r3, r2
 8005436:	d031      	beq.n	800549c <HAL_DMA_IRQHandler+0x678>
 8005438:	687b      	ldr	r3, [r7, #4]
 800543a:	681b      	ldr	r3, [r3, #0]
 800543c:	4a23      	ldr	r2, [pc, #140]	@ (80054cc <HAL_DMA_IRQHandler+0x6a8>)
 800543e:	4293      	cmp	r3, r2
 8005440:	d02c      	beq.n	800549c <HAL_DMA_IRQHandler+0x678>
 8005442:	687b      	ldr	r3, [r7, #4]
 8005444:	681b      	ldr	r3, [r3, #0]
 8005446:	4a22      	ldr	r2, [pc, #136]	@ (80054d0 <HAL_DMA_IRQHandler+0x6ac>)
 8005448:	4293      	cmp	r3, r2
 800544a:	d027      	beq.n	800549c <HAL_DMA_IRQHandler+0x678>
 800544c:	687b      	ldr	r3, [r7, #4]
 800544e:	681b      	ldr	r3, [r3, #0]
 8005450:	4a20      	ldr	r2, [pc, #128]	@ (80054d4 <HAL_DMA_IRQHandler+0x6b0>)
 8005452:	4293      	cmp	r3, r2
 8005454:	d022      	beq.n	800549c <HAL_DMA_IRQHandler+0x678>
 8005456:	687b      	ldr	r3, [r7, #4]
 8005458:	681b      	ldr	r3, [r3, #0]
 800545a:	4a1f      	ldr	r2, [pc, #124]	@ (80054d8 <HAL_DMA_IRQHandler+0x6b4>)
 800545c:	4293      	cmp	r3, r2
 800545e:	d01d      	beq.n	800549c <HAL_DMA_IRQHandler+0x678>
 8005460:	687b      	ldr	r3, [r7, #4]
 8005462:	681b      	ldr	r3, [r3, #0]
 8005464:	4a1d      	ldr	r2, [pc, #116]	@ (80054dc <HAL_DMA_IRQHandler+0x6b8>)
 8005466:	4293      	cmp	r3, r2
 8005468:	d018      	beq.n	800549c <HAL_DMA_IRQHandler+0x678>
 800546a:	687b      	ldr	r3, [r7, #4]
 800546c:	681b      	ldr	r3, [r3, #0]
 800546e:	4a1c      	ldr	r2, [pc, #112]	@ (80054e0 <HAL_DMA_IRQHandler+0x6bc>)
 8005470:	4293      	cmp	r3, r2
 8005472:	d013      	beq.n	800549c <HAL_DMA_IRQHandler+0x678>
 8005474:	687b      	ldr	r3, [r7, #4]
 8005476:	681b      	ldr	r3, [r3, #0]
 8005478:	4a1a      	ldr	r2, [pc, #104]	@ (80054e4 <HAL_DMA_IRQHandler+0x6c0>)
 800547a:	4293      	cmp	r3, r2
 800547c:	d00e      	beq.n	800549c <HAL_DMA_IRQHandler+0x678>
 800547e:	687b      	ldr	r3, [r7, #4]
 8005480:	681b      	ldr	r3, [r3, #0]
 8005482:	4a19      	ldr	r2, [pc, #100]	@ (80054e8 <HAL_DMA_IRQHandler+0x6c4>)
 8005484:	4293      	cmp	r3, r2
 8005486:	d009      	beq.n	800549c <HAL_DMA_IRQHandler+0x678>
 8005488:	687b      	ldr	r3, [r7, #4]
 800548a:	681b      	ldr	r3, [r3, #0]
 800548c:	4a17      	ldr	r2, [pc, #92]	@ (80054ec <HAL_DMA_IRQHandler+0x6c8>)
 800548e:	4293      	cmp	r3, r2
 8005490:	d004      	beq.n	800549c <HAL_DMA_IRQHandler+0x678>
 8005492:	687b      	ldr	r3, [r7, #4]
 8005494:	681b      	ldr	r3, [r3, #0]
 8005496:	4a16      	ldr	r2, [pc, #88]	@ (80054f0 <HAL_DMA_IRQHandler+0x6cc>)
 8005498:	4293      	cmp	r3, r2
 800549a:	d12b      	bne.n	80054f4 <HAL_DMA_IRQHandler+0x6d0>
 800549c:	687b      	ldr	r3, [r7, #4]
 800549e:	681b      	ldr	r3, [r3, #0]
 80054a0:	681b      	ldr	r3, [r3, #0]
 80054a2:	f003 0310 	and.w	r3, r3, #16
 80054a6:	2b00      	cmp	r3, #0
 80054a8:	bf14      	ite	ne
 80054aa:	2301      	movne	r3, #1
 80054ac:	2300      	moveq	r3, #0
 80054ae:	b2db      	uxtb	r3, r3
 80054b0:	e02a      	b.n	8005508 <HAL_DMA_IRQHandler+0x6e4>
 80054b2:	bf00      	nop
 80054b4:	40020010 	.word	0x40020010
 80054b8:	40020028 	.word	0x40020028
 80054bc:	40020040 	.word	0x40020040
 80054c0:	40020058 	.word	0x40020058
 80054c4:	40020070 	.word	0x40020070
 80054c8:	40020088 	.word	0x40020088
 80054cc:	400200a0 	.word	0x400200a0
 80054d0:	400200b8 	.word	0x400200b8
 80054d4:	40020410 	.word	0x40020410
 80054d8:	40020428 	.word	0x40020428
 80054dc:	40020440 	.word	0x40020440
 80054e0:	40020458 	.word	0x40020458
 80054e4:	40020470 	.word	0x40020470
 80054e8:	40020488 	.word	0x40020488
 80054ec:	400204a0 	.word	0x400204a0
 80054f0:	400204b8 	.word	0x400204b8
 80054f4:	687b      	ldr	r3, [r7, #4]
 80054f6:	681b      	ldr	r3, [r3, #0]
 80054f8:	681b      	ldr	r3, [r3, #0]
 80054fa:	f003 0302 	and.w	r3, r3, #2
 80054fe:	2b00      	cmp	r3, #0
 8005500:	bf14      	ite	ne
 8005502:	2301      	movne	r3, #1
 8005504:	2300      	moveq	r3, #0
 8005506:	b2db      	uxtb	r3, r3
 8005508:	2b00      	cmp	r3, #0
 800550a:	f000 8087 	beq.w	800561c <HAL_DMA_IRQHandler+0x7f8>
      {
        /* Clear the transfer complete flag */
        regs_dma->IFCR = DMA_FLAG_TCIF0_4 << (hdma->StreamIndex & 0x1FU);
 800550e:	687b      	ldr	r3, [r7, #4]
 8005510:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 8005512:	f003 031f 	and.w	r3, r3, #31
 8005516:	2220      	movs	r2, #32
 8005518:	409a      	lsls	r2, r3
 800551a:	6a3b      	ldr	r3, [r7, #32]
 800551c:	609a      	str	r2, [r3, #8]

        if(HAL_DMA_STATE_ABORT == hdma->State)
 800551e:	687b      	ldr	r3, [r7, #4]
 8005520:	f893 3035 	ldrb.w	r3, [r3, #53]	@ 0x35
 8005524:	b2db      	uxtb	r3, r3
 8005526:	2b04      	cmp	r3, #4
 8005528:	d139      	bne.n	800559e <HAL_DMA_IRQHandler+0x77a>
        {
          /* Disable all the transfer interrupts */
          ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
 800552a:	687b      	ldr	r3, [r7, #4]
 800552c:	681b      	ldr	r3, [r3, #0]
 800552e:	681a      	ldr	r2, [r3, #0]
 8005530:	687b      	ldr	r3, [r7, #4]
 8005532:	681b      	ldr	r3, [r3, #0]
 8005534:	f022 0216 	bic.w	r2, r2, #22
 8005538:	601a      	str	r2, [r3, #0]
          ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR &= ~(DMA_IT_FE);
 800553a:	687b      	ldr	r3, [r7, #4]
 800553c:	681b      	ldr	r3, [r3, #0]
 800553e:	695a      	ldr	r2, [r3, #20]
 8005540:	687b      	ldr	r3, [r7, #4]
 8005542:	681b      	ldr	r3, [r3, #0]
 8005544:	f022 0280 	bic.w	r2, r2, #128	@ 0x80
 8005548:	615a      	str	r2, [r3, #20]

          if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
 800554a:	687b      	ldr	r3, [r7, #4]
 800554c:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800554e:	2b00      	cmp	r3, #0
 8005550:	d103      	bne.n	800555a <HAL_DMA_IRQHandler+0x736>
 8005552:	687b      	ldr	r3, [r7, #4]
 8005554:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 8005556:	2b00      	cmp	r3, #0
 8005558:	d007      	beq.n	800556a <HAL_DMA_IRQHandler+0x746>
          {
            ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_HT);
 800555a:	687b      	ldr	r3, [r7, #4]
 800555c:	681b      	ldr	r3, [r3, #0]
 800555e:	681a      	ldr	r2, [r3, #0]
 8005560:	687b      	ldr	r3, [r7, #4]
 8005562:	681b      	ldr	r3, [r3, #0]
 8005564:	f022 0208 	bic.w	r2, r2, #8
 8005568:	601a      	str	r2, [r3, #0]
          }

          /* Clear all interrupt flags at correct offset within the register */
          regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);
 800556a:	687b      	ldr	r3, [r7, #4]
 800556c:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 800556e:	f003 031f 	and.w	r3, r3, #31
 8005572:	223f      	movs	r2, #63	@ 0x3f
 8005574:	409a      	lsls	r2, r3
 8005576:	6a3b      	ldr	r3, [r7, #32]
 8005578:	609a      	str	r2, [r3, #8]

          /* Change the DMA state */
          hdma->State = HAL_DMA_STATE_READY;
 800557a:	687b      	ldr	r3, [r7, #4]
 800557c:	2201      	movs	r2, #1
 800557e:	f883 2035 	strb.w	r2, [r3, #53]	@ 0x35

          /* Process Unlocked */
          __HAL_UNLOCK(hdma);
 8005582:	687b      	ldr	r3, [r7, #4]
 8005584:	2200      	movs	r2, #0
 8005586:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34

          if(hdma->XferAbortCallback != NULL)
 800558a:	687b      	ldr	r3, [r7, #4]
 800558c:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800558e:	2b00      	cmp	r3, #0
 8005590:	f000 8382 	beq.w	8005c98 <HAL_DMA_IRQHandler+0xe74>
          {
            hdma->XferAbortCallback(hdma);
 8005594:	687b      	ldr	r3, [r7, #4]
 8005596:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 8005598:	6878      	ldr	r0, [r7, #4]
 800559a:	4798      	blx	r3
          }
          return;
 800559c:	e37c      	b.n	8005c98 <HAL_DMA_IRQHandler+0xe74>
        }

        if(((((DMA_Stream_TypeDef   *)hdma->Instance)->CR) & (uint32_t)(DMA_SxCR_DBM)) != 0U)
 800559e:	687b      	ldr	r3, [r7, #4]
 80055a0:	681b      	ldr	r3, [r3, #0]
 80055a2:	681b      	ldr	r3, [r3, #0]
 80055a4:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
 80055a8:	2b00      	cmp	r3, #0
 80055aa:	d018      	beq.n	80055de <HAL_DMA_IRQHandler+0x7ba>
        {
          /* Current memory buffer used is Memory 0 */
          if((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_CT) == 0U)
 80055ac:	687b      	ldr	r3, [r7, #4]
 80055ae:	681b      	ldr	r3, [r3, #0]
 80055b0:	681b      	ldr	r3, [r3, #0]
 80055b2:	f403 2300 	and.w	r3, r3, #524288	@ 0x80000
 80055b6:	2b00      	cmp	r3, #0
 80055b8:	d108      	bne.n	80055cc <HAL_DMA_IRQHandler+0x7a8>
          {
            if(hdma->XferM1CpltCallback != NULL)
 80055ba:	687b      	ldr	r3, [r7, #4]
 80055bc:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 80055be:	2b00      	cmp	r3, #0
 80055c0:	d02c      	beq.n	800561c <HAL_DMA_IRQHandler+0x7f8>
            {
              /* Transfer complete Callback for memory1 */
              hdma->XferM1CpltCallback(hdma);
 80055c2:	687b      	ldr	r3, [r7, #4]
 80055c4:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 80055c6:	6878      	ldr	r0, [r7, #4]
 80055c8:	4798      	blx	r3
 80055ca:	e027      	b.n	800561c <HAL_DMA_IRQHandler+0x7f8>
            }
          }
          /* Current memory buffer used is Memory 1 */
          else
          {
            if(hdma->XferCpltCallback != NULL)
 80055cc:	687b      	ldr	r3, [r7, #4]
 80055ce:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 80055d0:	2b00      	cmp	r3, #0
 80055d2:	d023      	beq.n	800561c <HAL_DMA_IRQHandler+0x7f8>
            {
              /* Transfer complete Callback for memory0 */
              hdma->XferCpltCallback(hdma);
 80055d4:	687b      	ldr	r3, [r7, #4]
 80055d6:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 80055d8:	6878      	ldr	r0, [r7, #4]
 80055da:	4798      	blx	r3
 80055dc:	e01e      	b.n	800561c <HAL_DMA_IRQHandler+0x7f8>
          }
        }
        /* Disable the transfer complete interrupt if the DMA mode is not CIRCULAR */
        else
        {
          if((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_CIRC) == 0U)
 80055de:	687b      	ldr	r3, [r7, #4]
 80055e0:	681b      	ldr	r3, [r3, #0]
 80055e2:	681b      	ldr	r3, [r3, #0]
 80055e4:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 80055e8:	2b00      	cmp	r3, #0
 80055ea:	d10f      	bne.n	800560c <HAL_DMA_IRQHandler+0x7e8>
          {
            /* Disable the transfer complete interrupt */
            ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_TC);
 80055ec:	687b      	ldr	r3, [r7, #4]
 80055ee:	681b      	ldr	r3, [r3, #0]
 80055f0:	681a      	ldr	r2, [r3, #0]
 80055f2:	687b      	ldr	r3, [r7, #4]
 80055f4:	681b      	ldr	r3, [r3, #0]
 80055f6:	f022 0210 	bic.w	r2, r2, #16
 80055fa:	601a      	str	r2, [r3, #0]

            /* Change the DMA state */
            hdma->State = HAL_DMA_STATE_READY;
 80055fc:	687b      	ldr	r3, [r7, #4]
 80055fe:	2201      	movs	r2, #1
 8005600:	f883 2035 	strb.w	r2, [r3, #53]	@ 0x35

            /* Process Unlocked */
            __HAL_UNLOCK(hdma);
 8005604:	687b      	ldr	r3, [r7, #4]
 8005606:	2200      	movs	r2, #0
 8005608:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34
          }

          if(hdma->XferCpltCallback != NULL)
 800560c:	687b      	ldr	r3, [r7, #4]
 800560e:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8005610:	2b00      	cmp	r3, #0
 8005612:	d003      	beq.n	800561c <HAL_DMA_IRQHandler+0x7f8>
          {
            /* Transfer complete callback */
            hdma->XferCpltCallback(hdma);
 8005614:	687b      	ldr	r3, [r7, #4]
 8005616:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8005618:	6878      	ldr	r0, [r7, #4]
 800561a:	4798      	blx	r3
        }
      }
    }

    /* manage error case */
    if(hdma->ErrorCode != HAL_DMA_ERROR_NONE)
 800561c:	687b      	ldr	r3, [r7, #4]
 800561e:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8005620:	2b00      	cmp	r3, #0
 8005622:	f000 833e 	beq.w	8005ca2 <HAL_DMA_IRQHandler+0xe7e>
    {
      if((hdma->ErrorCode & HAL_DMA_ERROR_TE) != 0U)
 8005626:	687b      	ldr	r3, [r7, #4]
 8005628:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 800562a:	f003 0301 	and.w	r3, r3, #1
 800562e:	2b00      	cmp	r3, #0
 8005630:	f000 8088 	beq.w	8005744 <HAL_DMA_IRQHandler+0x920>
      {
        hdma->State = HAL_DMA_STATE_ABORT;
 8005634:	687b      	ldr	r3, [r7, #4]
 8005636:	2204      	movs	r2, #4
 8005638:	f883 2035 	strb.w	r2, [r3, #53]	@ 0x35

        /* Disable the stream */
        __HAL_DMA_DISABLE(hdma);
 800563c:	687b      	ldr	r3, [r7, #4]
 800563e:	681b      	ldr	r3, [r3, #0]
 8005640:	4a89      	ldr	r2, [pc, #548]	@ (8005868 <HAL_DMA_IRQHandler+0xa44>)
 8005642:	4293      	cmp	r3, r2
 8005644:	d04a      	beq.n	80056dc <HAL_DMA_IRQHandler+0x8b8>
 8005646:	687b      	ldr	r3, [r7, #4]
 8005648:	681b      	ldr	r3, [r3, #0]
 800564a:	4a88      	ldr	r2, [pc, #544]	@ (800586c <HAL_DMA_IRQHandler+0xa48>)
 800564c:	4293      	cmp	r3, r2
 800564e:	d045      	beq.n	80056dc <HAL_DMA_IRQHandler+0x8b8>
 8005650:	687b      	ldr	r3, [r7, #4]
 8005652:	681b      	ldr	r3, [r3, #0]
 8005654:	4a86      	ldr	r2, [pc, #536]	@ (8005870 <HAL_DMA_IRQHandler+0xa4c>)
 8005656:	4293      	cmp	r3, r2
 8005658:	d040      	beq.n	80056dc <HAL_DMA_IRQHandler+0x8b8>
 800565a:	687b      	ldr	r3, [r7, #4]
 800565c:	681b      	ldr	r3, [r3, #0]
 800565e:	4a85      	ldr	r2, [pc, #532]	@ (8005874 <HAL_DMA_IRQHandler+0xa50>)
 8005660:	4293      	cmp	r3, r2
 8005662:	d03b      	beq.n	80056dc <HAL_DMA_IRQHandler+0x8b8>
 8005664:	687b      	ldr	r3, [r7, #4]
 8005666:	681b      	ldr	r3, [r3, #0]
 8005668:	4a83      	ldr	r2, [pc, #524]	@ (8005878 <HAL_DMA_IRQHandler+0xa54>)
 800566a:	4293      	cmp	r3, r2
 800566c:	d036      	beq.n	80056dc <HAL_DMA_IRQHandler+0x8b8>
 800566e:	687b      	ldr	r3, [r7, #4]
 8005670:	681b      	ldr	r3, [r3, #0]
 8005672:	4a82      	ldr	r2, [pc, #520]	@ (800587c <HAL_DMA_IRQHandler+0xa58>)
 8005674:	4293      	cmp	r3, r2
 8005676:	d031      	beq.n	80056dc <HAL_DMA_IRQHandler+0x8b8>
 8005678:	687b      	ldr	r3, [r7, #4]
 800567a:	681b      	ldr	r3, [r3, #0]
 800567c:	4a80      	ldr	r2, [pc, #512]	@ (8005880 <HAL_DMA_IRQHandler+0xa5c>)
 800567e:	4293      	cmp	r3, r2
 8005680:	d02c      	beq.n	80056dc <HAL_DMA_IRQHandler+0x8b8>
 8005682:	687b      	ldr	r3, [r7, #4]
 8005684:	681b      	ldr	r3, [r3, #0]
 8005686:	4a7f      	ldr	r2, [pc, #508]	@ (8005884 <HAL_DMA_IRQHandler+0xa60>)
 8005688:	4293      	cmp	r3, r2
 800568a:	d027      	beq.n	80056dc <HAL_DMA_IRQHandler+0x8b8>
 800568c:	687b      	ldr	r3, [r7, #4]
 800568e:	681b      	ldr	r3, [r3, #0]
 8005690:	4a7d      	ldr	r2, [pc, #500]	@ (8005888 <HAL_DMA_IRQHandler+0xa64>)
 8005692:	4293      	cmp	r3, r2
 8005694:	d022      	beq.n	80056dc <HAL_DMA_IRQHandler+0x8b8>
 8005696:	687b      	ldr	r3, [r7, #4]
 8005698:	681b      	ldr	r3, [r3, #0]
 800569a:	4a7c      	ldr	r2, [pc, #496]	@ (800588c <HAL_DMA_IRQHandler+0xa68>)
 800569c:	4293      	cmp	r3, r2
 800569e:	d01d      	beq.n	80056dc <HAL_DMA_IRQHandler+0x8b8>
 80056a0:	687b      	ldr	r3, [r7, #4]
 80056a2:	681b      	ldr	r3, [r3, #0]
 80056a4:	4a7a      	ldr	r2, [pc, #488]	@ (8005890 <HAL_DMA_IRQHandler+0xa6c>)
 80056a6:	4293      	cmp	r3, r2
 80056a8:	d018      	beq.n	80056dc <HAL_DMA_IRQHandler+0x8b8>
 80056aa:	687b      	ldr	r3, [r7, #4]
 80056ac:	681b      	ldr	r3, [r3, #0]
 80056ae:	4a79      	ldr	r2, [pc, #484]	@ (8005894 <HAL_DMA_IRQHandler+0xa70>)
 80056b0:	4293      	cmp	r3, r2
 80056b2:	d013      	beq.n	80056dc <HAL_DMA_IRQHandler+0x8b8>
 80056b4:	687b      	ldr	r3, [r7, #4]
 80056b6:	681b      	ldr	r3, [r3, #0]
 80056b8:	4a77      	ldr	r2, [pc, #476]	@ (8005898 <HAL_DMA_IRQHandler+0xa74>)
 80056ba:	4293      	cmp	r3, r2
 80056bc:	d00e      	beq.n	80056dc <HAL_DMA_IRQHandler+0x8b8>
 80056be:	687b      	ldr	r3, [r7, #4]
 80056c0:	681b      	ldr	r3, [r3, #0]
 80056c2:	4a76      	ldr	r2, [pc, #472]	@ (800589c <HAL_DMA_IRQHandler+0xa78>)
 80056c4:	4293      	cmp	r3, r2
 80056c6:	d009      	beq.n	80056dc <HAL_DMA_IRQHandler+0x8b8>
 80056c8:	687b      	ldr	r3, [r7, #4]
 80056ca:	681b      	ldr	r3, [r3, #0]
 80056cc:	4a74      	ldr	r2, [pc, #464]	@ (80058a0 <HAL_DMA_IRQHandler+0xa7c>)
 80056ce:	4293      	cmp	r3, r2
 80056d0:	d004      	beq.n	80056dc <HAL_DMA_IRQHandler+0x8b8>
 80056d2:	687b      	ldr	r3, [r7, #4]
 80056d4:	681b      	ldr	r3, [r3, #0]
 80056d6:	4a73      	ldr	r2, [pc, #460]	@ (80058a4 <HAL_DMA_IRQHandler+0xa80>)
 80056d8:	4293      	cmp	r3, r2
 80056da:	d108      	bne.n	80056ee <HAL_DMA_IRQHandler+0x8ca>
 80056dc:	687b      	ldr	r3, [r7, #4]
 80056de:	681b      	ldr	r3, [r3, #0]
 80056e0:	681a      	ldr	r2, [r3, #0]
 80056e2:	687b      	ldr	r3, [r7, #4]
 80056e4:	681b      	ldr	r3, [r3, #0]
 80056e6:	f022 0201 	bic.w	r2, r2, #1
 80056ea:	601a      	str	r2, [r3, #0]
 80056ec:	e007      	b.n	80056fe <HAL_DMA_IRQHandler+0x8da>
 80056ee:	687b      	ldr	r3, [r7, #4]
 80056f0:	681b      	ldr	r3, [r3, #0]
 80056f2:	681a      	ldr	r2, [r3, #0]
 80056f4:	687b      	ldr	r3, [r7, #4]
 80056f6:	681b      	ldr	r3, [r3, #0]
 80056f8:	f022 0201 	bic.w	r2, r2, #1
 80056fc:	601a      	str	r2, [r3, #0]

        do
        {
          if (++count > timeout)
 80056fe:	68fb      	ldr	r3, [r7, #12]
 8005700:	3301      	adds	r3, #1
 8005702:	60fb      	str	r3, [r7, #12]
 8005704:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8005706:	429a      	cmp	r2, r3
 8005708:	d307      	bcc.n	800571a <HAL_DMA_IRQHandler+0x8f6>
          {
            break;
          }
        }
        while((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_EN) != 0U);
 800570a:	687b      	ldr	r3, [r7, #4]
 800570c:	681b      	ldr	r3, [r3, #0]
 800570e:	681b      	ldr	r3, [r3, #0]
 8005710:	f003 0301 	and.w	r3, r3, #1
 8005714:	2b00      	cmp	r3, #0
 8005716:	d1f2      	bne.n	80056fe <HAL_DMA_IRQHandler+0x8da>
 8005718:	e000      	b.n	800571c <HAL_DMA_IRQHandler+0x8f8>
            break;
 800571a:	bf00      	nop

        if((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_EN) != 0U)
 800571c:	687b      	ldr	r3, [r7, #4]
 800571e:	681b      	ldr	r3, [r3, #0]
 8005720:	681b      	ldr	r3, [r3, #0]
 8005722:	f003 0301 	and.w	r3, r3, #1
 8005726:	2b00      	cmp	r3, #0
 8005728:	d004      	beq.n	8005734 <HAL_DMA_IRQHandler+0x910>
        {
          /* Change the DMA state to error if DMA disable fails */
          hdma->State = HAL_DMA_STATE_ERROR;
 800572a:	687b      	ldr	r3, [r7, #4]
 800572c:	2203      	movs	r2, #3
 800572e:	f883 2035 	strb.w	r2, [r3, #53]	@ 0x35
 8005732:	e003      	b.n	800573c <HAL_DMA_IRQHandler+0x918>
        }
        else
        {
          /* Change the DMA state to Ready if DMA disable success */
          hdma->State = HAL_DMA_STATE_READY;
 8005734:	687b      	ldr	r3, [r7, #4]
 8005736:	2201      	movs	r2, #1
 8005738:	f883 2035 	strb.w	r2, [r3, #53]	@ 0x35
        }

        /* Process Unlocked */
        __HAL_UNLOCK(hdma);
 800573c:	687b      	ldr	r3, [r7, #4]
 800573e:	2200      	movs	r2, #0
 8005740:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34
      }

      if(hdma->XferErrorCallback != NULL)
 8005744:	687b      	ldr	r3, [r7, #4]
 8005746:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 8005748:	2b00      	cmp	r3, #0
 800574a:	f000 82aa 	beq.w	8005ca2 <HAL_DMA_IRQHandler+0xe7e>
      {
        /* Transfer error callback */
        hdma->XferErrorCallback(hdma);
 800574e:	687b      	ldr	r3, [r7, #4]
 8005750:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 8005752:	6878      	ldr	r0, [r7, #4]
 8005754:	4798      	blx	r3
 8005756:	e2a4      	b.n	8005ca2 <HAL_DMA_IRQHandler+0xe7e>
      }
    }
  }
  else if(IS_BDMA_CHANNEL_INSTANCE(hdma->Instance) != 0U)  /* BDMA instance(s) */
 8005758:	687b      	ldr	r3, [r7, #4]
 800575a:	681b      	ldr	r3, [r3, #0]
 800575c:	4a52      	ldr	r2, [pc, #328]	@ (80058a8 <HAL_DMA_IRQHandler+0xa84>)
 800575e:	4293      	cmp	r3, r2
 8005760:	d04a      	beq.n	80057f8 <HAL_DMA_IRQHandler+0x9d4>
 8005762:	687b      	ldr	r3, [r7, #4]
 8005764:	681b      	ldr	r3, [r3, #0]
 8005766:	4a51      	ldr	r2, [pc, #324]	@ (80058ac <HAL_DMA_IRQHandler+0xa88>)
 8005768:	4293      	cmp	r3, r2
 800576a:	d045      	beq.n	80057f8 <HAL_DMA_IRQHandler+0x9d4>
 800576c:	687b      	ldr	r3, [r7, #4]
 800576e:	681b      	ldr	r3, [r3, #0]
 8005770:	4a4f      	ldr	r2, [pc, #316]	@ (80058b0 <HAL_DMA_IRQHandler+0xa8c>)
 8005772:	4293      	cmp	r3, r2
 8005774:	d040      	beq.n	80057f8 <HAL_DMA_IRQHandler+0x9d4>
 8005776:	687b      	ldr	r3, [r7, #4]
 8005778:	681b      	ldr	r3, [r3, #0]
 800577a:	4a4e      	ldr	r2, [pc, #312]	@ (80058b4 <HAL_DMA_IRQHandler+0xa90>)
 800577c:	4293      	cmp	r3, r2
 800577e:	d03b      	beq.n	80057f8 <HAL_DMA_IRQHandler+0x9d4>
 8005780:	687b      	ldr	r3, [r7, #4]
 8005782:	681b      	ldr	r3, [r3, #0]
 8005784:	4a4c      	ldr	r2, [pc, #304]	@ (80058b8 <HAL_DMA_IRQHandler+0xa94>)
 8005786:	4293      	cmp	r3, r2
 8005788:	d036      	beq.n	80057f8 <HAL_DMA_IRQHandler+0x9d4>
 800578a:	687b      	ldr	r3, [r7, #4]
 800578c:	681b      	ldr	r3, [r3, #0]
 800578e:	4a4b      	ldr	r2, [pc, #300]	@ (80058bc <HAL_DMA_IRQHandler+0xa98>)
 8005790:	4293      	cmp	r3, r2
 8005792:	d031      	beq.n	80057f8 <HAL_DMA_IRQHandler+0x9d4>
 8005794:	687b      	ldr	r3, [r7, #4]
 8005796:	681b      	ldr	r3, [r3, #0]
 8005798:	4a49      	ldr	r2, [pc, #292]	@ (80058c0 <HAL_DMA_IRQHandler+0xa9c>)
 800579a:	4293      	cmp	r3, r2
 800579c:	d02c      	beq.n	80057f8 <HAL_DMA_IRQHandler+0x9d4>
 800579e:	687b      	ldr	r3, [r7, #4]
 80057a0:	681b      	ldr	r3, [r3, #0]
 80057a2:	4a48      	ldr	r2, [pc, #288]	@ (80058c4 <HAL_DMA_IRQHandler+0xaa0>)
 80057a4:	4293      	cmp	r3, r2
 80057a6:	d027      	beq.n	80057f8 <HAL_DMA_IRQHandler+0x9d4>
 80057a8:	687b      	ldr	r3, [r7, #4]
 80057aa:	681b      	ldr	r3, [r3, #0]
 80057ac:	4a46      	ldr	r2, [pc, #280]	@ (80058c8 <HAL_DMA_IRQHandler+0xaa4>)
 80057ae:	4293      	cmp	r3, r2
 80057b0:	d022      	beq.n	80057f8 <HAL_DMA_IRQHandler+0x9d4>
 80057b2:	687b      	ldr	r3, [r7, #4]
 80057b4:	681b      	ldr	r3, [r3, #0]
 80057b6:	4a45      	ldr	r2, [pc, #276]	@ (80058cc <HAL_DMA_IRQHandler+0xaa8>)
 80057b8:	4293      	cmp	r3, r2
 80057ba:	d01d      	beq.n	80057f8 <HAL_DMA_IRQHandler+0x9d4>
 80057bc:	687b      	ldr	r3, [r7, #4]
 80057be:	681b      	ldr	r3, [r3, #0]
 80057c0:	4a43      	ldr	r2, [pc, #268]	@ (80058d0 <HAL_DMA_IRQHandler+0xaac>)
 80057c2:	4293      	cmp	r3, r2
 80057c4:	d018      	beq.n	80057f8 <HAL_DMA_IRQHandler+0x9d4>
 80057c6:	687b      	ldr	r3, [r7, #4]
 80057c8:	681b      	ldr	r3, [r3, #0]
 80057ca:	4a42      	ldr	r2, [pc, #264]	@ (80058d4 <HAL_DMA_IRQHandler+0xab0>)
 80057cc:	4293      	cmp	r3, r2
 80057ce:	d013      	beq.n	80057f8 <HAL_DMA_IRQHandler+0x9d4>
 80057d0:	687b      	ldr	r3, [r7, #4]
 80057d2:	681b      	ldr	r3, [r3, #0]
 80057d4:	4a40      	ldr	r2, [pc, #256]	@ (80058d8 <HAL_DMA_IRQHandler+0xab4>)
 80057d6:	4293      	cmp	r3, r2
 80057d8:	d00e      	beq.n	80057f8 <HAL_DMA_IRQHandler+0x9d4>
 80057da:	687b      	ldr	r3, [r7, #4]
 80057dc:	681b      	ldr	r3, [r3, #0]
 80057de:	4a3f      	ldr	r2, [pc, #252]	@ (80058dc <HAL_DMA_IRQHandler+0xab8>)
 80057e0:	4293      	cmp	r3, r2
 80057e2:	d009      	beq.n	80057f8 <HAL_DMA_IRQHandler+0x9d4>
 80057e4:	687b      	ldr	r3, [r7, #4]
 80057e6:	681b      	ldr	r3, [r3, #0]
 80057e8:	4a3d      	ldr	r2, [pc, #244]	@ (80058e0 <HAL_DMA_IRQHandler+0xabc>)
 80057ea:	4293      	cmp	r3, r2
 80057ec:	d004      	beq.n	80057f8 <HAL_DMA_IRQHandler+0x9d4>
 80057ee:	687b      	ldr	r3, [r7, #4]
 80057f0:	681b      	ldr	r3, [r3, #0]
 80057f2:	4a3c      	ldr	r2, [pc, #240]	@ (80058e4 <HAL_DMA_IRQHandler+0xac0>)
 80057f4:	4293      	cmp	r3, r2
 80057f6:	d101      	bne.n	80057fc <HAL_DMA_IRQHandler+0x9d8>
 80057f8:	2301      	movs	r3, #1
 80057fa:	e000      	b.n	80057fe <HAL_DMA_IRQHandler+0x9da>
 80057fc:	2300      	movs	r3, #0
 80057fe:	2b00      	cmp	r3, #0
 8005800:	f000 824f 	beq.w	8005ca2 <HAL_DMA_IRQHandler+0xe7e>
  {
    ccr_reg = (((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR);
 8005804:	687b      	ldr	r3, [r7, #4]
 8005806:	681b      	ldr	r3, [r3, #0]
 8005808:	681b      	ldr	r3, [r3, #0]
 800580a:	613b      	str	r3, [r7, #16]

    /* Half Transfer Complete Interrupt management ******************************/
    if (((tmpisr_bdma & (BDMA_FLAG_HT0 << (hdma->StreamIndex & 0x1FU))) != 0U) && ((ccr_reg & BDMA_CCR_HTIE) != 0U))
 800580c:	687b      	ldr	r3, [r7, #4]
 800580e:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 8005810:	f003 031f 	and.w	r3, r3, #31
 8005814:	2204      	movs	r2, #4
 8005816:	409a      	lsls	r2, r3
 8005818:	697b      	ldr	r3, [r7, #20]
 800581a:	4013      	ands	r3, r2
 800581c:	2b00      	cmp	r3, #0
 800581e:	f000 80dd 	beq.w	80059dc <HAL_DMA_IRQHandler+0xbb8>
 8005822:	693b      	ldr	r3, [r7, #16]
 8005824:	f003 0304 	and.w	r3, r3, #4
 8005828:	2b00      	cmp	r3, #0
 800582a:	f000 80d7 	beq.w	80059dc <HAL_DMA_IRQHandler+0xbb8>
    {
      /* Clear the half transfer complete flag */
      regs_bdma->IFCR = (BDMA_ISR_HTIF0 << (hdma->StreamIndex & 0x1FU));
 800582e:	687b      	ldr	r3, [r7, #4]
 8005830:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 8005832:	f003 031f 	and.w	r3, r3, #31
 8005836:	2204      	movs	r2, #4
 8005838:	409a      	lsls	r2, r3
 800583a:	69fb      	ldr	r3, [r7, #28]
 800583c:	605a      	str	r2, [r3, #4]

      /* Disable the transfer complete interrupt if the DMA mode is Double Buffering */
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
 800583e:	693b      	ldr	r3, [r7, #16]
 8005840:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
 8005844:	2b00      	cmp	r3, #0
 8005846:	d059      	beq.n	80058fc <HAL_DMA_IRQHandler+0xad8>
      {
        /* Current memory buffer used is Memory 0 */
        if((ccr_reg & BDMA_CCR_CT) == 0U)
 8005848:	693b      	ldr	r3, [r7, #16]
 800584a:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 800584e:	2b00      	cmp	r3, #0
 8005850:	d14a      	bne.n	80058e8 <HAL_DMA_IRQHandler+0xac4>
        {
          if(hdma->XferM1HalfCpltCallback != NULL)
 8005852:	687b      	ldr	r3, [r7, #4]
 8005854:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 8005856:	2b00      	cmp	r3, #0
 8005858:	f000 8220 	beq.w	8005c9c <HAL_DMA_IRQHandler+0xe78>
          {
            /* Half transfer Callback for Memory 1 */
            hdma->XferM1HalfCpltCallback(hdma);
 800585c:	687b      	ldr	r3, [r7, #4]
 800585e:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 8005860:	6878      	ldr	r0, [r7, #4]
 8005862:	4798      	blx	r3
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
 8005864:	e21a      	b.n	8005c9c <HAL_DMA_IRQHandler+0xe78>
 8005866:	bf00      	nop
 8005868:	40020010 	.word	0x40020010
 800586c:	40020028 	.word	0x40020028
 8005870:	40020040 	.word	0x40020040
 8005874:	40020058 	.word	0x40020058
 8005878:	40020070 	.word	0x40020070
 800587c:	40020088 	.word	0x40020088
 8005880:	400200a0 	.word	0x400200a0
 8005884:	400200b8 	.word	0x400200b8
 8005888:	40020410 	.word	0x40020410
 800588c:	40020428 	.word	0x40020428
 8005890:	40020440 	.word	0x40020440
 8005894:	40020458 	.word	0x40020458
 8005898:	40020470 	.word	0x40020470
 800589c:	40020488 	.word	0x40020488
 80058a0:	400204a0 	.word	0x400204a0
 80058a4:	400204b8 	.word	0x400204b8
 80058a8:	48022c08 	.word	0x48022c08
 80058ac:	48022c1c 	.word	0x48022c1c
 80058b0:	48022c30 	.word	0x48022c30
 80058b4:	48022c44 	.word	0x48022c44
 80058b8:	48022c58 	.word	0x48022c58
 80058bc:	48022c6c 	.word	0x48022c6c
 80058c0:	48022c80 	.word	0x48022c80
 80058c4:	48022c94 	.word	0x48022c94
 80058c8:	58025408 	.word	0x58025408
 80058cc:	5802541c 	.word	0x5802541c
 80058d0:	58025430 	.word	0x58025430
 80058d4:	58025444 	.word	0x58025444
 80058d8:	58025458 	.word	0x58025458
 80058dc:	5802546c 	.word	0x5802546c
 80058e0:	58025480 	.word	0x58025480
 80058e4:	58025494 	.word	0x58025494
          }
        }
        /* Current memory buffer used is Memory 1 */
        else
        {
          if(hdma->XferHalfCpltCallback != NULL)
 80058e8:	687b      	ldr	r3, [r7, #4]
 80058ea:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 80058ec:	2b00      	cmp	r3, #0
 80058ee:	f000 81d5 	beq.w	8005c9c <HAL_DMA_IRQHandler+0xe78>
          {
            /* Half transfer Callback for Memory 0 */
            hdma->XferHalfCpltCallback(hdma);
 80058f2:	687b      	ldr	r3, [r7, #4]
 80058f4:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 80058f6:	6878      	ldr	r0, [r7, #4]
 80058f8:	4798      	blx	r3
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
 80058fa:	e1cf      	b.n	8005c9c <HAL_DMA_IRQHandler+0xe78>
          }
        }
      }
      else
      {
        if((ccr_reg & BDMA_CCR_CIRC) == 0U)
 80058fc:	693b      	ldr	r3, [r7, #16]
 80058fe:	f003 0320 	and.w	r3, r3, #32
 8005902:	2b00      	cmp	r3, #0
 8005904:	d160      	bne.n	80059c8 <HAL_DMA_IRQHandler+0xba4>
        {
          /* Disable the half transfer interrupt */
          __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
 8005906:	687b      	ldr	r3, [r7, #4]
 8005908:	681b      	ldr	r3, [r3, #0]
 800590a:	4a7f      	ldr	r2, [pc, #508]	@ (8005b08 <HAL_DMA_IRQHandler+0xce4>)
 800590c:	4293      	cmp	r3, r2
 800590e:	d04a      	beq.n	80059a6 <HAL_DMA_IRQHandler+0xb82>
 8005910:	687b      	ldr	r3, [r7, #4]
 8005912:	681b      	ldr	r3, [r3, #0]
 8005914:	4a7d      	ldr	r2, [pc, #500]	@ (8005b0c <HAL_DMA_IRQHandler+0xce8>)
 8005916:	4293      	cmp	r3, r2
 8005918:	d045      	beq.n	80059a6 <HAL_DMA_IRQHandler+0xb82>
 800591a:	687b      	ldr	r3, [r7, #4]
 800591c:	681b      	ldr	r3, [r3, #0]
 800591e:	4a7c      	ldr	r2, [pc, #496]	@ (8005b10 <HAL_DMA_IRQHandler+0xcec>)
 8005920:	4293      	cmp	r3, r2
 8005922:	d040      	beq.n	80059a6 <HAL_DMA_IRQHandler+0xb82>
 8005924:	687b      	ldr	r3, [r7, #4]
 8005926:	681b      	ldr	r3, [r3, #0]
 8005928:	4a7a      	ldr	r2, [pc, #488]	@ (8005b14 <HAL_DMA_IRQHandler+0xcf0>)
 800592a:	4293      	cmp	r3, r2
 800592c:	d03b      	beq.n	80059a6 <HAL_DMA_IRQHandler+0xb82>
 800592e:	687b      	ldr	r3, [r7, #4]
 8005930:	681b      	ldr	r3, [r3, #0]
 8005932:	4a79      	ldr	r2, [pc, #484]	@ (8005b18 <HAL_DMA_IRQHandler+0xcf4>)
 8005934:	4293      	cmp	r3, r2
 8005936:	d036      	beq.n	80059a6 <HAL_DMA_IRQHandler+0xb82>
 8005938:	687b      	ldr	r3, [r7, #4]
 800593a:	681b      	ldr	r3, [r3, #0]
 800593c:	4a77      	ldr	r2, [pc, #476]	@ (8005b1c <HAL_DMA_IRQHandler+0xcf8>)
 800593e:	4293      	cmp	r3, r2
 8005940:	d031      	beq.n	80059a6 <HAL_DMA_IRQHandler+0xb82>
 8005942:	687b      	ldr	r3, [r7, #4]
 8005944:	681b      	ldr	r3, [r3, #0]
 8005946:	4a76      	ldr	r2, [pc, #472]	@ (8005b20 <HAL_DMA_IRQHandler+0xcfc>)
 8005948:	4293      	cmp	r3, r2
 800594a:	d02c      	beq.n	80059a6 <HAL_DMA_IRQHandler+0xb82>
 800594c:	687b      	ldr	r3, [r7, #4]
 800594e:	681b      	ldr	r3, [r3, #0]
 8005950:	4a74      	ldr	r2, [pc, #464]	@ (8005b24 <HAL_DMA_IRQHandler+0xd00>)
 8005952:	4293      	cmp	r3, r2
 8005954:	d027      	beq.n	80059a6 <HAL_DMA_IRQHandler+0xb82>
 8005956:	687b      	ldr	r3, [r7, #4]
 8005958:	681b      	ldr	r3, [r3, #0]
 800595a:	4a73      	ldr	r2, [pc, #460]	@ (8005b28 <HAL_DMA_IRQHandler+0xd04>)
 800595c:	4293      	cmp	r3, r2
 800595e:	d022      	beq.n	80059a6 <HAL_DMA_IRQHandler+0xb82>
 8005960:	687b      	ldr	r3, [r7, #4]
 8005962:	681b      	ldr	r3, [r3, #0]
 8005964:	4a71      	ldr	r2, [pc, #452]	@ (8005b2c <HAL_DMA_IRQHandler+0xd08>)
 8005966:	4293      	cmp	r3, r2
 8005968:	d01d      	beq.n	80059a6 <HAL_DMA_IRQHandler+0xb82>
 800596a:	687b      	ldr	r3, [r7, #4]
 800596c:	681b      	ldr	r3, [r3, #0]
 800596e:	4a70      	ldr	r2, [pc, #448]	@ (8005b30 <HAL_DMA_IRQHandler+0xd0c>)
 8005970:	4293      	cmp	r3, r2
 8005972:	d018      	beq.n	80059a6 <HAL_DMA_IRQHandler+0xb82>
 8005974:	687b      	ldr	r3, [r7, #4]
 8005976:	681b      	ldr	r3, [r3, #0]
 8005978:	4a6e      	ldr	r2, [pc, #440]	@ (8005b34 <HAL_DMA_IRQHandler+0xd10>)
 800597a:	4293      	cmp	r3, r2
 800597c:	d013      	beq.n	80059a6 <HAL_DMA_IRQHandler+0xb82>
 800597e:	687b      	ldr	r3, [r7, #4]
 8005980:	681b      	ldr	r3, [r3, #0]
 8005982:	4a6d      	ldr	r2, [pc, #436]	@ (8005b38 <HAL_DMA_IRQHandler+0xd14>)
 8005984:	4293      	cmp	r3, r2
 8005986:	d00e      	beq.n	80059a6 <HAL_DMA_IRQHandler+0xb82>
 8005988:	687b      	ldr	r3, [r7, #4]
 800598a:	681b      	ldr	r3, [r3, #0]
 800598c:	4a6b      	ldr	r2, [pc, #428]	@ (8005b3c <HAL_DMA_IRQHandler+0xd18>)
 800598e:	4293      	cmp	r3, r2
 8005990:	d009      	beq.n	80059a6 <HAL_DMA_IRQHandler+0xb82>
 8005992:	687b      	ldr	r3, [r7, #4]
 8005994:	681b      	ldr	r3, [r3, #0]
 8005996:	4a6a      	ldr	r2, [pc, #424]	@ (8005b40 <HAL_DMA_IRQHandler+0xd1c>)
 8005998:	4293      	cmp	r3, r2
 800599a:	d004      	beq.n	80059a6 <HAL_DMA_IRQHandler+0xb82>
 800599c:	687b      	ldr	r3, [r7, #4]
 800599e:	681b      	ldr	r3, [r3, #0]
 80059a0:	4a68      	ldr	r2, [pc, #416]	@ (8005b44 <HAL_DMA_IRQHandler+0xd20>)
 80059a2:	4293      	cmp	r3, r2
 80059a4:	d108      	bne.n	80059b8 <HAL_DMA_IRQHandler+0xb94>
 80059a6:	687b      	ldr	r3, [r7, #4]
 80059a8:	681b      	ldr	r3, [r3, #0]
 80059aa:	681a      	ldr	r2, [r3, #0]
 80059ac:	687b      	ldr	r3, [r7, #4]
 80059ae:	681b      	ldr	r3, [r3, #0]
 80059b0:	f022 0208 	bic.w	r2, r2, #8
 80059b4:	601a      	str	r2, [r3, #0]
 80059b6:	e007      	b.n	80059c8 <HAL_DMA_IRQHandler+0xba4>
 80059b8:	687b      	ldr	r3, [r7, #4]
 80059ba:	681b      	ldr	r3, [r3, #0]
 80059bc:	681a      	ldr	r2, [r3, #0]
 80059be:	687b      	ldr	r3, [r7, #4]
 80059c0:	681b      	ldr	r3, [r3, #0]
 80059c2:	f022 0204 	bic.w	r2, r2, #4
 80059c6:	601a      	str	r2, [r3, #0]
        }

        /* DMA peripheral state is not updated in Half Transfer */
        /* but in Transfer Complete case */

       if(hdma->XferHalfCpltCallback != NULL)
 80059c8:	687b      	ldr	r3, [r7, #4]
 80059ca:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 80059cc:	2b00      	cmp	r3, #0
 80059ce:	f000 8165 	beq.w	8005c9c <HAL_DMA_IRQHandler+0xe78>
        {
          /* Half transfer callback */
          hdma->XferHalfCpltCallback(hdma);
 80059d2:	687b      	ldr	r3, [r7, #4]
 80059d4:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 80059d6:	6878      	ldr	r0, [r7, #4]
 80059d8:	4798      	blx	r3
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
 80059da:	e15f      	b.n	8005c9c <HAL_DMA_IRQHandler+0xe78>
        }
      }
    }

    /* Transfer Complete Interrupt management ***********************************/
    else if (((tmpisr_bdma & (BDMA_FLAG_TC0 << (hdma->StreamIndex & 0x1FU))) != 0U) && ((ccr_reg & BDMA_CCR_TCIE) != 0U))
 80059dc:	687b      	ldr	r3, [r7, #4]
 80059de:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 80059e0:	f003 031f 	and.w	r3, r3, #31
 80059e4:	2202      	movs	r2, #2
 80059e6:	409a      	lsls	r2, r3
 80059e8:	697b      	ldr	r3, [r7, #20]
 80059ea:	4013      	ands	r3, r2
 80059ec:	2b00      	cmp	r3, #0
 80059ee:	f000 80c5 	beq.w	8005b7c <HAL_DMA_IRQHandler+0xd58>
 80059f2:	693b      	ldr	r3, [r7, #16]
 80059f4:	f003 0302 	and.w	r3, r3, #2
 80059f8:	2b00      	cmp	r3, #0
 80059fa:	f000 80bf 	beq.w	8005b7c <HAL_DMA_IRQHandler+0xd58>
    {
      /* Clear the transfer complete flag */
      regs_bdma->IFCR = (BDMA_ISR_TCIF0) << (hdma->StreamIndex & 0x1FU);
 80059fe:	687b      	ldr	r3, [r7, #4]
 8005a00:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 8005a02:	f003 031f 	and.w	r3, r3, #31
 8005a06:	2202      	movs	r2, #2
 8005a08:	409a      	lsls	r2, r3
 8005a0a:	69fb      	ldr	r3, [r7, #28]
 8005a0c:	605a      	str	r2, [r3, #4]

      /* Disable the transfer complete interrupt if the DMA mode is Double Buffering */
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
 8005a0e:	693b      	ldr	r3, [r7, #16]
 8005a10:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
 8005a14:	2b00      	cmp	r3, #0
 8005a16:	d018      	beq.n	8005a4a <HAL_DMA_IRQHandler+0xc26>
      {
        /* Current memory buffer used is Memory 0 */
        if((ccr_reg & BDMA_CCR_CT) == 0U)
 8005a18:	693b      	ldr	r3, [r7, #16]
 8005a1a:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 8005a1e:	2b00      	cmp	r3, #0
 8005a20:	d109      	bne.n	8005a36 <HAL_DMA_IRQHandler+0xc12>
        {
          if(hdma->XferM1CpltCallback != NULL)
 8005a22:	687b      	ldr	r3, [r7, #4]
 8005a24:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8005a26:	2b00      	cmp	r3, #0
 8005a28:	f000 813a 	beq.w	8005ca0 <HAL_DMA_IRQHandler+0xe7c>
          {
            /* Transfer complete Callback for Memory 1 */
            hdma->XferM1CpltCallback(hdma);
 8005a2c:	687b      	ldr	r3, [r7, #4]
 8005a2e:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8005a30:	6878      	ldr	r0, [r7, #4]
 8005a32:	4798      	blx	r3
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
 8005a34:	e134      	b.n	8005ca0 <HAL_DMA_IRQHandler+0xe7c>
          }
        }
        /* Current memory buffer used is Memory 1 */
        else
        {
          if(hdma->XferCpltCallback != NULL)
 8005a36:	687b      	ldr	r3, [r7, #4]
 8005a38:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8005a3a:	2b00      	cmp	r3, #0
 8005a3c:	f000 8130 	beq.w	8005ca0 <HAL_DMA_IRQHandler+0xe7c>
          {
            /* Transfer complete Callback for Memory 0 */
            hdma->XferCpltCallback(hdma);
 8005a40:	687b      	ldr	r3, [r7, #4]
 8005a42:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8005a44:	6878      	ldr	r0, [r7, #4]
 8005a46:	4798      	blx	r3
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
 8005a48:	e12a      	b.n	8005ca0 <HAL_DMA_IRQHandler+0xe7c>
          }
        }
      }
      else
      {
        if((ccr_reg & BDMA_CCR_CIRC) == 0U)
 8005a4a:	693b      	ldr	r3, [r7, #16]
 8005a4c:	f003 0320 	and.w	r3, r3, #32
 8005a50:	2b00      	cmp	r3, #0
 8005a52:	f040 8089 	bne.w	8005b68 <HAL_DMA_IRQHandler+0xd44>
        {
          /* Disable the transfer complete and error interrupt, if the DMA mode is not CIRCULAR */
          __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE | DMA_IT_TC);
 8005a56:	687b      	ldr	r3, [r7, #4]
 8005a58:	681b      	ldr	r3, [r3, #0]
 8005a5a:	4a2b      	ldr	r2, [pc, #172]	@ (8005b08 <HAL_DMA_IRQHandler+0xce4>)
 8005a5c:	4293      	cmp	r3, r2
 8005a5e:	d04a      	beq.n	8005af6 <HAL_DMA_IRQHandler+0xcd2>
 8005a60:	687b      	ldr	r3, [r7, #4]
 8005a62:	681b      	ldr	r3, [r3, #0]
 8005a64:	4a29      	ldr	r2, [pc, #164]	@ (8005b0c <HAL_DMA_IRQHandler+0xce8>)
 8005a66:	4293      	cmp	r3, r2
 8005a68:	d045      	beq.n	8005af6 <HAL_DMA_IRQHandler+0xcd2>
 8005a6a:	687b      	ldr	r3, [r7, #4]
 8005a6c:	681b      	ldr	r3, [r3, #0]
 8005a6e:	4a28      	ldr	r2, [pc, #160]	@ (8005b10 <HAL_DMA_IRQHandler+0xcec>)
 8005a70:	4293      	cmp	r3, r2
 8005a72:	d040      	beq.n	8005af6 <HAL_DMA_IRQHandler+0xcd2>
 8005a74:	687b      	ldr	r3, [r7, #4]
 8005a76:	681b      	ldr	r3, [r3, #0]
 8005a78:	4a26      	ldr	r2, [pc, #152]	@ (8005b14 <HAL_DMA_IRQHandler+0xcf0>)
 8005a7a:	4293      	cmp	r3, r2
 8005a7c:	d03b      	beq.n	8005af6 <HAL_DMA_IRQHandler+0xcd2>
 8005a7e:	687b      	ldr	r3, [r7, #4]
 8005a80:	681b      	ldr	r3, [r3, #0]
 8005a82:	4a25      	ldr	r2, [pc, #148]	@ (8005b18 <HAL_DMA_IRQHandler+0xcf4>)
 8005a84:	4293      	cmp	r3, r2
 8005a86:	d036      	beq.n	8005af6 <HAL_DMA_IRQHandler+0xcd2>
 8005a88:	687b      	ldr	r3, [r7, #4]
 8005a8a:	681b      	ldr	r3, [r3, #0]
 8005a8c:	4a23      	ldr	r2, [pc, #140]	@ (8005b1c <HAL_DMA_IRQHandler+0xcf8>)
 8005a8e:	4293      	cmp	r3, r2
 8005a90:	d031      	beq.n	8005af6 <HAL_DMA_IRQHandler+0xcd2>
 8005a92:	687b      	ldr	r3, [r7, #4]
 8005a94:	681b      	ldr	r3, [r3, #0]
 8005a96:	4a22      	ldr	r2, [pc, #136]	@ (8005b20 <HAL_DMA_IRQHandler+0xcfc>)
 8005a98:	4293      	cmp	r3, r2
 8005a9a:	d02c      	beq.n	8005af6 <HAL_DMA_IRQHandler+0xcd2>
 8005a9c:	687b      	ldr	r3, [r7, #4]
 8005a9e:	681b      	ldr	r3, [r3, #0]
 8005aa0:	4a20      	ldr	r2, [pc, #128]	@ (8005b24 <HAL_DMA_IRQHandler+0xd00>)
 8005aa2:	4293      	cmp	r3, r2
 8005aa4:	d027      	beq.n	8005af6 <HAL_DMA_IRQHandler+0xcd2>
 8005aa6:	687b      	ldr	r3, [r7, #4]
 8005aa8:	681b      	ldr	r3, [r3, #0]
 8005aaa:	4a1f      	ldr	r2, [pc, #124]	@ (8005b28 <HAL_DMA_IRQHandler+0xd04>)
 8005aac:	4293      	cmp	r3, r2
 8005aae:	d022      	beq.n	8005af6 <HAL_DMA_IRQHandler+0xcd2>
 8005ab0:	687b      	ldr	r3, [r7, #4]
 8005ab2:	681b      	ldr	r3, [r3, #0]
 8005ab4:	4a1d      	ldr	r2, [pc, #116]	@ (8005b2c <HAL_DMA_IRQHandler+0xd08>)
 8005ab6:	4293      	cmp	r3, r2
 8005ab8:	d01d      	beq.n	8005af6 <HAL_DMA_IRQHandler+0xcd2>
 8005aba:	687b      	ldr	r3, [r7, #4]
 8005abc:	681b      	ldr	r3, [r3, #0]
 8005abe:	4a1c      	ldr	r2, [pc, #112]	@ (8005b30 <HAL_DMA_IRQHandler+0xd0c>)
 8005ac0:	4293      	cmp	r3, r2
 8005ac2:	d018      	beq.n	8005af6 <HAL_DMA_IRQHandler+0xcd2>
 8005ac4:	687b      	ldr	r3, [r7, #4]
 8005ac6:	681b      	ldr	r3, [r3, #0]
 8005ac8:	4a1a      	ldr	r2, [pc, #104]	@ (8005b34 <HAL_DMA_IRQHandler+0xd10>)
 8005aca:	4293      	cmp	r3, r2
 8005acc:	d013      	beq.n	8005af6 <HAL_DMA_IRQHandler+0xcd2>
 8005ace:	687b      	ldr	r3, [r7, #4]
 8005ad0:	681b      	ldr	r3, [r3, #0]
 8005ad2:	4a19      	ldr	r2, [pc, #100]	@ (8005b38 <HAL_DMA_IRQHandler+0xd14>)
 8005ad4:	4293      	cmp	r3, r2
 8005ad6:	d00e      	beq.n	8005af6 <HAL_DMA_IRQHandler+0xcd2>
 8005ad8:	687b      	ldr	r3, [r7, #4]
 8005ada:	681b      	ldr	r3, [r3, #0]
 8005adc:	4a17      	ldr	r2, [pc, #92]	@ (8005b3c <HAL_DMA_IRQHandler+0xd18>)
 8005ade:	4293      	cmp	r3, r2
 8005ae0:	d009      	beq.n	8005af6 <HAL_DMA_IRQHandler+0xcd2>
 8005ae2:	687b      	ldr	r3, [r7, #4]
 8005ae4:	681b      	ldr	r3, [r3, #0]
 8005ae6:	4a16      	ldr	r2, [pc, #88]	@ (8005b40 <HAL_DMA_IRQHandler+0xd1c>)
 8005ae8:	4293      	cmp	r3, r2
 8005aea:	d004      	beq.n	8005af6 <HAL_DMA_IRQHandler+0xcd2>
 8005aec:	687b      	ldr	r3, [r7, #4]
 8005aee:	681b      	ldr	r3, [r3, #0]
 8005af0:	4a14      	ldr	r2, [pc, #80]	@ (8005b44 <HAL_DMA_IRQHandler+0xd20>)
 8005af2:	4293      	cmp	r3, r2
 8005af4:	d128      	bne.n	8005b48 <HAL_DMA_IRQHandler+0xd24>
 8005af6:	687b      	ldr	r3, [r7, #4]
 8005af8:	681b      	ldr	r3, [r3, #0]
 8005afa:	681a      	ldr	r2, [r3, #0]
 8005afc:	687b      	ldr	r3, [r7, #4]
 8005afe:	681b      	ldr	r3, [r3, #0]
 8005b00:	f022 0214 	bic.w	r2, r2, #20
 8005b04:	601a      	str	r2, [r3, #0]
 8005b06:	e027      	b.n	8005b58 <HAL_DMA_IRQHandler+0xd34>
 8005b08:	40020010 	.word	0x40020010
 8005b0c:	40020028 	.word	0x40020028
 8005b10:	40020040 	.word	0x40020040
 8005b14:	40020058 	.word	0x40020058
 8005b18:	40020070 	.word	0x40020070
 8005b1c:	40020088 	.word	0x40020088
 8005b20:	400200a0 	.word	0x400200a0
 8005b24:	400200b8 	.word	0x400200b8
 8005b28:	40020410 	.word	0x40020410
 8005b2c:	40020428 	.word	0x40020428
 8005b30:	40020440 	.word	0x40020440
 8005b34:	40020458 	.word	0x40020458
 8005b38:	40020470 	.word	0x40020470
 8005b3c:	40020488 	.word	0x40020488
 8005b40:	400204a0 	.word	0x400204a0
 8005b44:	400204b8 	.word	0x400204b8
 8005b48:	687b      	ldr	r3, [r7, #4]
 8005b4a:	681b      	ldr	r3, [r3, #0]
 8005b4c:	681a      	ldr	r2, [r3, #0]
 8005b4e:	687b      	ldr	r3, [r7, #4]
 8005b50:	681b      	ldr	r3, [r3, #0]
 8005b52:	f022 020a 	bic.w	r2, r2, #10
 8005b56:	601a      	str	r2, [r3, #0]

          /* Change the DMA state */
          hdma->State = HAL_DMA_STATE_READY;
 8005b58:	687b      	ldr	r3, [r7, #4]
 8005b5a:	2201      	movs	r2, #1
 8005b5c:	f883 2035 	strb.w	r2, [r3, #53]	@ 0x35

          /* Process Unlocked */
          __HAL_UNLOCK(hdma);
 8005b60:	687b      	ldr	r3, [r7, #4]
 8005b62:	2200      	movs	r2, #0
 8005b64:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34
        }

        if(hdma->XferCpltCallback != NULL)
 8005b68:	687b      	ldr	r3, [r7, #4]
 8005b6a:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8005b6c:	2b00      	cmp	r3, #0
 8005b6e:	f000 8097 	beq.w	8005ca0 <HAL_DMA_IRQHandler+0xe7c>
        {
          /* Transfer complete callback */
          hdma->XferCpltCallback(hdma);
 8005b72:	687b      	ldr	r3, [r7, #4]
 8005b74:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8005b76:	6878      	ldr	r0, [r7, #4]
 8005b78:	4798      	blx	r3
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
 8005b7a:	e091      	b.n	8005ca0 <HAL_DMA_IRQHandler+0xe7c>
        }
      }
    }
    /* Transfer Error Interrupt management **************************************/
    else if (((tmpisr_bdma & (BDMA_FLAG_TE0 << (hdma->StreamIndex & 0x1FU))) != 0U) && ((ccr_reg & BDMA_CCR_TEIE) != 0U))
 8005b7c:	687b      	ldr	r3, [r7, #4]
 8005b7e:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 8005b80:	f003 031f 	and.w	r3, r3, #31
 8005b84:	2208      	movs	r2, #8
 8005b86:	409a      	lsls	r2, r3
 8005b88:	697b      	ldr	r3, [r7, #20]
 8005b8a:	4013      	ands	r3, r2
 8005b8c:	2b00      	cmp	r3, #0
 8005b8e:	f000 8088 	beq.w	8005ca2 <HAL_DMA_IRQHandler+0xe7e>
 8005b92:	693b      	ldr	r3, [r7, #16]
 8005b94:	f003 0308 	and.w	r3, r3, #8
 8005b98:	2b00      	cmp	r3, #0
 8005b9a:	f000 8082 	beq.w	8005ca2 <HAL_DMA_IRQHandler+0xe7e>
    {
      /* When a DMA transfer error occurs */
      /* A hardware clear of its EN bits is performed */
      /* Disable ALL DMA IT */
      __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 8005b9e:	687b      	ldr	r3, [r7, #4]
 8005ba0:	681b      	ldr	r3, [r3, #0]
 8005ba2:	4a41      	ldr	r2, [pc, #260]	@ (8005ca8 <HAL_DMA_IRQHandler+0xe84>)
 8005ba4:	4293      	cmp	r3, r2
 8005ba6:	d04a      	beq.n	8005c3e <HAL_DMA_IRQHandler+0xe1a>
 8005ba8:	687b      	ldr	r3, [r7, #4]
 8005baa:	681b      	ldr	r3, [r3, #0]
 8005bac:	4a3f      	ldr	r2, [pc, #252]	@ (8005cac <HAL_DMA_IRQHandler+0xe88>)
 8005bae:	4293      	cmp	r3, r2
 8005bb0:	d045      	beq.n	8005c3e <HAL_DMA_IRQHandler+0xe1a>
 8005bb2:	687b      	ldr	r3, [r7, #4]
 8005bb4:	681b      	ldr	r3, [r3, #0]
 8005bb6:	4a3e      	ldr	r2, [pc, #248]	@ (8005cb0 <HAL_DMA_IRQHandler+0xe8c>)
 8005bb8:	4293      	cmp	r3, r2
 8005bba:	d040      	beq.n	8005c3e <HAL_DMA_IRQHandler+0xe1a>
 8005bbc:	687b      	ldr	r3, [r7, #4]
 8005bbe:	681b      	ldr	r3, [r3, #0]
 8005bc0:	4a3c      	ldr	r2, [pc, #240]	@ (8005cb4 <HAL_DMA_IRQHandler+0xe90>)
 8005bc2:	4293      	cmp	r3, r2
 8005bc4:	d03b      	beq.n	8005c3e <HAL_DMA_IRQHandler+0xe1a>
 8005bc6:	687b      	ldr	r3, [r7, #4]
 8005bc8:	681b      	ldr	r3, [r3, #0]
 8005bca:	4a3b      	ldr	r2, [pc, #236]	@ (8005cb8 <HAL_DMA_IRQHandler+0xe94>)
 8005bcc:	4293      	cmp	r3, r2
 8005bce:	d036      	beq.n	8005c3e <HAL_DMA_IRQHandler+0xe1a>
 8005bd0:	687b      	ldr	r3, [r7, #4]
 8005bd2:	681b      	ldr	r3, [r3, #0]
 8005bd4:	4a39      	ldr	r2, [pc, #228]	@ (8005cbc <HAL_DMA_IRQHandler+0xe98>)
 8005bd6:	4293      	cmp	r3, r2
 8005bd8:	d031      	beq.n	8005c3e <HAL_DMA_IRQHandler+0xe1a>
 8005bda:	687b      	ldr	r3, [r7, #4]
 8005bdc:	681b      	ldr	r3, [r3, #0]
 8005bde:	4a38      	ldr	r2, [pc, #224]	@ (8005cc0 <HAL_DMA_IRQHandler+0xe9c>)
 8005be0:	4293      	cmp	r3, r2
 8005be2:	d02c      	beq.n	8005c3e <HAL_DMA_IRQHandler+0xe1a>
 8005be4:	687b      	ldr	r3, [r7, #4]
 8005be6:	681b      	ldr	r3, [r3, #0]
 8005be8:	4a36      	ldr	r2, [pc, #216]	@ (8005cc4 <HAL_DMA_IRQHandler+0xea0>)
 8005bea:	4293      	cmp	r3, r2
 8005bec:	d027      	beq.n	8005c3e <HAL_DMA_IRQHandler+0xe1a>
 8005bee:	687b      	ldr	r3, [r7, #4]
 8005bf0:	681b      	ldr	r3, [r3, #0]
 8005bf2:	4a35      	ldr	r2, [pc, #212]	@ (8005cc8 <HAL_DMA_IRQHandler+0xea4>)
 8005bf4:	4293      	cmp	r3, r2
 8005bf6:	d022      	beq.n	8005c3e <HAL_DMA_IRQHandler+0xe1a>
 8005bf8:	687b      	ldr	r3, [r7, #4]
 8005bfa:	681b      	ldr	r3, [r3, #0]
 8005bfc:	4a33      	ldr	r2, [pc, #204]	@ (8005ccc <HAL_DMA_IRQHandler+0xea8>)
 8005bfe:	4293      	cmp	r3, r2
 8005c00:	d01d      	beq.n	8005c3e <HAL_DMA_IRQHandler+0xe1a>
 8005c02:	687b      	ldr	r3, [r7, #4]
 8005c04:	681b      	ldr	r3, [r3, #0]
 8005c06:	4a32      	ldr	r2, [pc, #200]	@ (8005cd0 <HAL_DMA_IRQHandler+0xeac>)
 8005c08:	4293      	cmp	r3, r2
 8005c0a:	d018      	beq.n	8005c3e <HAL_DMA_IRQHandler+0xe1a>
 8005c0c:	687b      	ldr	r3, [r7, #4]
 8005c0e:	681b      	ldr	r3, [r3, #0]
 8005c10:	4a30      	ldr	r2, [pc, #192]	@ (8005cd4 <HAL_DMA_IRQHandler+0xeb0>)
 8005c12:	4293      	cmp	r3, r2
 8005c14:	d013      	beq.n	8005c3e <HAL_DMA_IRQHandler+0xe1a>
 8005c16:	687b      	ldr	r3, [r7, #4]
 8005c18:	681b      	ldr	r3, [r3, #0]
 8005c1a:	4a2f      	ldr	r2, [pc, #188]	@ (8005cd8 <HAL_DMA_IRQHandler+0xeb4>)
 8005c1c:	4293      	cmp	r3, r2
 8005c1e:	d00e      	beq.n	8005c3e <HAL_DMA_IRQHandler+0xe1a>
 8005c20:	687b      	ldr	r3, [r7, #4]
 8005c22:	681b      	ldr	r3, [r3, #0]
 8005c24:	4a2d      	ldr	r2, [pc, #180]	@ (8005cdc <HAL_DMA_IRQHandler+0xeb8>)
 8005c26:	4293      	cmp	r3, r2
 8005c28:	d009      	beq.n	8005c3e <HAL_DMA_IRQHandler+0xe1a>
 8005c2a:	687b      	ldr	r3, [r7, #4]
 8005c2c:	681b      	ldr	r3, [r3, #0]
 8005c2e:	4a2c      	ldr	r2, [pc, #176]	@ (8005ce0 <HAL_DMA_IRQHandler+0xebc>)
 8005c30:	4293      	cmp	r3, r2
 8005c32:	d004      	beq.n	8005c3e <HAL_DMA_IRQHandler+0xe1a>
 8005c34:	687b      	ldr	r3, [r7, #4]
 8005c36:	681b      	ldr	r3, [r3, #0]
 8005c38:	4a2a      	ldr	r2, [pc, #168]	@ (8005ce4 <HAL_DMA_IRQHandler+0xec0>)
 8005c3a:	4293      	cmp	r3, r2
 8005c3c:	d108      	bne.n	8005c50 <HAL_DMA_IRQHandler+0xe2c>
 8005c3e:	687b      	ldr	r3, [r7, #4]
 8005c40:	681b      	ldr	r3, [r3, #0]
 8005c42:	681a      	ldr	r2, [r3, #0]
 8005c44:	687b      	ldr	r3, [r7, #4]
 8005c46:	681b      	ldr	r3, [r3, #0]
 8005c48:	f022 021c 	bic.w	r2, r2, #28
 8005c4c:	601a      	str	r2, [r3, #0]
 8005c4e:	e007      	b.n	8005c60 <HAL_DMA_IRQHandler+0xe3c>
 8005c50:	687b      	ldr	r3, [r7, #4]
 8005c52:	681b      	ldr	r3, [r3, #0]
 8005c54:	681a      	ldr	r2, [r3, #0]
 8005c56:	687b      	ldr	r3, [r7, #4]
 8005c58:	681b      	ldr	r3, [r3, #0]
 8005c5a:	f022 020e 	bic.w	r2, r2, #14
 8005c5e:	601a      	str	r2, [r3, #0]

      /* Clear all flags */
      regs_bdma->IFCR = (BDMA_ISR_GIF0) << (hdma->StreamIndex & 0x1FU);
 8005c60:	687b      	ldr	r3, [r7, #4]
 8005c62:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 8005c64:	f003 031f 	and.w	r3, r3, #31
 8005c68:	2201      	movs	r2, #1
 8005c6a:	409a      	lsls	r2, r3
 8005c6c:	69fb      	ldr	r3, [r7, #28]
 8005c6e:	605a      	str	r2, [r3, #4]

      /* Update error code */
      hdma->ErrorCode = HAL_DMA_ERROR_TE;
 8005c70:	687b      	ldr	r3, [r7, #4]
 8005c72:	2201      	movs	r2, #1
 8005c74:	655a      	str	r2, [r3, #84]	@ 0x54

      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_READY;
 8005c76:	687b      	ldr	r3, [r7, #4]
 8005c78:	2201      	movs	r2, #1
 8005c7a:	f883 2035 	strb.w	r2, [r3, #53]	@ 0x35

      /* Process Unlocked */
      __HAL_UNLOCK(hdma);
 8005c7e:	687b      	ldr	r3, [r7, #4]
 8005c80:	2200      	movs	r2, #0
 8005c82:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34

      if (hdma->XferErrorCallback != NULL)
 8005c86:	687b      	ldr	r3, [r7, #4]
 8005c88:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 8005c8a:	2b00      	cmp	r3, #0
 8005c8c:	d009      	beq.n	8005ca2 <HAL_DMA_IRQHandler+0xe7e>
      {
        /* Transfer error callback */
        hdma->XferErrorCallback(hdma);
 8005c8e:	687b      	ldr	r3, [r7, #4]
 8005c90:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 8005c92:	6878      	ldr	r0, [r7, #4]
 8005c94:	4798      	blx	r3
 8005c96:	e004      	b.n	8005ca2 <HAL_DMA_IRQHandler+0xe7e>
          return;
 8005c98:	bf00      	nop
 8005c9a:	e002      	b.n	8005ca2 <HAL_DMA_IRQHandler+0xe7e>
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
 8005c9c:	bf00      	nop
 8005c9e:	e000      	b.n	8005ca2 <HAL_DMA_IRQHandler+0xe7e>
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
 8005ca0:	bf00      	nop
  }
  else
  {
    /* Nothing To Do */
  }
}
 8005ca2:	3728      	adds	r7, #40	@ 0x28
 8005ca4:	46bd      	mov	sp, r7
 8005ca6:	bd80      	pop	{r7, pc}
 8005ca8:	40020010 	.word	0x40020010
 8005cac:	40020028 	.word	0x40020028
 8005cb0:	40020040 	.word	0x40020040
 8005cb4:	40020058 	.word	0x40020058
 8005cb8:	40020070 	.word	0x40020070
 8005cbc:	40020088 	.word	0x40020088
 8005cc0:	400200a0 	.word	0x400200a0
 8005cc4:	400200b8 	.word	0x400200b8
 8005cc8:	40020410 	.word	0x40020410
 8005ccc:	40020428 	.word	0x40020428
 8005cd0:	40020440 	.word	0x40020440
 8005cd4:	40020458 	.word	0x40020458
 8005cd8:	40020470 	.word	0x40020470
 8005cdc:	40020488 	.word	0x40020488
 8005ce0:	400204a0 	.word	0x400204a0
 8005ce4:	400204b8 	.word	0x400204b8

08005ce8 <HAL_DMA_GetError>:
  * @param  hdma : pointer to a DMA_HandleTypeDef structure that contains
  *              the configuration information for the specified DMA Stream.
  * @retval DMA Error Code
  */
uint32_t HAL_DMA_GetError(DMA_HandleTypeDef *hdma)
{
 8005ce8:	b480      	push	{r7}
 8005cea:	b083      	sub	sp, #12
 8005cec:	af00      	add	r7, sp, #0
 8005cee:	6078      	str	r0, [r7, #4]
  return hdma->ErrorCode;
 8005cf0:	687b      	ldr	r3, [r7, #4]
 8005cf2:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
}
 8005cf4:	4618      	mov	r0, r3
 8005cf6:	370c      	adds	r7, #12
 8005cf8:	46bd      	mov	sp, r7
 8005cfa:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005cfe:	4770      	bx	lr

08005d00 <DMA_SetConfig>:
  * @param  DstAddress: The destination memory Buffer address
  * @param  DataLength: The length of data to be transferred from source to destination
  * @retval None
  */
static void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
 8005d00:	b480      	push	{r7}
 8005d02:	b087      	sub	sp, #28
 8005d04:	af00      	add	r7, sp, #0
 8005d06:	60f8      	str	r0, [r7, #12]
 8005d08:	60b9      	str	r1, [r7, #8]
 8005d0a:	607a      	str	r2, [r7, #4]
 8005d0c:	603b      	str	r3, [r7, #0]
  /* calculate DMA base and stream number */
  DMA_Base_Registers  *regs_dma  = (DMA_Base_Registers *)hdma->StreamBaseAddress;
 8005d0e:	68fb      	ldr	r3, [r7, #12]
 8005d10:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8005d12:	617b      	str	r3, [r7, #20]
  BDMA_Base_Registers *regs_bdma = (BDMA_Base_Registers *)hdma->StreamBaseAddress;
 8005d14:	68fb      	ldr	r3, [r7, #12]
 8005d16:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8005d18:	613b      	str	r3, [r7, #16]

  if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
 8005d1a:	68fb      	ldr	r3, [r7, #12]
 8005d1c:	681b      	ldr	r3, [r3, #0]
 8005d1e:	4a7f      	ldr	r2, [pc, #508]	@ (8005f1c <DMA_SetConfig+0x21c>)
 8005d20:	4293      	cmp	r3, r2
 8005d22:	d072      	beq.n	8005e0a <DMA_SetConfig+0x10a>
 8005d24:	68fb      	ldr	r3, [r7, #12]
 8005d26:	681b      	ldr	r3, [r3, #0]
 8005d28:	4a7d      	ldr	r2, [pc, #500]	@ (8005f20 <DMA_SetConfig+0x220>)
 8005d2a:	4293      	cmp	r3, r2
 8005d2c:	d06d      	beq.n	8005e0a <DMA_SetConfig+0x10a>
 8005d2e:	68fb      	ldr	r3, [r7, #12]
 8005d30:	681b      	ldr	r3, [r3, #0]
 8005d32:	4a7c      	ldr	r2, [pc, #496]	@ (8005f24 <DMA_SetConfig+0x224>)
 8005d34:	4293      	cmp	r3, r2
 8005d36:	d068      	beq.n	8005e0a <DMA_SetConfig+0x10a>
 8005d38:	68fb      	ldr	r3, [r7, #12]
 8005d3a:	681b      	ldr	r3, [r3, #0]
 8005d3c:	4a7a      	ldr	r2, [pc, #488]	@ (8005f28 <DMA_SetConfig+0x228>)
 8005d3e:	4293      	cmp	r3, r2
 8005d40:	d063      	beq.n	8005e0a <DMA_SetConfig+0x10a>
 8005d42:	68fb      	ldr	r3, [r7, #12]
 8005d44:	681b      	ldr	r3, [r3, #0]
 8005d46:	4a79      	ldr	r2, [pc, #484]	@ (8005f2c <DMA_SetConfig+0x22c>)
 8005d48:	4293      	cmp	r3, r2
 8005d4a:	d05e      	beq.n	8005e0a <DMA_SetConfig+0x10a>
 8005d4c:	68fb      	ldr	r3, [r7, #12]
 8005d4e:	681b      	ldr	r3, [r3, #0]
 8005d50:	4a77      	ldr	r2, [pc, #476]	@ (8005f30 <DMA_SetConfig+0x230>)
 8005d52:	4293      	cmp	r3, r2
 8005d54:	d059      	beq.n	8005e0a <DMA_SetConfig+0x10a>
 8005d56:	68fb      	ldr	r3, [r7, #12]
 8005d58:	681b      	ldr	r3, [r3, #0]
 8005d5a:	4a76      	ldr	r2, [pc, #472]	@ (8005f34 <DMA_SetConfig+0x234>)
 8005d5c:	4293      	cmp	r3, r2
 8005d5e:	d054      	beq.n	8005e0a <DMA_SetConfig+0x10a>
 8005d60:	68fb      	ldr	r3, [r7, #12]
 8005d62:	681b      	ldr	r3, [r3, #0]
 8005d64:	4a74      	ldr	r2, [pc, #464]	@ (8005f38 <DMA_SetConfig+0x238>)
 8005d66:	4293      	cmp	r3, r2
 8005d68:	d04f      	beq.n	8005e0a <DMA_SetConfig+0x10a>
 8005d6a:	68fb      	ldr	r3, [r7, #12]
 8005d6c:	681b      	ldr	r3, [r3, #0]
 8005d6e:	4a73      	ldr	r2, [pc, #460]	@ (8005f3c <DMA_SetConfig+0x23c>)
 8005d70:	4293      	cmp	r3, r2
 8005d72:	d04a      	beq.n	8005e0a <DMA_SetConfig+0x10a>
 8005d74:	68fb      	ldr	r3, [r7, #12]
 8005d76:	681b      	ldr	r3, [r3, #0]
 8005d78:	4a71      	ldr	r2, [pc, #452]	@ (8005f40 <DMA_SetConfig+0x240>)
 8005d7a:	4293      	cmp	r3, r2
 8005d7c:	d045      	beq.n	8005e0a <DMA_SetConfig+0x10a>
 8005d7e:	68fb      	ldr	r3, [r7, #12]
 8005d80:	681b      	ldr	r3, [r3, #0]
 8005d82:	4a70      	ldr	r2, [pc, #448]	@ (8005f44 <DMA_SetConfig+0x244>)
 8005d84:	4293      	cmp	r3, r2
 8005d86:	d040      	beq.n	8005e0a <DMA_SetConfig+0x10a>
 8005d88:	68fb      	ldr	r3, [r7, #12]
 8005d8a:	681b      	ldr	r3, [r3, #0]
 8005d8c:	4a6e      	ldr	r2, [pc, #440]	@ (8005f48 <DMA_SetConfig+0x248>)
 8005d8e:	4293      	cmp	r3, r2
 8005d90:	d03b      	beq.n	8005e0a <DMA_SetConfig+0x10a>
 8005d92:	68fb      	ldr	r3, [r7, #12]
 8005d94:	681b      	ldr	r3, [r3, #0]
 8005d96:	4a6d      	ldr	r2, [pc, #436]	@ (8005f4c <DMA_SetConfig+0x24c>)
 8005d98:	4293      	cmp	r3, r2
 8005d9a:	d036      	beq.n	8005e0a <DMA_SetConfig+0x10a>
 8005d9c:	68fb      	ldr	r3, [r7, #12]
 8005d9e:	681b      	ldr	r3, [r3, #0]
 8005da0:	4a6b      	ldr	r2, [pc, #428]	@ (8005f50 <DMA_SetConfig+0x250>)
 8005da2:	4293      	cmp	r3, r2
 8005da4:	d031      	beq.n	8005e0a <DMA_SetConfig+0x10a>
 8005da6:	68fb      	ldr	r3, [r7, #12]
 8005da8:	681b      	ldr	r3, [r3, #0]
 8005daa:	4a6a      	ldr	r2, [pc, #424]	@ (8005f54 <DMA_SetConfig+0x254>)
 8005dac:	4293      	cmp	r3, r2
 8005dae:	d02c      	beq.n	8005e0a <DMA_SetConfig+0x10a>
 8005db0:	68fb      	ldr	r3, [r7, #12]
 8005db2:	681b      	ldr	r3, [r3, #0]
 8005db4:	4a68      	ldr	r2, [pc, #416]	@ (8005f58 <DMA_SetConfig+0x258>)
 8005db6:	4293      	cmp	r3, r2
 8005db8:	d027      	beq.n	8005e0a <DMA_SetConfig+0x10a>
 8005dba:	68fb      	ldr	r3, [r7, #12]
 8005dbc:	681b      	ldr	r3, [r3, #0]
 8005dbe:	4a67      	ldr	r2, [pc, #412]	@ (8005f5c <DMA_SetConfig+0x25c>)
 8005dc0:	4293      	cmp	r3, r2
 8005dc2:	d022      	beq.n	8005e0a <DMA_SetConfig+0x10a>
 8005dc4:	68fb      	ldr	r3, [r7, #12]
 8005dc6:	681b      	ldr	r3, [r3, #0]
 8005dc8:	4a65      	ldr	r2, [pc, #404]	@ (8005f60 <DMA_SetConfig+0x260>)
 8005dca:	4293      	cmp	r3, r2
 8005dcc:	d01d      	beq.n	8005e0a <DMA_SetConfig+0x10a>
 8005dce:	68fb      	ldr	r3, [r7, #12]
 8005dd0:	681b      	ldr	r3, [r3, #0]
 8005dd2:	4a64      	ldr	r2, [pc, #400]	@ (8005f64 <DMA_SetConfig+0x264>)
 8005dd4:	4293      	cmp	r3, r2
 8005dd6:	d018      	beq.n	8005e0a <DMA_SetConfig+0x10a>
 8005dd8:	68fb      	ldr	r3, [r7, #12]
 8005dda:	681b      	ldr	r3, [r3, #0]
 8005ddc:	4a62      	ldr	r2, [pc, #392]	@ (8005f68 <DMA_SetConfig+0x268>)
 8005dde:	4293      	cmp	r3, r2
 8005de0:	d013      	beq.n	8005e0a <DMA_SetConfig+0x10a>
 8005de2:	68fb      	ldr	r3, [r7, #12]
 8005de4:	681b      	ldr	r3, [r3, #0]
 8005de6:	4a61      	ldr	r2, [pc, #388]	@ (8005f6c <DMA_SetConfig+0x26c>)
 8005de8:	4293      	cmp	r3, r2
 8005dea:	d00e      	beq.n	8005e0a <DMA_SetConfig+0x10a>
 8005dec:	68fb      	ldr	r3, [r7, #12]
 8005dee:	681b      	ldr	r3, [r3, #0]
 8005df0:	4a5f      	ldr	r2, [pc, #380]	@ (8005f70 <DMA_SetConfig+0x270>)
 8005df2:	4293      	cmp	r3, r2
 8005df4:	d009      	beq.n	8005e0a <DMA_SetConfig+0x10a>
 8005df6:	68fb      	ldr	r3, [r7, #12]
 8005df8:	681b      	ldr	r3, [r3, #0]
 8005dfa:	4a5e      	ldr	r2, [pc, #376]	@ (8005f74 <DMA_SetConfig+0x274>)
 8005dfc:	4293      	cmp	r3, r2
 8005dfe:	d004      	beq.n	8005e0a <DMA_SetConfig+0x10a>
 8005e00:	68fb      	ldr	r3, [r7, #12]
 8005e02:	681b      	ldr	r3, [r3, #0]
 8005e04:	4a5c      	ldr	r2, [pc, #368]	@ (8005f78 <DMA_SetConfig+0x278>)
 8005e06:	4293      	cmp	r3, r2
 8005e08:	d101      	bne.n	8005e0e <DMA_SetConfig+0x10e>
 8005e0a:	2301      	movs	r3, #1
 8005e0c:	e000      	b.n	8005e10 <DMA_SetConfig+0x110>
 8005e0e:	2300      	movs	r3, #0
 8005e10:	2b00      	cmp	r3, #0
 8005e12:	d00d      	beq.n	8005e30 <DMA_SetConfig+0x130>
  {
    /* Clear the DMAMUX synchro overrun flag */
    hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 8005e14:	68fb      	ldr	r3, [r7, #12]
 8005e16:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 8005e18:	68fa      	ldr	r2, [r7, #12]
 8005e1a:	6e92      	ldr	r2, [r2, #104]	@ 0x68
 8005e1c:	605a      	str	r2, [r3, #4]

    if(hdma->DMAmuxRequestGen != 0U)
 8005e1e:	68fb      	ldr	r3, [r7, #12]
 8005e20:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 8005e22:	2b00      	cmp	r3, #0
 8005e24:	d004      	beq.n	8005e30 <DMA_SetConfig+0x130>
    {
      /* Clear the DMAMUX request generator overrun flag */
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 8005e26:	68fb      	ldr	r3, [r7, #12]
 8005e28:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8005e2a:	68fa      	ldr	r2, [r7, #12]
 8005e2c:	6f52      	ldr	r2, [r2, #116]	@ 0x74
 8005e2e:	605a      	str	r2, [r3, #4]
    }
  }

  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
 8005e30:	68fb      	ldr	r3, [r7, #12]
 8005e32:	681b      	ldr	r3, [r3, #0]
 8005e34:	4a39      	ldr	r2, [pc, #228]	@ (8005f1c <DMA_SetConfig+0x21c>)
 8005e36:	4293      	cmp	r3, r2
 8005e38:	d04a      	beq.n	8005ed0 <DMA_SetConfig+0x1d0>
 8005e3a:	68fb      	ldr	r3, [r7, #12]
 8005e3c:	681b      	ldr	r3, [r3, #0]
 8005e3e:	4a38      	ldr	r2, [pc, #224]	@ (8005f20 <DMA_SetConfig+0x220>)
 8005e40:	4293      	cmp	r3, r2
 8005e42:	d045      	beq.n	8005ed0 <DMA_SetConfig+0x1d0>
 8005e44:	68fb      	ldr	r3, [r7, #12]
 8005e46:	681b      	ldr	r3, [r3, #0]
 8005e48:	4a36      	ldr	r2, [pc, #216]	@ (8005f24 <DMA_SetConfig+0x224>)
 8005e4a:	4293      	cmp	r3, r2
 8005e4c:	d040      	beq.n	8005ed0 <DMA_SetConfig+0x1d0>
 8005e4e:	68fb      	ldr	r3, [r7, #12]
 8005e50:	681b      	ldr	r3, [r3, #0]
 8005e52:	4a35      	ldr	r2, [pc, #212]	@ (8005f28 <DMA_SetConfig+0x228>)
 8005e54:	4293      	cmp	r3, r2
 8005e56:	d03b      	beq.n	8005ed0 <DMA_SetConfig+0x1d0>
 8005e58:	68fb      	ldr	r3, [r7, #12]
 8005e5a:	681b      	ldr	r3, [r3, #0]
 8005e5c:	4a33      	ldr	r2, [pc, #204]	@ (8005f2c <DMA_SetConfig+0x22c>)
 8005e5e:	4293      	cmp	r3, r2
 8005e60:	d036      	beq.n	8005ed0 <DMA_SetConfig+0x1d0>
 8005e62:	68fb      	ldr	r3, [r7, #12]
 8005e64:	681b      	ldr	r3, [r3, #0]
 8005e66:	4a32      	ldr	r2, [pc, #200]	@ (8005f30 <DMA_SetConfig+0x230>)
 8005e68:	4293      	cmp	r3, r2
 8005e6a:	d031      	beq.n	8005ed0 <DMA_SetConfig+0x1d0>
 8005e6c:	68fb      	ldr	r3, [r7, #12]
 8005e6e:	681b      	ldr	r3, [r3, #0]
 8005e70:	4a30      	ldr	r2, [pc, #192]	@ (8005f34 <DMA_SetConfig+0x234>)
 8005e72:	4293      	cmp	r3, r2
 8005e74:	d02c      	beq.n	8005ed0 <DMA_SetConfig+0x1d0>
 8005e76:	68fb      	ldr	r3, [r7, #12]
 8005e78:	681b      	ldr	r3, [r3, #0]
 8005e7a:	4a2f      	ldr	r2, [pc, #188]	@ (8005f38 <DMA_SetConfig+0x238>)
 8005e7c:	4293      	cmp	r3, r2
 8005e7e:	d027      	beq.n	8005ed0 <DMA_SetConfig+0x1d0>
 8005e80:	68fb      	ldr	r3, [r7, #12]
 8005e82:	681b      	ldr	r3, [r3, #0]
 8005e84:	4a2d      	ldr	r2, [pc, #180]	@ (8005f3c <DMA_SetConfig+0x23c>)
 8005e86:	4293      	cmp	r3, r2
 8005e88:	d022      	beq.n	8005ed0 <DMA_SetConfig+0x1d0>
 8005e8a:	68fb      	ldr	r3, [r7, #12]
 8005e8c:	681b      	ldr	r3, [r3, #0]
 8005e8e:	4a2c      	ldr	r2, [pc, #176]	@ (8005f40 <DMA_SetConfig+0x240>)
 8005e90:	4293      	cmp	r3, r2
 8005e92:	d01d      	beq.n	8005ed0 <DMA_SetConfig+0x1d0>
 8005e94:	68fb      	ldr	r3, [r7, #12]
 8005e96:	681b      	ldr	r3, [r3, #0]
 8005e98:	4a2a      	ldr	r2, [pc, #168]	@ (8005f44 <DMA_SetConfig+0x244>)
 8005e9a:	4293      	cmp	r3, r2
 8005e9c:	d018      	beq.n	8005ed0 <DMA_SetConfig+0x1d0>
 8005e9e:	68fb      	ldr	r3, [r7, #12]
 8005ea0:	681b      	ldr	r3, [r3, #0]
 8005ea2:	4a29      	ldr	r2, [pc, #164]	@ (8005f48 <DMA_SetConfig+0x248>)
 8005ea4:	4293      	cmp	r3, r2
 8005ea6:	d013      	beq.n	8005ed0 <DMA_SetConfig+0x1d0>
 8005ea8:	68fb      	ldr	r3, [r7, #12]
 8005eaa:	681b      	ldr	r3, [r3, #0]
 8005eac:	4a27      	ldr	r2, [pc, #156]	@ (8005f4c <DMA_SetConfig+0x24c>)
 8005eae:	4293      	cmp	r3, r2
 8005eb0:	d00e      	beq.n	8005ed0 <DMA_SetConfig+0x1d0>
 8005eb2:	68fb      	ldr	r3, [r7, #12]
 8005eb4:	681b      	ldr	r3, [r3, #0]
 8005eb6:	4a26      	ldr	r2, [pc, #152]	@ (8005f50 <DMA_SetConfig+0x250>)
 8005eb8:	4293      	cmp	r3, r2
 8005eba:	d009      	beq.n	8005ed0 <DMA_SetConfig+0x1d0>
 8005ebc:	68fb      	ldr	r3, [r7, #12]
 8005ebe:	681b      	ldr	r3, [r3, #0]
 8005ec0:	4a24      	ldr	r2, [pc, #144]	@ (8005f54 <DMA_SetConfig+0x254>)
 8005ec2:	4293      	cmp	r3, r2
 8005ec4:	d004      	beq.n	8005ed0 <DMA_SetConfig+0x1d0>
 8005ec6:	68fb      	ldr	r3, [r7, #12]
 8005ec8:	681b      	ldr	r3, [r3, #0]
 8005eca:	4a23      	ldr	r2, [pc, #140]	@ (8005f58 <DMA_SetConfig+0x258>)
 8005ecc:	4293      	cmp	r3, r2
 8005ece:	d101      	bne.n	8005ed4 <DMA_SetConfig+0x1d4>
 8005ed0:	2301      	movs	r3, #1
 8005ed2:	e000      	b.n	8005ed6 <DMA_SetConfig+0x1d6>
 8005ed4:	2300      	movs	r3, #0
 8005ed6:	2b00      	cmp	r3, #0
 8005ed8:	d059      	beq.n	8005f8e <DMA_SetConfig+0x28e>
  {
    /* Clear all interrupt flags at correct offset within the register */
    regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);
 8005eda:	68fb      	ldr	r3, [r7, #12]
 8005edc:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 8005ede:	f003 031f 	and.w	r3, r3, #31
 8005ee2:	223f      	movs	r2, #63	@ 0x3f
 8005ee4:	409a      	lsls	r2, r3
 8005ee6:	697b      	ldr	r3, [r7, #20]
 8005ee8:	609a      	str	r2, [r3, #8]

    /* Clear DBM bit */
    ((DMA_Stream_TypeDef *)hdma->Instance)->CR &= (uint32_t)(~DMA_SxCR_DBM);
 8005eea:	68fb      	ldr	r3, [r7, #12]
 8005eec:	681b      	ldr	r3, [r3, #0]
 8005eee:	681a      	ldr	r2, [r3, #0]
 8005ef0:	68fb      	ldr	r3, [r7, #12]
 8005ef2:	681b      	ldr	r3, [r3, #0]
 8005ef4:	f422 2280 	bic.w	r2, r2, #262144	@ 0x40000
 8005ef8:	601a      	str	r2, [r3, #0]

    /* Configure DMA Stream data length */
    ((DMA_Stream_TypeDef *)hdma->Instance)->NDTR = DataLength;
 8005efa:	68fb      	ldr	r3, [r7, #12]
 8005efc:	681b      	ldr	r3, [r3, #0]
 8005efe:	683a      	ldr	r2, [r7, #0]
 8005f00:	605a      	str	r2, [r3, #4]

    /* Peripheral to Memory */
    if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 8005f02:	68fb      	ldr	r3, [r7, #12]
 8005f04:	689b      	ldr	r3, [r3, #8]
 8005f06:	2b40      	cmp	r3, #64	@ 0x40
 8005f08:	d138      	bne.n	8005f7c <DMA_SetConfig+0x27c>
    {
      /* Configure DMA Stream destination address */
      ((DMA_Stream_TypeDef *)hdma->Instance)->PAR = DstAddress;
 8005f0a:	68fb      	ldr	r3, [r7, #12]
 8005f0c:	681b      	ldr	r3, [r3, #0]
 8005f0e:	687a      	ldr	r2, [r7, #4]
 8005f10:	609a      	str	r2, [r3, #8]

      /* Configure DMA Stream source address */
      ((DMA_Stream_TypeDef *)hdma->Instance)->M0AR = SrcAddress;
 8005f12:	68fb      	ldr	r3, [r7, #12]
 8005f14:	681b      	ldr	r3, [r3, #0]
 8005f16:	68ba      	ldr	r2, [r7, #8]
 8005f18:	60da      	str	r2, [r3, #12]
  }
  else
  {
    /* Nothing To Do */
  }
}
 8005f1a:	e0ae      	b.n	800607a <DMA_SetConfig+0x37a>
 8005f1c:	40020010 	.word	0x40020010
 8005f20:	40020028 	.word	0x40020028
 8005f24:	40020040 	.word	0x40020040
 8005f28:	40020058 	.word	0x40020058
 8005f2c:	40020070 	.word	0x40020070
 8005f30:	40020088 	.word	0x40020088
 8005f34:	400200a0 	.word	0x400200a0
 8005f38:	400200b8 	.word	0x400200b8
 8005f3c:	40020410 	.word	0x40020410
 8005f40:	40020428 	.word	0x40020428
 8005f44:	40020440 	.word	0x40020440
 8005f48:	40020458 	.word	0x40020458
 8005f4c:	40020470 	.word	0x40020470
 8005f50:	40020488 	.word	0x40020488
 8005f54:	400204a0 	.word	0x400204a0
 8005f58:	400204b8 	.word	0x400204b8
 8005f5c:	58025408 	.word	0x58025408
 8005f60:	5802541c 	.word	0x5802541c
 8005f64:	58025430 	.word	0x58025430
 8005f68:	58025444 	.word	0x58025444
 8005f6c:	58025458 	.word	0x58025458
 8005f70:	5802546c 	.word	0x5802546c
 8005f74:	58025480 	.word	0x58025480
 8005f78:	58025494 	.word	0x58025494
      ((DMA_Stream_TypeDef *)hdma->Instance)->PAR = SrcAddress;
 8005f7c:	68fb      	ldr	r3, [r7, #12]
 8005f7e:	681b      	ldr	r3, [r3, #0]
 8005f80:	68ba      	ldr	r2, [r7, #8]
 8005f82:	609a      	str	r2, [r3, #8]
      ((DMA_Stream_TypeDef *)hdma->Instance)->M0AR = DstAddress;
 8005f84:	68fb      	ldr	r3, [r7, #12]
 8005f86:	681b      	ldr	r3, [r3, #0]
 8005f88:	687a      	ldr	r2, [r7, #4]
 8005f8a:	60da      	str	r2, [r3, #12]
}
 8005f8c:	e075      	b.n	800607a <DMA_SetConfig+0x37a>
  else if(IS_BDMA_CHANNEL_INSTANCE(hdma->Instance) != 0U) /* BDMA instance(s) */
 8005f8e:	68fb      	ldr	r3, [r7, #12]
 8005f90:	681b      	ldr	r3, [r3, #0]
 8005f92:	4a3d      	ldr	r2, [pc, #244]	@ (8006088 <DMA_SetConfig+0x388>)
 8005f94:	4293      	cmp	r3, r2
 8005f96:	d04a      	beq.n	800602e <DMA_SetConfig+0x32e>
 8005f98:	68fb      	ldr	r3, [r7, #12]
 8005f9a:	681b      	ldr	r3, [r3, #0]
 8005f9c:	4a3b      	ldr	r2, [pc, #236]	@ (800608c <DMA_SetConfig+0x38c>)
 8005f9e:	4293      	cmp	r3, r2
 8005fa0:	d045      	beq.n	800602e <DMA_SetConfig+0x32e>
 8005fa2:	68fb      	ldr	r3, [r7, #12]
 8005fa4:	681b      	ldr	r3, [r3, #0]
 8005fa6:	4a3a      	ldr	r2, [pc, #232]	@ (8006090 <DMA_SetConfig+0x390>)
 8005fa8:	4293      	cmp	r3, r2
 8005faa:	d040      	beq.n	800602e <DMA_SetConfig+0x32e>
 8005fac:	68fb      	ldr	r3, [r7, #12]
 8005fae:	681b      	ldr	r3, [r3, #0]
 8005fb0:	4a38      	ldr	r2, [pc, #224]	@ (8006094 <DMA_SetConfig+0x394>)
 8005fb2:	4293      	cmp	r3, r2
 8005fb4:	d03b      	beq.n	800602e <DMA_SetConfig+0x32e>
 8005fb6:	68fb      	ldr	r3, [r7, #12]
 8005fb8:	681b      	ldr	r3, [r3, #0]
 8005fba:	4a37      	ldr	r2, [pc, #220]	@ (8006098 <DMA_SetConfig+0x398>)
 8005fbc:	4293      	cmp	r3, r2
 8005fbe:	d036      	beq.n	800602e <DMA_SetConfig+0x32e>
 8005fc0:	68fb      	ldr	r3, [r7, #12]
 8005fc2:	681b      	ldr	r3, [r3, #0]
 8005fc4:	4a35      	ldr	r2, [pc, #212]	@ (800609c <DMA_SetConfig+0x39c>)
 8005fc6:	4293      	cmp	r3, r2
 8005fc8:	d031      	beq.n	800602e <DMA_SetConfig+0x32e>
 8005fca:	68fb      	ldr	r3, [r7, #12]
 8005fcc:	681b      	ldr	r3, [r3, #0]
 8005fce:	4a34      	ldr	r2, [pc, #208]	@ (80060a0 <DMA_SetConfig+0x3a0>)
 8005fd0:	4293      	cmp	r3, r2
 8005fd2:	d02c      	beq.n	800602e <DMA_SetConfig+0x32e>
 8005fd4:	68fb      	ldr	r3, [r7, #12]
 8005fd6:	681b      	ldr	r3, [r3, #0]
 8005fd8:	4a32      	ldr	r2, [pc, #200]	@ (80060a4 <DMA_SetConfig+0x3a4>)
 8005fda:	4293      	cmp	r3, r2
 8005fdc:	d027      	beq.n	800602e <DMA_SetConfig+0x32e>
 8005fde:	68fb      	ldr	r3, [r7, #12]
 8005fe0:	681b      	ldr	r3, [r3, #0]
 8005fe2:	4a31      	ldr	r2, [pc, #196]	@ (80060a8 <DMA_SetConfig+0x3a8>)
 8005fe4:	4293      	cmp	r3, r2
 8005fe6:	d022      	beq.n	800602e <DMA_SetConfig+0x32e>
 8005fe8:	68fb      	ldr	r3, [r7, #12]
 8005fea:	681b      	ldr	r3, [r3, #0]
 8005fec:	4a2f      	ldr	r2, [pc, #188]	@ (80060ac <DMA_SetConfig+0x3ac>)
 8005fee:	4293      	cmp	r3, r2
 8005ff0:	d01d      	beq.n	800602e <DMA_SetConfig+0x32e>
 8005ff2:	68fb      	ldr	r3, [r7, #12]
 8005ff4:	681b      	ldr	r3, [r3, #0]
 8005ff6:	4a2e      	ldr	r2, [pc, #184]	@ (80060b0 <DMA_SetConfig+0x3b0>)
 8005ff8:	4293      	cmp	r3, r2
 8005ffa:	d018      	beq.n	800602e <DMA_SetConfig+0x32e>
 8005ffc:	68fb      	ldr	r3, [r7, #12]
 8005ffe:	681b      	ldr	r3, [r3, #0]
 8006000:	4a2c      	ldr	r2, [pc, #176]	@ (80060b4 <DMA_SetConfig+0x3b4>)
 8006002:	4293      	cmp	r3, r2
 8006004:	d013      	beq.n	800602e <DMA_SetConfig+0x32e>
 8006006:	68fb      	ldr	r3, [r7, #12]
 8006008:	681b      	ldr	r3, [r3, #0]
 800600a:	4a2b      	ldr	r2, [pc, #172]	@ (80060b8 <DMA_SetConfig+0x3b8>)
 800600c:	4293      	cmp	r3, r2
 800600e:	d00e      	beq.n	800602e <DMA_SetConfig+0x32e>
 8006010:	68fb      	ldr	r3, [r7, #12]
 8006012:	681b      	ldr	r3, [r3, #0]
 8006014:	4a29      	ldr	r2, [pc, #164]	@ (80060bc <DMA_SetConfig+0x3bc>)
 8006016:	4293      	cmp	r3, r2
 8006018:	d009      	beq.n	800602e <DMA_SetConfig+0x32e>
 800601a:	68fb      	ldr	r3, [r7, #12]
 800601c:	681b      	ldr	r3, [r3, #0]
 800601e:	4a28      	ldr	r2, [pc, #160]	@ (80060c0 <DMA_SetConfig+0x3c0>)
 8006020:	4293      	cmp	r3, r2
 8006022:	d004      	beq.n	800602e <DMA_SetConfig+0x32e>
 8006024:	68fb      	ldr	r3, [r7, #12]
 8006026:	681b      	ldr	r3, [r3, #0]
 8006028:	4a26      	ldr	r2, [pc, #152]	@ (80060c4 <DMA_SetConfig+0x3c4>)
 800602a:	4293      	cmp	r3, r2
 800602c:	d101      	bne.n	8006032 <DMA_SetConfig+0x332>
 800602e:	2301      	movs	r3, #1
 8006030:	e000      	b.n	8006034 <DMA_SetConfig+0x334>
 8006032:	2300      	movs	r3, #0
 8006034:	2b00      	cmp	r3, #0
 8006036:	d020      	beq.n	800607a <DMA_SetConfig+0x37a>
    regs_bdma->IFCR = (BDMA_ISR_GIF0) << (hdma->StreamIndex & 0x1FU);
 8006038:	68fb      	ldr	r3, [r7, #12]
 800603a:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 800603c:	f003 031f 	and.w	r3, r3, #31
 8006040:	2201      	movs	r2, #1
 8006042:	409a      	lsls	r2, r3
 8006044:	693b      	ldr	r3, [r7, #16]
 8006046:	605a      	str	r2, [r3, #4]
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CNDTR = DataLength;
 8006048:	68fb      	ldr	r3, [r7, #12]
 800604a:	681b      	ldr	r3, [r3, #0]
 800604c:	683a      	ldr	r2, [r7, #0]
 800604e:	605a      	str	r2, [r3, #4]
    if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 8006050:	68fb      	ldr	r3, [r7, #12]
 8006052:	689b      	ldr	r3, [r3, #8]
 8006054:	2b40      	cmp	r3, #64	@ 0x40
 8006056:	d108      	bne.n	800606a <DMA_SetConfig+0x36a>
      ((BDMA_Channel_TypeDef *)hdma->Instance)->CPAR = DstAddress;
 8006058:	68fb      	ldr	r3, [r7, #12]
 800605a:	681b      	ldr	r3, [r3, #0]
 800605c:	687a      	ldr	r2, [r7, #4]
 800605e:	609a      	str	r2, [r3, #8]
      ((BDMA_Channel_TypeDef *)hdma->Instance)->CM0AR = SrcAddress;
 8006060:	68fb      	ldr	r3, [r7, #12]
 8006062:	681b      	ldr	r3, [r3, #0]
 8006064:	68ba      	ldr	r2, [r7, #8]
 8006066:	60da      	str	r2, [r3, #12]
}
 8006068:	e007      	b.n	800607a <DMA_SetConfig+0x37a>
      ((BDMA_Channel_TypeDef *)hdma->Instance)->CPAR = SrcAddress;
 800606a:	68fb      	ldr	r3, [r7, #12]
 800606c:	681b      	ldr	r3, [r3, #0]
 800606e:	68ba      	ldr	r2, [r7, #8]
 8006070:	609a      	str	r2, [r3, #8]
      ((BDMA_Channel_TypeDef *)hdma->Instance)->CM0AR = DstAddress;
 8006072:	68fb      	ldr	r3, [r7, #12]
 8006074:	681b      	ldr	r3, [r3, #0]
 8006076:	687a      	ldr	r2, [r7, #4]
 8006078:	60da      	str	r2, [r3, #12]
}
 800607a:	bf00      	nop
 800607c:	371c      	adds	r7, #28
 800607e:	46bd      	mov	sp, r7
 8006080:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006084:	4770      	bx	lr
 8006086:	bf00      	nop
 8006088:	48022c08 	.word	0x48022c08
 800608c:	48022c1c 	.word	0x48022c1c
 8006090:	48022c30 	.word	0x48022c30
 8006094:	48022c44 	.word	0x48022c44
 8006098:	48022c58 	.word	0x48022c58
 800609c:	48022c6c 	.word	0x48022c6c
 80060a0:	48022c80 	.word	0x48022c80
 80060a4:	48022c94 	.word	0x48022c94
 80060a8:	58025408 	.word	0x58025408
 80060ac:	5802541c 	.word	0x5802541c
 80060b0:	58025430 	.word	0x58025430
 80060b4:	58025444 	.word	0x58025444
 80060b8:	58025458 	.word	0x58025458
 80060bc:	5802546c 	.word	0x5802546c
 80060c0:	58025480 	.word	0x58025480
 80060c4:	58025494 	.word	0x58025494

080060c8 <DMA_CalcBaseAndBitshift>:
  * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream.
  * @retval Stream base address
  */
static uint32_t DMA_CalcBaseAndBitshift(DMA_HandleTypeDef *hdma)
{
 80060c8:	b480      	push	{r7}
 80060ca:	b085      	sub	sp, #20
 80060cc:	af00      	add	r7, sp, #0
 80060ce:	6078      	str	r0, [r7, #4]
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
 80060d0:	687b      	ldr	r3, [r7, #4]
 80060d2:	681b      	ldr	r3, [r3, #0]
 80060d4:	4a42      	ldr	r2, [pc, #264]	@ (80061e0 <DMA_CalcBaseAndBitshift+0x118>)
 80060d6:	4293      	cmp	r3, r2
 80060d8:	d04a      	beq.n	8006170 <DMA_CalcBaseAndBitshift+0xa8>
 80060da:	687b      	ldr	r3, [r7, #4]
 80060dc:	681b      	ldr	r3, [r3, #0]
 80060de:	4a41      	ldr	r2, [pc, #260]	@ (80061e4 <DMA_CalcBaseAndBitshift+0x11c>)
 80060e0:	4293      	cmp	r3, r2
 80060e2:	d045      	beq.n	8006170 <DMA_CalcBaseAndBitshift+0xa8>
 80060e4:	687b      	ldr	r3, [r7, #4]
 80060e6:	681b      	ldr	r3, [r3, #0]
 80060e8:	4a3f      	ldr	r2, [pc, #252]	@ (80061e8 <DMA_CalcBaseAndBitshift+0x120>)
 80060ea:	4293      	cmp	r3, r2
 80060ec:	d040      	beq.n	8006170 <DMA_CalcBaseAndBitshift+0xa8>
 80060ee:	687b      	ldr	r3, [r7, #4]
 80060f0:	681b      	ldr	r3, [r3, #0]
 80060f2:	4a3e      	ldr	r2, [pc, #248]	@ (80061ec <DMA_CalcBaseAndBitshift+0x124>)
 80060f4:	4293      	cmp	r3, r2
 80060f6:	d03b      	beq.n	8006170 <DMA_CalcBaseAndBitshift+0xa8>
 80060f8:	687b      	ldr	r3, [r7, #4]
 80060fa:	681b      	ldr	r3, [r3, #0]
 80060fc:	4a3c      	ldr	r2, [pc, #240]	@ (80061f0 <DMA_CalcBaseAndBitshift+0x128>)
 80060fe:	4293      	cmp	r3, r2
 8006100:	d036      	beq.n	8006170 <DMA_CalcBaseAndBitshift+0xa8>
 8006102:	687b      	ldr	r3, [r7, #4]
 8006104:	681b      	ldr	r3, [r3, #0]
 8006106:	4a3b      	ldr	r2, [pc, #236]	@ (80061f4 <DMA_CalcBaseAndBitshift+0x12c>)
 8006108:	4293      	cmp	r3, r2
 800610a:	d031      	beq.n	8006170 <DMA_CalcBaseAndBitshift+0xa8>
 800610c:	687b      	ldr	r3, [r7, #4]
 800610e:	681b      	ldr	r3, [r3, #0]
 8006110:	4a39      	ldr	r2, [pc, #228]	@ (80061f8 <DMA_CalcBaseAndBitshift+0x130>)
 8006112:	4293      	cmp	r3, r2
 8006114:	d02c      	beq.n	8006170 <DMA_CalcBaseAndBitshift+0xa8>
 8006116:	687b      	ldr	r3, [r7, #4]
 8006118:	681b      	ldr	r3, [r3, #0]
 800611a:	4a38      	ldr	r2, [pc, #224]	@ (80061fc <DMA_CalcBaseAndBitshift+0x134>)
 800611c:	4293      	cmp	r3, r2
 800611e:	d027      	beq.n	8006170 <DMA_CalcBaseAndBitshift+0xa8>
 8006120:	687b      	ldr	r3, [r7, #4]
 8006122:	681b      	ldr	r3, [r3, #0]
 8006124:	4a36      	ldr	r2, [pc, #216]	@ (8006200 <DMA_CalcBaseAndBitshift+0x138>)
 8006126:	4293      	cmp	r3, r2
 8006128:	d022      	beq.n	8006170 <DMA_CalcBaseAndBitshift+0xa8>
 800612a:	687b      	ldr	r3, [r7, #4]
 800612c:	681b      	ldr	r3, [r3, #0]
 800612e:	4a35      	ldr	r2, [pc, #212]	@ (8006204 <DMA_CalcBaseAndBitshift+0x13c>)
 8006130:	4293      	cmp	r3, r2
 8006132:	d01d      	beq.n	8006170 <DMA_CalcBaseAndBitshift+0xa8>
 8006134:	687b      	ldr	r3, [r7, #4]
 8006136:	681b      	ldr	r3, [r3, #0]
 8006138:	4a33      	ldr	r2, [pc, #204]	@ (8006208 <DMA_CalcBaseAndBitshift+0x140>)
 800613a:	4293      	cmp	r3, r2
 800613c:	d018      	beq.n	8006170 <DMA_CalcBaseAndBitshift+0xa8>
 800613e:	687b      	ldr	r3, [r7, #4]
 8006140:	681b      	ldr	r3, [r3, #0]
 8006142:	4a32      	ldr	r2, [pc, #200]	@ (800620c <DMA_CalcBaseAndBitshift+0x144>)
 8006144:	4293      	cmp	r3, r2
 8006146:	d013      	beq.n	8006170 <DMA_CalcBaseAndBitshift+0xa8>
 8006148:	687b      	ldr	r3, [r7, #4]
 800614a:	681b      	ldr	r3, [r3, #0]
 800614c:	4a30      	ldr	r2, [pc, #192]	@ (8006210 <DMA_CalcBaseAndBitshift+0x148>)
 800614e:	4293      	cmp	r3, r2
 8006150:	d00e      	beq.n	8006170 <DMA_CalcBaseAndBitshift+0xa8>
 8006152:	687b      	ldr	r3, [r7, #4]
 8006154:	681b      	ldr	r3, [r3, #0]
 8006156:	4a2f      	ldr	r2, [pc, #188]	@ (8006214 <DMA_CalcBaseAndBitshift+0x14c>)
 8006158:	4293      	cmp	r3, r2
 800615a:	d009      	beq.n	8006170 <DMA_CalcBaseAndBitshift+0xa8>
 800615c:	687b      	ldr	r3, [r7, #4]
 800615e:	681b      	ldr	r3, [r3, #0]
 8006160:	4a2d      	ldr	r2, [pc, #180]	@ (8006218 <DMA_CalcBaseAndBitshift+0x150>)
 8006162:	4293      	cmp	r3, r2
 8006164:	d004      	beq.n	8006170 <DMA_CalcBaseAndBitshift+0xa8>
 8006166:	687b      	ldr	r3, [r7, #4]
 8006168:	681b      	ldr	r3, [r3, #0]
 800616a:	4a2c      	ldr	r2, [pc, #176]	@ (800621c <DMA_CalcBaseAndBitshift+0x154>)
 800616c:	4293      	cmp	r3, r2
 800616e:	d101      	bne.n	8006174 <DMA_CalcBaseAndBitshift+0xac>
 8006170:	2301      	movs	r3, #1
 8006172:	e000      	b.n	8006176 <DMA_CalcBaseAndBitshift+0xae>
 8006174:	2300      	movs	r3, #0
 8006176:	2b00      	cmp	r3, #0
 8006178:	d024      	beq.n	80061c4 <DMA_CalcBaseAndBitshift+0xfc>
  {
    uint32_t stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
 800617a:	687b      	ldr	r3, [r7, #4]
 800617c:	681b      	ldr	r3, [r3, #0]
 800617e:	b2db      	uxtb	r3, r3
 8006180:	3b10      	subs	r3, #16
 8006182:	4a27      	ldr	r2, [pc, #156]	@ (8006220 <DMA_CalcBaseAndBitshift+0x158>)
 8006184:	fba2 2303 	umull	r2, r3, r2, r3
 8006188:	091b      	lsrs	r3, r3, #4
 800618a:	60fb      	str	r3, [r7, #12]

    /* lookup table for necessary bitshift of flags within status registers */
    static const uint8_t flagBitshiftOffset[8U] = {0U, 6U, 16U, 22U, 0U, 6U, 16U, 22U};
    hdma->StreamIndex = flagBitshiftOffset[stream_number & 0x7U];
 800618c:	68fb      	ldr	r3, [r7, #12]
 800618e:	f003 0307 	and.w	r3, r3, #7
 8006192:	4a24      	ldr	r2, [pc, #144]	@ (8006224 <DMA_CalcBaseAndBitshift+0x15c>)
 8006194:	5cd3      	ldrb	r3, [r2, r3]
 8006196:	461a      	mov	r2, r3
 8006198:	687b      	ldr	r3, [r7, #4]
 800619a:	65da      	str	r2, [r3, #92]	@ 0x5c

    if (stream_number > 3U)
 800619c:	68fb      	ldr	r3, [r7, #12]
 800619e:	2b03      	cmp	r3, #3
 80061a0:	d908      	bls.n	80061b4 <DMA_CalcBaseAndBitshift+0xec>
    {
      /* return pointer to HISR and HIFCR */
      hdma->StreamBaseAddress = (((uint32_t)((uint32_t*)hdma->Instance) & (uint32_t)(~0x3FFU)) + 4U);
 80061a2:	687b      	ldr	r3, [r7, #4]
 80061a4:	681b      	ldr	r3, [r3, #0]
 80061a6:	461a      	mov	r2, r3
 80061a8:	4b1f      	ldr	r3, [pc, #124]	@ (8006228 <DMA_CalcBaseAndBitshift+0x160>)
 80061aa:	4013      	ands	r3, r2
 80061ac:	1d1a      	adds	r2, r3, #4
 80061ae:	687b      	ldr	r3, [r7, #4]
 80061b0:	659a      	str	r2, [r3, #88]	@ 0x58
 80061b2:	e00d      	b.n	80061d0 <DMA_CalcBaseAndBitshift+0x108>
    }
    else
    {
      /* return pointer to LISR and LIFCR */
      hdma->StreamBaseAddress = ((uint32_t)((uint32_t*)hdma->Instance) & (uint32_t)(~0x3FFU));
 80061b4:	687b      	ldr	r3, [r7, #4]
 80061b6:	681b      	ldr	r3, [r3, #0]
 80061b8:	461a      	mov	r2, r3
 80061ba:	4b1b      	ldr	r3, [pc, #108]	@ (8006228 <DMA_CalcBaseAndBitshift+0x160>)
 80061bc:	4013      	ands	r3, r2
 80061be:	687a      	ldr	r2, [r7, #4]
 80061c0:	6593      	str	r3, [r2, #88]	@ 0x58
 80061c2:	e005      	b.n	80061d0 <DMA_CalcBaseAndBitshift+0x108>
    }
  }
  else /* BDMA instance(s) */
  {
    /* return pointer to ISR and IFCR */
    hdma->StreamBaseAddress = ((uint32_t)((uint32_t*)hdma->Instance) & (uint32_t)(~0xFFU));
 80061c4:	687b      	ldr	r3, [r7, #4]
 80061c6:	681b      	ldr	r3, [r3, #0]
 80061c8:	f023 02ff 	bic.w	r2, r3, #255	@ 0xff
 80061cc:	687b      	ldr	r3, [r7, #4]
 80061ce:	659a      	str	r2, [r3, #88]	@ 0x58
  }

  return hdma->StreamBaseAddress;
 80061d0:	687b      	ldr	r3, [r7, #4]
 80061d2:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
}
 80061d4:	4618      	mov	r0, r3
 80061d6:	3714      	adds	r7, #20
 80061d8:	46bd      	mov	sp, r7
 80061da:	f85d 7b04 	ldr.w	r7, [sp], #4
 80061de:	4770      	bx	lr
 80061e0:	40020010 	.word	0x40020010
 80061e4:	40020028 	.word	0x40020028
 80061e8:	40020040 	.word	0x40020040
 80061ec:	40020058 	.word	0x40020058
 80061f0:	40020070 	.word	0x40020070
 80061f4:	40020088 	.word	0x40020088
 80061f8:	400200a0 	.word	0x400200a0
 80061fc:	400200b8 	.word	0x400200b8
 8006200:	40020410 	.word	0x40020410
 8006204:	40020428 	.word	0x40020428
 8006208:	40020440 	.word	0x40020440
 800620c:	40020458 	.word	0x40020458
 8006210:	40020470 	.word	0x40020470
 8006214:	40020488 	.word	0x40020488
 8006218:	400204a0 	.word	0x400204a0
 800621c:	400204b8 	.word	0x400204b8
 8006220:	aaaaaaab 	.word	0xaaaaaaab
 8006224:	080131b4 	.word	0x080131b4
 8006228:	fffffc00 	.word	0xfffffc00

0800622c <DMA_CheckFifoParam>:
  * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
static HAL_StatusTypeDef DMA_CheckFifoParam(DMA_HandleTypeDef *hdma)
{
 800622c:	b480      	push	{r7}
 800622e:	b085      	sub	sp, #20
 8006230:	af00      	add	r7, sp, #0
 8006232:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
 8006234:	2300      	movs	r3, #0
 8006236:	73fb      	strb	r3, [r7, #15]

  /* Memory Data size equal to Byte */
  if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_BYTE)
 8006238:	687b      	ldr	r3, [r7, #4]
 800623a:	699b      	ldr	r3, [r3, #24]
 800623c:	2b00      	cmp	r3, #0
 800623e:	d120      	bne.n	8006282 <DMA_CheckFifoParam+0x56>
  {
    switch (hdma->Init.FIFOThreshold)
 8006240:	687b      	ldr	r3, [r7, #4]
 8006242:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8006244:	2b03      	cmp	r3, #3
 8006246:	d858      	bhi.n	80062fa <DMA_CheckFifoParam+0xce>
 8006248:	a201      	add	r2, pc, #4	@ (adr r2, 8006250 <DMA_CheckFifoParam+0x24>)
 800624a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800624e:	bf00      	nop
 8006250:	08006261 	.word	0x08006261
 8006254:	08006273 	.word	0x08006273
 8006258:	08006261 	.word	0x08006261
 800625c:	080062fb 	.word	0x080062fb
    {
      case DMA_FIFO_THRESHOLD_1QUARTERFULL:
      case DMA_FIFO_THRESHOLD_3QUARTERSFULL:

        if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
 8006260:	687b      	ldr	r3, [r7, #4]
 8006262:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8006264:	f003 7380 	and.w	r3, r3, #16777216	@ 0x1000000
 8006268:	2b00      	cmp	r3, #0
 800626a:	d048      	beq.n	80062fe <DMA_CheckFifoParam+0xd2>
        {
          status = HAL_ERROR;
 800626c:	2301      	movs	r3, #1
 800626e:	73fb      	strb	r3, [r7, #15]
        }
        break;
 8006270:	e045      	b.n	80062fe <DMA_CheckFifoParam+0xd2>

      case DMA_FIFO_THRESHOLD_HALFFULL:
        if (hdma->Init.MemBurst == DMA_MBURST_INC16)
 8006272:	687b      	ldr	r3, [r7, #4]
 8006274:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8006276:	f1b3 7fc0 	cmp.w	r3, #25165824	@ 0x1800000
 800627a:	d142      	bne.n	8006302 <DMA_CheckFifoParam+0xd6>
        {
          status = HAL_ERROR;
 800627c:	2301      	movs	r3, #1
 800627e:	73fb      	strb	r3, [r7, #15]
        }
        break;
 8006280:	e03f      	b.n	8006302 <DMA_CheckFifoParam+0xd6>
        break;
    }
  }

  /* Memory Data size equal to Half-Word */
  else if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
 8006282:	687b      	ldr	r3, [r7, #4]
 8006284:	699b      	ldr	r3, [r3, #24]
 8006286:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 800628a:	d123      	bne.n	80062d4 <DMA_CheckFifoParam+0xa8>
  {
    switch (hdma->Init.FIFOThreshold)
 800628c:	687b      	ldr	r3, [r7, #4]
 800628e:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8006290:	2b03      	cmp	r3, #3
 8006292:	d838      	bhi.n	8006306 <DMA_CheckFifoParam+0xda>
 8006294:	a201      	add	r2, pc, #4	@ (adr r2, 800629c <DMA_CheckFifoParam+0x70>)
 8006296:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800629a:	bf00      	nop
 800629c:	080062ad 	.word	0x080062ad
 80062a0:	080062b3 	.word	0x080062b3
 80062a4:	080062ad 	.word	0x080062ad
 80062a8:	080062c5 	.word	0x080062c5
    {
      case DMA_FIFO_THRESHOLD_1QUARTERFULL:
      case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
        status = HAL_ERROR;
 80062ac:	2301      	movs	r3, #1
 80062ae:	73fb      	strb	r3, [r7, #15]
        break;
 80062b0:	e030      	b.n	8006314 <DMA_CheckFifoParam+0xe8>

      case DMA_FIFO_THRESHOLD_HALFFULL:
        if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
 80062b2:	687b      	ldr	r3, [r7, #4]
 80062b4:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80062b6:	f003 7380 	and.w	r3, r3, #16777216	@ 0x1000000
 80062ba:	2b00      	cmp	r3, #0
 80062bc:	d025      	beq.n	800630a <DMA_CheckFifoParam+0xde>
        {
          status = HAL_ERROR;
 80062be:	2301      	movs	r3, #1
 80062c0:	73fb      	strb	r3, [r7, #15]
        }
        break;
 80062c2:	e022      	b.n	800630a <DMA_CheckFifoParam+0xde>

      case DMA_FIFO_THRESHOLD_FULL:
        if (hdma->Init.MemBurst == DMA_MBURST_INC16)
 80062c4:	687b      	ldr	r3, [r7, #4]
 80062c6:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80062c8:	f1b3 7fc0 	cmp.w	r3, #25165824	@ 0x1800000
 80062cc:	d11f      	bne.n	800630e <DMA_CheckFifoParam+0xe2>
        {
          status = HAL_ERROR;
 80062ce:	2301      	movs	r3, #1
 80062d0:	73fb      	strb	r3, [r7, #15]
        }
        break;
 80062d2:	e01c      	b.n	800630e <DMA_CheckFifoParam+0xe2>
  }

  /* Memory Data size equal to Word */
  else
  {
    switch (hdma->Init.FIFOThreshold)
 80062d4:	687b      	ldr	r3, [r7, #4]
 80062d6:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80062d8:	2b02      	cmp	r3, #2
 80062da:	d902      	bls.n	80062e2 <DMA_CheckFifoParam+0xb6>
 80062dc:	2b03      	cmp	r3, #3
 80062de:	d003      	beq.n	80062e8 <DMA_CheckFifoParam+0xbc>
          status = HAL_ERROR;
        }
    break;

      default:
        break;
 80062e0:	e018      	b.n	8006314 <DMA_CheckFifoParam+0xe8>
        status = HAL_ERROR;
 80062e2:	2301      	movs	r3, #1
 80062e4:	73fb      	strb	r3, [r7, #15]
        break;
 80062e6:	e015      	b.n	8006314 <DMA_CheckFifoParam+0xe8>
        if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
 80062e8:	687b      	ldr	r3, [r7, #4]
 80062ea:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80062ec:	f003 7380 	and.w	r3, r3, #16777216	@ 0x1000000
 80062f0:	2b00      	cmp	r3, #0
 80062f2:	d00e      	beq.n	8006312 <DMA_CheckFifoParam+0xe6>
          status = HAL_ERROR;
 80062f4:	2301      	movs	r3, #1
 80062f6:	73fb      	strb	r3, [r7, #15]
    break;
 80062f8:	e00b      	b.n	8006312 <DMA_CheckFifoParam+0xe6>
        break;
 80062fa:	bf00      	nop
 80062fc:	e00a      	b.n	8006314 <DMA_CheckFifoParam+0xe8>
        break;
 80062fe:	bf00      	nop
 8006300:	e008      	b.n	8006314 <DMA_CheckFifoParam+0xe8>
        break;
 8006302:	bf00      	nop
 8006304:	e006      	b.n	8006314 <DMA_CheckFifoParam+0xe8>
        break;
 8006306:	bf00      	nop
 8006308:	e004      	b.n	8006314 <DMA_CheckFifoParam+0xe8>
        break;
 800630a:	bf00      	nop
 800630c:	e002      	b.n	8006314 <DMA_CheckFifoParam+0xe8>
        break;
 800630e:	bf00      	nop
 8006310:	e000      	b.n	8006314 <DMA_CheckFifoParam+0xe8>
    break;
 8006312:	bf00      	nop
    }
  }

  return status;
 8006314:	7bfb      	ldrb	r3, [r7, #15]
}
 8006316:	4618      	mov	r0, r3
 8006318:	3714      	adds	r7, #20
 800631a:	46bd      	mov	sp, r7
 800631c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006320:	4770      	bx	lr
 8006322:	bf00      	nop

08006324 <DMA_CalcDMAMUXChannelBaseAndMask>:
  * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
static void DMA_CalcDMAMUXChannelBaseAndMask(DMA_HandleTypeDef *hdma)
{
 8006324:	b480      	push	{r7}
 8006326:	b085      	sub	sp, #20
 8006328:	af00      	add	r7, sp, #0
 800632a:	6078      	str	r0, [r7, #4]
  uint32_t stream_number;
  uint32_t stream_baseaddress = (uint32_t)((uint32_t*)hdma->Instance);
 800632c:	687b      	ldr	r3, [r7, #4]
 800632e:	681b      	ldr	r3, [r3, #0]
 8006330:	60bb      	str	r3, [r7, #8]

  if(IS_BDMA_CHANNEL_DMAMUX_INSTANCE(hdma->Instance) != 0U)
 8006332:	687b      	ldr	r3, [r7, #4]
 8006334:	681b      	ldr	r3, [r3, #0]
 8006336:	4a38      	ldr	r2, [pc, #224]	@ (8006418 <DMA_CalcDMAMUXChannelBaseAndMask+0xf4>)
 8006338:	4293      	cmp	r3, r2
 800633a:	d022      	beq.n	8006382 <DMA_CalcDMAMUXChannelBaseAndMask+0x5e>
 800633c:	687b      	ldr	r3, [r7, #4]
 800633e:	681b      	ldr	r3, [r3, #0]
 8006340:	4a36      	ldr	r2, [pc, #216]	@ (800641c <DMA_CalcDMAMUXChannelBaseAndMask+0xf8>)
 8006342:	4293      	cmp	r3, r2
 8006344:	d01d      	beq.n	8006382 <DMA_CalcDMAMUXChannelBaseAndMask+0x5e>
 8006346:	687b      	ldr	r3, [r7, #4]
 8006348:	681b      	ldr	r3, [r3, #0]
 800634a:	4a35      	ldr	r2, [pc, #212]	@ (8006420 <DMA_CalcDMAMUXChannelBaseAndMask+0xfc>)
 800634c:	4293      	cmp	r3, r2
 800634e:	d018      	beq.n	8006382 <DMA_CalcDMAMUXChannelBaseAndMask+0x5e>
 8006350:	687b      	ldr	r3, [r7, #4]
 8006352:	681b      	ldr	r3, [r3, #0]
 8006354:	4a33      	ldr	r2, [pc, #204]	@ (8006424 <DMA_CalcDMAMUXChannelBaseAndMask+0x100>)
 8006356:	4293      	cmp	r3, r2
 8006358:	d013      	beq.n	8006382 <DMA_CalcDMAMUXChannelBaseAndMask+0x5e>
 800635a:	687b      	ldr	r3, [r7, #4]
 800635c:	681b      	ldr	r3, [r3, #0]
 800635e:	4a32      	ldr	r2, [pc, #200]	@ (8006428 <DMA_CalcDMAMUXChannelBaseAndMask+0x104>)
 8006360:	4293      	cmp	r3, r2
 8006362:	d00e      	beq.n	8006382 <DMA_CalcDMAMUXChannelBaseAndMask+0x5e>
 8006364:	687b      	ldr	r3, [r7, #4]
 8006366:	681b      	ldr	r3, [r3, #0]
 8006368:	4a30      	ldr	r2, [pc, #192]	@ (800642c <DMA_CalcDMAMUXChannelBaseAndMask+0x108>)
 800636a:	4293      	cmp	r3, r2
 800636c:	d009      	beq.n	8006382 <DMA_CalcDMAMUXChannelBaseAndMask+0x5e>
 800636e:	687b      	ldr	r3, [r7, #4]
 8006370:	681b      	ldr	r3, [r3, #0]
 8006372:	4a2f      	ldr	r2, [pc, #188]	@ (8006430 <DMA_CalcDMAMUXChannelBaseAndMask+0x10c>)
 8006374:	4293      	cmp	r3, r2
 8006376:	d004      	beq.n	8006382 <DMA_CalcDMAMUXChannelBaseAndMask+0x5e>
 8006378:	687b      	ldr	r3, [r7, #4]
 800637a:	681b      	ldr	r3, [r3, #0]
 800637c:	4a2d      	ldr	r2, [pc, #180]	@ (8006434 <DMA_CalcDMAMUXChannelBaseAndMask+0x110>)
 800637e:	4293      	cmp	r3, r2
 8006380:	d101      	bne.n	8006386 <DMA_CalcDMAMUXChannelBaseAndMask+0x62>
 8006382:	2301      	movs	r3, #1
 8006384:	e000      	b.n	8006388 <DMA_CalcDMAMUXChannelBaseAndMask+0x64>
 8006386:	2300      	movs	r3, #0
 8006388:	2b00      	cmp	r3, #0
 800638a:	d01a      	beq.n	80063c2 <DMA_CalcDMAMUXChannelBaseAndMask+0x9e>
  {
    /* BDMA Channels are connected to DMAMUX2 channels */
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 8U) / 20U;
 800638c:	687b      	ldr	r3, [r7, #4]
 800638e:	681b      	ldr	r3, [r3, #0]
 8006390:	b2db      	uxtb	r3, r3
 8006392:	3b08      	subs	r3, #8
 8006394:	4a28      	ldr	r2, [pc, #160]	@ (8006438 <DMA_CalcDMAMUXChannelBaseAndMask+0x114>)
 8006396:	fba2 2303 	umull	r2, r3, r2, r3
 800639a:	091b      	lsrs	r3, r3, #4
 800639c:	60fb      	str	r3, [r7, #12]
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_Channel0) + (stream_number * 4U)));
 800639e:	68fa      	ldr	r2, [r7, #12]
 80063a0:	4b26      	ldr	r3, [pc, #152]	@ (800643c <DMA_CalcDMAMUXChannelBaseAndMask+0x118>)
 80063a2:	4413      	add	r3, r2
 80063a4:	009b      	lsls	r3, r3, #2
 80063a6:	461a      	mov	r2, r3
 80063a8:	687b      	ldr	r3, [r7, #4]
 80063aa:	661a      	str	r2, [r3, #96]	@ 0x60
    hdma->DMAmuxChannelStatus = DMAMUX2_ChannelStatus;
 80063ac:	687b      	ldr	r3, [r7, #4]
 80063ae:	4a24      	ldr	r2, [pc, #144]	@ (8006440 <DMA_CalcDMAMUXChannelBaseAndMask+0x11c>)
 80063b0:	665a      	str	r2, [r3, #100]	@ 0x64
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
 80063b2:	68fb      	ldr	r3, [r7, #12]
 80063b4:	f003 031f 	and.w	r3, r3, #31
 80063b8:	2201      	movs	r2, #1
 80063ba:	409a      	lsls	r2, r3
 80063bc:	687b      	ldr	r3, [r7, #4]
 80063be:	669a      	str	r2, [r3, #104]	@ 0x68
    }
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_Channel0) + (stream_number * 4U)));
    hdma->DMAmuxChannelStatus = DMAMUX1_ChannelStatus;
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
  }
}
 80063c0:	e024      	b.n	800640c <DMA_CalcDMAMUXChannelBaseAndMask+0xe8>
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
 80063c2:	687b      	ldr	r3, [r7, #4]
 80063c4:	681b      	ldr	r3, [r3, #0]
 80063c6:	b2db      	uxtb	r3, r3
 80063c8:	3b10      	subs	r3, #16
 80063ca:	4a1e      	ldr	r2, [pc, #120]	@ (8006444 <DMA_CalcDMAMUXChannelBaseAndMask+0x120>)
 80063cc:	fba2 2303 	umull	r2, r3, r2, r3
 80063d0:	091b      	lsrs	r3, r3, #4
 80063d2:	60fb      	str	r3, [r7, #12]
    if((stream_baseaddress <= ((uint32_t)DMA2_Stream7) ) && \
 80063d4:	68bb      	ldr	r3, [r7, #8]
 80063d6:	4a1c      	ldr	r2, [pc, #112]	@ (8006448 <DMA_CalcDMAMUXChannelBaseAndMask+0x124>)
 80063d8:	4293      	cmp	r3, r2
 80063da:	d806      	bhi.n	80063ea <DMA_CalcDMAMUXChannelBaseAndMask+0xc6>
 80063dc:	68bb      	ldr	r3, [r7, #8]
 80063de:	4a1b      	ldr	r2, [pc, #108]	@ (800644c <DMA_CalcDMAMUXChannelBaseAndMask+0x128>)
 80063e0:	4293      	cmp	r3, r2
 80063e2:	d902      	bls.n	80063ea <DMA_CalcDMAMUXChannelBaseAndMask+0xc6>
      stream_number += 8U;
 80063e4:	68fb      	ldr	r3, [r7, #12]
 80063e6:	3308      	adds	r3, #8
 80063e8:	60fb      	str	r3, [r7, #12]
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_Channel0) + (stream_number * 4U)));
 80063ea:	68fa      	ldr	r2, [r7, #12]
 80063ec:	4b18      	ldr	r3, [pc, #96]	@ (8006450 <DMA_CalcDMAMUXChannelBaseAndMask+0x12c>)
 80063ee:	4413      	add	r3, r2
 80063f0:	009b      	lsls	r3, r3, #2
 80063f2:	461a      	mov	r2, r3
 80063f4:	687b      	ldr	r3, [r7, #4]
 80063f6:	661a      	str	r2, [r3, #96]	@ 0x60
    hdma->DMAmuxChannelStatus = DMAMUX1_ChannelStatus;
 80063f8:	687b      	ldr	r3, [r7, #4]
 80063fa:	4a16      	ldr	r2, [pc, #88]	@ (8006454 <DMA_CalcDMAMUXChannelBaseAndMask+0x130>)
 80063fc:	665a      	str	r2, [r3, #100]	@ 0x64
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
 80063fe:	68fb      	ldr	r3, [r7, #12]
 8006400:	f003 031f 	and.w	r3, r3, #31
 8006404:	2201      	movs	r2, #1
 8006406:	409a      	lsls	r2, r3
 8006408:	687b      	ldr	r3, [r7, #4]
 800640a:	669a      	str	r2, [r3, #104]	@ 0x68
}
 800640c:	bf00      	nop
 800640e:	3714      	adds	r7, #20
 8006410:	46bd      	mov	sp, r7
 8006412:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006416:	4770      	bx	lr
 8006418:	58025408 	.word	0x58025408
 800641c:	5802541c 	.word	0x5802541c
 8006420:	58025430 	.word	0x58025430
 8006424:	58025444 	.word	0x58025444
 8006428:	58025458 	.word	0x58025458
 800642c:	5802546c 	.word	0x5802546c
 8006430:	58025480 	.word	0x58025480
 8006434:	58025494 	.word	0x58025494
 8006438:	cccccccd 	.word	0xcccccccd
 800643c:	16009600 	.word	0x16009600
 8006440:	58025880 	.word	0x58025880
 8006444:	aaaaaaab 	.word	0xaaaaaaab
 8006448:	400204b8 	.word	0x400204b8
 800644c:	4002040f 	.word	0x4002040f
 8006450:	10008200 	.word	0x10008200
 8006454:	40020880 	.word	0x40020880

08006458 <DMA_CalcDMAMUXRequestGenBaseAndMask>:
  * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
static void DMA_CalcDMAMUXRequestGenBaseAndMask(DMA_HandleTypeDef *hdma)
{
 8006458:	b480      	push	{r7}
 800645a:	b085      	sub	sp, #20
 800645c:	af00      	add	r7, sp, #0
 800645e:	6078      	str	r0, [r7, #4]
  uint32_t request =  hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID;
 8006460:	687b      	ldr	r3, [r7, #4]
 8006462:	685b      	ldr	r3, [r3, #4]
 8006464:	b2db      	uxtb	r3, r3
 8006466:	60fb      	str	r3, [r7, #12]

  if((request >= DMA_REQUEST_GENERATOR0) && (request <= DMA_REQUEST_GENERATOR7))
 8006468:	68fb      	ldr	r3, [r7, #12]
 800646a:	2b00      	cmp	r3, #0
 800646c:	d04a      	beq.n	8006504 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xac>
 800646e:	68fb      	ldr	r3, [r7, #12]
 8006470:	2b08      	cmp	r3, #8
 8006472:	d847      	bhi.n	8006504 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xac>
  {
    if(IS_BDMA_CHANNEL_DMAMUX_INSTANCE(hdma->Instance) != 0U)
 8006474:	687b      	ldr	r3, [r7, #4]
 8006476:	681b      	ldr	r3, [r3, #0]
 8006478:	4a25      	ldr	r2, [pc, #148]	@ (8006510 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xb8>)
 800647a:	4293      	cmp	r3, r2
 800647c:	d022      	beq.n	80064c4 <DMA_CalcDMAMUXRequestGenBaseAndMask+0x6c>
 800647e:	687b      	ldr	r3, [r7, #4]
 8006480:	681b      	ldr	r3, [r3, #0]
 8006482:	4a24      	ldr	r2, [pc, #144]	@ (8006514 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xbc>)
 8006484:	4293      	cmp	r3, r2
 8006486:	d01d      	beq.n	80064c4 <DMA_CalcDMAMUXRequestGenBaseAndMask+0x6c>
 8006488:	687b      	ldr	r3, [r7, #4]
 800648a:	681b      	ldr	r3, [r3, #0]
 800648c:	4a22      	ldr	r2, [pc, #136]	@ (8006518 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xc0>)
 800648e:	4293      	cmp	r3, r2
 8006490:	d018      	beq.n	80064c4 <DMA_CalcDMAMUXRequestGenBaseAndMask+0x6c>
 8006492:	687b      	ldr	r3, [r7, #4]
 8006494:	681b      	ldr	r3, [r3, #0]
 8006496:	4a21      	ldr	r2, [pc, #132]	@ (800651c <DMA_CalcDMAMUXRequestGenBaseAndMask+0xc4>)
 8006498:	4293      	cmp	r3, r2
 800649a:	d013      	beq.n	80064c4 <DMA_CalcDMAMUXRequestGenBaseAndMask+0x6c>
 800649c:	687b      	ldr	r3, [r7, #4]
 800649e:	681b      	ldr	r3, [r3, #0]
 80064a0:	4a1f      	ldr	r2, [pc, #124]	@ (8006520 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xc8>)
 80064a2:	4293      	cmp	r3, r2
 80064a4:	d00e      	beq.n	80064c4 <DMA_CalcDMAMUXRequestGenBaseAndMask+0x6c>
 80064a6:	687b      	ldr	r3, [r7, #4]
 80064a8:	681b      	ldr	r3, [r3, #0]
 80064aa:	4a1e      	ldr	r2, [pc, #120]	@ (8006524 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xcc>)
 80064ac:	4293      	cmp	r3, r2
 80064ae:	d009      	beq.n	80064c4 <DMA_CalcDMAMUXRequestGenBaseAndMask+0x6c>
 80064b0:	687b      	ldr	r3, [r7, #4]
 80064b2:	681b      	ldr	r3, [r3, #0]
 80064b4:	4a1c      	ldr	r2, [pc, #112]	@ (8006528 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xd0>)
 80064b6:	4293      	cmp	r3, r2
 80064b8:	d004      	beq.n	80064c4 <DMA_CalcDMAMUXRequestGenBaseAndMask+0x6c>
 80064ba:	687b      	ldr	r3, [r7, #4]
 80064bc:	681b      	ldr	r3, [r3, #0]
 80064be:	4a1b      	ldr	r2, [pc, #108]	@ (800652c <DMA_CalcDMAMUXRequestGenBaseAndMask+0xd4>)
 80064c0:	4293      	cmp	r3, r2
 80064c2:	d101      	bne.n	80064c8 <DMA_CalcDMAMUXRequestGenBaseAndMask+0x70>
 80064c4:	2301      	movs	r3, #1
 80064c6:	e000      	b.n	80064ca <DMA_CalcDMAMUXRequestGenBaseAndMask+0x72>
 80064c8:	2300      	movs	r3, #0
 80064ca:	2b00      	cmp	r3, #0
 80064cc:	d00a      	beq.n	80064e4 <DMA_CalcDMAMUXRequestGenBaseAndMask+0x8c>
    {
      /* BDMA Channels are connected to DMAMUX2 request generator blocks */
      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_RequestGenerator0) + ((request - 1U) * 4U)));
 80064ce:	68fa      	ldr	r2, [r7, #12]
 80064d0:	4b17      	ldr	r3, [pc, #92]	@ (8006530 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xd8>)
 80064d2:	4413      	add	r3, r2
 80064d4:	009b      	lsls	r3, r3, #2
 80064d6:	461a      	mov	r2, r3
 80064d8:	687b      	ldr	r3, [r7, #4]
 80064da:	66da      	str	r2, [r3, #108]	@ 0x6c

      hdma->DMAmuxRequestGenStatus = DMAMUX2_RequestGenStatus;
 80064dc:	687b      	ldr	r3, [r7, #4]
 80064de:	4a15      	ldr	r2, [pc, #84]	@ (8006534 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xdc>)
 80064e0:	671a      	str	r2, [r3, #112]	@ 0x70
 80064e2:	e009      	b.n	80064f8 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xa0>
    }
    else
    {
      /* DMA1 and DMA2 Streams use DMAMUX1 request generator blocks */
      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
 80064e4:	68fa      	ldr	r2, [r7, #12]
 80064e6:	4b14      	ldr	r3, [pc, #80]	@ (8006538 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xe0>)
 80064e8:	4413      	add	r3, r2
 80064ea:	009b      	lsls	r3, r3, #2
 80064ec:	461a      	mov	r2, r3
 80064ee:	687b      	ldr	r3, [r7, #4]
 80064f0:	66da      	str	r2, [r3, #108]	@ 0x6c

      hdma->DMAmuxRequestGenStatus = DMAMUX1_RequestGenStatus;
 80064f2:	687b      	ldr	r3, [r7, #4]
 80064f4:	4a11      	ldr	r2, [pc, #68]	@ (800653c <DMA_CalcDMAMUXRequestGenBaseAndMask+0xe4>)
 80064f6:	671a      	str	r2, [r3, #112]	@ 0x70
    }

    hdma->DMAmuxRequestGenStatusMask = 1UL << (request - 1U);
 80064f8:	68fb      	ldr	r3, [r7, #12]
 80064fa:	3b01      	subs	r3, #1
 80064fc:	2201      	movs	r2, #1
 80064fe:	409a      	lsls	r2, r3
 8006500:	687b      	ldr	r3, [r7, #4]
 8006502:	675a      	str	r2, [r3, #116]	@ 0x74
  }
}
 8006504:	bf00      	nop
 8006506:	3714      	adds	r7, #20
 8006508:	46bd      	mov	sp, r7
 800650a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800650e:	4770      	bx	lr
 8006510:	58025408 	.word	0x58025408
 8006514:	5802541c 	.word	0x5802541c
 8006518:	58025430 	.word	0x58025430
 800651c:	58025444 	.word	0x58025444
 8006520:	58025458 	.word	0x58025458
 8006524:	5802546c 	.word	0x5802546c
 8006528:	58025480 	.word	0x58025480
 800652c:	58025494 	.word	0x58025494
 8006530:	1600963f 	.word	0x1600963f
 8006534:	58025940 	.word	0x58025940
 8006538:	1000823f 	.word	0x1000823f
 800653c:	40020940 	.word	0x40020940

08006540 <HAL_GPIO_Init>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8006540:	b480      	push	{r7}
 8006542:	b089      	sub	sp, #36	@ 0x24
 8006544:	af00      	add	r7, sp, #0
 8006546:	6078      	str	r0, [r7, #4]
 8006548:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00U;
 800654a:	2300      	movs	r3, #0
 800654c:	61fb      	str	r3, [r7, #28]
  EXTI_Core_TypeDef *EXTI_CurrentCPU;

#if defined(DUAL_CORE) && defined(CORE_CM4)
  EXTI_CurrentCPU = EXTI_D2; /* EXTI for CM4 CPU */
#else
  EXTI_CurrentCPU = EXTI_D1; /* EXTI for CM7 CPU */
 800654e:	4b89      	ldr	r3, [pc, #548]	@ (8006774 <HAL_GPIO_Init+0x234>)
 8006550:	617b      	str	r3, [r7, #20]
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0x00U)
 8006552:	e194      	b.n	800687e <HAL_GPIO_Init+0x33e>
  {
    /* Get current io position */
    iocurrent = (GPIO_Init->Pin) & (1UL << position);
 8006554:	683b      	ldr	r3, [r7, #0]
 8006556:	681a      	ldr	r2, [r3, #0]
 8006558:	2101      	movs	r1, #1
 800655a:	69fb      	ldr	r3, [r7, #28]
 800655c:	fa01 f303 	lsl.w	r3, r1, r3
 8006560:	4013      	ands	r3, r2
 8006562:	613b      	str	r3, [r7, #16]

    if (iocurrent != 0x00U)
 8006564:	693b      	ldr	r3, [r7, #16]
 8006566:	2b00      	cmp	r3, #0
 8006568:	f000 8186 	beq.w	8006878 <HAL_GPIO_Init+0x338>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Output or Alternate function mode selection */
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
 800656c:	683b      	ldr	r3, [r7, #0]
 800656e:	685b      	ldr	r3, [r3, #4]
 8006570:	f003 0303 	and.w	r3, r3, #3
 8006574:	2b01      	cmp	r3, #1
 8006576:	d005      	beq.n	8006584 <HAL_GPIO_Init+0x44>
 8006578:	683b      	ldr	r3, [r7, #0]
 800657a:	685b      	ldr	r3, [r3, #4]
 800657c:	f003 0303 	and.w	r3, r3, #3
 8006580:	2b02      	cmp	r3, #2
 8006582:	d130      	bne.n	80065e6 <HAL_GPIO_Init+0xa6>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));

        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR;
 8006584:	687b      	ldr	r3, [r7, #4]
 8006586:	689b      	ldr	r3, [r3, #8]
 8006588:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 800658a:	69fb      	ldr	r3, [r7, #28]
 800658c:	005b      	lsls	r3, r3, #1
 800658e:	2203      	movs	r2, #3
 8006590:	fa02 f303 	lsl.w	r3, r2, r3
 8006594:	43db      	mvns	r3, r3
 8006596:	69ba      	ldr	r2, [r7, #24]
 8006598:	4013      	ands	r3, r2
 800659a:	61bb      	str	r3, [r7, #24]
        temp |= (GPIO_Init->Speed << (position * 2U));
 800659c:	683b      	ldr	r3, [r7, #0]
 800659e:	68da      	ldr	r2, [r3, #12]
 80065a0:	69fb      	ldr	r3, [r7, #28]
 80065a2:	005b      	lsls	r3, r3, #1
 80065a4:	fa02 f303 	lsl.w	r3, r2, r3
 80065a8:	69ba      	ldr	r2, [r7, #24]
 80065aa:	4313      	orrs	r3, r2
 80065ac:	61bb      	str	r3, [r7, #24]
        GPIOx->OSPEEDR = temp;
 80065ae:	687b      	ldr	r3, [r7, #4]
 80065b0:	69ba      	ldr	r2, [r7, #24]
 80065b2:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
 80065b4:	687b      	ldr	r3, [r7, #4]
 80065b6:	685b      	ldr	r3, [r3, #4]
 80065b8:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
 80065ba:	2201      	movs	r2, #1
 80065bc:	69fb      	ldr	r3, [r7, #28]
 80065be:	fa02 f303 	lsl.w	r3, r2, r3
 80065c2:	43db      	mvns	r3, r3
 80065c4:	69ba      	ldr	r2, [r7, #24]
 80065c6:	4013      	ands	r3, r2
 80065c8:	61bb      	str	r3, [r7, #24]
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
 80065ca:	683b      	ldr	r3, [r7, #0]
 80065cc:	685b      	ldr	r3, [r3, #4]
 80065ce:	091b      	lsrs	r3, r3, #4
 80065d0:	f003 0201 	and.w	r2, r3, #1
 80065d4:	69fb      	ldr	r3, [r7, #28]
 80065d6:	fa02 f303 	lsl.w	r3, r2, r3
 80065da:	69ba      	ldr	r2, [r7, #24]
 80065dc:	4313      	orrs	r3, r2
 80065de:	61bb      	str	r3, [r7, #24]
        GPIOx->OTYPER = temp;
 80065e0:	687b      	ldr	r3, [r7, #4]
 80065e2:	69ba      	ldr	r2, [r7, #24]
 80065e4:	605a      	str	r2, [r3, #4]
      }

      if ((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)
 80065e6:	683b      	ldr	r3, [r7, #0]
 80065e8:	685b      	ldr	r3, [r3, #4]
 80065ea:	f003 0303 	and.w	r3, r3, #3
 80065ee:	2b03      	cmp	r3, #3
 80065f0:	d017      	beq.n	8006622 <HAL_GPIO_Init+0xe2>
      {
       /* Check the Pull parameter */
       assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

      /* Activate the Pull-up or Pull down resistor for the current IO */
      temp = GPIOx->PUPDR;
 80065f2:	687b      	ldr	r3, [r7, #4]
 80065f4:	68db      	ldr	r3, [r3, #12]
 80065f6:	61bb      	str	r3, [r7, #24]
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 80065f8:	69fb      	ldr	r3, [r7, #28]
 80065fa:	005b      	lsls	r3, r3, #1
 80065fc:	2203      	movs	r2, #3
 80065fe:	fa02 f303 	lsl.w	r3, r2, r3
 8006602:	43db      	mvns	r3, r3
 8006604:	69ba      	ldr	r2, [r7, #24]
 8006606:	4013      	ands	r3, r2
 8006608:	61bb      	str	r3, [r7, #24]
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 800660a:	683b      	ldr	r3, [r7, #0]
 800660c:	689a      	ldr	r2, [r3, #8]
 800660e:	69fb      	ldr	r3, [r7, #28]
 8006610:	005b      	lsls	r3, r3, #1
 8006612:	fa02 f303 	lsl.w	r3, r2, r3
 8006616:	69ba      	ldr	r2, [r7, #24]
 8006618:	4313      	orrs	r3, r2
 800661a:	61bb      	str	r3, [r7, #24]
      GPIOx->PUPDR = temp;
 800661c:	687b      	ldr	r3, [r7, #4]
 800661e:	69ba      	ldr	r2, [r7, #24]
 8006620:	60da      	str	r2, [r3, #12]
      }

      /* In case of Alternate function mode selection */
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 8006622:	683b      	ldr	r3, [r7, #0]
 8006624:	685b      	ldr	r3, [r3, #4]
 8006626:	f003 0303 	and.w	r3, r3, #3
 800662a:	2b02      	cmp	r3, #2
 800662c:	d123      	bne.n	8006676 <HAL_GPIO_Init+0x136>
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));

        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3U];
 800662e:	69fb      	ldr	r3, [r7, #28]
 8006630:	08da      	lsrs	r2, r3, #3
 8006632:	687b      	ldr	r3, [r7, #4]
 8006634:	3208      	adds	r2, #8
 8006636:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800663a:	61bb      	str	r3, [r7, #24]
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
 800663c:	69fb      	ldr	r3, [r7, #28]
 800663e:	f003 0307 	and.w	r3, r3, #7
 8006642:	009b      	lsls	r3, r3, #2
 8006644:	220f      	movs	r2, #15
 8006646:	fa02 f303 	lsl.w	r3, r2, r3
 800664a:	43db      	mvns	r3, r3
 800664c:	69ba      	ldr	r2, [r7, #24]
 800664e:	4013      	ands	r3, r2
 8006650:	61bb      	str	r3, [r7, #24]
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
 8006652:	683b      	ldr	r3, [r7, #0]
 8006654:	691a      	ldr	r2, [r3, #16]
 8006656:	69fb      	ldr	r3, [r7, #28]
 8006658:	f003 0307 	and.w	r3, r3, #7
 800665c:	009b      	lsls	r3, r3, #2
 800665e:	fa02 f303 	lsl.w	r3, r2, r3
 8006662:	69ba      	ldr	r2, [r7, #24]
 8006664:	4313      	orrs	r3, r2
 8006666:	61bb      	str	r3, [r7, #24]
        GPIOx->AFR[position >> 3U] = temp;
 8006668:	69fb      	ldr	r3, [r7, #28]
 800666a:	08da      	lsrs	r2, r3, #3
 800666c:	687b      	ldr	r3, [r7, #4]
 800666e:	3208      	adds	r2, #8
 8006670:	69b9      	ldr	r1, [r7, #24]
 8006672:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 8006676:	687b      	ldr	r3, [r7, #4]
 8006678:	681b      	ldr	r3, [r3, #0]
 800667a:	61bb      	str	r3, [r7, #24]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
 800667c:	69fb      	ldr	r3, [r7, #28]
 800667e:	005b      	lsls	r3, r3, #1
 8006680:	2203      	movs	r2, #3
 8006682:	fa02 f303 	lsl.w	r3, r2, r3
 8006686:	43db      	mvns	r3, r3
 8006688:	69ba      	ldr	r2, [r7, #24]
 800668a:	4013      	ands	r3, r2
 800668c:	61bb      	str	r3, [r7, #24]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 800668e:	683b      	ldr	r3, [r7, #0]
 8006690:	685b      	ldr	r3, [r3, #4]
 8006692:	f003 0203 	and.w	r2, r3, #3
 8006696:	69fb      	ldr	r3, [r7, #28]
 8006698:	005b      	lsls	r3, r3, #1
 800669a:	fa02 f303 	lsl.w	r3, r2, r3
 800669e:	69ba      	ldr	r2, [r7, #24]
 80066a0:	4313      	orrs	r3, r2
 80066a2:	61bb      	str	r3, [r7, #24]
      GPIOx->MODER = temp;
 80066a4:	687b      	ldr	r3, [r7, #4]
 80066a6:	69ba      	ldr	r2, [r7, #24]
 80066a8:	601a      	str	r2, [r3, #0]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00U)
 80066aa:	683b      	ldr	r3, [r7, #0]
 80066ac:	685b      	ldr	r3, [r3, #4]
 80066ae:	f403 3340 	and.w	r3, r3, #196608	@ 0x30000
 80066b2:	2b00      	cmp	r3, #0
 80066b4:	f000 80e0 	beq.w	8006878 <HAL_GPIO_Init+0x338>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 80066b8:	4b2f      	ldr	r3, [pc, #188]	@ (8006778 <HAL_GPIO_Init+0x238>)
 80066ba:	f8d3 3154 	ldr.w	r3, [r3, #340]	@ 0x154
 80066be:	4a2e      	ldr	r2, [pc, #184]	@ (8006778 <HAL_GPIO_Init+0x238>)
 80066c0:	f043 0302 	orr.w	r3, r3, #2
 80066c4:	f8c2 3154 	str.w	r3, [r2, #340]	@ 0x154
 80066c8:	4b2b      	ldr	r3, [pc, #172]	@ (8006778 <HAL_GPIO_Init+0x238>)
 80066ca:	f8d3 3154 	ldr.w	r3, [r3, #340]	@ 0x154
 80066ce:	f003 0302 	and.w	r3, r3, #2
 80066d2:	60fb      	str	r3, [r7, #12]
 80066d4:	68fb      	ldr	r3, [r7, #12]

        temp = SYSCFG->EXTICR[position >> 2U];
 80066d6:	4a29      	ldr	r2, [pc, #164]	@ (800677c <HAL_GPIO_Init+0x23c>)
 80066d8:	69fb      	ldr	r3, [r7, #28]
 80066da:	089b      	lsrs	r3, r3, #2
 80066dc:	3302      	adds	r3, #2
 80066de:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80066e2:	61bb      	str	r3, [r7, #24]
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
 80066e4:	69fb      	ldr	r3, [r7, #28]
 80066e6:	f003 0303 	and.w	r3, r3, #3
 80066ea:	009b      	lsls	r3, r3, #2
 80066ec:	220f      	movs	r2, #15
 80066ee:	fa02 f303 	lsl.w	r3, r2, r3
 80066f2:	43db      	mvns	r3, r3
 80066f4:	69ba      	ldr	r2, [r7, #24]
 80066f6:	4013      	ands	r3, r2
 80066f8:	61bb      	str	r3, [r7, #24]
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 80066fa:	687b      	ldr	r3, [r7, #4]
 80066fc:	4a20      	ldr	r2, [pc, #128]	@ (8006780 <HAL_GPIO_Init+0x240>)
 80066fe:	4293      	cmp	r3, r2
 8006700:	d052      	beq.n	80067a8 <HAL_GPIO_Init+0x268>
 8006702:	687b      	ldr	r3, [r7, #4]
 8006704:	4a1f      	ldr	r2, [pc, #124]	@ (8006784 <HAL_GPIO_Init+0x244>)
 8006706:	4293      	cmp	r3, r2
 8006708:	d031      	beq.n	800676e <HAL_GPIO_Init+0x22e>
 800670a:	687b      	ldr	r3, [r7, #4]
 800670c:	4a1e      	ldr	r2, [pc, #120]	@ (8006788 <HAL_GPIO_Init+0x248>)
 800670e:	4293      	cmp	r3, r2
 8006710:	d02b      	beq.n	800676a <HAL_GPIO_Init+0x22a>
 8006712:	687b      	ldr	r3, [r7, #4]
 8006714:	4a1d      	ldr	r2, [pc, #116]	@ (800678c <HAL_GPIO_Init+0x24c>)
 8006716:	4293      	cmp	r3, r2
 8006718:	d025      	beq.n	8006766 <HAL_GPIO_Init+0x226>
 800671a:	687b      	ldr	r3, [r7, #4]
 800671c:	4a1c      	ldr	r2, [pc, #112]	@ (8006790 <HAL_GPIO_Init+0x250>)
 800671e:	4293      	cmp	r3, r2
 8006720:	d01f      	beq.n	8006762 <HAL_GPIO_Init+0x222>
 8006722:	687b      	ldr	r3, [r7, #4]
 8006724:	4a1b      	ldr	r2, [pc, #108]	@ (8006794 <HAL_GPIO_Init+0x254>)
 8006726:	4293      	cmp	r3, r2
 8006728:	d019      	beq.n	800675e <HAL_GPIO_Init+0x21e>
 800672a:	687b      	ldr	r3, [r7, #4]
 800672c:	4a1a      	ldr	r2, [pc, #104]	@ (8006798 <HAL_GPIO_Init+0x258>)
 800672e:	4293      	cmp	r3, r2
 8006730:	d013      	beq.n	800675a <HAL_GPIO_Init+0x21a>
 8006732:	687b      	ldr	r3, [r7, #4]
 8006734:	4a19      	ldr	r2, [pc, #100]	@ (800679c <HAL_GPIO_Init+0x25c>)
 8006736:	4293      	cmp	r3, r2
 8006738:	d00d      	beq.n	8006756 <HAL_GPIO_Init+0x216>
 800673a:	687b      	ldr	r3, [r7, #4]
 800673c:	4a18      	ldr	r2, [pc, #96]	@ (80067a0 <HAL_GPIO_Init+0x260>)
 800673e:	4293      	cmp	r3, r2
 8006740:	d007      	beq.n	8006752 <HAL_GPIO_Init+0x212>
 8006742:	687b      	ldr	r3, [r7, #4]
 8006744:	4a17      	ldr	r2, [pc, #92]	@ (80067a4 <HAL_GPIO_Init+0x264>)
 8006746:	4293      	cmp	r3, r2
 8006748:	d101      	bne.n	800674e <HAL_GPIO_Init+0x20e>
 800674a:	2309      	movs	r3, #9
 800674c:	e02d      	b.n	80067aa <HAL_GPIO_Init+0x26a>
 800674e:	230a      	movs	r3, #10
 8006750:	e02b      	b.n	80067aa <HAL_GPIO_Init+0x26a>
 8006752:	2308      	movs	r3, #8
 8006754:	e029      	b.n	80067aa <HAL_GPIO_Init+0x26a>
 8006756:	2307      	movs	r3, #7
 8006758:	e027      	b.n	80067aa <HAL_GPIO_Init+0x26a>
 800675a:	2306      	movs	r3, #6
 800675c:	e025      	b.n	80067aa <HAL_GPIO_Init+0x26a>
 800675e:	2305      	movs	r3, #5
 8006760:	e023      	b.n	80067aa <HAL_GPIO_Init+0x26a>
 8006762:	2304      	movs	r3, #4
 8006764:	e021      	b.n	80067aa <HAL_GPIO_Init+0x26a>
 8006766:	2303      	movs	r3, #3
 8006768:	e01f      	b.n	80067aa <HAL_GPIO_Init+0x26a>
 800676a:	2302      	movs	r3, #2
 800676c:	e01d      	b.n	80067aa <HAL_GPIO_Init+0x26a>
 800676e:	2301      	movs	r3, #1
 8006770:	e01b      	b.n	80067aa <HAL_GPIO_Init+0x26a>
 8006772:	bf00      	nop
 8006774:	58000080 	.word	0x58000080
 8006778:	58024400 	.word	0x58024400
 800677c:	58000400 	.word	0x58000400
 8006780:	58020000 	.word	0x58020000
 8006784:	58020400 	.word	0x58020400
 8006788:	58020800 	.word	0x58020800
 800678c:	58020c00 	.word	0x58020c00
 8006790:	58021000 	.word	0x58021000
 8006794:	58021400 	.word	0x58021400
 8006798:	58021800 	.word	0x58021800
 800679c:	58021c00 	.word	0x58021c00
 80067a0:	58022000 	.word	0x58022000
 80067a4:	58022400 	.word	0x58022400
 80067a8:	2300      	movs	r3, #0
 80067aa:	69fa      	ldr	r2, [r7, #28]
 80067ac:	f002 0203 	and.w	r2, r2, #3
 80067b0:	0092      	lsls	r2, r2, #2
 80067b2:	4093      	lsls	r3, r2
 80067b4:	69ba      	ldr	r2, [r7, #24]
 80067b6:	4313      	orrs	r3, r2
 80067b8:	61bb      	str	r3, [r7, #24]
        SYSCFG->EXTICR[position >> 2U] = temp;
 80067ba:	4938      	ldr	r1, [pc, #224]	@ (800689c <HAL_GPIO_Init+0x35c>)
 80067bc:	69fb      	ldr	r3, [r7, #28]
 80067be:	089b      	lsrs	r3, r3, #2
 80067c0:	3302      	adds	r3, #2
 80067c2:	69ba      	ldr	r2, [r7, #24]
 80067c4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
 80067c8:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 80067cc:	681b      	ldr	r3, [r3, #0]
 80067ce:	61bb      	str	r3, [r7, #24]
        temp &= ~(iocurrent);
 80067d0:	693b      	ldr	r3, [r7, #16]
 80067d2:	43db      	mvns	r3, r3
 80067d4:	69ba      	ldr	r2, [r7, #24]
 80067d6:	4013      	ands	r3, r2
 80067d8:	61bb      	str	r3, [r7, #24]
        if ((GPIO_Init->Mode & TRIGGER_RISING) != 0x00U)
 80067da:	683b      	ldr	r3, [r7, #0]
 80067dc:	685b      	ldr	r3, [r3, #4]
 80067de:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
 80067e2:	2b00      	cmp	r3, #0
 80067e4:	d003      	beq.n	80067ee <HAL_GPIO_Init+0x2ae>
        {
          temp |= iocurrent;
 80067e6:	69ba      	ldr	r2, [r7, #24]
 80067e8:	693b      	ldr	r3, [r7, #16]
 80067ea:	4313      	orrs	r3, r2
 80067ec:	61bb      	str	r3, [r7, #24]
        }
        EXTI->RTSR1 = temp;
 80067ee:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 80067f2:	69bb      	ldr	r3, [r7, #24]
 80067f4:	6013      	str	r3, [r2, #0]

        temp = EXTI->FTSR1;
 80067f6:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 80067fa:	685b      	ldr	r3, [r3, #4]
 80067fc:	61bb      	str	r3, [r7, #24]
        temp &= ~(iocurrent);
 80067fe:	693b      	ldr	r3, [r7, #16]
 8006800:	43db      	mvns	r3, r3
 8006802:	69ba      	ldr	r2, [r7, #24]
 8006804:	4013      	ands	r3, r2
 8006806:	61bb      	str	r3, [r7, #24]
        if ((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00U)
 8006808:	683b      	ldr	r3, [r7, #0]
 800680a:	685b      	ldr	r3, [r3, #4]
 800680c:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
 8006810:	2b00      	cmp	r3, #0
 8006812:	d003      	beq.n	800681c <HAL_GPIO_Init+0x2dc>
        {
          temp |= iocurrent;
 8006814:	69ba      	ldr	r2, [r7, #24]
 8006816:	693b      	ldr	r3, [r7, #16]
 8006818:	4313      	orrs	r3, r2
 800681a:	61bb      	str	r3, [r7, #24]
        }
        EXTI->FTSR1 = temp;
 800681c:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8006820:	69bb      	ldr	r3, [r7, #24]
 8006822:	6053      	str	r3, [r2, #4]

        temp = EXTI_CurrentCPU->EMR1;
 8006824:	697b      	ldr	r3, [r7, #20]
 8006826:	685b      	ldr	r3, [r3, #4]
 8006828:	61bb      	str	r3, [r7, #24]
        temp &= ~(iocurrent);
 800682a:	693b      	ldr	r3, [r7, #16]
 800682c:	43db      	mvns	r3, r3
 800682e:	69ba      	ldr	r2, [r7, #24]
 8006830:	4013      	ands	r3, r2
 8006832:	61bb      	str	r3, [r7, #24]
        if ((GPIO_Init->Mode & EXTI_EVT) != 0x00U)
 8006834:	683b      	ldr	r3, [r7, #0]
 8006836:	685b      	ldr	r3, [r3, #4]
 8006838:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 800683c:	2b00      	cmp	r3, #0
 800683e:	d003      	beq.n	8006848 <HAL_GPIO_Init+0x308>
        {
          temp |= iocurrent;
 8006840:	69ba      	ldr	r2, [r7, #24]
 8006842:	693b      	ldr	r3, [r7, #16]
 8006844:	4313      	orrs	r3, r2
 8006846:	61bb      	str	r3, [r7, #24]
        }
        EXTI_CurrentCPU->EMR1 = temp;
 8006848:	697b      	ldr	r3, [r7, #20]
 800684a:	69ba      	ldr	r2, [r7, #24]
 800684c:	605a      	str	r2, [r3, #4]

        /* Clear EXTI line configuration */
        temp = EXTI_CurrentCPU->IMR1;
 800684e:	697b      	ldr	r3, [r7, #20]
 8006850:	681b      	ldr	r3, [r3, #0]
 8006852:	61bb      	str	r3, [r7, #24]
        temp &= ~(iocurrent);
 8006854:	693b      	ldr	r3, [r7, #16]
 8006856:	43db      	mvns	r3, r3
 8006858:	69ba      	ldr	r2, [r7, #24]
 800685a:	4013      	ands	r3, r2
 800685c:	61bb      	str	r3, [r7, #24]
        if ((GPIO_Init->Mode & EXTI_IT) != 0x00U)
 800685e:	683b      	ldr	r3, [r7, #0]
 8006860:	685b      	ldr	r3, [r3, #4]
 8006862:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 8006866:	2b00      	cmp	r3, #0
 8006868:	d003      	beq.n	8006872 <HAL_GPIO_Init+0x332>
        {
          temp |= iocurrent;
 800686a:	69ba      	ldr	r2, [r7, #24]
 800686c:	693b      	ldr	r3, [r7, #16]
 800686e:	4313      	orrs	r3, r2
 8006870:	61bb      	str	r3, [r7, #24]
        }
        EXTI_CurrentCPU->IMR1 = temp;
 8006872:	697b      	ldr	r3, [r7, #20]
 8006874:	69ba      	ldr	r2, [r7, #24]
 8006876:	601a      	str	r2, [r3, #0]
      }
    }

    position++;
 8006878:	69fb      	ldr	r3, [r7, #28]
 800687a:	3301      	adds	r3, #1
 800687c:	61fb      	str	r3, [r7, #28]
  while (((GPIO_Init->Pin) >> position) != 0x00U)
 800687e:	683b      	ldr	r3, [r7, #0]
 8006880:	681a      	ldr	r2, [r3, #0]
 8006882:	69fb      	ldr	r3, [r7, #28]
 8006884:	fa22 f303 	lsr.w	r3, r2, r3
 8006888:	2b00      	cmp	r3, #0
 800688a:	f47f ae63 	bne.w	8006554 <HAL_GPIO_Init+0x14>
  }
}
 800688e:	bf00      	nop
 8006890:	bf00      	nop
 8006892:	3724      	adds	r7, #36	@ 0x24
 8006894:	46bd      	mov	sp, r7
 8006896:	f85d 7b04 	ldr.w	r7, [sp], #4
 800689a:	4770      	bx	lr
 800689c:	58000400 	.word	0x58000400

080068a0 <HAL_GPIO_ReadPin>:
  * @param  GPIO_Pin: specifies the port bit to read.
  *         This parameter can be GPIO_PIN_x where x can be (0..15).
  * @retval The input port pin value.
  */
GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
{
 80068a0:	b480      	push	{r7}
 80068a2:	b085      	sub	sp, #20
 80068a4:	af00      	add	r7, sp, #0
 80068a6:	6078      	str	r0, [r7, #4]
 80068a8:	460b      	mov	r3, r1
 80068aa:	807b      	strh	r3, [r7, #2]
  GPIO_PinState bitstatus;

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  if ((GPIOx->IDR & GPIO_Pin) != 0x00U)
 80068ac:	687b      	ldr	r3, [r7, #4]
 80068ae:	691a      	ldr	r2, [r3, #16]
 80068b0:	887b      	ldrh	r3, [r7, #2]
 80068b2:	4013      	ands	r3, r2
 80068b4:	2b00      	cmp	r3, #0
 80068b6:	d002      	beq.n	80068be <HAL_GPIO_ReadPin+0x1e>
  {
    bitstatus = GPIO_PIN_SET;
 80068b8:	2301      	movs	r3, #1
 80068ba:	73fb      	strb	r3, [r7, #15]
 80068bc:	e001      	b.n	80068c2 <HAL_GPIO_ReadPin+0x22>
  }
  else
  {
    bitstatus = GPIO_PIN_RESET;
 80068be:	2300      	movs	r3, #0
 80068c0:	73fb      	strb	r3, [r7, #15]
  }
  return bitstatus;
 80068c2:	7bfb      	ldrb	r3, [r7, #15]
}
 80068c4:	4618      	mov	r0, r3
 80068c6:	3714      	adds	r7, #20
 80068c8:	46bd      	mov	sp, r7
 80068ca:	f85d 7b04 	ldr.w	r7, [sp], #4
 80068ce:	4770      	bx	lr

080068d0 <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
 80068d0:	b480      	push	{r7}
 80068d2:	b083      	sub	sp, #12
 80068d4:	af00      	add	r7, sp, #0
 80068d6:	6078      	str	r0, [r7, #4]
 80068d8:	460b      	mov	r3, r1
 80068da:	807b      	strh	r3, [r7, #2]
 80068dc:	4613      	mov	r3, r2
 80068de:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
 80068e0:	787b      	ldrb	r3, [r7, #1]
 80068e2:	2b00      	cmp	r3, #0
 80068e4:	d003      	beq.n	80068ee <HAL_GPIO_WritePin+0x1e>
  {
    GPIOx->BSRR = GPIO_Pin;
 80068e6:	887a      	ldrh	r2, [r7, #2]
 80068e8:	687b      	ldr	r3, [r7, #4]
 80068ea:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << GPIO_NUMBER;
  }
}
 80068ec:	e003      	b.n	80068f6 <HAL_GPIO_WritePin+0x26>
    GPIOx->BSRR = (uint32_t)GPIO_Pin << GPIO_NUMBER;
 80068ee:	887b      	ldrh	r3, [r7, #2]
 80068f0:	041a      	lsls	r2, r3, #16
 80068f2:	687b      	ldr	r3, [r7, #4]
 80068f4:	619a      	str	r2, [r3, #24]
}
 80068f6:	bf00      	nop
 80068f8:	370c      	adds	r7, #12
 80068fa:	46bd      	mov	sp, r7
 80068fc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006900:	4770      	bx	lr

08006902 <HAL_GPIO_EXTI_IRQHandler>:
  * @brief  Handle EXTI interrupt request.
  * @param  GPIO_Pin: Specifies the port pin connected to corresponding EXTI line.
  * @retval None
  */
void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
{
 8006902:	b580      	push	{r7, lr}
 8006904:	b082      	sub	sp, #8
 8006906:	af00      	add	r7, sp, #0
 8006908:	4603      	mov	r3, r0
 800690a:	80fb      	strh	r3, [r7, #6]
    __HAL_GPIO_EXTID2_CLEAR_IT(GPIO_Pin);
    HAL_GPIO_EXTI_Callback(GPIO_Pin);
  }
#else
  /* EXTI line interrupt detected */
  if (__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != 0x00U)
 800690c:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8006910:	f8d3 2088 	ldr.w	r2, [r3, #136]	@ 0x88
 8006914:	88fb      	ldrh	r3, [r7, #6]
 8006916:	4013      	ands	r3, r2
 8006918:	2b00      	cmp	r3, #0
 800691a:	d008      	beq.n	800692e <HAL_GPIO_EXTI_IRQHandler+0x2c>
  {
    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
 800691c:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8006920:	88fb      	ldrh	r3, [r7, #6]
 8006922:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88
    HAL_GPIO_EXTI_Callback(GPIO_Pin);
 8006926:	88fb      	ldrh	r3, [r7, #6]
 8006928:	4618      	mov	r0, r3
 800692a:	f7fa fa01 	bl	8000d30 <HAL_GPIO_EXTI_Callback>
  }
#endif
}
 800692e:	bf00      	nop
 8006930:	3708      	adds	r7, #8
 8006932:	46bd      	mov	sp, r7
 8006934:	bd80      	pop	{r7, pc}
	...

08006938 <HAL_I2C_Init>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Init(I2C_HandleTypeDef *hi2c)
{
 8006938:	b580      	push	{r7, lr}
 800693a:	b082      	sub	sp, #8
 800693c:	af00      	add	r7, sp, #0
 800693e:	6078      	str	r0, [r7, #4]
  /* Check the I2C handle allocation */
  if (hi2c == NULL)
 8006940:	687b      	ldr	r3, [r7, #4]
 8006942:	2b00      	cmp	r3, #0
 8006944:	d101      	bne.n	800694a <HAL_I2C_Init+0x12>
  {
    return HAL_ERROR;
 8006946:	2301      	movs	r3, #1
 8006948:	e08b      	b.n	8006a62 <HAL_I2C_Init+0x12a>
  assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
  assert_param(IS_I2C_OWN_ADDRESS2_MASK(hi2c->Init.OwnAddress2Masks));
  assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
  assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));

  if (hi2c->State == HAL_I2C_STATE_RESET)
 800694a:	687b      	ldr	r3, [r7, #4]
 800694c:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
 8006950:	b2db      	uxtb	r3, r3
 8006952:	2b00      	cmp	r3, #0
 8006954:	d106      	bne.n	8006964 <HAL_I2C_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    hi2c->Lock = HAL_UNLOCKED;
 8006956:	687b      	ldr	r3, [r7, #4]
 8006958:	2200      	movs	r2, #0
 800695a:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    hi2c->MspInitCallback(hi2c);
#else
    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    HAL_I2C_MspInit(hi2c);
 800695e:	6878      	ldr	r0, [r7, #4]
 8006960:	f7fb fb58 	bl	8002014 <HAL_I2C_MspInit>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
  }

  hi2c->State = HAL_I2C_STATE_BUSY;
 8006964:	687b      	ldr	r3, [r7, #4]
 8006966:	2224      	movs	r2, #36	@ 0x24
 8006968:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

  /* Disable the selected I2C peripheral */
  __HAL_I2C_DISABLE(hi2c);
 800696c:	687b      	ldr	r3, [r7, #4]
 800696e:	681b      	ldr	r3, [r3, #0]
 8006970:	681a      	ldr	r2, [r3, #0]
 8006972:	687b      	ldr	r3, [r7, #4]
 8006974:	681b      	ldr	r3, [r3, #0]
 8006976:	f022 0201 	bic.w	r2, r2, #1
 800697a:	601a      	str	r2, [r3, #0]

  /*---------------------------- I2Cx TIMINGR Configuration ------------------*/
  /* Configure I2Cx: Frequency range */
  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
 800697c:	687b      	ldr	r3, [r7, #4]
 800697e:	685a      	ldr	r2, [r3, #4]
 8006980:	687b      	ldr	r3, [r7, #4]
 8006982:	681b      	ldr	r3, [r3, #0]
 8006984:	f022 6270 	bic.w	r2, r2, #251658240	@ 0xf000000
 8006988:	611a      	str	r2, [r3, #16]

  /*---------------------------- I2Cx OAR1 Configuration ---------------------*/
  /* Disable Own Address1 before set the Own Address1 configuration */
  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
 800698a:	687b      	ldr	r3, [r7, #4]
 800698c:	681b      	ldr	r3, [r3, #0]
 800698e:	689a      	ldr	r2, [r3, #8]
 8006990:	687b      	ldr	r3, [r7, #4]
 8006992:	681b      	ldr	r3, [r3, #0]
 8006994:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
 8006998:	609a      	str	r2, [r3, #8]

  /* Configure I2Cx: Own Address1 and ack own address1 mode */
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
 800699a:	687b      	ldr	r3, [r7, #4]
 800699c:	68db      	ldr	r3, [r3, #12]
 800699e:	2b01      	cmp	r3, #1
 80069a0:	d107      	bne.n	80069b2 <HAL_I2C_Init+0x7a>
  {
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
 80069a2:	687b      	ldr	r3, [r7, #4]
 80069a4:	689a      	ldr	r2, [r3, #8]
 80069a6:	687b      	ldr	r3, [r7, #4]
 80069a8:	681b      	ldr	r3, [r3, #0]
 80069aa:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
 80069ae:	609a      	str	r2, [r3, #8]
 80069b0:	e006      	b.n	80069c0 <HAL_I2C_Init+0x88>
  }
  else /* I2C_ADDRESSINGMODE_10BIT */
  {
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
 80069b2:	687b      	ldr	r3, [r7, #4]
 80069b4:	689a      	ldr	r2, [r3, #8]
 80069b6:	687b      	ldr	r3, [r7, #4]
 80069b8:	681b      	ldr	r3, [r3, #0]
 80069ba:	f442 4204 	orr.w	r2, r2, #33792	@ 0x8400
 80069be:	609a      	str	r2, [r3, #8]
  }

  /*---------------------------- I2Cx CR2 Configuration ----------------------*/
  /* Configure I2Cx: Addressing Master mode */
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
 80069c0:	687b      	ldr	r3, [r7, #4]
 80069c2:	68db      	ldr	r3, [r3, #12]
 80069c4:	2b02      	cmp	r3, #2
 80069c6:	d108      	bne.n	80069da <HAL_I2C_Init+0xa2>
  {
    SET_BIT(hi2c->Instance->CR2, I2C_CR2_ADD10);
 80069c8:	687b      	ldr	r3, [r7, #4]
 80069ca:	681b      	ldr	r3, [r3, #0]
 80069cc:	685a      	ldr	r2, [r3, #4]
 80069ce:	687b      	ldr	r3, [r7, #4]
 80069d0:	681b      	ldr	r3, [r3, #0]
 80069d2:	f442 6200 	orr.w	r2, r2, #2048	@ 0x800
 80069d6:	605a      	str	r2, [r3, #4]
 80069d8:	e007      	b.n	80069ea <HAL_I2C_Init+0xb2>
  }
  else
  {
    /* Clear the I2C ADD10 bit */
    CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_ADD10);
 80069da:	687b      	ldr	r3, [r7, #4]
 80069dc:	681b      	ldr	r3, [r3, #0]
 80069de:	685a      	ldr	r2, [r3, #4]
 80069e0:	687b      	ldr	r3, [r7, #4]
 80069e2:	681b      	ldr	r3, [r3, #0]
 80069e4:	f422 6200 	bic.w	r2, r2, #2048	@ 0x800
 80069e8:	605a      	str	r2, [r3, #4]
  }
  /* Enable the AUTOEND by default, and enable NACK (should be disable only during Slave process */
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
 80069ea:	687b      	ldr	r3, [r7, #4]
 80069ec:	681b      	ldr	r3, [r3, #0]
 80069ee:	6859      	ldr	r1, [r3, #4]
 80069f0:	687b      	ldr	r3, [r7, #4]
 80069f2:	681a      	ldr	r2, [r3, #0]
 80069f4:	4b1d      	ldr	r3, [pc, #116]	@ (8006a6c <HAL_I2C_Init+0x134>)
 80069f6:	430b      	orrs	r3, r1
 80069f8:	6053      	str	r3, [r2, #4]

  /*---------------------------- I2Cx OAR2 Configuration ---------------------*/
  /* Disable Own Address2 before set the Own Address2 configuration */
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
 80069fa:	687b      	ldr	r3, [r7, #4]
 80069fc:	681b      	ldr	r3, [r3, #0]
 80069fe:	68da      	ldr	r2, [r3, #12]
 8006a00:	687b      	ldr	r3, [r7, #4]
 8006a02:	681b      	ldr	r3, [r3, #0]
 8006a04:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
 8006a08:	60da      	str	r2, [r3, #12]

  /* Configure I2Cx: Dual mode and Own Address2 */
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | \
 8006a0a:	687b      	ldr	r3, [r7, #4]
 8006a0c:	691a      	ldr	r2, [r3, #16]
 8006a0e:	687b      	ldr	r3, [r7, #4]
 8006a10:	695b      	ldr	r3, [r3, #20]
 8006a12:	ea42 0103 	orr.w	r1, r2, r3
                          (hi2c->Init.OwnAddress2Masks << 8));
 8006a16:	687b      	ldr	r3, [r7, #4]
 8006a18:	699b      	ldr	r3, [r3, #24]
 8006a1a:	021a      	lsls	r2, r3, #8
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | \
 8006a1c:	687b      	ldr	r3, [r7, #4]
 8006a1e:	681b      	ldr	r3, [r3, #0]
 8006a20:	430a      	orrs	r2, r1
 8006a22:	60da      	str	r2, [r3, #12]

  /*---------------------------- I2Cx CR1 Configuration ----------------------*/
  /* Configure I2Cx: Generalcall and NoStretch mode */
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
 8006a24:	687b      	ldr	r3, [r7, #4]
 8006a26:	69d9      	ldr	r1, [r3, #28]
 8006a28:	687b      	ldr	r3, [r7, #4]
 8006a2a:	6a1a      	ldr	r2, [r3, #32]
 8006a2c:	687b      	ldr	r3, [r7, #4]
 8006a2e:	681b      	ldr	r3, [r3, #0]
 8006a30:	430a      	orrs	r2, r1
 8006a32:	601a      	str	r2, [r3, #0]

  /* Enable the selected I2C peripheral */
  __HAL_I2C_ENABLE(hi2c);
 8006a34:	687b      	ldr	r3, [r7, #4]
 8006a36:	681b      	ldr	r3, [r3, #0]
 8006a38:	681a      	ldr	r2, [r3, #0]
 8006a3a:	687b      	ldr	r3, [r7, #4]
 8006a3c:	681b      	ldr	r3, [r3, #0]
 8006a3e:	f042 0201 	orr.w	r2, r2, #1
 8006a42:	601a      	str	r2, [r3, #0]

  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8006a44:	687b      	ldr	r3, [r7, #4]
 8006a46:	2200      	movs	r2, #0
 8006a48:	645a      	str	r2, [r3, #68]	@ 0x44
  hi2c->State = HAL_I2C_STATE_READY;
 8006a4a:	687b      	ldr	r3, [r7, #4]
 8006a4c:	2220      	movs	r2, #32
 8006a4e:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
  hi2c->PreviousState = I2C_STATE_NONE;
 8006a52:	687b      	ldr	r3, [r7, #4]
 8006a54:	2200      	movs	r2, #0
 8006a56:	631a      	str	r2, [r3, #48]	@ 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
 8006a58:	687b      	ldr	r3, [r7, #4]
 8006a5a:	2200      	movs	r2, #0
 8006a5c:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42

  return HAL_OK;
 8006a60:	2300      	movs	r3, #0
}
 8006a62:	4618      	mov	r0, r3
 8006a64:	3708      	adds	r7, #8
 8006a66:	46bd      	mov	sp, r7
 8006a68:	bd80      	pop	{r7, pc}
 8006a6a:	bf00      	nop
 8006a6c:	02008000 	.word	0x02008000

08006a70 <HAL_I2C_Mem_Write>:
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Write(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress,
                                    uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 8006a70:	b580      	push	{r7, lr}
 8006a72:	b088      	sub	sp, #32
 8006a74:	af02      	add	r7, sp, #8
 8006a76:	60f8      	str	r0, [r7, #12]
 8006a78:	4608      	mov	r0, r1
 8006a7a:	4611      	mov	r1, r2
 8006a7c:	461a      	mov	r2, r3
 8006a7e:	4603      	mov	r3, r0
 8006a80:	817b      	strh	r3, [r7, #10]
 8006a82:	460b      	mov	r3, r1
 8006a84:	813b      	strh	r3, [r7, #8]
 8006a86:	4613      	mov	r3, r2
 8006a88:	80fb      	strh	r3, [r7, #6]
  uint32_t tickstart;

  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));

  if (hi2c->State == HAL_I2C_STATE_READY)
 8006a8a:	68fb      	ldr	r3, [r7, #12]
 8006a8c:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
 8006a90:	b2db      	uxtb	r3, r3
 8006a92:	2b20      	cmp	r3, #32
 8006a94:	f040 80f9 	bne.w	8006c8a <HAL_I2C_Mem_Write+0x21a>
  {
    if ((pData == NULL) || (Size == 0U))
 8006a98:	6a3b      	ldr	r3, [r7, #32]
 8006a9a:	2b00      	cmp	r3, #0
 8006a9c:	d002      	beq.n	8006aa4 <HAL_I2C_Mem_Write+0x34>
 8006a9e:	8cbb      	ldrh	r3, [r7, #36]	@ 0x24
 8006aa0:	2b00      	cmp	r3, #0
 8006aa2:	d105      	bne.n	8006ab0 <HAL_I2C_Mem_Write+0x40>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
 8006aa4:	68fb      	ldr	r3, [r7, #12]
 8006aa6:	f44f 7200 	mov.w	r2, #512	@ 0x200
 8006aaa:	645a      	str	r2, [r3, #68]	@ 0x44
      return  HAL_ERROR;
 8006aac:	2301      	movs	r3, #1
 8006aae:	e0ed      	b.n	8006c8c <HAL_I2C_Mem_Write+0x21c>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
 8006ab0:	68fb      	ldr	r3, [r7, #12]
 8006ab2:	f893 3040 	ldrb.w	r3, [r3, #64]	@ 0x40
 8006ab6:	2b01      	cmp	r3, #1
 8006ab8:	d101      	bne.n	8006abe <HAL_I2C_Mem_Write+0x4e>
 8006aba:	2302      	movs	r3, #2
 8006abc:	e0e6      	b.n	8006c8c <HAL_I2C_Mem_Write+0x21c>
 8006abe:	68fb      	ldr	r3, [r7, #12]
 8006ac0:	2201      	movs	r2, #1
 8006ac2:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
 8006ac6:	f7fb ff4b 	bl	8002960 <HAL_GetTick>
 8006aca:	6178      	str	r0, [r7, #20]

    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
 8006acc:	697b      	ldr	r3, [r7, #20]
 8006ace:	9300      	str	r3, [sp, #0]
 8006ad0:	2319      	movs	r3, #25
 8006ad2:	2201      	movs	r2, #1
 8006ad4:	f44f 4100 	mov.w	r1, #32768	@ 0x8000
 8006ad8:	68f8      	ldr	r0, [r7, #12]
 8006ada:	f000 fac3 	bl	8007064 <I2C_WaitOnFlagUntilTimeout>
 8006ade:	4603      	mov	r3, r0
 8006ae0:	2b00      	cmp	r3, #0
 8006ae2:	d001      	beq.n	8006ae8 <HAL_I2C_Mem_Write+0x78>
    {
      return HAL_ERROR;
 8006ae4:	2301      	movs	r3, #1
 8006ae6:	e0d1      	b.n	8006c8c <HAL_I2C_Mem_Write+0x21c>
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
 8006ae8:	68fb      	ldr	r3, [r7, #12]
 8006aea:	2221      	movs	r2, #33	@ 0x21
 8006aec:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
    hi2c->Mode      = HAL_I2C_MODE_MEM;
 8006af0:	68fb      	ldr	r3, [r7, #12]
 8006af2:	2240      	movs	r2, #64	@ 0x40
 8006af4:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8006af8:	68fb      	ldr	r3, [r7, #12]
 8006afa:	2200      	movs	r2, #0
 8006afc:	645a      	str	r2, [r3, #68]	@ 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
 8006afe:	68fb      	ldr	r3, [r7, #12]
 8006b00:	6a3a      	ldr	r2, [r7, #32]
 8006b02:	625a      	str	r2, [r3, #36]	@ 0x24
    hi2c->XferCount = Size;
 8006b04:	68fb      	ldr	r3, [r7, #12]
 8006b06:	8cba      	ldrh	r2, [r7, #36]	@ 0x24
 8006b08:	855a      	strh	r2, [r3, #42]	@ 0x2a
    hi2c->XferISR   = NULL;
 8006b0a:	68fb      	ldr	r3, [r7, #12]
 8006b0c:	2200      	movs	r2, #0
 8006b0e:	635a      	str	r2, [r3, #52]	@ 0x34

    /* Send Slave Address and Memory Address */
    if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 8006b10:	88f8      	ldrh	r0, [r7, #6]
 8006b12:	893a      	ldrh	r2, [r7, #8]
 8006b14:	8979      	ldrh	r1, [r7, #10]
 8006b16:	697b      	ldr	r3, [r7, #20]
 8006b18:	9301      	str	r3, [sp, #4]
 8006b1a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8006b1c:	9300      	str	r3, [sp, #0]
 8006b1e:	4603      	mov	r3, r0
 8006b20:	68f8      	ldr	r0, [r7, #12]
 8006b22:	f000 f9d3 	bl	8006ecc <I2C_RequestMemoryWrite>
 8006b26:	4603      	mov	r3, r0
 8006b28:	2b00      	cmp	r3, #0
 8006b2a:	d005      	beq.n	8006b38 <HAL_I2C_Mem_Write+0xc8>
    {
      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
 8006b2c:	68fb      	ldr	r3, [r7, #12]
 8006b2e:	2200      	movs	r2, #0
 8006b30:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
      return HAL_ERROR;
 8006b34:	2301      	movs	r3, #1
 8006b36:	e0a9      	b.n	8006c8c <HAL_I2C_Mem_Write+0x21c>
    }

    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 8006b38:	68fb      	ldr	r3, [r7, #12]
 8006b3a:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8006b3c:	b29b      	uxth	r3, r3
 8006b3e:	2bff      	cmp	r3, #255	@ 0xff
 8006b40:	d90e      	bls.n	8006b60 <HAL_I2C_Mem_Write+0xf0>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
 8006b42:	68fb      	ldr	r3, [r7, #12]
 8006b44:	22ff      	movs	r2, #255	@ 0xff
 8006b46:	851a      	strh	r2, [r3, #40]	@ 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
 8006b48:	68fb      	ldr	r3, [r7, #12]
 8006b4a:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 8006b4c:	b2da      	uxtb	r2, r3
 8006b4e:	8979      	ldrh	r1, [r7, #10]
 8006b50:	2300      	movs	r3, #0
 8006b52:	9300      	str	r3, [sp, #0]
 8006b54:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
 8006b58:	68f8      	ldr	r0, [r7, #12]
 8006b5a:	f000 fc47 	bl	80073ec <I2C_TransferConfig>
 8006b5e:	e00f      	b.n	8006b80 <HAL_I2C_Mem_Write+0x110>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
 8006b60:	68fb      	ldr	r3, [r7, #12]
 8006b62:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8006b64:	b29a      	uxth	r2, r3
 8006b66:	68fb      	ldr	r3, [r7, #12]
 8006b68:	851a      	strh	r2, [r3, #40]	@ 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 8006b6a:	68fb      	ldr	r3, [r7, #12]
 8006b6c:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 8006b6e:	b2da      	uxtb	r2, r3
 8006b70:	8979      	ldrh	r1, [r7, #10]
 8006b72:	2300      	movs	r3, #0
 8006b74:	9300      	str	r3, [sp, #0]
 8006b76:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
 8006b7a:	68f8      	ldr	r0, [r7, #12]
 8006b7c:	f000 fc36 	bl	80073ec <I2C_TransferConfig>
    }

    do
    {
      /* Wait until TXIS flag is set */
      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 8006b80:	697a      	ldr	r2, [r7, #20]
 8006b82:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 8006b84:	68f8      	ldr	r0, [r7, #12]
 8006b86:	f000 fac6 	bl	8007116 <I2C_WaitOnTXISFlagUntilTimeout>
 8006b8a:	4603      	mov	r3, r0
 8006b8c:	2b00      	cmp	r3, #0
 8006b8e:	d001      	beq.n	8006b94 <HAL_I2C_Mem_Write+0x124>
      {
        return HAL_ERROR;
 8006b90:	2301      	movs	r3, #1
 8006b92:	e07b      	b.n	8006c8c <HAL_I2C_Mem_Write+0x21c>
      }

      /* Write data to TXDR */
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
 8006b94:	68fb      	ldr	r3, [r7, #12]
 8006b96:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8006b98:	781a      	ldrb	r2, [r3, #0]
 8006b9a:	68fb      	ldr	r3, [r7, #12]
 8006b9c:	681b      	ldr	r3, [r3, #0]
 8006b9e:	629a      	str	r2, [r3, #40]	@ 0x28

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
 8006ba0:	68fb      	ldr	r3, [r7, #12]
 8006ba2:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8006ba4:	1c5a      	adds	r2, r3, #1
 8006ba6:	68fb      	ldr	r3, [r7, #12]
 8006ba8:	625a      	str	r2, [r3, #36]	@ 0x24

      hi2c->XferCount--;
 8006baa:	68fb      	ldr	r3, [r7, #12]
 8006bac:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8006bae:	b29b      	uxth	r3, r3
 8006bb0:	3b01      	subs	r3, #1
 8006bb2:	b29a      	uxth	r2, r3
 8006bb4:	68fb      	ldr	r3, [r7, #12]
 8006bb6:	855a      	strh	r2, [r3, #42]	@ 0x2a
      hi2c->XferSize--;
 8006bb8:	68fb      	ldr	r3, [r7, #12]
 8006bba:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 8006bbc:	3b01      	subs	r3, #1
 8006bbe:	b29a      	uxth	r2, r3
 8006bc0:	68fb      	ldr	r3, [r7, #12]
 8006bc2:	851a      	strh	r2, [r3, #40]	@ 0x28

      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 8006bc4:	68fb      	ldr	r3, [r7, #12]
 8006bc6:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8006bc8:	b29b      	uxth	r3, r3
 8006bca:	2b00      	cmp	r3, #0
 8006bcc:	d034      	beq.n	8006c38 <HAL_I2C_Mem_Write+0x1c8>
 8006bce:	68fb      	ldr	r3, [r7, #12]
 8006bd0:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 8006bd2:	2b00      	cmp	r3, #0
 8006bd4:	d130      	bne.n	8006c38 <HAL_I2C_Mem_Write+0x1c8>
      {
        /* Wait until TCR flag is set */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
 8006bd6:	697b      	ldr	r3, [r7, #20]
 8006bd8:	9300      	str	r3, [sp, #0]
 8006bda:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8006bdc:	2200      	movs	r2, #0
 8006bde:	2180      	movs	r1, #128	@ 0x80
 8006be0:	68f8      	ldr	r0, [r7, #12]
 8006be2:	f000 fa3f 	bl	8007064 <I2C_WaitOnFlagUntilTimeout>
 8006be6:	4603      	mov	r3, r0
 8006be8:	2b00      	cmp	r3, #0
 8006bea:	d001      	beq.n	8006bf0 <HAL_I2C_Mem_Write+0x180>
        {
          return HAL_ERROR;
 8006bec:	2301      	movs	r3, #1
 8006bee:	e04d      	b.n	8006c8c <HAL_I2C_Mem_Write+0x21c>
        }

        if (hi2c->XferCount > MAX_NBYTE_SIZE)
 8006bf0:	68fb      	ldr	r3, [r7, #12]
 8006bf2:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8006bf4:	b29b      	uxth	r3, r3
 8006bf6:	2bff      	cmp	r3, #255	@ 0xff
 8006bf8:	d90e      	bls.n	8006c18 <HAL_I2C_Mem_Write+0x1a8>
        {
          hi2c->XferSize = MAX_NBYTE_SIZE;
 8006bfa:	68fb      	ldr	r3, [r7, #12]
 8006bfc:	22ff      	movs	r2, #255	@ 0xff
 8006bfe:	851a      	strh	r2, [r3, #40]	@ 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE,
 8006c00:	68fb      	ldr	r3, [r7, #12]
 8006c02:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 8006c04:	b2da      	uxtb	r2, r3
 8006c06:	8979      	ldrh	r1, [r7, #10]
 8006c08:	2300      	movs	r3, #0
 8006c0a:	9300      	str	r3, [sp, #0]
 8006c0c:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
 8006c10:	68f8      	ldr	r0, [r7, #12]
 8006c12:	f000 fbeb 	bl	80073ec <I2C_TransferConfig>
 8006c16:	e00f      	b.n	8006c38 <HAL_I2C_Mem_Write+0x1c8>
                             I2C_NO_STARTSTOP);
        }
        else
        {
          hi2c->XferSize = hi2c->XferCount;
 8006c18:	68fb      	ldr	r3, [r7, #12]
 8006c1a:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8006c1c:	b29a      	uxth	r2, r3
 8006c1e:	68fb      	ldr	r3, [r7, #12]
 8006c20:	851a      	strh	r2, [r3, #40]	@ 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
 8006c22:	68fb      	ldr	r3, [r7, #12]
 8006c24:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 8006c26:	b2da      	uxtb	r2, r3
 8006c28:	8979      	ldrh	r1, [r7, #10]
 8006c2a:	2300      	movs	r3, #0
 8006c2c:	9300      	str	r3, [sp, #0]
 8006c2e:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
 8006c32:	68f8      	ldr	r0, [r7, #12]
 8006c34:	f000 fbda 	bl	80073ec <I2C_TransferConfig>
                             I2C_NO_STARTSTOP);
        }
      }

    } while (hi2c->XferCount > 0U);
 8006c38:	68fb      	ldr	r3, [r7, #12]
 8006c3a:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8006c3c:	b29b      	uxth	r3, r3
 8006c3e:	2b00      	cmp	r3, #0
 8006c40:	d19e      	bne.n	8006b80 <HAL_I2C_Mem_Write+0x110>

    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    /* Wait until STOPF flag is reset */
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 8006c42:	697a      	ldr	r2, [r7, #20]
 8006c44:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 8006c46:	68f8      	ldr	r0, [r7, #12]
 8006c48:	f000 faac 	bl	80071a4 <I2C_WaitOnSTOPFlagUntilTimeout>
 8006c4c:	4603      	mov	r3, r0
 8006c4e:	2b00      	cmp	r3, #0
 8006c50:	d001      	beq.n	8006c56 <HAL_I2C_Mem_Write+0x1e6>
    {
      return HAL_ERROR;
 8006c52:	2301      	movs	r3, #1
 8006c54:	e01a      	b.n	8006c8c <HAL_I2C_Mem_Write+0x21c>
    }

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8006c56:	68fb      	ldr	r3, [r7, #12]
 8006c58:	681b      	ldr	r3, [r3, #0]
 8006c5a:	2220      	movs	r2, #32
 8006c5c:	61da      	str	r2, [r3, #28]

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
 8006c5e:	68fb      	ldr	r3, [r7, #12]
 8006c60:	681b      	ldr	r3, [r3, #0]
 8006c62:	6859      	ldr	r1, [r3, #4]
 8006c64:	68fb      	ldr	r3, [r7, #12]
 8006c66:	681a      	ldr	r2, [r3, #0]
 8006c68:	4b0a      	ldr	r3, [pc, #40]	@ (8006c94 <HAL_I2C_Mem_Write+0x224>)
 8006c6a:	400b      	ands	r3, r1
 8006c6c:	6053      	str	r3, [r2, #4]

    hi2c->State = HAL_I2C_STATE_READY;
 8006c6e:	68fb      	ldr	r3, [r7, #12]
 8006c70:	2220      	movs	r2, #32
 8006c72:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
    hi2c->Mode  = HAL_I2C_MODE_NONE;
 8006c76:	68fb      	ldr	r3, [r7, #12]
 8006c78:	2200      	movs	r2, #0
 8006c7a:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 8006c7e:	68fb      	ldr	r3, [r7, #12]
 8006c80:	2200      	movs	r2, #0
 8006c82:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    return HAL_OK;
 8006c86:	2300      	movs	r3, #0
 8006c88:	e000      	b.n	8006c8c <HAL_I2C_Mem_Write+0x21c>
  }
  else
  {
    return HAL_BUSY;
 8006c8a:	2302      	movs	r3, #2
  }
}
 8006c8c:	4618      	mov	r0, r3
 8006c8e:	3718      	adds	r7, #24
 8006c90:	46bd      	mov	sp, r7
 8006c92:	bd80      	pop	{r7, pc}
 8006c94:	fe00e800 	.word	0xfe00e800

08006c98 <HAL_I2C_Mem_Read>:
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Read(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress,
                                   uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 8006c98:	b580      	push	{r7, lr}
 8006c9a:	b088      	sub	sp, #32
 8006c9c:	af02      	add	r7, sp, #8
 8006c9e:	60f8      	str	r0, [r7, #12]
 8006ca0:	4608      	mov	r0, r1
 8006ca2:	4611      	mov	r1, r2
 8006ca4:	461a      	mov	r2, r3
 8006ca6:	4603      	mov	r3, r0
 8006ca8:	817b      	strh	r3, [r7, #10]
 8006caa:	460b      	mov	r3, r1
 8006cac:	813b      	strh	r3, [r7, #8]
 8006cae:	4613      	mov	r3, r2
 8006cb0:	80fb      	strh	r3, [r7, #6]
  uint32_t tickstart;

  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));

  if (hi2c->State == HAL_I2C_STATE_READY)
 8006cb2:	68fb      	ldr	r3, [r7, #12]
 8006cb4:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
 8006cb8:	b2db      	uxtb	r3, r3
 8006cba:	2b20      	cmp	r3, #32
 8006cbc:	f040 80fd 	bne.w	8006eba <HAL_I2C_Mem_Read+0x222>
  {
    if ((pData == NULL) || (Size == 0U))
 8006cc0:	6a3b      	ldr	r3, [r7, #32]
 8006cc2:	2b00      	cmp	r3, #0
 8006cc4:	d002      	beq.n	8006ccc <HAL_I2C_Mem_Read+0x34>
 8006cc6:	8cbb      	ldrh	r3, [r7, #36]	@ 0x24
 8006cc8:	2b00      	cmp	r3, #0
 8006cca:	d105      	bne.n	8006cd8 <HAL_I2C_Mem_Read+0x40>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
 8006ccc:	68fb      	ldr	r3, [r7, #12]
 8006cce:	f44f 7200 	mov.w	r2, #512	@ 0x200
 8006cd2:	645a      	str	r2, [r3, #68]	@ 0x44
      return  HAL_ERROR;
 8006cd4:	2301      	movs	r3, #1
 8006cd6:	e0f1      	b.n	8006ebc <HAL_I2C_Mem_Read+0x224>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
 8006cd8:	68fb      	ldr	r3, [r7, #12]
 8006cda:	f893 3040 	ldrb.w	r3, [r3, #64]	@ 0x40
 8006cde:	2b01      	cmp	r3, #1
 8006ce0:	d101      	bne.n	8006ce6 <HAL_I2C_Mem_Read+0x4e>
 8006ce2:	2302      	movs	r3, #2
 8006ce4:	e0ea      	b.n	8006ebc <HAL_I2C_Mem_Read+0x224>
 8006ce6:	68fb      	ldr	r3, [r7, #12]
 8006ce8:	2201      	movs	r2, #1
 8006cea:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
 8006cee:	f7fb fe37 	bl	8002960 <HAL_GetTick>
 8006cf2:	6178      	str	r0, [r7, #20]

    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
 8006cf4:	697b      	ldr	r3, [r7, #20]
 8006cf6:	9300      	str	r3, [sp, #0]
 8006cf8:	2319      	movs	r3, #25
 8006cfa:	2201      	movs	r2, #1
 8006cfc:	f44f 4100 	mov.w	r1, #32768	@ 0x8000
 8006d00:	68f8      	ldr	r0, [r7, #12]
 8006d02:	f000 f9af 	bl	8007064 <I2C_WaitOnFlagUntilTimeout>
 8006d06:	4603      	mov	r3, r0
 8006d08:	2b00      	cmp	r3, #0
 8006d0a:	d001      	beq.n	8006d10 <HAL_I2C_Mem_Read+0x78>
    {
      return HAL_ERROR;
 8006d0c:	2301      	movs	r3, #1
 8006d0e:	e0d5      	b.n	8006ebc <HAL_I2C_Mem_Read+0x224>
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
 8006d10:	68fb      	ldr	r3, [r7, #12]
 8006d12:	2222      	movs	r2, #34	@ 0x22
 8006d14:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
    hi2c->Mode      = HAL_I2C_MODE_MEM;
 8006d18:	68fb      	ldr	r3, [r7, #12]
 8006d1a:	2240      	movs	r2, #64	@ 0x40
 8006d1c:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8006d20:	68fb      	ldr	r3, [r7, #12]
 8006d22:	2200      	movs	r2, #0
 8006d24:	645a      	str	r2, [r3, #68]	@ 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
 8006d26:	68fb      	ldr	r3, [r7, #12]
 8006d28:	6a3a      	ldr	r2, [r7, #32]
 8006d2a:	625a      	str	r2, [r3, #36]	@ 0x24
    hi2c->XferCount = Size;
 8006d2c:	68fb      	ldr	r3, [r7, #12]
 8006d2e:	8cba      	ldrh	r2, [r7, #36]	@ 0x24
 8006d30:	855a      	strh	r2, [r3, #42]	@ 0x2a
    hi2c->XferISR   = NULL;
 8006d32:	68fb      	ldr	r3, [r7, #12]
 8006d34:	2200      	movs	r2, #0
 8006d36:	635a      	str	r2, [r3, #52]	@ 0x34

    /* Send Slave Address and Memory Address */
    if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 8006d38:	88f8      	ldrh	r0, [r7, #6]
 8006d3a:	893a      	ldrh	r2, [r7, #8]
 8006d3c:	8979      	ldrh	r1, [r7, #10]
 8006d3e:	697b      	ldr	r3, [r7, #20]
 8006d40:	9301      	str	r3, [sp, #4]
 8006d42:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8006d44:	9300      	str	r3, [sp, #0]
 8006d46:	4603      	mov	r3, r0
 8006d48:	68f8      	ldr	r0, [r7, #12]
 8006d4a:	f000 f913 	bl	8006f74 <I2C_RequestMemoryRead>
 8006d4e:	4603      	mov	r3, r0
 8006d50:	2b00      	cmp	r3, #0
 8006d52:	d005      	beq.n	8006d60 <HAL_I2C_Mem_Read+0xc8>
    {
      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
 8006d54:	68fb      	ldr	r3, [r7, #12]
 8006d56:	2200      	movs	r2, #0
 8006d58:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
      return HAL_ERROR;
 8006d5c:	2301      	movs	r3, #1
 8006d5e:	e0ad      	b.n	8006ebc <HAL_I2C_Mem_Read+0x224>
    }

    /* Send Slave Address */
    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 8006d60:	68fb      	ldr	r3, [r7, #12]
 8006d62:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8006d64:	b29b      	uxth	r3, r3
 8006d66:	2bff      	cmp	r3, #255	@ 0xff
 8006d68:	d90e      	bls.n	8006d88 <HAL_I2C_Mem_Read+0xf0>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
 8006d6a:	68fb      	ldr	r3, [r7, #12]
 8006d6c:	22ff      	movs	r2, #255	@ 0xff
 8006d6e:	851a      	strh	r2, [r3, #40]	@ 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE,
 8006d70:	68fb      	ldr	r3, [r7, #12]
 8006d72:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 8006d74:	b2da      	uxtb	r2, r3
 8006d76:	8979      	ldrh	r1, [r7, #10]
 8006d78:	4b52      	ldr	r3, [pc, #328]	@ (8006ec4 <HAL_I2C_Mem_Read+0x22c>)
 8006d7a:	9300      	str	r3, [sp, #0]
 8006d7c:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
 8006d80:	68f8      	ldr	r0, [r7, #12]
 8006d82:	f000 fb33 	bl	80073ec <I2C_TransferConfig>
 8006d86:	e00f      	b.n	8006da8 <HAL_I2C_Mem_Read+0x110>
                         I2C_GENERATE_START_READ);
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
 8006d88:	68fb      	ldr	r3, [r7, #12]
 8006d8a:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8006d8c:	b29a      	uxth	r2, r3
 8006d8e:	68fb      	ldr	r3, [r7, #12]
 8006d90:	851a      	strh	r2, [r3, #40]	@ 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
 8006d92:	68fb      	ldr	r3, [r7, #12]
 8006d94:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 8006d96:	b2da      	uxtb	r2, r3
 8006d98:	8979      	ldrh	r1, [r7, #10]
 8006d9a:	4b4a      	ldr	r3, [pc, #296]	@ (8006ec4 <HAL_I2C_Mem_Read+0x22c>)
 8006d9c:	9300      	str	r3, [sp, #0]
 8006d9e:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
 8006da2:	68f8      	ldr	r0, [r7, #12]
 8006da4:	f000 fb22 	bl	80073ec <I2C_TransferConfig>
    }

    do
    {
      /* Wait until RXNE flag is set */
      if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_RXNE, RESET, Timeout, tickstart) != HAL_OK)
 8006da8:	697b      	ldr	r3, [r7, #20]
 8006daa:	9300      	str	r3, [sp, #0]
 8006dac:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8006dae:	2200      	movs	r2, #0
 8006db0:	2104      	movs	r1, #4
 8006db2:	68f8      	ldr	r0, [r7, #12]
 8006db4:	f000 f956 	bl	8007064 <I2C_WaitOnFlagUntilTimeout>
 8006db8:	4603      	mov	r3, r0
 8006dba:	2b00      	cmp	r3, #0
 8006dbc:	d001      	beq.n	8006dc2 <HAL_I2C_Mem_Read+0x12a>
      {
        return HAL_ERROR;
 8006dbe:	2301      	movs	r3, #1
 8006dc0:	e07c      	b.n	8006ebc <HAL_I2C_Mem_Read+0x224>
      }

      /* Read data from RXDR */
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
 8006dc2:	68fb      	ldr	r3, [r7, #12]
 8006dc4:	681b      	ldr	r3, [r3, #0]
 8006dc6:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 8006dc8:	68fb      	ldr	r3, [r7, #12]
 8006dca:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8006dcc:	b2d2      	uxtb	r2, r2
 8006dce:	701a      	strb	r2, [r3, #0]

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
 8006dd0:	68fb      	ldr	r3, [r7, #12]
 8006dd2:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8006dd4:	1c5a      	adds	r2, r3, #1
 8006dd6:	68fb      	ldr	r3, [r7, #12]
 8006dd8:	625a      	str	r2, [r3, #36]	@ 0x24

      hi2c->XferSize--;
 8006dda:	68fb      	ldr	r3, [r7, #12]
 8006ddc:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 8006dde:	3b01      	subs	r3, #1
 8006de0:	b29a      	uxth	r2, r3
 8006de2:	68fb      	ldr	r3, [r7, #12]
 8006de4:	851a      	strh	r2, [r3, #40]	@ 0x28
      hi2c->XferCount--;
 8006de6:	68fb      	ldr	r3, [r7, #12]
 8006de8:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8006dea:	b29b      	uxth	r3, r3
 8006dec:	3b01      	subs	r3, #1
 8006dee:	b29a      	uxth	r2, r3
 8006df0:	68fb      	ldr	r3, [r7, #12]
 8006df2:	855a      	strh	r2, [r3, #42]	@ 0x2a

      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 8006df4:	68fb      	ldr	r3, [r7, #12]
 8006df6:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8006df8:	b29b      	uxth	r3, r3
 8006dfa:	2b00      	cmp	r3, #0
 8006dfc:	d034      	beq.n	8006e68 <HAL_I2C_Mem_Read+0x1d0>
 8006dfe:	68fb      	ldr	r3, [r7, #12]
 8006e00:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 8006e02:	2b00      	cmp	r3, #0
 8006e04:	d130      	bne.n	8006e68 <HAL_I2C_Mem_Read+0x1d0>
      {
        /* Wait until TCR flag is set */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
 8006e06:	697b      	ldr	r3, [r7, #20]
 8006e08:	9300      	str	r3, [sp, #0]
 8006e0a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8006e0c:	2200      	movs	r2, #0
 8006e0e:	2180      	movs	r1, #128	@ 0x80
 8006e10:	68f8      	ldr	r0, [r7, #12]
 8006e12:	f000 f927 	bl	8007064 <I2C_WaitOnFlagUntilTimeout>
 8006e16:	4603      	mov	r3, r0
 8006e18:	2b00      	cmp	r3, #0
 8006e1a:	d001      	beq.n	8006e20 <HAL_I2C_Mem_Read+0x188>
        {
          return HAL_ERROR;
 8006e1c:	2301      	movs	r3, #1
 8006e1e:	e04d      	b.n	8006ebc <HAL_I2C_Mem_Read+0x224>
        }

        if (hi2c->XferCount > MAX_NBYTE_SIZE)
 8006e20:	68fb      	ldr	r3, [r7, #12]
 8006e22:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8006e24:	b29b      	uxth	r3, r3
 8006e26:	2bff      	cmp	r3, #255	@ 0xff
 8006e28:	d90e      	bls.n	8006e48 <HAL_I2C_Mem_Read+0x1b0>
        {
          hi2c->XferSize = MAX_NBYTE_SIZE;
 8006e2a:	68fb      	ldr	r3, [r7, #12]
 8006e2c:	22ff      	movs	r2, #255	@ 0xff
 8006e2e:	851a      	strh	r2, [r3, #40]	@ 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t) hi2c->XferSize, I2C_RELOAD_MODE,
 8006e30:	68fb      	ldr	r3, [r7, #12]
 8006e32:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 8006e34:	b2da      	uxtb	r2, r3
 8006e36:	8979      	ldrh	r1, [r7, #10]
 8006e38:	2300      	movs	r3, #0
 8006e3a:	9300      	str	r3, [sp, #0]
 8006e3c:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
 8006e40:	68f8      	ldr	r0, [r7, #12]
 8006e42:	f000 fad3 	bl	80073ec <I2C_TransferConfig>
 8006e46:	e00f      	b.n	8006e68 <HAL_I2C_Mem_Read+0x1d0>
                             I2C_NO_STARTSTOP);
        }
        else
        {
          hi2c->XferSize = hi2c->XferCount;
 8006e48:	68fb      	ldr	r3, [r7, #12]
 8006e4a:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8006e4c:	b29a      	uxth	r2, r3
 8006e4e:	68fb      	ldr	r3, [r7, #12]
 8006e50:	851a      	strh	r2, [r3, #40]	@ 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
 8006e52:	68fb      	ldr	r3, [r7, #12]
 8006e54:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 8006e56:	b2da      	uxtb	r2, r3
 8006e58:	8979      	ldrh	r1, [r7, #10]
 8006e5a:	2300      	movs	r3, #0
 8006e5c:	9300      	str	r3, [sp, #0]
 8006e5e:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
 8006e62:	68f8      	ldr	r0, [r7, #12]
 8006e64:	f000 fac2 	bl	80073ec <I2C_TransferConfig>
                             I2C_NO_STARTSTOP);
        }
      }
    } while (hi2c->XferCount > 0U);
 8006e68:	68fb      	ldr	r3, [r7, #12]
 8006e6a:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8006e6c:	b29b      	uxth	r3, r3
 8006e6e:	2b00      	cmp	r3, #0
 8006e70:	d19a      	bne.n	8006da8 <HAL_I2C_Mem_Read+0x110>

    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    /* Wait until STOPF flag is reset */
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 8006e72:	697a      	ldr	r2, [r7, #20]
 8006e74:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 8006e76:	68f8      	ldr	r0, [r7, #12]
 8006e78:	f000 f994 	bl	80071a4 <I2C_WaitOnSTOPFlagUntilTimeout>
 8006e7c:	4603      	mov	r3, r0
 8006e7e:	2b00      	cmp	r3, #0
 8006e80:	d001      	beq.n	8006e86 <HAL_I2C_Mem_Read+0x1ee>
    {
      return HAL_ERROR;
 8006e82:	2301      	movs	r3, #1
 8006e84:	e01a      	b.n	8006ebc <HAL_I2C_Mem_Read+0x224>
    }

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8006e86:	68fb      	ldr	r3, [r7, #12]
 8006e88:	681b      	ldr	r3, [r3, #0]
 8006e8a:	2220      	movs	r2, #32
 8006e8c:	61da      	str	r2, [r3, #28]

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
 8006e8e:	68fb      	ldr	r3, [r7, #12]
 8006e90:	681b      	ldr	r3, [r3, #0]
 8006e92:	6859      	ldr	r1, [r3, #4]
 8006e94:	68fb      	ldr	r3, [r7, #12]
 8006e96:	681a      	ldr	r2, [r3, #0]
 8006e98:	4b0b      	ldr	r3, [pc, #44]	@ (8006ec8 <HAL_I2C_Mem_Read+0x230>)
 8006e9a:	400b      	ands	r3, r1
 8006e9c:	6053      	str	r3, [r2, #4]

    hi2c->State = HAL_I2C_STATE_READY;
 8006e9e:	68fb      	ldr	r3, [r7, #12]
 8006ea0:	2220      	movs	r2, #32
 8006ea2:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
    hi2c->Mode  = HAL_I2C_MODE_NONE;
 8006ea6:	68fb      	ldr	r3, [r7, #12]
 8006ea8:	2200      	movs	r2, #0
 8006eaa:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 8006eae:	68fb      	ldr	r3, [r7, #12]
 8006eb0:	2200      	movs	r2, #0
 8006eb2:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    return HAL_OK;
 8006eb6:	2300      	movs	r3, #0
 8006eb8:	e000      	b.n	8006ebc <HAL_I2C_Mem_Read+0x224>
  }
  else
  {
    return HAL_BUSY;
 8006eba:	2302      	movs	r3, #2
  }
}
 8006ebc:	4618      	mov	r0, r3
 8006ebe:	3718      	adds	r7, #24
 8006ec0:	46bd      	mov	sp, r7
 8006ec2:	bd80      	pop	{r7, pc}
 8006ec4:	80002400 	.word	0x80002400
 8006ec8:	fe00e800 	.word	0xfe00e800

08006ecc <I2C_RequestMemoryWrite>:
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_RequestMemoryWrite(I2C_HandleTypeDef *hi2c, uint16_t DevAddress,
                                                uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout,
                                                uint32_t Tickstart)
{
 8006ecc:	b580      	push	{r7, lr}
 8006ece:	b086      	sub	sp, #24
 8006ed0:	af02      	add	r7, sp, #8
 8006ed2:	60f8      	str	r0, [r7, #12]
 8006ed4:	4608      	mov	r0, r1
 8006ed6:	4611      	mov	r1, r2
 8006ed8:	461a      	mov	r2, r3
 8006eda:	4603      	mov	r3, r0
 8006edc:	817b      	strh	r3, [r7, #10]
 8006ede:	460b      	mov	r3, r1
 8006ee0:	813b      	strh	r3, [r7, #8]
 8006ee2:	4613      	mov	r3, r2
 8006ee4:	80fb      	strh	r3, [r7, #6]
  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
 8006ee6:	88fb      	ldrh	r3, [r7, #6]
 8006ee8:	b2da      	uxtb	r2, r3
 8006eea:	8979      	ldrh	r1, [r7, #10]
 8006eec:	4b20      	ldr	r3, [pc, #128]	@ (8006f70 <I2C_RequestMemoryWrite+0xa4>)
 8006eee:	9300      	str	r3, [sp, #0]
 8006ef0:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
 8006ef4:	68f8      	ldr	r0, [r7, #12]
 8006ef6:	f000 fa79 	bl	80073ec <I2C_TransferConfig>

  /* Wait until TXIS flag is set */
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 8006efa:	69fa      	ldr	r2, [r7, #28]
 8006efc:	69b9      	ldr	r1, [r7, #24]
 8006efe:	68f8      	ldr	r0, [r7, #12]
 8006f00:	f000 f909 	bl	8007116 <I2C_WaitOnTXISFlagUntilTimeout>
 8006f04:	4603      	mov	r3, r0
 8006f06:	2b00      	cmp	r3, #0
 8006f08:	d001      	beq.n	8006f0e <I2C_RequestMemoryWrite+0x42>
  {
    return HAL_ERROR;
 8006f0a:	2301      	movs	r3, #1
 8006f0c:	e02c      	b.n	8006f68 <I2C_RequestMemoryWrite+0x9c>
  }

  /* If Memory address size is 8Bit */
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
 8006f0e:	88fb      	ldrh	r3, [r7, #6]
 8006f10:	2b01      	cmp	r3, #1
 8006f12:	d105      	bne.n	8006f20 <I2C_RequestMemoryWrite+0x54>
  {
    /* Send Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
 8006f14:	893b      	ldrh	r3, [r7, #8]
 8006f16:	b2da      	uxtb	r2, r3
 8006f18:	68fb      	ldr	r3, [r7, #12]
 8006f1a:	681b      	ldr	r3, [r3, #0]
 8006f1c:	629a      	str	r2, [r3, #40]	@ 0x28
 8006f1e:	e015      	b.n	8006f4c <I2C_RequestMemoryWrite+0x80>
  }
  /* If Memory address size is 16Bit */
  else
  {
    /* Send MSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
 8006f20:	893b      	ldrh	r3, [r7, #8]
 8006f22:	0a1b      	lsrs	r3, r3, #8
 8006f24:	b29b      	uxth	r3, r3
 8006f26:	b2da      	uxtb	r2, r3
 8006f28:	68fb      	ldr	r3, [r7, #12]
 8006f2a:	681b      	ldr	r3, [r3, #0]
 8006f2c:	629a      	str	r2, [r3, #40]	@ 0x28

    /* Wait until TXIS flag is set */
    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 8006f2e:	69fa      	ldr	r2, [r7, #28]
 8006f30:	69b9      	ldr	r1, [r7, #24]
 8006f32:	68f8      	ldr	r0, [r7, #12]
 8006f34:	f000 f8ef 	bl	8007116 <I2C_WaitOnTXISFlagUntilTimeout>
 8006f38:	4603      	mov	r3, r0
 8006f3a:	2b00      	cmp	r3, #0
 8006f3c:	d001      	beq.n	8006f42 <I2C_RequestMemoryWrite+0x76>
    {
      return HAL_ERROR;
 8006f3e:	2301      	movs	r3, #1
 8006f40:	e012      	b.n	8006f68 <I2C_RequestMemoryWrite+0x9c>
    }

    /* Send LSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
 8006f42:	893b      	ldrh	r3, [r7, #8]
 8006f44:	b2da      	uxtb	r2, r3
 8006f46:	68fb      	ldr	r3, [r7, #12]
 8006f48:	681b      	ldr	r3, [r3, #0]
 8006f4a:	629a      	str	r2, [r3, #40]	@ 0x28
  }

  /* Wait until TCR flag is set */
  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, Tickstart) != HAL_OK)
 8006f4c:	69fb      	ldr	r3, [r7, #28]
 8006f4e:	9300      	str	r3, [sp, #0]
 8006f50:	69bb      	ldr	r3, [r7, #24]
 8006f52:	2200      	movs	r2, #0
 8006f54:	2180      	movs	r1, #128	@ 0x80
 8006f56:	68f8      	ldr	r0, [r7, #12]
 8006f58:	f000 f884 	bl	8007064 <I2C_WaitOnFlagUntilTimeout>
 8006f5c:	4603      	mov	r3, r0
 8006f5e:	2b00      	cmp	r3, #0
 8006f60:	d001      	beq.n	8006f66 <I2C_RequestMemoryWrite+0x9a>
  {
    return HAL_ERROR;
 8006f62:	2301      	movs	r3, #1
 8006f64:	e000      	b.n	8006f68 <I2C_RequestMemoryWrite+0x9c>
  }

  return HAL_OK;
 8006f66:	2300      	movs	r3, #0
}
 8006f68:	4618      	mov	r0, r3
 8006f6a:	3710      	adds	r7, #16
 8006f6c:	46bd      	mov	sp, r7
 8006f6e:	bd80      	pop	{r7, pc}
 8006f70:	80002000 	.word	0x80002000

08006f74 <I2C_RequestMemoryRead>:
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_RequestMemoryRead(I2C_HandleTypeDef *hi2c, uint16_t DevAddress,
                                               uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout,
                                               uint32_t Tickstart)
{
 8006f74:	b580      	push	{r7, lr}
 8006f76:	b086      	sub	sp, #24
 8006f78:	af02      	add	r7, sp, #8
 8006f7a:	60f8      	str	r0, [r7, #12]
 8006f7c:	4608      	mov	r0, r1
 8006f7e:	4611      	mov	r1, r2
 8006f80:	461a      	mov	r2, r3
 8006f82:	4603      	mov	r3, r0
 8006f84:	817b      	strh	r3, [r7, #10]
 8006f86:	460b      	mov	r3, r1
 8006f88:	813b      	strh	r3, [r7, #8]
 8006f8a:	4613      	mov	r3, r2
 8006f8c:	80fb      	strh	r3, [r7, #6]
  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_SOFTEND_MODE, I2C_GENERATE_START_WRITE);
 8006f8e:	88fb      	ldrh	r3, [r7, #6]
 8006f90:	b2da      	uxtb	r2, r3
 8006f92:	8979      	ldrh	r1, [r7, #10]
 8006f94:	4b20      	ldr	r3, [pc, #128]	@ (8007018 <I2C_RequestMemoryRead+0xa4>)
 8006f96:	9300      	str	r3, [sp, #0]
 8006f98:	2300      	movs	r3, #0
 8006f9a:	68f8      	ldr	r0, [r7, #12]
 8006f9c:	f000 fa26 	bl	80073ec <I2C_TransferConfig>

  /* Wait until TXIS flag is set */
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 8006fa0:	69fa      	ldr	r2, [r7, #28]
 8006fa2:	69b9      	ldr	r1, [r7, #24]
 8006fa4:	68f8      	ldr	r0, [r7, #12]
 8006fa6:	f000 f8b6 	bl	8007116 <I2C_WaitOnTXISFlagUntilTimeout>
 8006faa:	4603      	mov	r3, r0
 8006fac:	2b00      	cmp	r3, #0
 8006fae:	d001      	beq.n	8006fb4 <I2C_RequestMemoryRead+0x40>
  {
    return HAL_ERROR;
 8006fb0:	2301      	movs	r3, #1
 8006fb2:	e02c      	b.n	800700e <I2C_RequestMemoryRead+0x9a>
  }

  /* If Memory address size is 8Bit */
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
 8006fb4:	88fb      	ldrh	r3, [r7, #6]
 8006fb6:	2b01      	cmp	r3, #1
 8006fb8:	d105      	bne.n	8006fc6 <I2C_RequestMemoryRead+0x52>
  {
    /* Send Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
 8006fba:	893b      	ldrh	r3, [r7, #8]
 8006fbc:	b2da      	uxtb	r2, r3
 8006fbe:	68fb      	ldr	r3, [r7, #12]
 8006fc0:	681b      	ldr	r3, [r3, #0]
 8006fc2:	629a      	str	r2, [r3, #40]	@ 0x28
 8006fc4:	e015      	b.n	8006ff2 <I2C_RequestMemoryRead+0x7e>
  }
  /* If Memory address size is 16Bit */
  else
  {
    /* Send MSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
 8006fc6:	893b      	ldrh	r3, [r7, #8]
 8006fc8:	0a1b      	lsrs	r3, r3, #8
 8006fca:	b29b      	uxth	r3, r3
 8006fcc:	b2da      	uxtb	r2, r3
 8006fce:	68fb      	ldr	r3, [r7, #12]
 8006fd0:	681b      	ldr	r3, [r3, #0]
 8006fd2:	629a      	str	r2, [r3, #40]	@ 0x28

    /* Wait until TXIS flag is set */
    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 8006fd4:	69fa      	ldr	r2, [r7, #28]
 8006fd6:	69b9      	ldr	r1, [r7, #24]
 8006fd8:	68f8      	ldr	r0, [r7, #12]
 8006fda:	f000 f89c 	bl	8007116 <I2C_WaitOnTXISFlagUntilTimeout>
 8006fde:	4603      	mov	r3, r0
 8006fe0:	2b00      	cmp	r3, #0
 8006fe2:	d001      	beq.n	8006fe8 <I2C_RequestMemoryRead+0x74>
    {
      return HAL_ERROR;
 8006fe4:	2301      	movs	r3, #1
 8006fe6:	e012      	b.n	800700e <I2C_RequestMemoryRead+0x9a>
    }

    /* Send LSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
 8006fe8:	893b      	ldrh	r3, [r7, #8]
 8006fea:	b2da      	uxtb	r2, r3
 8006fec:	68fb      	ldr	r3, [r7, #12]
 8006fee:	681b      	ldr	r3, [r3, #0]
 8006ff0:	629a      	str	r2, [r3, #40]	@ 0x28
  }

  /* Wait until TC flag is set */
  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TC, RESET, Timeout, Tickstart) != HAL_OK)
 8006ff2:	69fb      	ldr	r3, [r7, #28]
 8006ff4:	9300      	str	r3, [sp, #0]
 8006ff6:	69bb      	ldr	r3, [r7, #24]
 8006ff8:	2200      	movs	r2, #0
 8006ffa:	2140      	movs	r1, #64	@ 0x40
 8006ffc:	68f8      	ldr	r0, [r7, #12]
 8006ffe:	f000 f831 	bl	8007064 <I2C_WaitOnFlagUntilTimeout>
 8007002:	4603      	mov	r3, r0
 8007004:	2b00      	cmp	r3, #0
 8007006:	d001      	beq.n	800700c <I2C_RequestMemoryRead+0x98>
  {
    return HAL_ERROR;
 8007008:	2301      	movs	r3, #1
 800700a:	e000      	b.n	800700e <I2C_RequestMemoryRead+0x9a>
  }

  return HAL_OK;
 800700c:	2300      	movs	r3, #0
}
 800700e:	4618      	mov	r0, r3
 8007010:	3710      	adds	r7, #16
 8007012:	46bd      	mov	sp, r7
 8007014:	bd80      	pop	{r7, pc}
 8007016:	bf00      	nop
 8007018:	80002000 	.word	0x80002000

0800701c <I2C_Flush_TXDR>:
  * @brief  I2C Tx data register flush process.
  * @param  hi2c I2C handle.
  * @retval None
  */
static void I2C_Flush_TXDR(I2C_HandleTypeDef *hi2c)
{
 800701c:	b480      	push	{r7}
 800701e:	b083      	sub	sp, #12
 8007020:	af00      	add	r7, sp, #0
 8007022:	6078      	str	r0, [r7, #4]
  /* If a pending TXIS flag is set */
  /* Write a dummy data in TXDR to clear it */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
 8007024:	687b      	ldr	r3, [r7, #4]
 8007026:	681b      	ldr	r3, [r3, #0]
 8007028:	699b      	ldr	r3, [r3, #24]
 800702a:	f003 0302 	and.w	r3, r3, #2
 800702e:	2b02      	cmp	r3, #2
 8007030:	d103      	bne.n	800703a <I2C_Flush_TXDR+0x1e>
  {
    hi2c->Instance->TXDR = 0x00U;
 8007032:	687b      	ldr	r3, [r7, #4]
 8007034:	681b      	ldr	r3, [r3, #0]
 8007036:	2200      	movs	r2, #0
 8007038:	629a      	str	r2, [r3, #40]	@ 0x28
  }

  /* Flush TX register if not empty */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
 800703a:	687b      	ldr	r3, [r7, #4]
 800703c:	681b      	ldr	r3, [r3, #0]
 800703e:	699b      	ldr	r3, [r3, #24]
 8007040:	f003 0301 	and.w	r3, r3, #1
 8007044:	2b01      	cmp	r3, #1
 8007046:	d007      	beq.n	8007058 <I2C_Flush_TXDR+0x3c>
  {
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
 8007048:	687b      	ldr	r3, [r7, #4]
 800704a:	681b      	ldr	r3, [r3, #0]
 800704c:	699a      	ldr	r2, [r3, #24]
 800704e:	687b      	ldr	r3, [r7, #4]
 8007050:	681b      	ldr	r3, [r3, #0]
 8007052:	f042 0201 	orr.w	r2, r2, #1
 8007056:	619a      	str	r2, [r3, #24]
  }
}
 8007058:	bf00      	nop
 800705a:	370c      	adds	r7, #12
 800705c:	46bd      	mov	sp, r7
 800705e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007062:	4770      	bx	lr

08007064 <I2C_WaitOnFlagUntilTimeout>:
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, FlagStatus Status,
                                                    uint32_t Timeout, uint32_t Tickstart)
{
 8007064:	b580      	push	{r7, lr}
 8007066:	b084      	sub	sp, #16
 8007068:	af00      	add	r7, sp, #0
 800706a:	60f8      	str	r0, [r7, #12]
 800706c:	60b9      	str	r1, [r7, #8]
 800706e:	603b      	str	r3, [r7, #0]
 8007070:	4613      	mov	r3, r2
 8007072:	71fb      	strb	r3, [r7, #7]
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 8007074:	e03b      	b.n	80070ee <I2C_WaitOnFlagUntilTimeout+0x8a>
  {
    /* Check if an error is detected */
    if (I2C_IsErrorOccurred(hi2c, Timeout, Tickstart) != HAL_OK)
 8007076:	69ba      	ldr	r2, [r7, #24]
 8007078:	6839      	ldr	r1, [r7, #0]
 800707a:	68f8      	ldr	r0, [r7, #12]
 800707c:	f000 f8d6 	bl	800722c <I2C_IsErrorOccurred>
 8007080:	4603      	mov	r3, r0
 8007082:	2b00      	cmp	r3, #0
 8007084:	d001      	beq.n	800708a <I2C_WaitOnFlagUntilTimeout+0x26>
    {
      return HAL_ERROR;
 8007086:	2301      	movs	r3, #1
 8007088:	e041      	b.n	800710e <I2C_WaitOnFlagUntilTimeout+0xaa>
    }

    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
 800708a:	683b      	ldr	r3, [r7, #0]
 800708c:	f1b3 3fff 	cmp.w	r3, #4294967295
 8007090:	d02d      	beq.n	80070ee <I2C_WaitOnFlagUntilTimeout+0x8a>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8007092:	f7fb fc65 	bl	8002960 <HAL_GetTick>
 8007096:	4602      	mov	r2, r0
 8007098:	69bb      	ldr	r3, [r7, #24]
 800709a:	1ad3      	subs	r3, r2, r3
 800709c:	683a      	ldr	r2, [r7, #0]
 800709e:	429a      	cmp	r2, r3
 80070a0:	d302      	bcc.n	80070a8 <I2C_WaitOnFlagUntilTimeout+0x44>
 80070a2:	683b      	ldr	r3, [r7, #0]
 80070a4:	2b00      	cmp	r3, #0
 80070a6:	d122      	bne.n	80070ee <I2C_WaitOnFlagUntilTimeout+0x8a>
      {
        if ((__HAL_I2C_GET_FLAG(hi2c, Flag) == Status))
 80070a8:	68fb      	ldr	r3, [r7, #12]
 80070aa:	681b      	ldr	r3, [r3, #0]
 80070ac:	699a      	ldr	r2, [r3, #24]
 80070ae:	68bb      	ldr	r3, [r7, #8]
 80070b0:	4013      	ands	r3, r2
 80070b2:	68ba      	ldr	r2, [r7, #8]
 80070b4:	429a      	cmp	r2, r3
 80070b6:	bf0c      	ite	eq
 80070b8:	2301      	moveq	r3, #1
 80070ba:	2300      	movne	r3, #0
 80070bc:	b2db      	uxtb	r3, r3
 80070be:	461a      	mov	r2, r3
 80070c0:	79fb      	ldrb	r3, [r7, #7]
 80070c2:	429a      	cmp	r2, r3
 80070c4:	d113      	bne.n	80070ee <I2C_WaitOnFlagUntilTimeout+0x8a>
        {
          hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 80070c6:	68fb      	ldr	r3, [r7, #12]
 80070c8:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 80070ca:	f043 0220 	orr.w	r2, r3, #32
 80070ce:	68fb      	ldr	r3, [r7, #12]
 80070d0:	645a      	str	r2, [r3, #68]	@ 0x44
          hi2c->State = HAL_I2C_STATE_READY;
 80070d2:	68fb      	ldr	r3, [r7, #12]
 80070d4:	2220      	movs	r2, #32
 80070d6:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
          hi2c->Mode = HAL_I2C_MODE_NONE;
 80070da:	68fb      	ldr	r3, [r7, #12]
 80070dc:	2200      	movs	r2, #0
 80070de:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42

          /* Process Unlocked */
          __HAL_UNLOCK(hi2c);
 80070e2:	68fb      	ldr	r3, [r7, #12]
 80070e4:	2200      	movs	r2, #0
 80070e6:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
          return HAL_ERROR;
 80070ea:	2301      	movs	r3, #1
 80070ec:	e00f      	b.n	800710e <I2C_WaitOnFlagUntilTimeout+0xaa>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 80070ee:	68fb      	ldr	r3, [r7, #12]
 80070f0:	681b      	ldr	r3, [r3, #0]
 80070f2:	699a      	ldr	r2, [r3, #24]
 80070f4:	68bb      	ldr	r3, [r7, #8]
 80070f6:	4013      	ands	r3, r2
 80070f8:	68ba      	ldr	r2, [r7, #8]
 80070fa:	429a      	cmp	r2, r3
 80070fc:	bf0c      	ite	eq
 80070fe:	2301      	moveq	r3, #1
 8007100:	2300      	movne	r3, #0
 8007102:	b2db      	uxtb	r3, r3
 8007104:	461a      	mov	r2, r3
 8007106:	79fb      	ldrb	r3, [r7, #7]
 8007108:	429a      	cmp	r2, r3
 800710a:	d0b4      	beq.n	8007076 <I2C_WaitOnFlagUntilTimeout+0x12>
        }
      }
    }
  }
  return HAL_OK;
 800710c:	2300      	movs	r3, #0
}
 800710e:	4618      	mov	r0, r3
 8007110:	3710      	adds	r7, #16
 8007112:	46bd      	mov	sp, r7
 8007114:	bd80      	pop	{r7, pc}

08007116 <I2C_WaitOnTXISFlagUntilTimeout>:
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnTXISFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout,
                                                        uint32_t Tickstart)
{
 8007116:	b580      	push	{r7, lr}
 8007118:	b084      	sub	sp, #16
 800711a:	af00      	add	r7, sp, #0
 800711c:	60f8      	str	r0, [r7, #12]
 800711e:	60b9      	str	r1, [r7, #8]
 8007120:	607a      	str	r2, [r7, #4]
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
 8007122:	e033      	b.n	800718c <I2C_WaitOnTXISFlagUntilTimeout+0x76>
  {
    /* Check if an error is detected */
    if (I2C_IsErrorOccurred(hi2c, Timeout, Tickstart) != HAL_OK)
 8007124:	687a      	ldr	r2, [r7, #4]
 8007126:	68b9      	ldr	r1, [r7, #8]
 8007128:	68f8      	ldr	r0, [r7, #12]
 800712a:	f000 f87f 	bl	800722c <I2C_IsErrorOccurred>
 800712e:	4603      	mov	r3, r0
 8007130:	2b00      	cmp	r3, #0
 8007132:	d001      	beq.n	8007138 <I2C_WaitOnTXISFlagUntilTimeout+0x22>
    {
      return HAL_ERROR;
 8007134:	2301      	movs	r3, #1
 8007136:	e031      	b.n	800719c <I2C_WaitOnTXISFlagUntilTimeout+0x86>
    }

    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
 8007138:	68bb      	ldr	r3, [r7, #8]
 800713a:	f1b3 3fff 	cmp.w	r3, #4294967295
 800713e:	d025      	beq.n	800718c <I2C_WaitOnTXISFlagUntilTimeout+0x76>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8007140:	f7fb fc0e 	bl	8002960 <HAL_GetTick>
 8007144:	4602      	mov	r2, r0
 8007146:	687b      	ldr	r3, [r7, #4]
 8007148:	1ad3      	subs	r3, r2, r3
 800714a:	68ba      	ldr	r2, [r7, #8]
 800714c:	429a      	cmp	r2, r3
 800714e:	d302      	bcc.n	8007156 <I2C_WaitOnTXISFlagUntilTimeout+0x40>
 8007150:	68bb      	ldr	r3, [r7, #8]
 8007152:	2b00      	cmp	r3, #0
 8007154:	d11a      	bne.n	800718c <I2C_WaitOnTXISFlagUntilTimeout+0x76>
      {
        if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET))
 8007156:	68fb      	ldr	r3, [r7, #12]
 8007158:	681b      	ldr	r3, [r3, #0]
 800715a:	699b      	ldr	r3, [r3, #24]
 800715c:	f003 0302 	and.w	r3, r3, #2
 8007160:	2b02      	cmp	r3, #2
 8007162:	d013      	beq.n	800718c <I2C_WaitOnTXISFlagUntilTimeout+0x76>
        {
          hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8007164:	68fb      	ldr	r3, [r7, #12]
 8007166:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8007168:	f043 0220 	orr.w	r2, r3, #32
 800716c:	68fb      	ldr	r3, [r7, #12]
 800716e:	645a      	str	r2, [r3, #68]	@ 0x44
          hi2c->State = HAL_I2C_STATE_READY;
 8007170:	68fb      	ldr	r3, [r7, #12]
 8007172:	2220      	movs	r2, #32
 8007174:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
          hi2c->Mode = HAL_I2C_MODE_NONE;
 8007178:	68fb      	ldr	r3, [r7, #12]
 800717a:	2200      	movs	r2, #0
 800717c:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42

          /* Process Unlocked */
          __HAL_UNLOCK(hi2c);
 8007180:	68fb      	ldr	r3, [r7, #12]
 8007182:	2200      	movs	r2, #0
 8007184:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

          return HAL_ERROR;
 8007188:	2301      	movs	r3, #1
 800718a:	e007      	b.n	800719c <I2C_WaitOnTXISFlagUntilTimeout+0x86>
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
 800718c:	68fb      	ldr	r3, [r7, #12]
 800718e:	681b      	ldr	r3, [r3, #0]
 8007190:	699b      	ldr	r3, [r3, #24]
 8007192:	f003 0302 	and.w	r3, r3, #2
 8007196:	2b02      	cmp	r3, #2
 8007198:	d1c4      	bne.n	8007124 <I2C_WaitOnTXISFlagUntilTimeout+0xe>
        }
      }
    }
  }
  return HAL_OK;
 800719a:	2300      	movs	r3, #0
}
 800719c:	4618      	mov	r0, r3
 800719e:	3710      	adds	r7, #16
 80071a0:	46bd      	mov	sp, r7
 80071a2:	bd80      	pop	{r7, pc}

080071a4 <I2C_WaitOnSTOPFlagUntilTimeout>:
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnSTOPFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout,
                                                        uint32_t Tickstart)
{
 80071a4:	b580      	push	{r7, lr}
 80071a6:	b084      	sub	sp, #16
 80071a8:	af00      	add	r7, sp, #0
 80071aa:	60f8      	str	r0, [r7, #12]
 80071ac:	60b9      	str	r1, [r7, #8]
 80071ae:	607a      	str	r2, [r7, #4]
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 80071b0:	e02f      	b.n	8007212 <I2C_WaitOnSTOPFlagUntilTimeout+0x6e>
  {
    /* Check if an error is detected */
    if (I2C_IsErrorOccurred(hi2c, Timeout, Tickstart) != HAL_OK)
 80071b2:	687a      	ldr	r2, [r7, #4]
 80071b4:	68b9      	ldr	r1, [r7, #8]
 80071b6:	68f8      	ldr	r0, [r7, #12]
 80071b8:	f000 f838 	bl	800722c <I2C_IsErrorOccurred>
 80071bc:	4603      	mov	r3, r0
 80071be:	2b00      	cmp	r3, #0
 80071c0:	d001      	beq.n	80071c6 <I2C_WaitOnSTOPFlagUntilTimeout+0x22>
    {
      return HAL_ERROR;
 80071c2:	2301      	movs	r3, #1
 80071c4:	e02d      	b.n	8007222 <I2C_WaitOnSTOPFlagUntilTimeout+0x7e>
    }

    /* Check for the Timeout */
    if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 80071c6:	f7fb fbcb 	bl	8002960 <HAL_GetTick>
 80071ca:	4602      	mov	r2, r0
 80071cc:	687b      	ldr	r3, [r7, #4]
 80071ce:	1ad3      	subs	r3, r2, r3
 80071d0:	68ba      	ldr	r2, [r7, #8]
 80071d2:	429a      	cmp	r2, r3
 80071d4:	d302      	bcc.n	80071dc <I2C_WaitOnSTOPFlagUntilTimeout+0x38>
 80071d6:	68bb      	ldr	r3, [r7, #8]
 80071d8:	2b00      	cmp	r3, #0
 80071da:	d11a      	bne.n	8007212 <I2C_WaitOnSTOPFlagUntilTimeout+0x6e>
    {
      if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET))
 80071dc:	68fb      	ldr	r3, [r7, #12]
 80071de:	681b      	ldr	r3, [r3, #0]
 80071e0:	699b      	ldr	r3, [r3, #24]
 80071e2:	f003 0320 	and.w	r3, r3, #32
 80071e6:	2b20      	cmp	r3, #32
 80071e8:	d013      	beq.n	8007212 <I2C_WaitOnSTOPFlagUntilTimeout+0x6e>
      {
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 80071ea:	68fb      	ldr	r3, [r7, #12]
 80071ec:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 80071ee:	f043 0220 	orr.w	r2, r3, #32
 80071f2:	68fb      	ldr	r3, [r7, #12]
 80071f4:	645a      	str	r2, [r3, #68]	@ 0x44
        hi2c->State = HAL_I2C_STATE_READY;
 80071f6:	68fb      	ldr	r3, [r7, #12]
 80071f8:	2220      	movs	r2, #32
 80071fa:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
 80071fe:	68fb      	ldr	r3, [r7, #12]
 8007200:	2200      	movs	r2, #0
 8007202:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
 8007206:	68fb      	ldr	r3, [r7, #12]
 8007208:	2200      	movs	r2, #0
 800720a:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

        return HAL_ERROR;
 800720e:	2301      	movs	r3, #1
 8007210:	e007      	b.n	8007222 <I2C_WaitOnSTOPFlagUntilTimeout+0x7e>
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 8007212:	68fb      	ldr	r3, [r7, #12]
 8007214:	681b      	ldr	r3, [r3, #0]
 8007216:	699b      	ldr	r3, [r3, #24]
 8007218:	f003 0320 	and.w	r3, r3, #32
 800721c:	2b20      	cmp	r3, #32
 800721e:	d1c8      	bne.n	80071b2 <I2C_WaitOnSTOPFlagUntilTimeout+0xe>
      }
    }
  }
  return HAL_OK;
 8007220:	2300      	movs	r3, #0
}
 8007222:	4618      	mov	r0, r3
 8007224:	3710      	adds	r7, #16
 8007226:	46bd      	mov	sp, r7
 8007228:	bd80      	pop	{r7, pc}
	...

0800722c <I2C_IsErrorOccurred>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_IsErrorOccurred(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
 800722c:	b580      	push	{r7, lr}
 800722e:	b08a      	sub	sp, #40	@ 0x28
 8007230:	af00      	add	r7, sp, #0
 8007232:	60f8      	str	r0, [r7, #12]
 8007234:	60b9      	str	r1, [r7, #8]
 8007236:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
 8007238:	2300      	movs	r3, #0
 800723a:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
  uint32_t itflag   = hi2c->Instance->ISR;
 800723e:	68fb      	ldr	r3, [r7, #12]
 8007240:	681b      	ldr	r3, [r3, #0]
 8007242:	699b      	ldr	r3, [r3, #24]
 8007244:	61bb      	str	r3, [r7, #24]
  uint32_t error_code = 0;
 8007246:	2300      	movs	r3, #0
 8007248:	623b      	str	r3, [r7, #32]
  uint32_t tickstart = Tickstart;
 800724a:	687b      	ldr	r3, [r7, #4]
 800724c:	61fb      	str	r3, [r7, #28]
  uint32_t tmp1;
  HAL_I2C_ModeTypeDef tmp2;

  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_AF))
 800724e:	69bb      	ldr	r3, [r7, #24]
 8007250:	f003 0310 	and.w	r3, r3, #16
 8007254:	2b00      	cmp	r3, #0
 8007256:	d068      	beq.n	800732a <I2C_IsErrorOccurred+0xfe>
  {
    /* Clear NACKF Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8007258:	68fb      	ldr	r3, [r7, #12]
 800725a:	681b      	ldr	r3, [r3, #0]
 800725c:	2210      	movs	r2, #16
 800725e:	61da      	str	r2, [r3, #28]

    /* Wait until STOP Flag is set or timeout occurred */
    /* AutoEnd should be initiate after AF */
    while ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET) && (status == HAL_OK))
 8007260:	e049      	b.n	80072f6 <I2C_IsErrorOccurred+0xca>
    {
      /* Check for the Timeout */
      if (Timeout != HAL_MAX_DELAY)
 8007262:	68bb      	ldr	r3, [r7, #8]
 8007264:	f1b3 3fff 	cmp.w	r3, #4294967295
 8007268:	d045      	beq.n	80072f6 <I2C_IsErrorOccurred+0xca>
      {
        if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
 800726a:	f7fb fb79 	bl	8002960 <HAL_GetTick>
 800726e:	4602      	mov	r2, r0
 8007270:	69fb      	ldr	r3, [r7, #28]
 8007272:	1ad3      	subs	r3, r2, r3
 8007274:	68ba      	ldr	r2, [r7, #8]
 8007276:	429a      	cmp	r2, r3
 8007278:	d302      	bcc.n	8007280 <I2C_IsErrorOccurred+0x54>
 800727a:	68bb      	ldr	r3, [r7, #8]
 800727c:	2b00      	cmp	r3, #0
 800727e:	d13a      	bne.n	80072f6 <I2C_IsErrorOccurred+0xca>
        {
          tmp1 = (uint32_t)(hi2c->Instance->CR2 & I2C_CR2_STOP);
 8007280:	68fb      	ldr	r3, [r7, #12]
 8007282:	681b      	ldr	r3, [r3, #0]
 8007284:	685b      	ldr	r3, [r3, #4]
 8007286:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
 800728a:	617b      	str	r3, [r7, #20]
          tmp2 = hi2c->Mode;
 800728c:	68fb      	ldr	r3, [r7, #12]
 800728e:	f893 3042 	ldrb.w	r3, [r3, #66]	@ 0x42
 8007292:	74fb      	strb	r3, [r7, #19]

          /* In case of I2C still busy, try to regenerate a STOP manually */
          if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET) && \
 8007294:	68fb      	ldr	r3, [r7, #12]
 8007296:	681b      	ldr	r3, [r3, #0]
 8007298:	699b      	ldr	r3, [r3, #24]
 800729a:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
 800729e:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
 80072a2:	d121      	bne.n	80072e8 <I2C_IsErrorOccurred+0xbc>
 80072a4:	697b      	ldr	r3, [r7, #20]
 80072a6:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
 80072aa:	d01d      	beq.n	80072e8 <I2C_IsErrorOccurred+0xbc>
              (tmp1 != I2C_CR2_STOP) && \
 80072ac:	7cfb      	ldrb	r3, [r7, #19]
 80072ae:	2b20      	cmp	r3, #32
 80072b0:	d01a      	beq.n	80072e8 <I2C_IsErrorOccurred+0xbc>
              (tmp2 != HAL_I2C_MODE_SLAVE))
          {
            /* Generate Stop */
            hi2c->Instance->CR2 |= I2C_CR2_STOP;
 80072b2:	68fb      	ldr	r3, [r7, #12]
 80072b4:	681b      	ldr	r3, [r3, #0]
 80072b6:	685a      	ldr	r2, [r3, #4]
 80072b8:	68fb      	ldr	r3, [r7, #12]
 80072ba:	681b      	ldr	r3, [r3, #0]
 80072bc:	f442 4280 	orr.w	r2, r2, #16384	@ 0x4000
 80072c0:	605a      	str	r2, [r3, #4]

            /* Update Tick with new reference */
            tickstart = HAL_GetTick();
 80072c2:	f7fb fb4d 	bl	8002960 <HAL_GetTick>
 80072c6:	61f8      	str	r0, [r7, #28]
          }

          while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 80072c8:	e00e      	b.n	80072e8 <I2C_IsErrorOccurred+0xbc>
          {
            /* Check for the Timeout */
            if ((HAL_GetTick() - tickstart) > I2C_TIMEOUT_STOPF)
 80072ca:	f7fb fb49 	bl	8002960 <HAL_GetTick>
 80072ce:	4602      	mov	r2, r0
 80072d0:	69fb      	ldr	r3, [r7, #28]
 80072d2:	1ad3      	subs	r3, r2, r3
 80072d4:	2b19      	cmp	r3, #25
 80072d6:	d907      	bls.n	80072e8 <I2C_IsErrorOccurred+0xbc>
            {
              error_code |= HAL_I2C_ERROR_TIMEOUT;
 80072d8:	6a3b      	ldr	r3, [r7, #32]
 80072da:	f043 0320 	orr.w	r3, r3, #32
 80072de:	623b      	str	r3, [r7, #32]

              status = HAL_ERROR;
 80072e0:	2301      	movs	r3, #1
 80072e2:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27

              break;
 80072e6:	e006      	b.n	80072f6 <I2C_IsErrorOccurred+0xca>
          while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 80072e8:	68fb      	ldr	r3, [r7, #12]
 80072ea:	681b      	ldr	r3, [r3, #0]
 80072ec:	699b      	ldr	r3, [r3, #24]
 80072ee:	f003 0320 	and.w	r3, r3, #32
 80072f2:	2b20      	cmp	r3, #32
 80072f4:	d1e9      	bne.n	80072ca <I2C_IsErrorOccurred+0x9e>
    while ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET) && (status == HAL_OK))
 80072f6:	68fb      	ldr	r3, [r7, #12]
 80072f8:	681b      	ldr	r3, [r3, #0]
 80072fa:	699b      	ldr	r3, [r3, #24]
 80072fc:	f003 0320 	and.w	r3, r3, #32
 8007300:	2b20      	cmp	r3, #32
 8007302:	d003      	beq.n	800730c <I2C_IsErrorOccurred+0xe0>
 8007304:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 8007308:	2b00      	cmp	r3, #0
 800730a:	d0aa      	beq.n	8007262 <I2C_IsErrorOccurred+0x36>
        }
      }
    }

    /* In case STOP Flag is detected, clear it */
    if (status == HAL_OK)
 800730c:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 8007310:	2b00      	cmp	r3, #0
 8007312:	d103      	bne.n	800731c <I2C_IsErrorOccurred+0xf0>
    {
      /* Clear STOP Flag */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8007314:	68fb      	ldr	r3, [r7, #12]
 8007316:	681b      	ldr	r3, [r3, #0]
 8007318:	2220      	movs	r2, #32
 800731a:	61da      	str	r2, [r3, #28]
    }

    error_code |= HAL_I2C_ERROR_AF;
 800731c:	6a3b      	ldr	r3, [r7, #32]
 800731e:	f043 0304 	orr.w	r3, r3, #4
 8007322:	623b      	str	r3, [r7, #32]

    status = HAL_ERROR;
 8007324:	2301      	movs	r3, #1
 8007326:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
  }

  /* Refresh Content of Status register */
  itflag = hi2c->Instance->ISR;
 800732a:	68fb      	ldr	r3, [r7, #12]
 800732c:	681b      	ldr	r3, [r3, #0]
 800732e:	699b      	ldr	r3, [r3, #24]
 8007330:	61bb      	str	r3, [r7, #24]

  /* Then verify if an additional errors occurs */
  /* Check if a Bus error occurred */
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_BERR))
 8007332:	69bb      	ldr	r3, [r7, #24]
 8007334:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8007338:	2b00      	cmp	r3, #0
 800733a:	d00b      	beq.n	8007354 <I2C_IsErrorOccurred+0x128>
  {
    error_code |= HAL_I2C_ERROR_BERR;
 800733c:	6a3b      	ldr	r3, [r7, #32]
 800733e:	f043 0301 	orr.w	r3, r3, #1
 8007342:	623b      	str	r3, [r7, #32]

    /* Clear BERR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
 8007344:	68fb      	ldr	r3, [r7, #12]
 8007346:	681b      	ldr	r3, [r3, #0]
 8007348:	f44f 7280 	mov.w	r2, #256	@ 0x100
 800734c:	61da      	str	r2, [r3, #28]

    status = HAL_ERROR;
 800734e:	2301      	movs	r3, #1
 8007350:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
  }

  /* Check if an Over-Run/Under-Run error occurred */
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_OVR))
 8007354:	69bb      	ldr	r3, [r7, #24]
 8007356:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 800735a:	2b00      	cmp	r3, #0
 800735c:	d00b      	beq.n	8007376 <I2C_IsErrorOccurred+0x14a>
  {
    error_code |= HAL_I2C_ERROR_OVR;
 800735e:	6a3b      	ldr	r3, [r7, #32]
 8007360:	f043 0308 	orr.w	r3, r3, #8
 8007364:	623b      	str	r3, [r7, #32]

    /* Clear OVR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
 8007366:	68fb      	ldr	r3, [r7, #12]
 8007368:	681b      	ldr	r3, [r3, #0]
 800736a:	f44f 6280 	mov.w	r2, #1024	@ 0x400
 800736e:	61da      	str	r2, [r3, #28]

    status = HAL_ERROR;
 8007370:	2301      	movs	r3, #1
 8007372:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
  }

  /* Check if an Arbitration Loss error occurred */
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_ARLO))
 8007376:	69bb      	ldr	r3, [r7, #24]
 8007378:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 800737c:	2b00      	cmp	r3, #0
 800737e:	d00b      	beq.n	8007398 <I2C_IsErrorOccurred+0x16c>
  {
    error_code |= HAL_I2C_ERROR_ARLO;
 8007380:	6a3b      	ldr	r3, [r7, #32]
 8007382:	f043 0302 	orr.w	r3, r3, #2
 8007386:	623b      	str	r3, [r7, #32]

    /* Clear ARLO flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
 8007388:	68fb      	ldr	r3, [r7, #12]
 800738a:	681b      	ldr	r3, [r3, #0]
 800738c:	f44f 7200 	mov.w	r2, #512	@ 0x200
 8007390:	61da      	str	r2, [r3, #28]

    status = HAL_ERROR;
 8007392:	2301      	movs	r3, #1
 8007394:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
  }

  if (status != HAL_OK)
 8007398:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 800739c:	2b00      	cmp	r3, #0
 800739e:	d01c      	beq.n	80073da <I2C_IsErrorOccurred+0x1ae>
  {
    /* Flush TX register */
    I2C_Flush_TXDR(hi2c);
 80073a0:	68f8      	ldr	r0, [r7, #12]
 80073a2:	f7ff fe3b 	bl	800701c <I2C_Flush_TXDR>

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
 80073a6:	68fb      	ldr	r3, [r7, #12]
 80073a8:	681b      	ldr	r3, [r3, #0]
 80073aa:	6859      	ldr	r1, [r3, #4]
 80073ac:	68fb      	ldr	r3, [r7, #12]
 80073ae:	681a      	ldr	r2, [r3, #0]
 80073b0:	4b0d      	ldr	r3, [pc, #52]	@ (80073e8 <I2C_IsErrorOccurred+0x1bc>)
 80073b2:	400b      	ands	r3, r1
 80073b4:	6053      	str	r3, [r2, #4]

    hi2c->ErrorCode |= error_code;
 80073b6:	68fb      	ldr	r3, [r7, #12]
 80073b8:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
 80073ba:	6a3b      	ldr	r3, [r7, #32]
 80073bc:	431a      	orrs	r2, r3
 80073be:	68fb      	ldr	r3, [r7, #12]
 80073c0:	645a      	str	r2, [r3, #68]	@ 0x44
    hi2c->State = HAL_I2C_STATE_READY;
 80073c2:	68fb      	ldr	r3, [r7, #12]
 80073c4:	2220      	movs	r2, #32
 80073c6:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
    hi2c->Mode = HAL_I2C_MODE_NONE;
 80073ca:	68fb      	ldr	r3, [r7, #12]
 80073cc:	2200      	movs	r2, #0
 80073ce:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 80073d2:	68fb      	ldr	r3, [r7, #12]
 80073d4:	2200      	movs	r2, #0
 80073d6:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
  }

  return status;
 80073da:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
}
 80073de:	4618      	mov	r0, r3
 80073e0:	3728      	adds	r7, #40	@ 0x28
 80073e2:	46bd      	mov	sp, r7
 80073e4:	bd80      	pop	{r7, pc}
 80073e6:	bf00      	nop
 80073e8:	fe00e800 	.word	0xfe00e800

080073ec <I2C_TransferConfig>:
  *     @arg @ref I2C_GENERATE_START_WRITE Generate Restart for write request.
  * @retval None
  */
static void I2C_TransferConfig(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t Size, uint32_t Mode,
                               uint32_t Request)
{
 80073ec:	b480      	push	{r7}
 80073ee:	b087      	sub	sp, #28
 80073f0:	af00      	add	r7, sp, #0
 80073f2:	60f8      	str	r0, [r7, #12]
 80073f4:	607b      	str	r3, [r7, #4]
 80073f6:	460b      	mov	r3, r1
 80073f8:	817b      	strh	r3, [r7, #10]
 80073fa:	4613      	mov	r3, r2
 80073fc:	727b      	strb	r3, [r7, #9]
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));

  /* Declaration of tmp to prevent undefined behavior of volatile usage */
  uint32_t tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \
 80073fe:	897b      	ldrh	r3, [r7, #10]
 8007400:	f3c3 0209 	ubfx	r2, r3, #0, #10
                             (((uint32_t)Size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES) | \
 8007404:	7a7b      	ldrb	r3, [r7, #9]
 8007406:	041b      	lsls	r3, r3, #16
 8007408:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
  uint32_t tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \
 800740c:	431a      	orrs	r2, r3
                             (((uint32_t)Size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES) | \
 800740e:	687b      	ldr	r3, [r7, #4]
 8007410:	431a      	orrs	r2, r3
  uint32_t tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \
 8007412:	6a3b      	ldr	r3, [r7, #32]
 8007414:	4313      	orrs	r3, r2
 8007416:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
 800741a:	617b      	str	r3, [r7, #20]
                             (uint32_t)Mode | (uint32_t)Request) & (~0x80000000U));

  /* update CR2 register */
  MODIFY_REG(hi2c->Instance->CR2, \
 800741c:	68fb      	ldr	r3, [r7, #12]
 800741e:	681b      	ldr	r3, [r3, #0]
 8007420:	685a      	ldr	r2, [r3, #4]
 8007422:	6a3b      	ldr	r3, [r7, #32]
 8007424:	0d5b      	lsrs	r3, r3, #21
 8007426:	f403 6180 	and.w	r1, r3, #1024	@ 0x400
 800742a:	4b08      	ldr	r3, [pc, #32]	@ (800744c <I2C_TransferConfig+0x60>)
 800742c:	430b      	orrs	r3, r1
 800742e:	43db      	mvns	r3, r3
 8007430:	ea02 0103 	and.w	r1, r2, r3
 8007434:	68fb      	ldr	r3, [r7, #12]
 8007436:	681b      	ldr	r3, [r3, #0]
 8007438:	697a      	ldr	r2, [r7, #20]
 800743a:	430a      	orrs	r2, r1
 800743c:	605a      	str	r2, [r3, #4]
             ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | \
               (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | \
               I2C_CR2_START | I2C_CR2_STOP)), tmp);
}
 800743e:	bf00      	nop
 8007440:	371c      	adds	r7, #28
 8007442:	46bd      	mov	sp, r7
 8007444:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007448:	4770      	bx	lr
 800744a:	bf00      	nop
 800744c:	03ff63ff 	.word	0x03ff63ff

08007450 <HAL_I2CEx_ConfigAnalogFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  AnalogFilter New state of the Analog filter.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigAnalogFilter(I2C_HandleTypeDef *hi2c, uint32_t AnalogFilter)
{
 8007450:	b480      	push	{r7}
 8007452:	b083      	sub	sp, #12
 8007454:	af00      	add	r7, sp, #0
 8007456:	6078      	str	r0, [r7, #4]
 8007458:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_ANALOG_FILTER(AnalogFilter));

  if (hi2c->State == HAL_I2C_STATE_READY)
 800745a:	687b      	ldr	r3, [r7, #4]
 800745c:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
 8007460:	b2db      	uxtb	r3, r3
 8007462:	2b20      	cmp	r3, #32
 8007464:	d138      	bne.n	80074d8 <HAL_I2CEx_ConfigAnalogFilter+0x88>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
 8007466:	687b      	ldr	r3, [r7, #4]
 8007468:	f893 3040 	ldrb.w	r3, [r3, #64]	@ 0x40
 800746c:	2b01      	cmp	r3, #1
 800746e:	d101      	bne.n	8007474 <HAL_I2CEx_ConfigAnalogFilter+0x24>
 8007470:	2302      	movs	r3, #2
 8007472:	e032      	b.n	80074da <HAL_I2CEx_ConfigAnalogFilter+0x8a>
 8007474:	687b      	ldr	r3, [r7, #4]
 8007476:	2201      	movs	r2, #1
 8007478:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    hi2c->State = HAL_I2C_STATE_BUSY;
 800747c:	687b      	ldr	r3, [r7, #4]
 800747e:	2224      	movs	r2, #36	@ 0x24
 8007480:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
 8007484:	687b      	ldr	r3, [r7, #4]
 8007486:	681b      	ldr	r3, [r3, #0]
 8007488:	681a      	ldr	r2, [r3, #0]
 800748a:	687b      	ldr	r3, [r7, #4]
 800748c:	681b      	ldr	r3, [r3, #0]
 800748e:	f022 0201 	bic.w	r2, r2, #1
 8007492:	601a      	str	r2, [r3, #0]

    /* Reset I2Cx ANOFF bit */
    hi2c->Instance->CR1 &= ~(I2C_CR1_ANFOFF);
 8007494:	687b      	ldr	r3, [r7, #4]
 8007496:	681b      	ldr	r3, [r3, #0]
 8007498:	681a      	ldr	r2, [r3, #0]
 800749a:	687b      	ldr	r3, [r7, #4]
 800749c:	681b      	ldr	r3, [r3, #0]
 800749e:	f422 5280 	bic.w	r2, r2, #4096	@ 0x1000
 80074a2:	601a      	str	r2, [r3, #0]

    /* Set analog filter bit*/
    hi2c->Instance->CR1 |= AnalogFilter;
 80074a4:	687b      	ldr	r3, [r7, #4]
 80074a6:	681b      	ldr	r3, [r3, #0]
 80074a8:	6819      	ldr	r1, [r3, #0]
 80074aa:	687b      	ldr	r3, [r7, #4]
 80074ac:	681b      	ldr	r3, [r3, #0]
 80074ae:	683a      	ldr	r2, [r7, #0]
 80074b0:	430a      	orrs	r2, r1
 80074b2:	601a      	str	r2, [r3, #0]

    __HAL_I2C_ENABLE(hi2c);
 80074b4:	687b      	ldr	r3, [r7, #4]
 80074b6:	681b      	ldr	r3, [r3, #0]
 80074b8:	681a      	ldr	r2, [r3, #0]
 80074ba:	687b      	ldr	r3, [r7, #4]
 80074bc:	681b      	ldr	r3, [r3, #0]
 80074be:	f042 0201 	orr.w	r2, r2, #1
 80074c2:	601a      	str	r2, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;
 80074c4:	687b      	ldr	r3, [r7, #4]
 80074c6:	2220      	movs	r2, #32
 80074c8:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 80074cc:	687b      	ldr	r3, [r7, #4]
 80074ce:	2200      	movs	r2, #0
 80074d0:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    return HAL_OK;
 80074d4:	2300      	movs	r3, #0
 80074d6:	e000      	b.n	80074da <HAL_I2CEx_ConfigAnalogFilter+0x8a>
  }
  else
  {
    return HAL_BUSY;
 80074d8:	2302      	movs	r3, #2
  }
}
 80074da:	4618      	mov	r0, r3
 80074dc:	370c      	adds	r7, #12
 80074de:	46bd      	mov	sp, r7
 80074e0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80074e4:	4770      	bx	lr

080074e6 <HAL_I2CEx_ConfigDigitalFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  DigitalFilter Coefficient of digital noise filter between Min_Data=0x00 and Max_Data=0x0F.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigDigitalFilter(I2C_HandleTypeDef *hi2c, uint32_t DigitalFilter)
{
 80074e6:	b480      	push	{r7}
 80074e8:	b085      	sub	sp, #20
 80074ea:	af00      	add	r7, sp, #0
 80074ec:	6078      	str	r0, [r7, #4]
 80074ee:	6039      	str	r1, [r7, #0]

  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_DIGITAL_FILTER(DigitalFilter));

  if (hi2c->State == HAL_I2C_STATE_READY)
 80074f0:	687b      	ldr	r3, [r7, #4]
 80074f2:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
 80074f6:	b2db      	uxtb	r3, r3
 80074f8:	2b20      	cmp	r3, #32
 80074fa:	d139      	bne.n	8007570 <HAL_I2CEx_ConfigDigitalFilter+0x8a>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
 80074fc:	687b      	ldr	r3, [r7, #4]
 80074fe:	f893 3040 	ldrb.w	r3, [r3, #64]	@ 0x40
 8007502:	2b01      	cmp	r3, #1
 8007504:	d101      	bne.n	800750a <HAL_I2CEx_ConfigDigitalFilter+0x24>
 8007506:	2302      	movs	r3, #2
 8007508:	e033      	b.n	8007572 <HAL_I2CEx_ConfigDigitalFilter+0x8c>
 800750a:	687b      	ldr	r3, [r7, #4]
 800750c:	2201      	movs	r2, #1
 800750e:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    hi2c->State = HAL_I2C_STATE_BUSY;
 8007512:	687b      	ldr	r3, [r7, #4]
 8007514:	2224      	movs	r2, #36	@ 0x24
 8007516:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
 800751a:	687b      	ldr	r3, [r7, #4]
 800751c:	681b      	ldr	r3, [r3, #0]
 800751e:	681a      	ldr	r2, [r3, #0]
 8007520:	687b      	ldr	r3, [r7, #4]
 8007522:	681b      	ldr	r3, [r3, #0]
 8007524:	f022 0201 	bic.w	r2, r2, #1
 8007528:	601a      	str	r2, [r3, #0]

    /* Get the old register value */
    tmpreg = hi2c->Instance->CR1;
 800752a:	687b      	ldr	r3, [r7, #4]
 800752c:	681b      	ldr	r3, [r3, #0]
 800752e:	681b      	ldr	r3, [r3, #0]
 8007530:	60fb      	str	r3, [r7, #12]

    /* Reset I2Cx DNF bits [11:8] */
    tmpreg &= ~(I2C_CR1_DNF);
 8007532:	68fb      	ldr	r3, [r7, #12]
 8007534:	f423 6370 	bic.w	r3, r3, #3840	@ 0xf00
 8007538:	60fb      	str	r3, [r7, #12]

    /* Set I2Cx DNF coefficient */
    tmpreg |= DigitalFilter << 8U;
 800753a:	683b      	ldr	r3, [r7, #0]
 800753c:	021b      	lsls	r3, r3, #8
 800753e:	68fa      	ldr	r2, [r7, #12]
 8007540:	4313      	orrs	r3, r2
 8007542:	60fb      	str	r3, [r7, #12]

    /* Store the new register value */
    hi2c->Instance->CR1 = tmpreg;
 8007544:	687b      	ldr	r3, [r7, #4]
 8007546:	681b      	ldr	r3, [r3, #0]
 8007548:	68fa      	ldr	r2, [r7, #12]
 800754a:	601a      	str	r2, [r3, #0]

    __HAL_I2C_ENABLE(hi2c);
 800754c:	687b      	ldr	r3, [r7, #4]
 800754e:	681b      	ldr	r3, [r3, #0]
 8007550:	681a      	ldr	r2, [r3, #0]
 8007552:	687b      	ldr	r3, [r7, #4]
 8007554:	681b      	ldr	r3, [r3, #0]
 8007556:	f042 0201 	orr.w	r2, r2, #1
 800755a:	601a      	str	r2, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;
 800755c:	687b      	ldr	r3, [r7, #4]
 800755e:	2220      	movs	r2, #32
 8007560:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 8007564:	687b      	ldr	r3, [r7, #4]
 8007566:	2200      	movs	r2, #0
 8007568:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    return HAL_OK;
 800756c:	2300      	movs	r3, #0
 800756e:	e000      	b.n	8007572 <HAL_I2CEx_ConfigDigitalFilter+0x8c>
  }
  else
  {
    return HAL_BUSY;
 8007570:	2302      	movs	r3, #2
  }
}
 8007572:	4618      	mov	r0, r3
 8007574:	3714      	adds	r7, #20
 8007576:	46bd      	mov	sp, r7
 8007578:	f85d 7b04 	ldr.w	r7, [sp], #4
 800757c:	4770      	bx	lr
	...

08007580 <HAL_OSPI_Init>:
  *         in the OSPI_InitTypeDef and initialize the associated handle.
  * @param  hospi : OSPI handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_OSPI_Init(OSPI_HandleTypeDef *hospi)
{
 8007580:	b580      	push	{r7, lr}
 8007582:	b086      	sub	sp, #24
 8007584:	af02      	add	r7, sp, #8
 8007586:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
 8007588:	2300      	movs	r3, #0
 800758a:	73fb      	strb	r3, [r7, #15]
  uint32_t tickstart = HAL_GetTick();
 800758c:	f7fb f9e8 	bl	8002960 <HAL_GetTick>
 8007590:	60b8      	str	r0, [r7, #8]

  /* Check the OSPI handle allocation */
  if (hospi == NULL)
 8007592:	687b      	ldr	r3, [r7, #4]
 8007594:	2b00      	cmp	r3, #0
 8007596:	d102      	bne.n	800759e <HAL_OSPI_Init+0x1e>
  {
    status = HAL_ERROR;
 8007598:	2301      	movs	r3, #1
 800759a:	73fb      	strb	r3, [r7, #15]
 800759c:	e0a5      	b.n	80076ea <HAL_OSPI_Init+0x16a>
    assert_param(IS_OSPI_CS_BOUNDARY(hospi->Init.ChipSelectBoundary));
    assert_param(IS_OSPI_DLYBYP(hospi->Init.DelayBlockBypass));
    assert_param(IS_OSPI_MAXTRAN(hospi->Init.MaxTran));

    /* Initialize error code */
    hospi->ErrorCode = HAL_OSPI_ERROR_NONE;
 800759e:	687b      	ldr	r3, [r7, #4]
 80075a0:	2200      	movs	r2, #0
 80075a2:	655a      	str	r2, [r3, #84]	@ 0x54

    /* Check if the state is the reset state */
    if (hospi->State == HAL_OSPI_STATE_RESET)
 80075a4:	687b      	ldr	r3, [r7, #4]
 80075a6:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 80075a8:	2b00      	cmp	r3, #0
 80075aa:	f040 809e 	bne.w	80076ea <HAL_OSPI_Init+0x16a>

      /* Init the low level hardware */
      hospi->MspInitCallback(hospi);
#else
      /* Initialization of the low level hardware */
      HAL_OSPI_MspInit(hospi);
 80075ae:	6878      	ldr	r0, [r7, #4]
 80075b0:	f7fa fd9a 	bl	80020e8 <HAL_OSPI_MspInit>
#endif /* defined (USE_HAL_OSPI_REGISTER_CALLBACKS) && (USE_HAL_OSPI_REGISTER_CALLBACKS == 1U) */

      /* Configure the default timeout for the OSPI memory access */
      (void)HAL_OSPI_SetTimeout(hospi, HAL_OSPI_TIMEOUT_DEFAULT_VALUE);
 80075b4:	f241 3188 	movw	r1, #5000	@ 0x1388
 80075b8:	6878      	ldr	r0, [r7, #4]
 80075ba:	f000 f89d 	bl	80076f8 <HAL_OSPI_SetTimeout>

      /* Configure memory type, device size, chip select high time, delay block bypass,
         free running clock, clock mode */
      MODIFY_REG(hospi->Instance->DCR1,
 80075be:	687b      	ldr	r3, [r7, #4]
 80075c0:	681b      	ldr	r3, [r3, #0]
 80075c2:	689a      	ldr	r2, [r3, #8]
 80075c4:	4b4b      	ldr	r3, [pc, #300]	@ (80076f4 <HAL_OSPI_Init+0x174>)
 80075c6:	4013      	ands	r3, r2
 80075c8:	687a      	ldr	r2, [r7, #4]
 80075ca:	68d1      	ldr	r1, [r2, #12]
 80075cc:	687a      	ldr	r2, [r7, #4]
 80075ce:	6912      	ldr	r2, [r2, #16]
 80075d0:	3a01      	subs	r2, #1
 80075d2:	0412      	lsls	r2, r2, #16
 80075d4:	4311      	orrs	r1, r2
 80075d6:	687a      	ldr	r2, [r7, #4]
 80075d8:	6952      	ldr	r2, [r2, #20]
 80075da:	3a01      	subs	r2, #1
 80075dc:	0212      	lsls	r2, r2, #8
 80075de:	4311      	orrs	r1, r2
 80075e0:	687a      	ldr	r2, [r7, #4]
 80075e2:	6b52      	ldr	r2, [r2, #52]	@ 0x34
 80075e4:	4311      	orrs	r1, r2
 80075e6:	687a      	ldr	r2, [r7, #4]
 80075e8:	69d2      	ldr	r2, [r2, #28]
 80075ea:	4311      	orrs	r1, r2
 80075ec:	687a      	ldr	r2, [r7, #4]
 80075ee:	6812      	ldr	r2, [r2, #0]
 80075f0:	430b      	orrs	r3, r1
 80075f2:	6093      	str	r3, [r2, #8]
                 (hospi->Init.MemoryType | ((hospi->Init.DeviceSize - 1U) << OCTOSPI_DCR1_DEVSIZE_Pos) |
                  ((hospi->Init.ChipSelectHighTime - 1U) << OCTOSPI_DCR1_CSHT_Pos) |
                  hospi->Init.DelayBlockBypass | hospi->Init.ClockMode));

      /* Configure wrap size */
      MODIFY_REG(hospi->Instance->DCR2, OCTOSPI_DCR2_WRAPSIZE, hospi->Init.WrapSize);
 80075f4:	687b      	ldr	r3, [r7, #4]
 80075f6:	681b      	ldr	r3, [r3, #0]
 80075f8:	68db      	ldr	r3, [r3, #12]
 80075fa:	f423 21e0 	bic.w	r1, r3, #458752	@ 0x70000
 80075fe:	687b      	ldr	r3, [r7, #4]
 8007600:	6a1a      	ldr	r2, [r3, #32]
 8007602:	687b      	ldr	r3, [r7, #4]
 8007604:	681b      	ldr	r3, [r3, #0]
 8007606:	430a      	orrs	r2, r1
 8007608:	60da      	str	r2, [r3, #12]

      /* Configure chip select boundary and maximum transfer */
      hospi->Instance->DCR3 = ((hospi->Init.ChipSelectBoundary << OCTOSPI_DCR3_CSBOUND_Pos) |
 800760a:	687b      	ldr	r3, [r7, #4]
 800760c:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800760e:	0419      	lsls	r1, r3, #16
                               (hospi->Init.MaxTran << OCTOSPI_DCR3_MAXTRAN_Pos));
 8007610:	687b      	ldr	r3, [r7, #4]
 8007612:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
      hospi->Instance->DCR3 = ((hospi->Init.ChipSelectBoundary << OCTOSPI_DCR3_CSBOUND_Pos) |
 8007614:	687b      	ldr	r3, [r7, #4]
 8007616:	681b      	ldr	r3, [r3, #0]
 8007618:	430a      	orrs	r2, r1
 800761a:	611a      	str	r2, [r3, #16]

      /* Configure refresh */
      hospi->Instance->DCR4 = hospi->Init.Refresh;
 800761c:	687b      	ldr	r3, [r7, #4]
 800761e:	681b      	ldr	r3, [r3, #0]
 8007620:	687a      	ldr	r2, [r7, #4]
 8007622:	6bd2      	ldr	r2, [r2, #60]	@ 0x3c
 8007624:	615a      	str	r2, [r3, #20]

      /* Configure FIFO threshold */
      MODIFY_REG(hospi->Instance->CR, OCTOSPI_CR_FTHRES, ((hospi->Init.FifoThreshold - 1U) << OCTOSPI_CR_FTHRES_Pos));
 8007626:	687b      	ldr	r3, [r7, #4]
 8007628:	681b      	ldr	r3, [r3, #0]
 800762a:	681b      	ldr	r3, [r3, #0]
 800762c:	f423 51f8 	bic.w	r1, r3, #7936	@ 0x1f00
 8007630:	687b      	ldr	r3, [r7, #4]
 8007632:	685b      	ldr	r3, [r3, #4]
 8007634:	3b01      	subs	r3, #1
 8007636:	021a      	lsls	r2, r3, #8
 8007638:	687b      	ldr	r3, [r7, #4]
 800763a:	681b      	ldr	r3, [r3, #0]
 800763c:	430a      	orrs	r2, r1
 800763e:	601a      	str	r2, [r3, #0]

      /* Wait till busy flag is reset */
      status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_BUSY, RESET, tickstart, hospi->Timeout);
 8007640:	687b      	ldr	r3, [r7, #4]
 8007642:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8007644:	9300      	str	r3, [sp, #0]
 8007646:	68bb      	ldr	r3, [r7, #8]
 8007648:	2200      	movs	r2, #0
 800764a:	2120      	movs	r1, #32
 800764c:	6878      	ldr	r0, [r7, #4]
 800764e:	f000 fd4b 	bl	80080e8 <OSPI_WaitFlagStateUntilTimeout>
 8007652:	4603      	mov	r3, r0
 8007654:	73fb      	strb	r3, [r7, #15]

      if (status == HAL_OK)
 8007656:	7bfb      	ldrb	r3, [r7, #15]
 8007658:	2b00      	cmp	r3, #0
 800765a:	d146      	bne.n	80076ea <HAL_OSPI_Init+0x16a>
      {
        /* Configure clock prescaler */
        MODIFY_REG(hospi->Instance->DCR2, OCTOSPI_DCR2_PRESCALER,
 800765c:	687b      	ldr	r3, [r7, #4]
 800765e:	681b      	ldr	r3, [r3, #0]
 8007660:	68db      	ldr	r3, [r3, #12]
 8007662:	f023 01ff 	bic.w	r1, r3, #255	@ 0xff
 8007666:	687b      	ldr	r3, [r7, #4]
 8007668:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800766a:	1e5a      	subs	r2, r3, #1
 800766c:	687b      	ldr	r3, [r7, #4]
 800766e:	681b      	ldr	r3, [r3, #0]
 8007670:	430a      	orrs	r2, r1
 8007672:	60da      	str	r2, [r3, #12]
                   ((hospi->Init.ClockPrescaler - 1U) << OCTOSPI_DCR2_PRESCALER_Pos));

        /* Configure Dual Quad mode */
        MODIFY_REG(hospi->Instance->CR, OCTOSPI_CR_DQM, hospi->Init.DualQuad);
 8007674:	687b      	ldr	r3, [r7, #4]
 8007676:	681b      	ldr	r3, [r3, #0]
 8007678:	681b      	ldr	r3, [r3, #0]
 800767a:	f023 0140 	bic.w	r1, r3, #64	@ 0x40
 800767e:	687b      	ldr	r3, [r7, #4]
 8007680:	689a      	ldr	r2, [r3, #8]
 8007682:	687b      	ldr	r3, [r7, #4]
 8007684:	681b      	ldr	r3, [r3, #0]
 8007686:	430a      	orrs	r2, r1
 8007688:	601a      	str	r2, [r3, #0]

        /* Configure sample shifting and delay hold quarter cycle */
        MODIFY_REG(hospi->Instance->TCR, (OCTOSPI_TCR_SSHIFT | OCTOSPI_TCR_DHQC),
 800768a:	687b      	ldr	r3, [r7, #4]
 800768c:	681b      	ldr	r3, [r3, #0]
 800768e:	f8d3 3108 	ldr.w	r3, [r3, #264]	@ 0x108
 8007692:	f023 41a0 	bic.w	r1, r3, #1342177280	@ 0x50000000
 8007696:	687b      	ldr	r3, [r7, #4]
 8007698:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 800769a:	687b      	ldr	r3, [r7, #4]
 800769c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800769e:	431a      	orrs	r2, r3
 80076a0:	687b      	ldr	r3, [r7, #4]
 80076a2:	681b      	ldr	r3, [r3, #0]
 80076a4:	430a      	orrs	r2, r1
 80076a6:	f8c3 2108 	str.w	r2, [r3, #264]	@ 0x108
                   (hospi->Init.SampleShifting | hospi->Init.DelayHoldQuarterCycle));

        /* Enable OctoSPI */
        __HAL_OSPI_ENABLE(hospi);
 80076aa:	687b      	ldr	r3, [r7, #4]
 80076ac:	681b      	ldr	r3, [r3, #0]
 80076ae:	681a      	ldr	r2, [r3, #0]
 80076b0:	687b      	ldr	r3, [r7, #4]
 80076b2:	681b      	ldr	r3, [r3, #0]
 80076b4:	f042 0201 	orr.w	r2, r2, #1
 80076b8:	601a      	str	r2, [r3, #0]

        /* Enable free running clock if needed : must be done after OSPI enable */
        if (hospi->Init.FreeRunningClock == HAL_OSPI_FREERUNCLK_ENABLE)
 80076ba:	687b      	ldr	r3, [r7, #4]
 80076bc:	699b      	ldr	r3, [r3, #24]
 80076be:	2b02      	cmp	r3, #2
 80076c0:	d107      	bne.n	80076d2 <HAL_OSPI_Init+0x152>
        {
          SET_BIT(hospi->Instance->DCR1, OCTOSPI_DCR1_FRCK);
 80076c2:	687b      	ldr	r3, [r7, #4]
 80076c4:	681b      	ldr	r3, [r3, #0]
 80076c6:	689a      	ldr	r2, [r3, #8]
 80076c8:	687b      	ldr	r3, [r7, #4]
 80076ca:	681b      	ldr	r3, [r3, #0]
 80076cc:	f042 0202 	orr.w	r2, r2, #2
 80076d0:	609a      	str	r2, [r3, #8]
        }

        /* Initialize the OSPI state */
        if (hospi->Init.MemoryType == HAL_OSPI_MEMTYPE_HYPERBUS)
 80076d2:	687b      	ldr	r3, [r7, #4]
 80076d4:	68db      	ldr	r3, [r3, #12]
 80076d6:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
 80076da:	d103      	bne.n	80076e4 <HAL_OSPI_Init+0x164>
        {
          hospi->State = HAL_OSPI_STATE_HYPERBUS_INIT;
 80076dc:	687b      	ldr	r3, [r7, #4]
 80076de:	2201      	movs	r2, #1
 80076e0:	651a      	str	r2, [r3, #80]	@ 0x50
 80076e2:	e002      	b.n	80076ea <HAL_OSPI_Init+0x16a>
        }
        else
        {
          hospi->State = HAL_OSPI_STATE_READY;
 80076e4:	687b      	ldr	r3, [r7, #4]
 80076e6:	2202      	movs	r2, #2
 80076e8:	651a      	str	r2, [r3, #80]	@ 0x50
      }
    }
  }

  /* Return function status */
  return status;
 80076ea:	7bfb      	ldrb	r3, [r7, #15]
}
 80076ec:	4618      	mov	r0, r3
 80076ee:	3710      	adds	r7, #16
 80076f0:	46bd      	mov	sp, r7
 80076f2:	bd80      	pop	{r7, pc}
 80076f4:	f8e0f8f4 	.word	0xf8e0f8f4

080076f8 <HAL_OSPI_SetTimeout>:
  * @param  hospi   : OSPI handle.
  * @param  Timeout : Timeout for the memory access.
  * @retval None
  */
HAL_StatusTypeDef HAL_OSPI_SetTimeout(OSPI_HandleTypeDef *hospi, uint32_t Timeout)
{
 80076f8:	b480      	push	{r7}
 80076fa:	b083      	sub	sp, #12
 80076fc:	af00      	add	r7, sp, #0
 80076fe:	6078      	str	r0, [r7, #4]
 8007700:	6039      	str	r1, [r7, #0]
  hospi->Timeout = Timeout;
 8007702:	687b      	ldr	r3, [r7, #4]
 8007704:	683a      	ldr	r2, [r7, #0]
 8007706:	659a      	str	r2, [r3, #88]	@ 0x58
  return HAL_OK;
 8007708:	2300      	movs	r3, #0
}
 800770a:	4618      	mov	r0, r3
 800770c:	370c      	adds	r7, #12
 800770e:	46bd      	mov	sp, r7
 8007710:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007714:	4770      	bx	lr
	...

08007718 <HAL_OSPIM_Config>:
  * @param  cfg     : Configuration of the IO Manager for the instance
  * @param  Timeout : Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_OSPIM_Config(OSPI_HandleTypeDef *hospi, OSPIM_CfgTypeDef *cfg, uint32_t Timeout)
{
 8007718:	b580      	push	{r7, lr}
 800771a:	b094      	sub	sp, #80	@ 0x50
 800771c:	af00      	add	r7, sp, #0
 800771e:	60f8      	str	r0, [r7, #12]
 8007720:	60b9      	str	r1, [r7, #8]
 8007722:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
 8007724:	2300      	movs	r3, #0
 8007726:	f887 304f 	strb.w	r3, [r7, #79]	@ 0x4f
  uint32_t instance;
  uint8_t index;
  uint8_t ospi_enabled = 0U;
 800772a:	2300      	movs	r3, #0
 800772c:	f887 3046 	strb.w	r3, [r7, #70]	@ 0x46
  assert_param(IS_OSPIM_PORT(cfg->NCSPort));
  assert_param(IS_OSPIM_IO_PORT(cfg->IOLowPort));
  assert_param(IS_OSPIM_IO_PORT(cfg->IOHighPort));
  assert_param(IS_OSPIM_REQ2ACKTIME(cfg->Req2AckTime));

  if (hospi->Instance == OCTOSPI1)
 8007730:	68fb      	ldr	r3, [r7, #12]
 8007732:	681b      	ldr	r3, [r3, #0]
 8007734:	4a9d      	ldr	r2, [pc, #628]	@ (80079ac <HAL_OSPIM_Config+0x294>)
 8007736:	4293      	cmp	r3, r2
 8007738:	d105      	bne.n	8007746 <HAL_OSPIM_Config+0x2e>
  {
    instance = 0U;
 800773a:	2300      	movs	r3, #0
 800773c:	64bb      	str	r3, [r7, #72]	@ 0x48
    other_instance = 1U;
 800773e:	2301      	movs	r3, #1
 8007740:	f887 3045 	strb.w	r3, [r7, #69]	@ 0x45
 8007744:	e004      	b.n	8007750 <HAL_OSPIM_Config+0x38>
  }
  else
  {
    instance = 1U;
 8007746:	2301      	movs	r3, #1
 8007748:	64bb      	str	r3, [r7, #72]	@ 0x48
    other_instance = 0U;
 800774a:	2300      	movs	r3, #0
 800774c:	f887 3045 	strb.w	r3, [r7, #69]	@ 0x45
  }

  /**************** Get current configuration of the instances ****************/
  for (index = 0U; index < OSPI_NB_INSTANCE; index++)
 8007750:	2300      	movs	r3, #0
 8007752:	f887 3047 	strb.w	r3, [r7, #71]	@ 0x47
 8007756:	e01d      	b.n	8007794 <HAL_OSPIM_Config+0x7c>
  {
    if (OSPIM_GetConfig(index + 1U, &(IOM_cfg[index])) != HAL_OK)
 8007758:	f897 3047 	ldrb.w	r3, [r7, #71]	@ 0x47
 800775c:	3301      	adds	r3, #1
 800775e:	b2d8      	uxtb	r0, r3
 8007760:	f897 2047 	ldrb.w	r2, [r7, #71]	@ 0x47
 8007764:	f107 0114 	add.w	r1, r7, #20
 8007768:	4613      	mov	r3, r2
 800776a:	005b      	lsls	r3, r3, #1
 800776c:	4413      	add	r3, r2
 800776e:	00db      	lsls	r3, r3, #3
 8007770:	440b      	add	r3, r1
 8007772:	4619      	mov	r1, r3
 8007774:	f000 fcf0 	bl	8008158 <OSPIM_GetConfig>
 8007778:	4603      	mov	r3, r0
 800777a:	2b00      	cmp	r3, #0
 800777c:	d005      	beq.n	800778a <HAL_OSPIM_Config+0x72>
    {
      status = HAL_ERROR;
 800777e:	2301      	movs	r3, #1
 8007780:	f887 304f 	strb.w	r3, [r7, #79]	@ 0x4f
      hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_PARAM;
 8007784:	68fb      	ldr	r3, [r7, #12]
 8007786:	2208      	movs	r2, #8
 8007788:	655a      	str	r2, [r3, #84]	@ 0x54
  for (index = 0U; index < OSPI_NB_INSTANCE; index++)
 800778a:	f897 3047 	ldrb.w	r3, [r7, #71]	@ 0x47
 800778e:	3301      	adds	r3, #1
 8007790:	f887 3047 	strb.w	r3, [r7, #71]	@ 0x47
 8007794:	f897 3047 	ldrb.w	r3, [r7, #71]	@ 0x47
 8007798:	2b01      	cmp	r3, #1
 800779a:	d9dd      	bls.n	8007758 <HAL_OSPIM_Config+0x40>
    }
  }

  if (status == HAL_OK)
 800779c:	f897 304f 	ldrb.w	r3, [r7, #79]	@ 0x4f
 80077a0:	2b00      	cmp	r3, #0
 80077a2:	f040 8495 	bne.w	80080d0 <HAL_OSPIM_Config+0x9b8>
  {
    /********** Disable both OctoSPI to configure OctoSPI IO Manager **********/
    if ((OCTOSPI1->CR & OCTOSPI_CR_EN) != 0U)
 80077a6:	4b81      	ldr	r3, [pc, #516]	@ (80079ac <HAL_OSPIM_Config+0x294>)
 80077a8:	681b      	ldr	r3, [r3, #0]
 80077aa:	f003 0301 	and.w	r3, r3, #1
 80077ae:	2b00      	cmp	r3, #0
 80077b0:	d00b      	beq.n	80077ca <HAL_OSPIM_Config+0xb2>
    {
      CLEAR_BIT(OCTOSPI1->CR, OCTOSPI_CR_EN);
 80077b2:	4b7e      	ldr	r3, [pc, #504]	@ (80079ac <HAL_OSPIM_Config+0x294>)
 80077b4:	681b      	ldr	r3, [r3, #0]
 80077b6:	4a7d      	ldr	r2, [pc, #500]	@ (80079ac <HAL_OSPIM_Config+0x294>)
 80077b8:	f023 0301 	bic.w	r3, r3, #1
 80077bc:	6013      	str	r3, [r2, #0]
      ospi_enabled |= 0x1U;
 80077be:	f897 3046 	ldrb.w	r3, [r7, #70]	@ 0x46
 80077c2:	f043 0301 	orr.w	r3, r3, #1
 80077c6:	f887 3046 	strb.w	r3, [r7, #70]	@ 0x46
    }
    if ((OCTOSPI2->CR & OCTOSPI_CR_EN) != 0U)
 80077ca:	4b79      	ldr	r3, [pc, #484]	@ (80079b0 <HAL_OSPIM_Config+0x298>)
 80077cc:	681b      	ldr	r3, [r3, #0]
 80077ce:	f003 0301 	and.w	r3, r3, #1
 80077d2:	2b00      	cmp	r3, #0
 80077d4:	d00b      	beq.n	80077ee <HAL_OSPIM_Config+0xd6>
    {
      CLEAR_BIT(OCTOSPI2->CR, OCTOSPI_CR_EN);
 80077d6:	4b76      	ldr	r3, [pc, #472]	@ (80079b0 <HAL_OSPIM_Config+0x298>)
 80077d8:	681b      	ldr	r3, [r3, #0]
 80077da:	4a75      	ldr	r2, [pc, #468]	@ (80079b0 <HAL_OSPIM_Config+0x298>)
 80077dc:	f023 0301 	bic.w	r3, r3, #1
 80077e0:	6013      	str	r3, [r2, #0]
      ospi_enabled |= 0x2U;
 80077e2:	f897 3046 	ldrb.w	r3, [r7, #70]	@ 0x46
 80077e6:	f043 0302 	orr.w	r3, r3, #2
 80077ea:	f887 3046 	strb.w	r3, [r7, #70]	@ 0x46
    }

    /***************** Deactivation of previous configuration *****************/
    CLEAR_BIT(OCTOSPIM->PCR[(IOM_cfg[instance].NCSPort - 1U)], OCTOSPIM_PCR_NCSEN);
 80077ee:	4971      	ldr	r1, [pc, #452]	@ (80079b4 <HAL_OSPIM_Config+0x29c>)
 80077f0:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 80077f2:	4613      	mov	r3, r2
 80077f4:	005b      	lsls	r3, r3, #1
 80077f6:	4413      	add	r3, r2
 80077f8:	00db      	lsls	r3, r3, #3
 80077fa:	3350      	adds	r3, #80	@ 0x50
 80077fc:	443b      	add	r3, r7
 80077fe:	3b34      	subs	r3, #52	@ 0x34
 8007800:	681b      	ldr	r3, [r3, #0]
 8007802:	3b01      	subs	r3, #1
 8007804:	009b      	lsls	r3, r3, #2
 8007806:	440b      	add	r3, r1
 8007808:	6859      	ldr	r1, [r3, #4]
 800780a:	486a      	ldr	r0, [pc, #424]	@ (80079b4 <HAL_OSPIM_Config+0x29c>)
 800780c:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 800780e:	4613      	mov	r3, r2
 8007810:	005b      	lsls	r3, r3, #1
 8007812:	4413      	add	r3, r2
 8007814:	00db      	lsls	r3, r3, #3
 8007816:	3350      	adds	r3, #80	@ 0x50
 8007818:	443b      	add	r3, r7
 800781a:	3b34      	subs	r3, #52	@ 0x34
 800781c:	681b      	ldr	r3, [r3, #0]
 800781e:	3b01      	subs	r3, #1
 8007820:	f421 7280 	bic.w	r2, r1, #256	@ 0x100
 8007824:	009b      	lsls	r3, r3, #2
 8007826:	4403      	add	r3, r0
 8007828:	605a      	str	r2, [r3, #4]
    if ((OCTOSPIM->CR & OCTOSPIM_CR_MUXEN) != 0U)
 800782a:	4b62      	ldr	r3, [pc, #392]	@ (80079b4 <HAL_OSPIM_Config+0x29c>)
 800782c:	681b      	ldr	r3, [r3, #0]
 800782e:	f003 0301 	and.w	r3, r3, #1
 8007832:	2b00      	cmp	r3, #0
 8007834:	f000 80c0 	beq.w	80079b8 <HAL_OSPIM_Config+0x2a0>
    {
      /* De-multiplexing should be performed */
      CLEAR_BIT(OCTOSPIM->CR, OCTOSPIM_CR_MUXEN);
 8007838:	4b5e      	ldr	r3, [pc, #376]	@ (80079b4 <HAL_OSPIM_Config+0x29c>)
 800783a:	681b      	ldr	r3, [r3, #0]
 800783c:	4a5d      	ldr	r2, [pc, #372]	@ (80079b4 <HAL_OSPIM_Config+0x29c>)
 800783e:	f023 0301 	bic.w	r3, r3, #1
 8007842:	6013      	str	r3, [r2, #0]

      if (other_instance == 1U)
 8007844:	f897 3045 	ldrb.w	r3, [r7, #69]	@ 0x45
 8007848:	2b01      	cmp	r3, #1
 800784a:	f040 8162 	bne.w	8007b12 <HAL_OSPIM_Config+0x3fa>
      {
        SET_BIT(OCTOSPIM->PCR[(IOM_cfg[other_instance].ClkPort - 1U)], OCTOSPIM_PCR_CLKSRC);
 800784e:	4959      	ldr	r1, [pc, #356]	@ (80079b4 <HAL_OSPIM_Config+0x29c>)
 8007850:	f897 2045 	ldrb.w	r2, [r7, #69]	@ 0x45
 8007854:	4613      	mov	r3, r2
 8007856:	005b      	lsls	r3, r3, #1
 8007858:	4413      	add	r3, r2
 800785a:	00db      	lsls	r3, r3, #3
 800785c:	3350      	adds	r3, #80	@ 0x50
 800785e:	443b      	add	r3, r7
 8007860:	3b3c      	subs	r3, #60	@ 0x3c
 8007862:	681b      	ldr	r3, [r3, #0]
 8007864:	3b01      	subs	r3, #1
 8007866:	009b      	lsls	r3, r3, #2
 8007868:	440b      	add	r3, r1
 800786a:	6859      	ldr	r1, [r3, #4]
 800786c:	4851      	ldr	r0, [pc, #324]	@ (80079b4 <HAL_OSPIM_Config+0x29c>)
 800786e:	f897 2045 	ldrb.w	r2, [r7, #69]	@ 0x45
 8007872:	4613      	mov	r3, r2
 8007874:	005b      	lsls	r3, r3, #1
 8007876:	4413      	add	r3, r2
 8007878:	00db      	lsls	r3, r3, #3
 800787a:	3350      	adds	r3, #80	@ 0x50
 800787c:	443b      	add	r3, r7
 800787e:	3b3c      	subs	r3, #60	@ 0x3c
 8007880:	681b      	ldr	r3, [r3, #0]
 8007882:	3b01      	subs	r3, #1
 8007884:	f041 0202 	orr.w	r2, r1, #2
 8007888:	009b      	lsls	r3, r3, #2
 800788a:	4403      	add	r3, r0
 800788c:	605a      	str	r2, [r3, #4]
        if (IOM_cfg[other_instance].DQSPort != 0U)
 800788e:	f897 2045 	ldrb.w	r2, [r7, #69]	@ 0x45
 8007892:	4613      	mov	r3, r2
 8007894:	005b      	lsls	r3, r3, #1
 8007896:	4413      	add	r3, r2
 8007898:	00db      	lsls	r3, r3, #3
 800789a:	3350      	adds	r3, #80	@ 0x50
 800789c:	443b      	add	r3, r7
 800789e:	3b38      	subs	r3, #56	@ 0x38
 80078a0:	681b      	ldr	r3, [r3, #0]
 80078a2:	2b00      	cmp	r3, #0
 80078a4:	d01f      	beq.n	80078e6 <HAL_OSPIM_Config+0x1ce>
        {
          SET_BIT(OCTOSPIM->PCR[(IOM_cfg[other_instance].DQSPort - 1U)], OCTOSPIM_PCR_DQSSRC);
 80078a6:	4943      	ldr	r1, [pc, #268]	@ (80079b4 <HAL_OSPIM_Config+0x29c>)
 80078a8:	f897 2045 	ldrb.w	r2, [r7, #69]	@ 0x45
 80078ac:	4613      	mov	r3, r2
 80078ae:	005b      	lsls	r3, r3, #1
 80078b0:	4413      	add	r3, r2
 80078b2:	00db      	lsls	r3, r3, #3
 80078b4:	3350      	adds	r3, #80	@ 0x50
 80078b6:	443b      	add	r3, r7
 80078b8:	3b38      	subs	r3, #56	@ 0x38
 80078ba:	681b      	ldr	r3, [r3, #0]
 80078bc:	3b01      	subs	r3, #1
 80078be:	009b      	lsls	r3, r3, #2
 80078c0:	440b      	add	r3, r1
 80078c2:	6859      	ldr	r1, [r3, #4]
 80078c4:	483b      	ldr	r0, [pc, #236]	@ (80079b4 <HAL_OSPIM_Config+0x29c>)
 80078c6:	f897 2045 	ldrb.w	r2, [r7, #69]	@ 0x45
 80078ca:	4613      	mov	r3, r2
 80078cc:	005b      	lsls	r3, r3, #1
 80078ce:	4413      	add	r3, r2
 80078d0:	00db      	lsls	r3, r3, #3
 80078d2:	3350      	adds	r3, #80	@ 0x50
 80078d4:	443b      	add	r3, r7
 80078d6:	3b38      	subs	r3, #56	@ 0x38
 80078d8:	681b      	ldr	r3, [r3, #0]
 80078da:	3b01      	subs	r3, #1
 80078dc:	f041 0220 	orr.w	r2, r1, #32
 80078e0:	009b      	lsls	r3, r3, #2
 80078e2:	4403      	add	r3, r0
 80078e4:	605a      	str	r2, [r3, #4]
        }
        if (IOM_cfg[other_instance].IOLowPort != HAL_OSPIM_IOPORT_NONE)
 80078e6:	f897 2045 	ldrb.w	r2, [r7, #69]	@ 0x45
 80078ea:	4613      	mov	r3, r2
 80078ec:	005b      	lsls	r3, r3, #1
 80078ee:	4413      	add	r3, r2
 80078f0:	00db      	lsls	r3, r3, #3
 80078f2:	3350      	adds	r3, #80	@ 0x50
 80078f4:	443b      	add	r3, r7
 80078f6:	3b30      	subs	r3, #48	@ 0x30
 80078f8:	681b      	ldr	r3, [r3, #0]
 80078fa:	2b00      	cmp	r3, #0
 80078fc:	d023      	beq.n	8007946 <HAL_OSPIM_Config+0x22e>
        {
          SET_BIT(OCTOSPIM->PCR[((IOM_cfg[other_instance].IOLowPort - 1U)& OSPI_IOM_PORT_MASK)], \
 80078fe:	492d      	ldr	r1, [pc, #180]	@ (80079b4 <HAL_OSPIM_Config+0x29c>)
 8007900:	f897 2045 	ldrb.w	r2, [r7, #69]	@ 0x45
 8007904:	4613      	mov	r3, r2
 8007906:	005b      	lsls	r3, r3, #1
 8007908:	4413      	add	r3, r2
 800790a:	00db      	lsls	r3, r3, #3
 800790c:	3350      	adds	r3, #80	@ 0x50
 800790e:	443b      	add	r3, r7
 8007910:	3b30      	subs	r3, #48	@ 0x30
 8007912:	681b      	ldr	r3, [r3, #0]
 8007914:	3b01      	subs	r3, #1
 8007916:	f003 0301 	and.w	r3, r3, #1
 800791a:	009b      	lsls	r3, r3, #2
 800791c:	440b      	add	r3, r1
 800791e:	6859      	ldr	r1, [r3, #4]
 8007920:	4824      	ldr	r0, [pc, #144]	@ (80079b4 <HAL_OSPIM_Config+0x29c>)
 8007922:	f897 2045 	ldrb.w	r2, [r7, #69]	@ 0x45
 8007926:	4613      	mov	r3, r2
 8007928:	005b      	lsls	r3, r3, #1
 800792a:	4413      	add	r3, r2
 800792c:	00db      	lsls	r3, r3, #3
 800792e:	3350      	adds	r3, #80	@ 0x50
 8007930:	443b      	add	r3, r7
 8007932:	3b30      	subs	r3, #48	@ 0x30
 8007934:	681b      	ldr	r3, [r3, #0]
 8007936:	3b01      	subs	r3, #1
 8007938:	f003 0301 	and.w	r3, r3, #1
 800793c:	f441 2280 	orr.w	r2, r1, #262144	@ 0x40000
 8007940:	009b      	lsls	r3, r3, #2
 8007942:	4403      	add	r3, r0
 8007944:	605a      	str	r2, [r3, #4]
                  OCTOSPIM_PCR_IOLSRC_1);
        }
        if (IOM_cfg[other_instance].IOHighPort != HAL_OSPIM_IOPORT_NONE)
 8007946:	f897 2045 	ldrb.w	r2, [r7, #69]	@ 0x45
 800794a:	4613      	mov	r3, r2
 800794c:	005b      	lsls	r3, r3, #1
 800794e:	4413      	add	r3, r2
 8007950:	00db      	lsls	r3, r3, #3
 8007952:	3350      	adds	r3, #80	@ 0x50
 8007954:	443b      	add	r3, r7
 8007956:	3b2c      	subs	r3, #44	@ 0x2c
 8007958:	681b      	ldr	r3, [r3, #0]
 800795a:	2b00      	cmp	r3, #0
 800795c:	f000 80d9 	beq.w	8007b12 <HAL_OSPIM_Config+0x3fa>
        {
          SET_BIT(OCTOSPIM->PCR[((IOM_cfg[other_instance].IOHighPort - 1U)& OSPI_IOM_PORT_MASK)], \
 8007960:	4914      	ldr	r1, [pc, #80]	@ (80079b4 <HAL_OSPIM_Config+0x29c>)
 8007962:	f897 2045 	ldrb.w	r2, [r7, #69]	@ 0x45
 8007966:	4613      	mov	r3, r2
 8007968:	005b      	lsls	r3, r3, #1
 800796a:	4413      	add	r3, r2
 800796c:	00db      	lsls	r3, r3, #3
 800796e:	3350      	adds	r3, #80	@ 0x50
 8007970:	443b      	add	r3, r7
 8007972:	3b2c      	subs	r3, #44	@ 0x2c
 8007974:	681b      	ldr	r3, [r3, #0]
 8007976:	3b01      	subs	r3, #1
 8007978:	f003 0301 	and.w	r3, r3, #1
 800797c:	009b      	lsls	r3, r3, #2
 800797e:	440b      	add	r3, r1
 8007980:	6859      	ldr	r1, [r3, #4]
 8007982:	480c      	ldr	r0, [pc, #48]	@ (80079b4 <HAL_OSPIM_Config+0x29c>)
 8007984:	f897 2045 	ldrb.w	r2, [r7, #69]	@ 0x45
 8007988:	4613      	mov	r3, r2
 800798a:	005b      	lsls	r3, r3, #1
 800798c:	4413      	add	r3, r2
 800798e:	00db      	lsls	r3, r3, #3
 8007990:	3350      	adds	r3, #80	@ 0x50
 8007992:	443b      	add	r3, r7
 8007994:	3b2c      	subs	r3, #44	@ 0x2c
 8007996:	681b      	ldr	r3, [r3, #0]
 8007998:	3b01      	subs	r3, #1
 800799a:	f003 0301 	and.w	r3, r3, #1
 800799e:	f041 6280 	orr.w	r2, r1, #67108864	@ 0x4000000
 80079a2:	009b      	lsls	r3, r3, #2
 80079a4:	4403      	add	r3, r0
 80079a6:	605a      	str	r2, [r3, #4]
 80079a8:	e0b3      	b.n	8007b12 <HAL_OSPIM_Config+0x3fa>
 80079aa:	bf00      	nop
 80079ac:	52005000 	.word	0x52005000
 80079b0:	5200a000 	.word	0x5200a000
 80079b4:	5200b400 	.word	0x5200b400
        }
      }
    }
    else
    {
      if (IOM_cfg[instance].ClkPort != 0U)
 80079b8:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 80079ba:	4613      	mov	r3, r2
 80079bc:	005b      	lsls	r3, r3, #1
 80079be:	4413      	add	r3, r2
 80079c0:	00db      	lsls	r3, r3, #3
 80079c2:	3350      	adds	r3, #80	@ 0x50
 80079c4:	443b      	add	r3, r7
 80079c6:	3b3c      	subs	r3, #60	@ 0x3c
 80079c8:	681b      	ldr	r3, [r3, #0]
 80079ca:	2b00      	cmp	r3, #0
 80079cc:	f000 80a1 	beq.w	8007b12 <HAL_OSPIM_Config+0x3fa>
      {
        CLEAR_BIT(OCTOSPIM->PCR[(IOM_cfg[instance].ClkPort - 1U)], OCTOSPIM_PCR_CLKEN);
 80079d0:	4993      	ldr	r1, [pc, #588]	@ (8007c20 <HAL_OSPIM_Config+0x508>)
 80079d2:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 80079d4:	4613      	mov	r3, r2
 80079d6:	005b      	lsls	r3, r3, #1
 80079d8:	4413      	add	r3, r2
 80079da:	00db      	lsls	r3, r3, #3
 80079dc:	3350      	adds	r3, #80	@ 0x50
 80079de:	443b      	add	r3, r7
 80079e0:	3b3c      	subs	r3, #60	@ 0x3c
 80079e2:	681b      	ldr	r3, [r3, #0]
 80079e4:	3b01      	subs	r3, #1
 80079e6:	009b      	lsls	r3, r3, #2
 80079e8:	440b      	add	r3, r1
 80079ea:	6859      	ldr	r1, [r3, #4]
 80079ec:	488c      	ldr	r0, [pc, #560]	@ (8007c20 <HAL_OSPIM_Config+0x508>)
 80079ee:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 80079f0:	4613      	mov	r3, r2
 80079f2:	005b      	lsls	r3, r3, #1
 80079f4:	4413      	add	r3, r2
 80079f6:	00db      	lsls	r3, r3, #3
 80079f8:	3350      	adds	r3, #80	@ 0x50
 80079fa:	443b      	add	r3, r7
 80079fc:	3b3c      	subs	r3, #60	@ 0x3c
 80079fe:	681b      	ldr	r3, [r3, #0]
 8007a00:	3b01      	subs	r3, #1
 8007a02:	f021 0201 	bic.w	r2, r1, #1
 8007a06:	009b      	lsls	r3, r3, #2
 8007a08:	4403      	add	r3, r0
 8007a0a:	605a      	str	r2, [r3, #4]
        if (IOM_cfg[instance].DQSPort != 0U)
 8007a0c:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8007a0e:	4613      	mov	r3, r2
 8007a10:	005b      	lsls	r3, r3, #1
 8007a12:	4413      	add	r3, r2
 8007a14:	00db      	lsls	r3, r3, #3
 8007a16:	3350      	adds	r3, #80	@ 0x50
 8007a18:	443b      	add	r3, r7
 8007a1a:	3b38      	subs	r3, #56	@ 0x38
 8007a1c:	681b      	ldr	r3, [r3, #0]
 8007a1e:	2b00      	cmp	r3, #0
 8007a20:	d01d      	beq.n	8007a5e <HAL_OSPIM_Config+0x346>
        {
          CLEAR_BIT(OCTOSPIM->PCR[(IOM_cfg[instance].DQSPort - 1U)], OCTOSPIM_PCR_DQSEN);
 8007a22:	497f      	ldr	r1, [pc, #508]	@ (8007c20 <HAL_OSPIM_Config+0x508>)
 8007a24:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8007a26:	4613      	mov	r3, r2
 8007a28:	005b      	lsls	r3, r3, #1
 8007a2a:	4413      	add	r3, r2
 8007a2c:	00db      	lsls	r3, r3, #3
 8007a2e:	3350      	adds	r3, #80	@ 0x50
 8007a30:	443b      	add	r3, r7
 8007a32:	3b38      	subs	r3, #56	@ 0x38
 8007a34:	681b      	ldr	r3, [r3, #0]
 8007a36:	3b01      	subs	r3, #1
 8007a38:	009b      	lsls	r3, r3, #2
 8007a3a:	440b      	add	r3, r1
 8007a3c:	6859      	ldr	r1, [r3, #4]
 8007a3e:	4878      	ldr	r0, [pc, #480]	@ (8007c20 <HAL_OSPIM_Config+0x508>)
 8007a40:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8007a42:	4613      	mov	r3, r2
 8007a44:	005b      	lsls	r3, r3, #1
 8007a46:	4413      	add	r3, r2
 8007a48:	00db      	lsls	r3, r3, #3
 8007a4a:	3350      	adds	r3, #80	@ 0x50
 8007a4c:	443b      	add	r3, r7
 8007a4e:	3b38      	subs	r3, #56	@ 0x38
 8007a50:	681b      	ldr	r3, [r3, #0]
 8007a52:	3b01      	subs	r3, #1
 8007a54:	f021 0210 	bic.w	r2, r1, #16
 8007a58:	009b      	lsls	r3, r3, #2
 8007a5a:	4403      	add	r3, r0
 8007a5c:	605a      	str	r2, [r3, #4]
        }
        if (IOM_cfg[instance].IOLowPort != HAL_OSPIM_IOPORT_NONE)
 8007a5e:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8007a60:	4613      	mov	r3, r2
 8007a62:	005b      	lsls	r3, r3, #1
 8007a64:	4413      	add	r3, r2
 8007a66:	00db      	lsls	r3, r3, #3
 8007a68:	3350      	adds	r3, #80	@ 0x50
 8007a6a:	443b      	add	r3, r7
 8007a6c:	3b30      	subs	r3, #48	@ 0x30
 8007a6e:	681b      	ldr	r3, [r3, #0]
 8007a70:	2b00      	cmp	r3, #0
 8007a72:	d021      	beq.n	8007ab8 <HAL_OSPIM_Config+0x3a0>
        {
          CLEAR_BIT(OCTOSPIM->PCR[((IOM_cfg[instance].IOLowPort - 1U)& OSPI_IOM_PORT_MASK)], OCTOSPIM_PCR_IOLEN);
 8007a74:	496a      	ldr	r1, [pc, #424]	@ (8007c20 <HAL_OSPIM_Config+0x508>)
 8007a76:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8007a78:	4613      	mov	r3, r2
 8007a7a:	005b      	lsls	r3, r3, #1
 8007a7c:	4413      	add	r3, r2
 8007a7e:	00db      	lsls	r3, r3, #3
 8007a80:	3350      	adds	r3, #80	@ 0x50
 8007a82:	443b      	add	r3, r7
 8007a84:	3b30      	subs	r3, #48	@ 0x30
 8007a86:	681b      	ldr	r3, [r3, #0]
 8007a88:	3b01      	subs	r3, #1
 8007a8a:	f003 0301 	and.w	r3, r3, #1
 8007a8e:	009b      	lsls	r3, r3, #2
 8007a90:	440b      	add	r3, r1
 8007a92:	6859      	ldr	r1, [r3, #4]
 8007a94:	4862      	ldr	r0, [pc, #392]	@ (8007c20 <HAL_OSPIM_Config+0x508>)
 8007a96:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8007a98:	4613      	mov	r3, r2
 8007a9a:	005b      	lsls	r3, r3, #1
 8007a9c:	4413      	add	r3, r2
 8007a9e:	00db      	lsls	r3, r3, #3
 8007aa0:	3350      	adds	r3, #80	@ 0x50
 8007aa2:	443b      	add	r3, r7
 8007aa4:	3b30      	subs	r3, #48	@ 0x30
 8007aa6:	681b      	ldr	r3, [r3, #0]
 8007aa8:	3b01      	subs	r3, #1
 8007aaa:	f003 0301 	and.w	r3, r3, #1
 8007aae:	f421 3280 	bic.w	r2, r1, #65536	@ 0x10000
 8007ab2:	009b      	lsls	r3, r3, #2
 8007ab4:	4403      	add	r3, r0
 8007ab6:	605a      	str	r2, [r3, #4]
        }
        if (IOM_cfg[instance].IOHighPort != HAL_OSPIM_IOPORT_NONE)
 8007ab8:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8007aba:	4613      	mov	r3, r2
 8007abc:	005b      	lsls	r3, r3, #1
 8007abe:	4413      	add	r3, r2
 8007ac0:	00db      	lsls	r3, r3, #3
 8007ac2:	3350      	adds	r3, #80	@ 0x50
 8007ac4:	443b      	add	r3, r7
 8007ac6:	3b2c      	subs	r3, #44	@ 0x2c
 8007ac8:	681b      	ldr	r3, [r3, #0]
 8007aca:	2b00      	cmp	r3, #0
 8007acc:	d021      	beq.n	8007b12 <HAL_OSPIM_Config+0x3fa>
        {
          CLEAR_BIT(OCTOSPIM->PCR[((IOM_cfg[instance].IOHighPort - 1U)& OSPI_IOM_PORT_MASK)], OCTOSPIM_PCR_IOHEN);
 8007ace:	4954      	ldr	r1, [pc, #336]	@ (8007c20 <HAL_OSPIM_Config+0x508>)
 8007ad0:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8007ad2:	4613      	mov	r3, r2
 8007ad4:	005b      	lsls	r3, r3, #1
 8007ad6:	4413      	add	r3, r2
 8007ad8:	00db      	lsls	r3, r3, #3
 8007ada:	3350      	adds	r3, #80	@ 0x50
 8007adc:	443b      	add	r3, r7
 8007ade:	3b2c      	subs	r3, #44	@ 0x2c
 8007ae0:	681b      	ldr	r3, [r3, #0]
 8007ae2:	3b01      	subs	r3, #1
 8007ae4:	f003 0301 	and.w	r3, r3, #1
 8007ae8:	009b      	lsls	r3, r3, #2
 8007aea:	440b      	add	r3, r1
 8007aec:	6859      	ldr	r1, [r3, #4]
 8007aee:	484c      	ldr	r0, [pc, #304]	@ (8007c20 <HAL_OSPIM_Config+0x508>)
 8007af0:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8007af2:	4613      	mov	r3, r2
 8007af4:	005b      	lsls	r3, r3, #1
 8007af6:	4413      	add	r3, r2
 8007af8:	00db      	lsls	r3, r3, #3
 8007afa:	3350      	adds	r3, #80	@ 0x50
 8007afc:	443b      	add	r3, r7
 8007afe:	3b2c      	subs	r3, #44	@ 0x2c
 8007b00:	681b      	ldr	r3, [r3, #0]
 8007b02:	3b01      	subs	r3, #1
 8007b04:	f003 0301 	and.w	r3, r3, #1
 8007b08:	f021 7280 	bic.w	r2, r1, #16777216	@ 0x1000000
 8007b0c:	009b      	lsls	r3, r3, #2
 8007b0e:	4403      	add	r3, r0
 8007b10:	605a      	str	r2, [r3, #4]
        }
      }
    }

    /********************* Deactivation of other instance *********************/
    if ((cfg->ClkPort == IOM_cfg[other_instance].ClkPort) || (cfg->DQSPort == IOM_cfg[other_instance].DQSPort)     ||
 8007b12:	68bb      	ldr	r3, [r7, #8]
 8007b14:	6819      	ldr	r1, [r3, #0]
 8007b16:	f897 2045 	ldrb.w	r2, [r7, #69]	@ 0x45
 8007b1a:	4613      	mov	r3, r2
 8007b1c:	005b      	lsls	r3, r3, #1
 8007b1e:	4413      	add	r3, r2
 8007b20:	00db      	lsls	r3, r3, #3
 8007b22:	3350      	adds	r3, #80	@ 0x50
 8007b24:	443b      	add	r3, r7
 8007b26:	3b3c      	subs	r3, #60	@ 0x3c
 8007b28:	681b      	ldr	r3, [r3, #0]
 8007b2a:	4299      	cmp	r1, r3
 8007b2c:	d038      	beq.n	8007ba0 <HAL_OSPIM_Config+0x488>
 8007b2e:	68bb      	ldr	r3, [r7, #8]
 8007b30:	6859      	ldr	r1, [r3, #4]
 8007b32:	f897 2045 	ldrb.w	r2, [r7, #69]	@ 0x45
 8007b36:	4613      	mov	r3, r2
 8007b38:	005b      	lsls	r3, r3, #1
 8007b3a:	4413      	add	r3, r2
 8007b3c:	00db      	lsls	r3, r3, #3
 8007b3e:	3350      	adds	r3, #80	@ 0x50
 8007b40:	443b      	add	r3, r7
 8007b42:	3b38      	subs	r3, #56	@ 0x38
 8007b44:	681b      	ldr	r3, [r3, #0]
 8007b46:	4299      	cmp	r1, r3
 8007b48:	d02a      	beq.n	8007ba0 <HAL_OSPIM_Config+0x488>
        (cfg->NCSPort == IOM_cfg[other_instance].NCSPort) || (cfg->IOLowPort == IOM_cfg[other_instance].IOLowPort) ||
 8007b4a:	68bb      	ldr	r3, [r7, #8]
 8007b4c:	6899      	ldr	r1, [r3, #8]
 8007b4e:	f897 2045 	ldrb.w	r2, [r7, #69]	@ 0x45
 8007b52:	4613      	mov	r3, r2
 8007b54:	005b      	lsls	r3, r3, #1
 8007b56:	4413      	add	r3, r2
 8007b58:	00db      	lsls	r3, r3, #3
 8007b5a:	3350      	adds	r3, #80	@ 0x50
 8007b5c:	443b      	add	r3, r7
 8007b5e:	3b34      	subs	r3, #52	@ 0x34
 8007b60:	681b      	ldr	r3, [r3, #0]
    if ((cfg->ClkPort == IOM_cfg[other_instance].ClkPort) || (cfg->DQSPort == IOM_cfg[other_instance].DQSPort)     ||
 8007b62:	4299      	cmp	r1, r3
 8007b64:	d01c      	beq.n	8007ba0 <HAL_OSPIM_Config+0x488>
        (cfg->NCSPort == IOM_cfg[other_instance].NCSPort) || (cfg->IOLowPort == IOM_cfg[other_instance].IOLowPort) ||
 8007b66:	68bb      	ldr	r3, [r7, #8]
 8007b68:	68d9      	ldr	r1, [r3, #12]
 8007b6a:	f897 2045 	ldrb.w	r2, [r7, #69]	@ 0x45
 8007b6e:	4613      	mov	r3, r2
 8007b70:	005b      	lsls	r3, r3, #1
 8007b72:	4413      	add	r3, r2
 8007b74:	00db      	lsls	r3, r3, #3
 8007b76:	3350      	adds	r3, #80	@ 0x50
 8007b78:	443b      	add	r3, r7
 8007b7a:	3b30      	subs	r3, #48	@ 0x30
 8007b7c:	681b      	ldr	r3, [r3, #0]
 8007b7e:	4299      	cmp	r1, r3
 8007b80:	d00e      	beq.n	8007ba0 <HAL_OSPIM_Config+0x488>
        (cfg->IOHighPort == IOM_cfg[other_instance].IOHighPort))
 8007b82:	68bb      	ldr	r3, [r7, #8]
 8007b84:	6919      	ldr	r1, [r3, #16]
 8007b86:	f897 2045 	ldrb.w	r2, [r7, #69]	@ 0x45
 8007b8a:	4613      	mov	r3, r2
 8007b8c:	005b      	lsls	r3, r3, #1
 8007b8e:	4413      	add	r3, r2
 8007b90:	00db      	lsls	r3, r3, #3
 8007b92:	3350      	adds	r3, #80	@ 0x50
 8007b94:	443b      	add	r3, r7
 8007b96:	3b2c      	subs	r3, #44	@ 0x2c
 8007b98:	681b      	ldr	r3, [r3, #0]
        (cfg->NCSPort == IOM_cfg[other_instance].NCSPort) || (cfg->IOLowPort == IOM_cfg[other_instance].IOLowPort) ||
 8007b9a:	4299      	cmp	r1, r3
 8007b9c:	f040 810e 	bne.w	8007dbc <HAL_OSPIM_Config+0x6a4>
    {
      if ((cfg->ClkPort   == IOM_cfg[other_instance].ClkPort)   &&
 8007ba0:	68bb      	ldr	r3, [r7, #8]
 8007ba2:	6819      	ldr	r1, [r3, #0]
 8007ba4:	f897 2045 	ldrb.w	r2, [r7, #69]	@ 0x45
 8007ba8:	4613      	mov	r3, r2
 8007baa:	005b      	lsls	r3, r3, #1
 8007bac:	4413      	add	r3, r2
 8007bae:	00db      	lsls	r3, r3, #3
 8007bb0:	3350      	adds	r3, #80	@ 0x50
 8007bb2:	443b      	add	r3, r7
 8007bb4:	3b3c      	subs	r3, #60	@ 0x3c
 8007bb6:	681b      	ldr	r3, [r3, #0]
 8007bb8:	4299      	cmp	r1, r3
 8007bba:	d133      	bne.n	8007c24 <HAL_OSPIM_Config+0x50c>
          (cfg->DQSPort    == IOM_cfg[other_instance].DQSPort)  &&
 8007bbc:	68bb      	ldr	r3, [r7, #8]
 8007bbe:	6859      	ldr	r1, [r3, #4]
 8007bc0:	f897 2045 	ldrb.w	r2, [r7, #69]	@ 0x45
 8007bc4:	4613      	mov	r3, r2
 8007bc6:	005b      	lsls	r3, r3, #1
 8007bc8:	4413      	add	r3, r2
 8007bca:	00db      	lsls	r3, r3, #3
 8007bcc:	3350      	adds	r3, #80	@ 0x50
 8007bce:	443b      	add	r3, r7
 8007bd0:	3b38      	subs	r3, #56	@ 0x38
 8007bd2:	681b      	ldr	r3, [r3, #0]
      if ((cfg->ClkPort   == IOM_cfg[other_instance].ClkPort)   &&
 8007bd4:	4299      	cmp	r1, r3
 8007bd6:	d125      	bne.n	8007c24 <HAL_OSPIM_Config+0x50c>
          (cfg->IOLowPort == IOM_cfg[other_instance].IOLowPort) &&
 8007bd8:	68bb      	ldr	r3, [r7, #8]
 8007bda:	68d9      	ldr	r1, [r3, #12]
 8007bdc:	f897 2045 	ldrb.w	r2, [r7, #69]	@ 0x45
 8007be0:	4613      	mov	r3, r2
 8007be2:	005b      	lsls	r3, r3, #1
 8007be4:	4413      	add	r3, r2
 8007be6:	00db      	lsls	r3, r3, #3
 8007be8:	3350      	adds	r3, #80	@ 0x50
 8007bea:	443b      	add	r3, r7
 8007bec:	3b30      	subs	r3, #48	@ 0x30
 8007bee:	681b      	ldr	r3, [r3, #0]
          (cfg->DQSPort    == IOM_cfg[other_instance].DQSPort)  &&
 8007bf0:	4299      	cmp	r1, r3
 8007bf2:	d117      	bne.n	8007c24 <HAL_OSPIM_Config+0x50c>
          (cfg->IOHighPort == IOM_cfg[other_instance].IOHighPort))
 8007bf4:	68bb      	ldr	r3, [r7, #8]
 8007bf6:	6919      	ldr	r1, [r3, #16]
 8007bf8:	f897 2045 	ldrb.w	r2, [r7, #69]	@ 0x45
 8007bfc:	4613      	mov	r3, r2
 8007bfe:	005b      	lsls	r3, r3, #1
 8007c00:	4413      	add	r3, r2
 8007c02:	00db      	lsls	r3, r3, #3
 8007c04:	3350      	adds	r3, #80	@ 0x50
 8007c06:	443b      	add	r3, r7
 8007c08:	3b2c      	subs	r3, #44	@ 0x2c
 8007c0a:	681b      	ldr	r3, [r3, #0]
          (cfg->IOLowPort == IOM_cfg[other_instance].IOLowPort) &&
 8007c0c:	4299      	cmp	r1, r3
 8007c0e:	d109      	bne.n	8007c24 <HAL_OSPIM_Config+0x50c>
      {
        /* Multiplexing should be performed */
        SET_BIT(OCTOSPIM->CR, OCTOSPIM_CR_MUXEN);
 8007c10:	4b03      	ldr	r3, [pc, #12]	@ (8007c20 <HAL_OSPIM_Config+0x508>)
 8007c12:	681b      	ldr	r3, [r3, #0]
 8007c14:	4a02      	ldr	r2, [pc, #8]	@ (8007c20 <HAL_OSPIM_Config+0x508>)
 8007c16:	f043 0301 	orr.w	r3, r3, #1
 8007c1a:	6013      	str	r3, [r2, #0]
 8007c1c:	e0ce      	b.n	8007dbc <HAL_OSPIM_Config+0x6a4>
 8007c1e:	bf00      	nop
 8007c20:	5200b400 	.word	0x5200b400
      }
      else
      {
        CLEAR_BIT(OCTOSPIM->PCR[(IOM_cfg[other_instance].ClkPort - 1U)], OCTOSPIM_PCR_CLKEN);
 8007c24:	49bb      	ldr	r1, [pc, #748]	@ (8007f14 <HAL_OSPIM_Config+0x7fc>)
 8007c26:	f897 2045 	ldrb.w	r2, [r7, #69]	@ 0x45
 8007c2a:	4613      	mov	r3, r2
 8007c2c:	005b      	lsls	r3, r3, #1
 8007c2e:	4413      	add	r3, r2
 8007c30:	00db      	lsls	r3, r3, #3
 8007c32:	3350      	adds	r3, #80	@ 0x50
 8007c34:	443b      	add	r3, r7
 8007c36:	3b3c      	subs	r3, #60	@ 0x3c
 8007c38:	681b      	ldr	r3, [r3, #0]
 8007c3a:	3b01      	subs	r3, #1
 8007c3c:	009b      	lsls	r3, r3, #2
 8007c3e:	440b      	add	r3, r1
 8007c40:	6859      	ldr	r1, [r3, #4]
 8007c42:	48b4      	ldr	r0, [pc, #720]	@ (8007f14 <HAL_OSPIM_Config+0x7fc>)
 8007c44:	f897 2045 	ldrb.w	r2, [r7, #69]	@ 0x45
 8007c48:	4613      	mov	r3, r2
 8007c4a:	005b      	lsls	r3, r3, #1
 8007c4c:	4413      	add	r3, r2
 8007c4e:	00db      	lsls	r3, r3, #3
 8007c50:	3350      	adds	r3, #80	@ 0x50
 8007c52:	443b      	add	r3, r7
 8007c54:	3b3c      	subs	r3, #60	@ 0x3c
 8007c56:	681b      	ldr	r3, [r3, #0]
 8007c58:	3b01      	subs	r3, #1
 8007c5a:	f021 0201 	bic.w	r2, r1, #1
 8007c5e:	009b      	lsls	r3, r3, #2
 8007c60:	4403      	add	r3, r0
 8007c62:	605a      	str	r2, [r3, #4]
        if (IOM_cfg[other_instance].DQSPort != 0U)
 8007c64:	f897 2045 	ldrb.w	r2, [r7, #69]	@ 0x45
 8007c68:	4613      	mov	r3, r2
 8007c6a:	005b      	lsls	r3, r3, #1
 8007c6c:	4413      	add	r3, r2
 8007c6e:	00db      	lsls	r3, r3, #3
 8007c70:	3350      	adds	r3, #80	@ 0x50
 8007c72:	443b      	add	r3, r7
 8007c74:	3b38      	subs	r3, #56	@ 0x38
 8007c76:	681b      	ldr	r3, [r3, #0]
 8007c78:	2b00      	cmp	r3, #0
 8007c7a:	d01f      	beq.n	8007cbc <HAL_OSPIM_Config+0x5a4>
        {
          CLEAR_BIT(OCTOSPIM->PCR[(IOM_cfg[other_instance].DQSPort - 1U)], OCTOSPIM_PCR_DQSEN);
 8007c7c:	49a5      	ldr	r1, [pc, #660]	@ (8007f14 <HAL_OSPIM_Config+0x7fc>)
 8007c7e:	f897 2045 	ldrb.w	r2, [r7, #69]	@ 0x45
 8007c82:	4613      	mov	r3, r2
 8007c84:	005b      	lsls	r3, r3, #1
 8007c86:	4413      	add	r3, r2
 8007c88:	00db      	lsls	r3, r3, #3
 8007c8a:	3350      	adds	r3, #80	@ 0x50
 8007c8c:	443b      	add	r3, r7
 8007c8e:	3b38      	subs	r3, #56	@ 0x38
 8007c90:	681b      	ldr	r3, [r3, #0]
 8007c92:	3b01      	subs	r3, #1
 8007c94:	009b      	lsls	r3, r3, #2
 8007c96:	440b      	add	r3, r1
 8007c98:	6859      	ldr	r1, [r3, #4]
 8007c9a:	489e      	ldr	r0, [pc, #632]	@ (8007f14 <HAL_OSPIM_Config+0x7fc>)
 8007c9c:	f897 2045 	ldrb.w	r2, [r7, #69]	@ 0x45
 8007ca0:	4613      	mov	r3, r2
 8007ca2:	005b      	lsls	r3, r3, #1
 8007ca4:	4413      	add	r3, r2
 8007ca6:	00db      	lsls	r3, r3, #3
 8007ca8:	3350      	adds	r3, #80	@ 0x50
 8007caa:	443b      	add	r3, r7
 8007cac:	3b38      	subs	r3, #56	@ 0x38
 8007cae:	681b      	ldr	r3, [r3, #0]
 8007cb0:	3b01      	subs	r3, #1
 8007cb2:	f021 0210 	bic.w	r2, r1, #16
 8007cb6:	009b      	lsls	r3, r3, #2
 8007cb8:	4403      	add	r3, r0
 8007cba:	605a      	str	r2, [r3, #4]
        }
        CLEAR_BIT(OCTOSPIM->PCR[(IOM_cfg[other_instance].NCSPort - 1U)], OCTOSPIM_PCR_NCSEN);
 8007cbc:	4995      	ldr	r1, [pc, #596]	@ (8007f14 <HAL_OSPIM_Config+0x7fc>)
 8007cbe:	f897 2045 	ldrb.w	r2, [r7, #69]	@ 0x45
 8007cc2:	4613      	mov	r3, r2
 8007cc4:	005b      	lsls	r3, r3, #1
 8007cc6:	4413      	add	r3, r2
 8007cc8:	00db      	lsls	r3, r3, #3
 8007cca:	3350      	adds	r3, #80	@ 0x50
 8007ccc:	443b      	add	r3, r7
 8007cce:	3b34      	subs	r3, #52	@ 0x34
 8007cd0:	681b      	ldr	r3, [r3, #0]
 8007cd2:	3b01      	subs	r3, #1
 8007cd4:	009b      	lsls	r3, r3, #2
 8007cd6:	440b      	add	r3, r1
 8007cd8:	6859      	ldr	r1, [r3, #4]
 8007cda:	488e      	ldr	r0, [pc, #568]	@ (8007f14 <HAL_OSPIM_Config+0x7fc>)
 8007cdc:	f897 2045 	ldrb.w	r2, [r7, #69]	@ 0x45
 8007ce0:	4613      	mov	r3, r2
 8007ce2:	005b      	lsls	r3, r3, #1
 8007ce4:	4413      	add	r3, r2
 8007ce6:	00db      	lsls	r3, r3, #3
 8007ce8:	3350      	adds	r3, #80	@ 0x50
 8007cea:	443b      	add	r3, r7
 8007cec:	3b34      	subs	r3, #52	@ 0x34
 8007cee:	681b      	ldr	r3, [r3, #0]
 8007cf0:	3b01      	subs	r3, #1
 8007cf2:	f421 7280 	bic.w	r2, r1, #256	@ 0x100
 8007cf6:	009b      	lsls	r3, r3, #2
 8007cf8:	4403      	add	r3, r0
 8007cfa:	605a      	str	r2, [r3, #4]
        if (IOM_cfg[other_instance].IOLowPort != HAL_OSPIM_IOPORT_NONE)
 8007cfc:	f897 2045 	ldrb.w	r2, [r7, #69]	@ 0x45
 8007d00:	4613      	mov	r3, r2
 8007d02:	005b      	lsls	r3, r3, #1
 8007d04:	4413      	add	r3, r2
 8007d06:	00db      	lsls	r3, r3, #3
 8007d08:	3350      	adds	r3, #80	@ 0x50
 8007d0a:	443b      	add	r3, r7
 8007d0c:	3b30      	subs	r3, #48	@ 0x30
 8007d0e:	681b      	ldr	r3, [r3, #0]
 8007d10:	2b00      	cmp	r3, #0
 8007d12:	d023      	beq.n	8007d5c <HAL_OSPIM_Config+0x644>
        {
          CLEAR_BIT(OCTOSPIM->PCR[((IOM_cfg[other_instance].IOLowPort - 1U)& OSPI_IOM_PORT_MASK)],
 8007d14:	497f      	ldr	r1, [pc, #508]	@ (8007f14 <HAL_OSPIM_Config+0x7fc>)
 8007d16:	f897 2045 	ldrb.w	r2, [r7, #69]	@ 0x45
 8007d1a:	4613      	mov	r3, r2
 8007d1c:	005b      	lsls	r3, r3, #1
 8007d1e:	4413      	add	r3, r2
 8007d20:	00db      	lsls	r3, r3, #3
 8007d22:	3350      	adds	r3, #80	@ 0x50
 8007d24:	443b      	add	r3, r7
 8007d26:	3b30      	subs	r3, #48	@ 0x30
 8007d28:	681b      	ldr	r3, [r3, #0]
 8007d2a:	3b01      	subs	r3, #1
 8007d2c:	f003 0301 	and.w	r3, r3, #1
 8007d30:	009b      	lsls	r3, r3, #2
 8007d32:	440b      	add	r3, r1
 8007d34:	6859      	ldr	r1, [r3, #4]
 8007d36:	4877      	ldr	r0, [pc, #476]	@ (8007f14 <HAL_OSPIM_Config+0x7fc>)
 8007d38:	f897 2045 	ldrb.w	r2, [r7, #69]	@ 0x45
 8007d3c:	4613      	mov	r3, r2
 8007d3e:	005b      	lsls	r3, r3, #1
 8007d40:	4413      	add	r3, r2
 8007d42:	00db      	lsls	r3, r3, #3
 8007d44:	3350      	adds	r3, #80	@ 0x50
 8007d46:	443b      	add	r3, r7
 8007d48:	3b30      	subs	r3, #48	@ 0x30
 8007d4a:	681b      	ldr	r3, [r3, #0]
 8007d4c:	3b01      	subs	r3, #1
 8007d4e:	f003 0301 	and.w	r3, r3, #1
 8007d52:	f421 3280 	bic.w	r2, r1, #65536	@ 0x10000
 8007d56:	009b      	lsls	r3, r3, #2
 8007d58:	4403      	add	r3, r0
 8007d5a:	605a      	str	r2, [r3, #4]
                    OCTOSPIM_PCR_IOLEN);
        }
        if (IOM_cfg[other_instance].IOHighPort != HAL_OSPIM_IOPORT_NONE)
 8007d5c:	f897 2045 	ldrb.w	r2, [r7, #69]	@ 0x45
 8007d60:	4613      	mov	r3, r2
 8007d62:	005b      	lsls	r3, r3, #1
 8007d64:	4413      	add	r3, r2
 8007d66:	00db      	lsls	r3, r3, #3
 8007d68:	3350      	adds	r3, #80	@ 0x50
 8007d6a:	443b      	add	r3, r7
 8007d6c:	3b2c      	subs	r3, #44	@ 0x2c
 8007d6e:	681b      	ldr	r3, [r3, #0]
 8007d70:	2b00      	cmp	r3, #0
 8007d72:	d023      	beq.n	8007dbc <HAL_OSPIM_Config+0x6a4>
        {
          CLEAR_BIT(OCTOSPIM->PCR[((IOM_cfg[other_instance].IOHighPort - 1U)& OSPI_IOM_PORT_MASK)],
 8007d74:	4967      	ldr	r1, [pc, #412]	@ (8007f14 <HAL_OSPIM_Config+0x7fc>)
 8007d76:	f897 2045 	ldrb.w	r2, [r7, #69]	@ 0x45
 8007d7a:	4613      	mov	r3, r2
 8007d7c:	005b      	lsls	r3, r3, #1
 8007d7e:	4413      	add	r3, r2
 8007d80:	00db      	lsls	r3, r3, #3
 8007d82:	3350      	adds	r3, #80	@ 0x50
 8007d84:	443b      	add	r3, r7
 8007d86:	3b2c      	subs	r3, #44	@ 0x2c
 8007d88:	681b      	ldr	r3, [r3, #0]
 8007d8a:	3b01      	subs	r3, #1
 8007d8c:	f003 0301 	and.w	r3, r3, #1
 8007d90:	009b      	lsls	r3, r3, #2
 8007d92:	440b      	add	r3, r1
 8007d94:	6859      	ldr	r1, [r3, #4]
 8007d96:	485f      	ldr	r0, [pc, #380]	@ (8007f14 <HAL_OSPIM_Config+0x7fc>)
 8007d98:	f897 2045 	ldrb.w	r2, [r7, #69]	@ 0x45
 8007d9c:	4613      	mov	r3, r2
 8007d9e:	005b      	lsls	r3, r3, #1
 8007da0:	4413      	add	r3, r2
 8007da2:	00db      	lsls	r3, r3, #3
 8007da4:	3350      	adds	r3, #80	@ 0x50
 8007da6:	443b      	add	r3, r7
 8007da8:	3b2c      	subs	r3, #44	@ 0x2c
 8007daa:	681b      	ldr	r3, [r3, #0]
 8007dac:	3b01      	subs	r3, #1
 8007dae:	f003 0301 	and.w	r3, r3, #1
 8007db2:	f021 7280 	bic.w	r2, r1, #16777216	@ 0x1000000
 8007db6:	009b      	lsls	r3, r3, #2
 8007db8:	4403      	add	r3, r0
 8007dba:	605a      	str	r2, [r3, #4]
        }
      }
    }

    /******************** Activation of new configuration *********************/
    MODIFY_REG(OCTOSPIM->PCR[(cfg->NCSPort - 1U)], (OCTOSPIM_PCR_NCSEN | OCTOSPIM_PCR_NCSSRC),
 8007dbc:	4a55      	ldr	r2, [pc, #340]	@ (8007f14 <HAL_OSPIM_Config+0x7fc>)
 8007dbe:	68bb      	ldr	r3, [r7, #8]
 8007dc0:	689b      	ldr	r3, [r3, #8]
 8007dc2:	3b01      	subs	r3, #1
 8007dc4:	009b      	lsls	r3, r3, #2
 8007dc6:	4413      	add	r3, r2
 8007dc8:	685b      	ldr	r3, [r3, #4]
 8007dca:	f423 7240 	bic.w	r2, r3, #768	@ 0x300
 8007dce:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8007dd0:	025b      	lsls	r3, r3, #9
 8007dd2:	431a      	orrs	r2, r3
 8007dd4:	494f      	ldr	r1, [pc, #316]	@ (8007f14 <HAL_OSPIM_Config+0x7fc>)
 8007dd6:	68bb      	ldr	r3, [r7, #8]
 8007dd8:	689b      	ldr	r3, [r3, #8]
 8007dda:	3b01      	subs	r3, #1
 8007ddc:	f442 7280 	orr.w	r2, r2, #256	@ 0x100
 8007de0:	009b      	lsls	r3, r3, #2
 8007de2:	440b      	add	r3, r1
 8007de4:	605a      	str	r2, [r3, #4]
               (OCTOSPIM_PCR_NCSEN | (instance << OCTOSPIM_PCR_NCSSRC_Pos)));

    if ((cfg->Req2AckTime - 1U) > ((OCTOSPIM->CR & OCTOSPIM_CR_REQ2ACK_TIME) >> OCTOSPIM_CR_REQ2ACK_TIME_Pos))
 8007de6:	68bb      	ldr	r3, [r7, #8]
 8007de8:	695b      	ldr	r3, [r3, #20]
 8007dea:	1e5a      	subs	r2, r3, #1
 8007dec:	4b49      	ldr	r3, [pc, #292]	@ (8007f14 <HAL_OSPIM_Config+0x7fc>)
 8007dee:	681b      	ldr	r3, [r3, #0]
 8007df0:	0c1b      	lsrs	r3, r3, #16
 8007df2:	b2db      	uxtb	r3, r3
 8007df4:	429a      	cmp	r2, r3
 8007df6:	d90a      	bls.n	8007e0e <HAL_OSPIM_Config+0x6f6>
    {
      MODIFY_REG(OCTOSPIM->CR, OCTOSPIM_CR_REQ2ACK_TIME, ((cfg->Req2AckTime - 1U) << OCTOSPIM_CR_REQ2ACK_TIME_Pos));
 8007df8:	4b46      	ldr	r3, [pc, #280]	@ (8007f14 <HAL_OSPIM_Config+0x7fc>)
 8007dfa:	681b      	ldr	r3, [r3, #0]
 8007dfc:	f423 027f 	bic.w	r2, r3, #16711680	@ 0xff0000
 8007e00:	68bb      	ldr	r3, [r7, #8]
 8007e02:	695b      	ldr	r3, [r3, #20]
 8007e04:	3b01      	subs	r3, #1
 8007e06:	041b      	lsls	r3, r3, #16
 8007e08:	4942      	ldr	r1, [pc, #264]	@ (8007f14 <HAL_OSPIM_Config+0x7fc>)
 8007e0a:	4313      	orrs	r3, r2
 8007e0c:	600b      	str	r3, [r1, #0]
    }

    if ((OCTOSPIM->CR & OCTOSPIM_CR_MUXEN) != 0U)
 8007e0e:	4b41      	ldr	r3, [pc, #260]	@ (8007f14 <HAL_OSPIM_Config+0x7fc>)
 8007e10:	681b      	ldr	r3, [r3, #0]
 8007e12:	f003 0301 	and.w	r3, r3, #1
 8007e16:	2b00      	cmp	r3, #0
 8007e18:	f000 809a 	beq.w	8007f50 <HAL_OSPIM_Config+0x838>
    {
      MODIFY_REG(OCTOSPIM->PCR[(cfg->ClkPort - 1U)], (OCTOSPIM_PCR_CLKEN | OCTOSPIM_PCR_CLKSRC), OCTOSPIM_PCR_CLKEN);
 8007e1c:	4a3d      	ldr	r2, [pc, #244]	@ (8007f14 <HAL_OSPIM_Config+0x7fc>)
 8007e1e:	68bb      	ldr	r3, [r7, #8]
 8007e20:	681b      	ldr	r3, [r3, #0]
 8007e22:	3b01      	subs	r3, #1
 8007e24:	009b      	lsls	r3, r3, #2
 8007e26:	4413      	add	r3, r2
 8007e28:	685b      	ldr	r3, [r3, #4]
 8007e2a:	f023 0203 	bic.w	r2, r3, #3
 8007e2e:	4939      	ldr	r1, [pc, #228]	@ (8007f14 <HAL_OSPIM_Config+0x7fc>)
 8007e30:	68bb      	ldr	r3, [r7, #8]
 8007e32:	681b      	ldr	r3, [r3, #0]
 8007e34:	3b01      	subs	r3, #1
 8007e36:	f042 0201 	orr.w	r2, r2, #1
 8007e3a:	009b      	lsls	r3, r3, #2
 8007e3c:	440b      	add	r3, r1
 8007e3e:	605a      	str	r2, [r3, #4]
      if (cfg->DQSPort != 0U)
 8007e40:	68bb      	ldr	r3, [r7, #8]
 8007e42:	685b      	ldr	r3, [r3, #4]
 8007e44:	2b00      	cmp	r3, #0
 8007e46:	d011      	beq.n	8007e6c <HAL_OSPIM_Config+0x754>
      {
        MODIFY_REG(OCTOSPIM->PCR[(cfg->DQSPort - 1U)], (OCTOSPIM_PCR_DQSEN | OCTOSPIM_PCR_DQSSRC), OCTOSPIM_PCR_DQSEN);
 8007e48:	4a32      	ldr	r2, [pc, #200]	@ (8007f14 <HAL_OSPIM_Config+0x7fc>)
 8007e4a:	68bb      	ldr	r3, [r7, #8]
 8007e4c:	685b      	ldr	r3, [r3, #4]
 8007e4e:	3b01      	subs	r3, #1
 8007e50:	009b      	lsls	r3, r3, #2
 8007e52:	4413      	add	r3, r2
 8007e54:	685b      	ldr	r3, [r3, #4]
 8007e56:	f023 0230 	bic.w	r2, r3, #48	@ 0x30
 8007e5a:	492e      	ldr	r1, [pc, #184]	@ (8007f14 <HAL_OSPIM_Config+0x7fc>)
 8007e5c:	68bb      	ldr	r3, [r7, #8]
 8007e5e:	685b      	ldr	r3, [r3, #4]
 8007e60:	3b01      	subs	r3, #1
 8007e62:	f042 0210 	orr.w	r2, r2, #16
 8007e66:	009b      	lsls	r3, r3, #2
 8007e68:	440b      	add	r3, r1
 8007e6a:	605a      	str	r2, [r3, #4]
      }

      if ((cfg->IOLowPort & OCTOSPIM_PCR_IOLEN) != 0U)
 8007e6c:	68bb      	ldr	r3, [r7, #8]
 8007e6e:	68db      	ldr	r3, [r3, #12]
 8007e70:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 8007e74:	2b00      	cmp	r3, #0
 8007e76:	d016      	beq.n	8007ea6 <HAL_OSPIM_Config+0x78e>
      {
        MODIFY_REG(OCTOSPIM->PCR[((cfg->IOLowPort - 1U)& OSPI_IOM_PORT_MASK)],
 8007e78:	4a26      	ldr	r2, [pc, #152]	@ (8007f14 <HAL_OSPIM_Config+0x7fc>)
 8007e7a:	68bb      	ldr	r3, [r7, #8]
 8007e7c:	68db      	ldr	r3, [r3, #12]
 8007e7e:	3b01      	subs	r3, #1
 8007e80:	f003 0301 	and.w	r3, r3, #1
 8007e84:	009b      	lsls	r3, r3, #2
 8007e86:	4413      	add	r3, r2
 8007e88:	685b      	ldr	r3, [r3, #4]
 8007e8a:	f423 22e0 	bic.w	r2, r3, #458752	@ 0x70000
 8007e8e:	4921      	ldr	r1, [pc, #132]	@ (8007f14 <HAL_OSPIM_Config+0x7fc>)
 8007e90:	68bb      	ldr	r3, [r7, #8]
 8007e92:	68db      	ldr	r3, [r3, #12]
 8007e94:	3b01      	subs	r3, #1
 8007e96:	f003 0301 	and.w	r3, r3, #1
 8007e9a:	f442 3280 	orr.w	r2, r2, #65536	@ 0x10000
 8007e9e:	009b      	lsls	r3, r3, #2
 8007ea0:	440b      	add	r3, r1
 8007ea2:	605a      	str	r2, [r3, #4]
 8007ea4:	e019      	b.n	8007eda <HAL_OSPIM_Config+0x7c2>
                   (OCTOSPIM_PCR_IOLEN | OCTOSPIM_PCR_IOLSRC), OCTOSPIM_PCR_IOLEN);
      }
      else if (cfg->IOLowPort != HAL_OSPIM_IOPORT_NONE)
 8007ea6:	68bb      	ldr	r3, [r7, #8]
 8007ea8:	68db      	ldr	r3, [r3, #12]
 8007eaa:	2b00      	cmp	r3, #0
 8007eac:	d015      	beq.n	8007eda <HAL_OSPIM_Config+0x7c2>
      {
        MODIFY_REG(OCTOSPIM->PCR[((cfg->IOLowPort - 1U)& OSPI_IOM_PORT_MASK)],
 8007eae:	4a19      	ldr	r2, [pc, #100]	@ (8007f14 <HAL_OSPIM_Config+0x7fc>)
 8007eb0:	68bb      	ldr	r3, [r7, #8]
 8007eb2:	68db      	ldr	r3, [r3, #12]
 8007eb4:	3b01      	subs	r3, #1
 8007eb6:	f003 0301 	and.w	r3, r3, #1
 8007eba:	009b      	lsls	r3, r3, #2
 8007ebc:	4413      	add	r3, r2
 8007ebe:	685b      	ldr	r3, [r3, #4]
 8007ec0:	f023 62e0 	bic.w	r2, r3, #117440512	@ 0x7000000
 8007ec4:	4913      	ldr	r1, [pc, #76]	@ (8007f14 <HAL_OSPIM_Config+0x7fc>)
 8007ec6:	68bb      	ldr	r3, [r7, #8]
 8007ec8:	68db      	ldr	r3, [r3, #12]
 8007eca:	3b01      	subs	r3, #1
 8007ecc:	f003 0301 	and.w	r3, r3, #1
 8007ed0:	f042 7280 	orr.w	r2, r2, #16777216	@ 0x1000000
 8007ed4:	009b      	lsls	r3, r3, #2
 8007ed6:	440b      	add	r3, r1
 8007ed8:	605a      	str	r2, [r3, #4]
      else
      {
        /* Nothing to do */
      }

      if ((cfg->IOHighPort & OCTOSPIM_PCR_IOLEN) != 0U)
 8007eda:	68bb      	ldr	r3, [r7, #8]
 8007edc:	691b      	ldr	r3, [r3, #16]
 8007ede:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 8007ee2:	2b00      	cmp	r3, #0
 8007ee4:	d018      	beq.n	8007f18 <HAL_OSPIM_Config+0x800>
      {
        MODIFY_REG(OCTOSPIM->PCR[((cfg->IOHighPort - 1U)& OSPI_IOM_PORT_MASK)],
 8007ee6:	4a0b      	ldr	r2, [pc, #44]	@ (8007f14 <HAL_OSPIM_Config+0x7fc>)
 8007ee8:	68bb      	ldr	r3, [r7, #8]
 8007eea:	691b      	ldr	r3, [r3, #16]
 8007eec:	3b01      	subs	r3, #1
 8007eee:	f003 0301 	and.w	r3, r3, #1
 8007ef2:	009b      	lsls	r3, r3, #2
 8007ef4:	4413      	add	r3, r2
 8007ef6:	685b      	ldr	r3, [r3, #4]
 8007ef8:	f423 22e0 	bic.w	r2, r3, #458752	@ 0x70000
 8007efc:	4905      	ldr	r1, [pc, #20]	@ (8007f14 <HAL_OSPIM_Config+0x7fc>)
 8007efe:	68bb      	ldr	r3, [r7, #8]
 8007f00:	691b      	ldr	r3, [r3, #16]
 8007f02:	3b01      	subs	r3, #1
 8007f04:	f003 0301 	and.w	r3, r3, #1
 8007f08:	f442 3240 	orr.w	r2, r2, #196608	@ 0x30000
 8007f0c:	009b      	lsls	r3, r3, #2
 8007f0e:	440b      	add	r3, r1
 8007f10:	605a      	str	r2, [r3, #4]
 8007f12:	e0c5      	b.n	80080a0 <HAL_OSPIM_Config+0x988>
 8007f14:	5200b400 	.word	0x5200b400
                   (OCTOSPIM_PCR_IOLEN | OCTOSPIM_PCR_IOLSRC), (OCTOSPIM_PCR_IOLEN | OCTOSPIM_PCR_IOLSRC_0));
      }
      else if (cfg->IOHighPort != HAL_OSPIM_IOPORT_NONE)
 8007f18:	68bb      	ldr	r3, [r7, #8]
 8007f1a:	691b      	ldr	r3, [r3, #16]
 8007f1c:	2b00      	cmp	r3, #0
 8007f1e:	f000 80bf 	beq.w	80080a0 <HAL_OSPIM_Config+0x988>
      {
        MODIFY_REG(OCTOSPIM->PCR[((cfg->IOHighPort - 1U)& OSPI_IOM_PORT_MASK)],
 8007f22:	4a6e      	ldr	r2, [pc, #440]	@ (80080dc <HAL_OSPIM_Config+0x9c4>)
 8007f24:	68bb      	ldr	r3, [r7, #8]
 8007f26:	691b      	ldr	r3, [r3, #16]
 8007f28:	3b01      	subs	r3, #1
 8007f2a:	f003 0301 	and.w	r3, r3, #1
 8007f2e:	009b      	lsls	r3, r3, #2
 8007f30:	4413      	add	r3, r2
 8007f32:	685b      	ldr	r3, [r3, #4]
 8007f34:	f023 62e0 	bic.w	r2, r3, #117440512	@ 0x7000000
 8007f38:	4968      	ldr	r1, [pc, #416]	@ (80080dc <HAL_OSPIM_Config+0x9c4>)
 8007f3a:	68bb      	ldr	r3, [r7, #8]
 8007f3c:	691b      	ldr	r3, [r3, #16]
 8007f3e:	3b01      	subs	r3, #1
 8007f40:	f003 0301 	and.w	r3, r3, #1
 8007f44:	f042 7240 	orr.w	r2, r2, #50331648	@ 0x3000000
 8007f48:	009b      	lsls	r3, r3, #2
 8007f4a:	440b      	add	r3, r1
 8007f4c:	605a      	str	r2, [r3, #4]
 8007f4e:	e0a7      	b.n	80080a0 <HAL_OSPIM_Config+0x988>
        /* Nothing to do */
      }
    }
    else
    {
      MODIFY_REG(OCTOSPIM->PCR[(cfg->ClkPort - 1U)], (OCTOSPIM_PCR_CLKEN | OCTOSPIM_PCR_CLKSRC),
 8007f50:	4a62      	ldr	r2, [pc, #392]	@ (80080dc <HAL_OSPIM_Config+0x9c4>)
 8007f52:	68bb      	ldr	r3, [r7, #8]
 8007f54:	681b      	ldr	r3, [r3, #0]
 8007f56:	3b01      	subs	r3, #1
 8007f58:	009b      	lsls	r3, r3, #2
 8007f5a:	4413      	add	r3, r2
 8007f5c:	685b      	ldr	r3, [r3, #4]
 8007f5e:	f023 0203 	bic.w	r2, r3, #3
 8007f62:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8007f64:	005b      	lsls	r3, r3, #1
 8007f66:	431a      	orrs	r2, r3
 8007f68:	495c      	ldr	r1, [pc, #368]	@ (80080dc <HAL_OSPIM_Config+0x9c4>)
 8007f6a:	68bb      	ldr	r3, [r7, #8]
 8007f6c:	681b      	ldr	r3, [r3, #0]
 8007f6e:	3b01      	subs	r3, #1
 8007f70:	f042 0201 	orr.w	r2, r2, #1
 8007f74:	009b      	lsls	r3, r3, #2
 8007f76:	440b      	add	r3, r1
 8007f78:	605a      	str	r2, [r3, #4]
                 (OCTOSPIM_PCR_CLKEN | (instance << OCTOSPIM_PCR_CLKSRC_Pos)));
      if (cfg->DQSPort != 0U)
 8007f7a:	68bb      	ldr	r3, [r7, #8]
 8007f7c:	685b      	ldr	r3, [r3, #4]
 8007f7e:	2b00      	cmp	r3, #0
 8007f80:	d014      	beq.n	8007fac <HAL_OSPIM_Config+0x894>
      {
        MODIFY_REG(OCTOSPIM->PCR[(cfg->DQSPort - 1U)], (OCTOSPIM_PCR_DQSEN | OCTOSPIM_PCR_DQSSRC),
 8007f82:	4a56      	ldr	r2, [pc, #344]	@ (80080dc <HAL_OSPIM_Config+0x9c4>)
 8007f84:	68bb      	ldr	r3, [r7, #8]
 8007f86:	685b      	ldr	r3, [r3, #4]
 8007f88:	3b01      	subs	r3, #1
 8007f8a:	009b      	lsls	r3, r3, #2
 8007f8c:	4413      	add	r3, r2
 8007f8e:	685b      	ldr	r3, [r3, #4]
 8007f90:	f023 0230 	bic.w	r2, r3, #48	@ 0x30
 8007f94:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8007f96:	015b      	lsls	r3, r3, #5
 8007f98:	431a      	orrs	r2, r3
 8007f9a:	4950      	ldr	r1, [pc, #320]	@ (80080dc <HAL_OSPIM_Config+0x9c4>)
 8007f9c:	68bb      	ldr	r3, [r7, #8]
 8007f9e:	685b      	ldr	r3, [r3, #4]
 8007fa0:	3b01      	subs	r3, #1
 8007fa2:	f042 0210 	orr.w	r2, r2, #16
 8007fa6:	009b      	lsls	r3, r3, #2
 8007fa8:	440b      	add	r3, r1
 8007faa:	605a      	str	r2, [r3, #4]
                   (OCTOSPIM_PCR_DQSEN | (instance << OCTOSPIM_PCR_DQSSRC_Pos)));
      }

      if ((cfg->IOLowPort & OCTOSPIM_PCR_IOLEN) != 0U)
 8007fac:	68bb      	ldr	r3, [r7, #8]
 8007fae:	68db      	ldr	r3, [r3, #12]
 8007fb0:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 8007fb4:	2b00      	cmp	r3, #0
 8007fb6:	d019      	beq.n	8007fec <HAL_OSPIM_Config+0x8d4>
      {
        MODIFY_REG(OCTOSPIM->PCR[((cfg->IOLowPort - 1U)& OSPI_IOM_PORT_MASK)],
 8007fb8:	4a48      	ldr	r2, [pc, #288]	@ (80080dc <HAL_OSPIM_Config+0x9c4>)
 8007fba:	68bb      	ldr	r3, [r7, #8]
 8007fbc:	68db      	ldr	r3, [r3, #12]
 8007fbe:	3b01      	subs	r3, #1
 8007fc0:	f003 0301 	and.w	r3, r3, #1
 8007fc4:	009b      	lsls	r3, r3, #2
 8007fc6:	4413      	add	r3, r2
 8007fc8:	685b      	ldr	r3, [r3, #4]
 8007fca:	f423 22e0 	bic.w	r2, r3, #458752	@ 0x70000
 8007fce:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8007fd0:	049b      	lsls	r3, r3, #18
 8007fd2:	431a      	orrs	r2, r3
 8007fd4:	4941      	ldr	r1, [pc, #260]	@ (80080dc <HAL_OSPIM_Config+0x9c4>)
 8007fd6:	68bb      	ldr	r3, [r7, #8]
 8007fd8:	68db      	ldr	r3, [r3, #12]
 8007fda:	3b01      	subs	r3, #1
 8007fdc:	f003 0301 	and.w	r3, r3, #1
 8007fe0:	f442 3280 	orr.w	r2, r2, #65536	@ 0x10000
 8007fe4:	009b      	lsls	r3, r3, #2
 8007fe6:	440b      	add	r3, r1
 8007fe8:	605a      	str	r2, [r3, #4]
 8007fea:	e01c      	b.n	8008026 <HAL_OSPIM_Config+0x90e>
                   (OCTOSPIM_PCR_IOLEN | OCTOSPIM_PCR_IOLSRC),
                   (OCTOSPIM_PCR_IOLEN | (instance << (OCTOSPIM_PCR_IOLSRC_Pos + 1U))));
      }
      else if (cfg->IOLowPort != HAL_OSPIM_IOPORT_NONE)
 8007fec:	68bb      	ldr	r3, [r7, #8]
 8007fee:	68db      	ldr	r3, [r3, #12]
 8007ff0:	2b00      	cmp	r3, #0
 8007ff2:	d018      	beq.n	8008026 <HAL_OSPIM_Config+0x90e>
      {
        MODIFY_REG(OCTOSPIM->PCR[((cfg->IOLowPort - 1U)& OSPI_IOM_PORT_MASK)],
 8007ff4:	4a39      	ldr	r2, [pc, #228]	@ (80080dc <HAL_OSPIM_Config+0x9c4>)
 8007ff6:	68bb      	ldr	r3, [r7, #8]
 8007ff8:	68db      	ldr	r3, [r3, #12]
 8007ffa:	3b01      	subs	r3, #1
 8007ffc:	f003 0301 	and.w	r3, r3, #1
 8008000:	009b      	lsls	r3, r3, #2
 8008002:	4413      	add	r3, r2
 8008004:	685b      	ldr	r3, [r3, #4]
 8008006:	f023 62e0 	bic.w	r2, r3, #117440512	@ 0x7000000
 800800a:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 800800c:	069b      	lsls	r3, r3, #26
 800800e:	431a      	orrs	r2, r3
 8008010:	4932      	ldr	r1, [pc, #200]	@ (80080dc <HAL_OSPIM_Config+0x9c4>)
 8008012:	68bb      	ldr	r3, [r7, #8]
 8008014:	68db      	ldr	r3, [r3, #12]
 8008016:	3b01      	subs	r3, #1
 8008018:	f003 0301 	and.w	r3, r3, #1
 800801c:	f042 7280 	orr.w	r2, r2, #16777216	@ 0x1000000
 8008020:	009b      	lsls	r3, r3, #2
 8008022:	440b      	add	r3, r1
 8008024:	605a      	str	r2, [r3, #4]
      else
      {
        /* Nothing to do */
      }

      if ((cfg->IOHighPort & OCTOSPIM_PCR_IOLEN) != 0U)
 8008026:	68bb      	ldr	r3, [r7, #8]
 8008028:	691b      	ldr	r3, [r3, #16]
 800802a:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 800802e:	2b00      	cmp	r3, #0
 8008030:	d019      	beq.n	8008066 <HAL_OSPIM_Config+0x94e>
      {
        MODIFY_REG(OCTOSPIM->PCR[((cfg->IOHighPort - 1U)& OSPI_IOM_PORT_MASK)],
 8008032:	4a2a      	ldr	r2, [pc, #168]	@ (80080dc <HAL_OSPIM_Config+0x9c4>)
 8008034:	68bb      	ldr	r3, [r7, #8]
 8008036:	691b      	ldr	r3, [r3, #16]
 8008038:	3b01      	subs	r3, #1
 800803a:	f003 0301 	and.w	r3, r3, #1
 800803e:	009b      	lsls	r3, r3, #2
 8008040:	4413      	add	r3, r2
 8008042:	685b      	ldr	r3, [r3, #4]
 8008044:	f423 22e0 	bic.w	r2, r3, #458752	@ 0x70000
 8008048:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 800804a:	049b      	lsls	r3, r3, #18
 800804c:	431a      	orrs	r2, r3
 800804e:	4923      	ldr	r1, [pc, #140]	@ (80080dc <HAL_OSPIM_Config+0x9c4>)
 8008050:	68bb      	ldr	r3, [r7, #8]
 8008052:	691b      	ldr	r3, [r3, #16]
 8008054:	3b01      	subs	r3, #1
 8008056:	f003 0301 	and.w	r3, r3, #1
 800805a:	f442 3240 	orr.w	r2, r2, #196608	@ 0x30000
 800805e:	009b      	lsls	r3, r3, #2
 8008060:	440b      	add	r3, r1
 8008062:	605a      	str	r2, [r3, #4]
 8008064:	e01c      	b.n	80080a0 <HAL_OSPIM_Config+0x988>
                   (OCTOSPIM_PCR_IOLEN | OCTOSPIM_PCR_IOLSRC),
                   (OCTOSPIM_PCR_IOLEN | OCTOSPIM_PCR_IOLSRC_0 | (instance << (OCTOSPIM_PCR_IOLSRC_Pos + 1U))));
      }
      else if (cfg->IOHighPort != HAL_OSPIM_IOPORT_NONE)
 8008066:	68bb      	ldr	r3, [r7, #8]
 8008068:	691b      	ldr	r3, [r3, #16]
 800806a:	2b00      	cmp	r3, #0
 800806c:	d018      	beq.n	80080a0 <HAL_OSPIM_Config+0x988>
      {
        MODIFY_REG(OCTOSPIM->PCR[((cfg->IOHighPort - 1U)& OSPI_IOM_PORT_MASK)],
 800806e:	4a1b      	ldr	r2, [pc, #108]	@ (80080dc <HAL_OSPIM_Config+0x9c4>)
 8008070:	68bb      	ldr	r3, [r7, #8]
 8008072:	691b      	ldr	r3, [r3, #16]
 8008074:	3b01      	subs	r3, #1
 8008076:	f003 0301 	and.w	r3, r3, #1
 800807a:	009b      	lsls	r3, r3, #2
 800807c:	4413      	add	r3, r2
 800807e:	685b      	ldr	r3, [r3, #4]
 8008080:	f023 62e0 	bic.w	r2, r3, #117440512	@ 0x7000000
 8008084:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8008086:	069b      	lsls	r3, r3, #26
 8008088:	431a      	orrs	r2, r3
 800808a:	4914      	ldr	r1, [pc, #80]	@ (80080dc <HAL_OSPIM_Config+0x9c4>)
 800808c:	68bb      	ldr	r3, [r7, #8]
 800808e:	691b      	ldr	r3, [r3, #16]
 8008090:	3b01      	subs	r3, #1
 8008092:	f003 0301 	and.w	r3, r3, #1
 8008096:	f042 7240 	orr.w	r2, r2, #50331648	@ 0x3000000
 800809a:	009b      	lsls	r3, r3, #2
 800809c:	440b      	add	r3, r1
 800809e:	605a      	str	r2, [r3, #4]
        /* Nothing to do */
      }
    }

    /******* Re-enable both OctoSPI after configure OctoSPI IO Manager ********/
    if ((ospi_enabled & 0x1U) != 0U)
 80080a0:	f897 3046 	ldrb.w	r3, [r7, #70]	@ 0x46
 80080a4:	f003 0301 	and.w	r3, r3, #1
 80080a8:	2b00      	cmp	r3, #0
 80080aa:	d005      	beq.n	80080b8 <HAL_OSPIM_Config+0x9a0>
    {
      SET_BIT(OCTOSPI1->CR, OCTOSPI_CR_EN);
 80080ac:	4b0c      	ldr	r3, [pc, #48]	@ (80080e0 <HAL_OSPIM_Config+0x9c8>)
 80080ae:	681b      	ldr	r3, [r3, #0]
 80080b0:	4a0b      	ldr	r2, [pc, #44]	@ (80080e0 <HAL_OSPIM_Config+0x9c8>)
 80080b2:	f043 0301 	orr.w	r3, r3, #1
 80080b6:	6013      	str	r3, [r2, #0]
    }
    if ((ospi_enabled & 0x2U) != 0U)
 80080b8:	f897 3046 	ldrb.w	r3, [r7, #70]	@ 0x46
 80080bc:	f003 0302 	and.w	r3, r3, #2
 80080c0:	2b00      	cmp	r3, #0
 80080c2:	d005      	beq.n	80080d0 <HAL_OSPIM_Config+0x9b8>
    {
      SET_BIT(OCTOSPI2->CR, OCTOSPI_CR_EN);
 80080c4:	4b07      	ldr	r3, [pc, #28]	@ (80080e4 <HAL_OSPIM_Config+0x9cc>)
 80080c6:	681b      	ldr	r3, [r3, #0]
 80080c8:	4a06      	ldr	r2, [pc, #24]	@ (80080e4 <HAL_OSPIM_Config+0x9cc>)
 80080ca:	f043 0301 	orr.w	r3, r3, #1
 80080ce:	6013      	str	r3, [r2, #0]
    }
  }

  /* Return function status */
  return status;
 80080d0:	f897 304f 	ldrb.w	r3, [r7, #79]	@ 0x4f
}
 80080d4:	4618      	mov	r0, r3
 80080d6:	3750      	adds	r7, #80	@ 0x50
 80080d8:	46bd      	mov	sp, r7
 80080da:	bd80      	pop	{r7, pc}
 80080dc:	5200b400 	.word	0x5200b400
 80080e0:	52005000 	.word	0x52005000
 80080e4:	5200a000 	.word	0x5200a000

080080e8 <OSPI_WaitFlagStateUntilTimeout>:
  * @param  Tickstart : Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef OSPI_WaitFlagStateUntilTimeout(OSPI_HandleTypeDef *hospi, uint32_t Flag,
                                                        FlagStatus State, uint32_t Tickstart, uint32_t Timeout)
{
 80080e8:	b580      	push	{r7, lr}
 80080ea:	b084      	sub	sp, #16
 80080ec:	af00      	add	r7, sp, #0
 80080ee:	60f8      	str	r0, [r7, #12]
 80080f0:	60b9      	str	r1, [r7, #8]
 80080f2:	603b      	str	r3, [r7, #0]
 80080f4:	4613      	mov	r3, r2
 80080f6:	71fb      	strb	r3, [r7, #7]
  /* Wait until flag is in expected state */
  while ((__HAL_OSPI_GET_FLAG(hospi, Flag)) != State)
 80080f8:	e01a      	b.n	8008130 <OSPI_WaitFlagStateUntilTimeout+0x48>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
 80080fa:	69bb      	ldr	r3, [r7, #24]
 80080fc:	f1b3 3fff 	cmp.w	r3, #4294967295
 8008100:	d016      	beq.n	8008130 <OSPI_WaitFlagStateUntilTimeout+0x48>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8008102:	f7fa fc2d 	bl	8002960 <HAL_GetTick>
 8008106:	4602      	mov	r2, r0
 8008108:	683b      	ldr	r3, [r7, #0]
 800810a:	1ad3      	subs	r3, r2, r3
 800810c:	69ba      	ldr	r2, [r7, #24]
 800810e:	429a      	cmp	r2, r3
 8008110:	d302      	bcc.n	8008118 <OSPI_WaitFlagStateUntilTimeout+0x30>
 8008112:	69bb      	ldr	r3, [r7, #24]
 8008114:	2b00      	cmp	r3, #0
 8008116:	d10b      	bne.n	8008130 <OSPI_WaitFlagStateUntilTimeout+0x48>
      {
        hospi->State     = HAL_OSPI_STATE_ERROR;
 8008118:	68fb      	ldr	r3, [r7, #12]
 800811a:	f44f 7200 	mov.w	r2, #512	@ 0x200
 800811e:	651a      	str	r2, [r3, #80]	@ 0x50
        hospi->ErrorCode |= HAL_OSPI_ERROR_TIMEOUT;
 8008120:	68fb      	ldr	r3, [r7, #12]
 8008122:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8008124:	f043 0201 	orr.w	r2, r3, #1
 8008128:	68fb      	ldr	r3, [r7, #12]
 800812a:	655a      	str	r2, [r3, #84]	@ 0x54

        return HAL_ERROR;
 800812c:	2301      	movs	r3, #1
 800812e:	e00e      	b.n	800814e <OSPI_WaitFlagStateUntilTimeout+0x66>
  while ((__HAL_OSPI_GET_FLAG(hospi, Flag)) != State)
 8008130:	68fb      	ldr	r3, [r7, #12]
 8008132:	681b      	ldr	r3, [r3, #0]
 8008134:	6a1a      	ldr	r2, [r3, #32]
 8008136:	68bb      	ldr	r3, [r7, #8]
 8008138:	4013      	ands	r3, r2
 800813a:	2b00      	cmp	r3, #0
 800813c:	bf14      	ite	ne
 800813e:	2301      	movne	r3, #1
 8008140:	2300      	moveq	r3, #0
 8008142:	b2db      	uxtb	r3, r3
 8008144:	461a      	mov	r2, r3
 8008146:	79fb      	ldrb	r3, [r7, #7]
 8008148:	429a      	cmp	r2, r3
 800814a:	d1d6      	bne.n	80080fa <OSPI_WaitFlagStateUntilTimeout+0x12>
      }
    }
  }
  return HAL_OK;
 800814c:	2300      	movs	r3, #0
}
 800814e:	4618      	mov	r0, r3
 8008150:	3710      	adds	r7, #16
 8008152:	46bd      	mov	sp, r7
 8008154:	bd80      	pop	{r7, pc}
	...

08008158 <OSPIM_GetConfig>:
  * @param  instance_nb : number of the instance
  * @param  cfg         : configuration of the IO Manager for the instance
  * @retval HAL status
  */
static HAL_StatusTypeDef OSPIM_GetConfig(uint8_t instance_nb, OSPIM_CfgTypeDef *cfg)
{
 8008158:	b480      	push	{r7}
 800815a:	b087      	sub	sp, #28
 800815c:	af00      	add	r7, sp, #0
 800815e:	4603      	mov	r3, r0
 8008160:	6039      	str	r1, [r7, #0]
 8008162:	71fb      	strb	r3, [r7, #7]
  HAL_StatusTypeDef status = HAL_OK;
 8008164:	2300      	movs	r3, #0
 8008166:	75fb      	strb	r3, [r7, #23]
  uint32_t reg;
  uint32_t value = 0U;
 8008168:	2300      	movs	r3, #0
 800816a:	613b      	str	r3, [r7, #16]
  uint32_t index;

  if ((instance_nb == 0U) || (instance_nb > OSPI_NB_INSTANCE) || (cfg == NULL))
 800816c:	79fb      	ldrb	r3, [r7, #7]
 800816e:	2b00      	cmp	r3, #0
 8008170:	d005      	beq.n	800817e <OSPIM_GetConfig+0x26>
 8008172:	79fb      	ldrb	r3, [r7, #7]
 8008174:	2b02      	cmp	r3, #2
 8008176:	d802      	bhi.n	800817e <OSPIM_GetConfig+0x26>
 8008178:	683b      	ldr	r3, [r7, #0]
 800817a:	2b00      	cmp	r3, #0
 800817c:	d102      	bne.n	8008184 <OSPIM_GetConfig+0x2c>
  {
    /* Invalid parameter -> error returned */
    status = HAL_ERROR;
 800817e:	2301      	movs	r3, #1
 8008180:	75fb      	strb	r3, [r7, #23]
 8008182:	e098      	b.n	80082b6 <OSPIM_GetConfig+0x15e>
  }
  else
  {
    /* Initialize the structure */
    cfg->ClkPort    = 0U;
 8008184:	683b      	ldr	r3, [r7, #0]
 8008186:	2200      	movs	r2, #0
 8008188:	601a      	str	r2, [r3, #0]
    cfg->DQSPort    = 0U;
 800818a:	683b      	ldr	r3, [r7, #0]
 800818c:	2200      	movs	r2, #0
 800818e:	605a      	str	r2, [r3, #4]
    cfg->NCSPort    = 0U;
 8008190:	683b      	ldr	r3, [r7, #0]
 8008192:	2200      	movs	r2, #0
 8008194:	609a      	str	r2, [r3, #8]
    cfg->IOLowPort  = 0U;
 8008196:	683b      	ldr	r3, [r7, #0]
 8008198:	2200      	movs	r2, #0
 800819a:	60da      	str	r2, [r3, #12]
    cfg->IOHighPort = 0U;
 800819c:	683b      	ldr	r3, [r7, #0]
 800819e:	2200      	movs	r2, #0
 80081a0:	611a      	str	r2, [r3, #16]

    if (instance_nb == 2U)
 80081a2:	79fb      	ldrb	r3, [r7, #7]
 80081a4:	2b02      	cmp	r3, #2
 80081a6:	d10b      	bne.n	80081c0 <OSPIM_GetConfig+0x68>
    {
      if ((OCTOSPIM->CR & OCTOSPIM_CR_MUXEN) == 0U)
 80081a8:	4b46      	ldr	r3, [pc, #280]	@ (80082c4 <OSPIM_GetConfig+0x16c>)
 80081aa:	681b      	ldr	r3, [r3, #0]
 80081ac:	f003 0301 	and.w	r3, r3, #1
 80081b0:	2b00      	cmp	r3, #0
 80081b2:	d102      	bne.n	80081ba <OSPIM_GetConfig+0x62>
      {
        value = (OCTOSPIM_PCR_CLKSRC | OCTOSPIM_PCR_DQSSRC | OCTOSPIM_PCR_NCSSRC
 80081b4:	4b44      	ldr	r3, [pc, #272]	@ (80082c8 <OSPIM_GetConfig+0x170>)
 80081b6:	613b      	str	r3, [r7, #16]
 80081b8:	e002      	b.n	80081c0 <OSPIM_GetConfig+0x68>
                 | OCTOSPIM_PCR_IOLSRC_1 | OCTOSPIM_PCR_IOHSRC_1);
      }
      else
      {
        value = OCTOSPIM_PCR_NCSSRC;
 80081ba:	f44f 7300 	mov.w	r3, #512	@ 0x200
 80081be:	613b      	str	r3, [r7, #16]
      }
    }

    /* Get the information about the instance */
    for (index = 0U; index < OSPI_IOM_NB_PORTS; index ++)
 80081c0:	2300      	movs	r3, #0
 80081c2:	60fb      	str	r3, [r7, #12]
 80081c4:	e074      	b.n	80082b0 <OSPIM_GetConfig+0x158>
    {
      reg = OCTOSPIM->PCR[index];
 80081c6:	4a3f      	ldr	r2, [pc, #252]	@ (80082c4 <OSPIM_GetConfig+0x16c>)
 80081c8:	68fb      	ldr	r3, [r7, #12]
 80081ca:	009b      	lsls	r3, r3, #2
 80081cc:	4413      	add	r3, r2
 80081ce:	685b      	ldr	r3, [r3, #4]
 80081d0:	60bb      	str	r3, [r7, #8]

      if ((reg & OCTOSPIM_PCR_CLKEN) != 0U)
 80081d2:	68bb      	ldr	r3, [r7, #8]
 80081d4:	f003 0301 	and.w	r3, r3, #1
 80081d8:	2b00      	cmp	r3, #0
 80081da:	d00a      	beq.n	80081f2 <OSPIM_GetConfig+0x9a>
      {
        /* The clock is enabled on this port */
        if ((reg & OCTOSPIM_PCR_CLKSRC) == (value & OCTOSPIM_PCR_CLKSRC))
 80081dc:	68ba      	ldr	r2, [r7, #8]
 80081de:	693b      	ldr	r3, [r7, #16]
 80081e0:	4053      	eors	r3, r2
 80081e2:	f003 0302 	and.w	r3, r3, #2
 80081e6:	2b00      	cmp	r3, #0
 80081e8:	d103      	bne.n	80081f2 <OSPIM_GetConfig+0x9a>
        {
          /* The clock correspond to the instance passed as parameter */
          cfg->ClkPort = index + 1U;
 80081ea:	68fb      	ldr	r3, [r7, #12]
 80081ec:	1c5a      	adds	r2, r3, #1
 80081ee:	683b      	ldr	r3, [r7, #0]
 80081f0:	601a      	str	r2, [r3, #0]
        }
      }

      if ((reg & OCTOSPIM_PCR_DQSEN) != 0U)
 80081f2:	68bb      	ldr	r3, [r7, #8]
 80081f4:	f003 0310 	and.w	r3, r3, #16
 80081f8:	2b00      	cmp	r3, #0
 80081fa:	d00a      	beq.n	8008212 <OSPIM_GetConfig+0xba>
      {
        /* The DQS is enabled on this port */
        if ((reg & OCTOSPIM_PCR_DQSSRC) == (value & OCTOSPIM_PCR_DQSSRC))
 80081fc:	68ba      	ldr	r2, [r7, #8]
 80081fe:	693b      	ldr	r3, [r7, #16]
 8008200:	4053      	eors	r3, r2
 8008202:	f003 0320 	and.w	r3, r3, #32
 8008206:	2b00      	cmp	r3, #0
 8008208:	d103      	bne.n	8008212 <OSPIM_GetConfig+0xba>
        {
          /* The DQS correspond to the instance passed as parameter */
          cfg->DQSPort = index + 1U;
 800820a:	68fb      	ldr	r3, [r7, #12]
 800820c:	1c5a      	adds	r2, r3, #1
 800820e:	683b      	ldr	r3, [r7, #0]
 8008210:	605a      	str	r2, [r3, #4]
        }
      }

      if ((reg & OCTOSPIM_PCR_NCSEN) != 0U)
 8008212:	68bb      	ldr	r3, [r7, #8]
 8008214:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8008218:	2b00      	cmp	r3, #0
 800821a:	d00a      	beq.n	8008232 <OSPIM_GetConfig+0xda>
      {
        /* The nCS is enabled on this port */
        if ((reg & OCTOSPIM_PCR_NCSSRC) == (value & OCTOSPIM_PCR_NCSSRC))
 800821c:	68ba      	ldr	r2, [r7, #8]
 800821e:	693b      	ldr	r3, [r7, #16]
 8008220:	4053      	eors	r3, r2
 8008222:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 8008226:	2b00      	cmp	r3, #0
 8008228:	d103      	bne.n	8008232 <OSPIM_GetConfig+0xda>
        {
          /* The nCS correspond to the instance passed as parameter */
          cfg->NCSPort = index + 1U;
 800822a:	68fb      	ldr	r3, [r7, #12]
 800822c:	1c5a      	adds	r2, r3, #1
 800822e:	683b      	ldr	r3, [r7, #0]
 8008230:	609a      	str	r2, [r3, #8]
        }
      }

      if ((reg & OCTOSPIM_PCR_IOLEN) != 0U)
 8008232:	68bb      	ldr	r3, [r7, #8]
 8008234:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 8008238:	2b00      	cmp	r3, #0
 800823a:	d018      	beq.n	800826e <OSPIM_GetConfig+0x116>
      {
        /* The IO Low is enabled on this port */
        if ((reg & OCTOSPIM_PCR_IOLSRC_1) == (value & OCTOSPIM_PCR_IOLSRC_1))
 800823c:	68ba      	ldr	r2, [r7, #8]
 800823e:	693b      	ldr	r3, [r7, #16]
 8008240:	4053      	eors	r3, r2
 8008242:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
 8008246:	2b00      	cmp	r3, #0
 8008248:	d111      	bne.n	800826e <OSPIM_GetConfig+0x116>
        {
          /* The IO Low correspond to the instance passed as parameter */
          if ((reg & OCTOSPIM_PCR_IOLSRC_0) == 0U)
 800824a:	68bb      	ldr	r3, [r7, #8]
 800824c:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 8008250:	2b00      	cmp	r3, #0
 8008252:	d106      	bne.n	8008262 <OSPIM_GetConfig+0x10a>
          {
            cfg->IOLowPort = (OCTOSPIM_PCR_IOLEN | (index + 1U));
 8008254:	68fb      	ldr	r3, [r7, #12]
 8008256:	3301      	adds	r3, #1
 8008258:	f443 3280 	orr.w	r2, r3, #65536	@ 0x10000
 800825c:	683b      	ldr	r3, [r7, #0]
 800825e:	60da      	str	r2, [r3, #12]
 8008260:	e005      	b.n	800826e <OSPIM_GetConfig+0x116>
          }
          else
          {
            cfg->IOLowPort = (OCTOSPIM_PCR_IOHEN | (index + 1U));
 8008262:	68fb      	ldr	r3, [r7, #12]
 8008264:	3301      	adds	r3, #1
 8008266:	f043 7280 	orr.w	r2, r3, #16777216	@ 0x1000000
 800826a:	683b      	ldr	r3, [r7, #0]
 800826c:	60da      	str	r2, [r3, #12]
          }
        }
      }

      if ((reg & OCTOSPIM_PCR_IOHEN) != 0U)
 800826e:	68bb      	ldr	r3, [r7, #8]
 8008270:	f003 7380 	and.w	r3, r3, #16777216	@ 0x1000000
 8008274:	2b00      	cmp	r3, #0
 8008276:	d018      	beq.n	80082aa <OSPIM_GetConfig+0x152>
      {
        /* The IO High is enabled on this port */
        if ((reg & OCTOSPIM_PCR_IOHSRC_1) == (value & OCTOSPIM_PCR_IOHSRC_1))
 8008278:	68ba      	ldr	r2, [r7, #8]
 800827a:	693b      	ldr	r3, [r7, #16]
 800827c:	4053      	eors	r3, r2
 800827e:	f003 6380 	and.w	r3, r3, #67108864	@ 0x4000000
 8008282:	2b00      	cmp	r3, #0
 8008284:	d111      	bne.n	80082aa <OSPIM_GetConfig+0x152>
        {
          /* The IO High correspond to the instance passed as parameter */
          if ((reg & OCTOSPIM_PCR_IOHSRC_0) == 0U)
 8008286:	68bb      	ldr	r3, [r7, #8]
 8008288:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 800828c:	2b00      	cmp	r3, #0
 800828e:	d106      	bne.n	800829e <OSPIM_GetConfig+0x146>
          {
            cfg->IOHighPort = (OCTOSPIM_PCR_IOLEN | (index + 1U));
 8008290:	68fb      	ldr	r3, [r7, #12]
 8008292:	3301      	adds	r3, #1
 8008294:	f443 3280 	orr.w	r2, r3, #65536	@ 0x10000
 8008298:	683b      	ldr	r3, [r7, #0]
 800829a:	611a      	str	r2, [r3, #16]
 800829c:	e005      	b.n	80082aa <OSPIM_GetConfig+0x152>
          }
          else
          {
            cfg->IOHighPort = (OCTOSPIM_PCR_IOHEN | (index + 1U));
 800829e:	68fb      	ldr	r3, [r7, #12]
 80082a0:	3301      	adds	r3, #1
 80082a2:	f043 7280 	orr.w	r2, r3, #16777216	@ 0x1000000
 80082a6:	683b      	ldr	r3, [r7, #0]
 80082a8:	611a      	str	r2, [r3, #16]
    for (index = 0U; index < OSPI_IOM_NB_PORTS; index ++)
 80082aa:	68fb      	ldr	r3, [r7, #12]
 80082ac:	3301      	adds	r3, #1
 80082ae:	60fb      	str	r3, [r7, #12]
 80082b0:	68fb      	ldr	r3, [r7, #12]
 80082b2:	2b01      	cmp	r3, #1
 80082b4:	d987      	bls.n	80081c6 <OSPIM_GetConfig+0x6e>
      }
    }
  }

  /* Return function status */
  return status;
 80082b6:	7dfb      	ldrb	r3, [r7, #23]
}
 80082b8:	4618      	mov	r0, r3
 80082ba:	371c      	adds	r7, #28
 80082bc:	46bd      	mov	sp, r7
 80082be:	f85d 7b04 	ldr.w	r7, [sp], #4
 80082c2:	4770      	bx	lr
 80082c4:	5200b400 	.word	0x5200b400
 80082c8:	04040222 	.word	0x04040222

080082cc <HAL_PCD_Init>:
  *         parameters in the PCD_InitTypeDef and initialize the associated handle.
  * @param  hpcd PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Init(PCD_HandleTypeDef *hpcd)
{
 80082cc:	b580      	push	{r7, lr}
 80082ce:	b086      	sub	sp, #24
 80082d0:	af02      	add	r7, sp, #8
 80082d2:	6078      	str	r0, [r7, #4]
  uint8_t i;

  /* Check the PCD handle allocation */
  if (hpcd == NULL)
 80082d4:	687b      	ldr	r3, [r7, #4]
 80082d6:	2b00      	cmp	r3, #0
 80082d8:	d101      	bne.n	80082de <HAL_PCD_Init+0x12>
  {
    return HAL_ERROR;
 80082da:	2301      	movs	r3, #1
 80082dc:	e0fe      	b.n	80084dc <HAL_PCD_Init+0x210>
  }

  /* Check the parameters */
  assert_param(IS_PCD_ALL_INSTANCE(hpcd->Instance));

  if (hpcd->State == HAL_PCD_STATE_RESET)
 80082de:	687b      	ldr	r3, [r7, #4]
 80082e0:	f893 3495 	ldrb.w	r3, [r3, #1173]	@ 0x495
 80082e4:	b2db      	uxtb	r3, r3
 80082e6:	2b00      	cmp	r3, #0
 80082e8:	d106      	bne.n	80082f8 <HAL_PCD_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    hpcd->Lock = HAL_UNLOCKED;
 80082ea:	687b      	ldr	r3, [r7, #4]
 80082ec:	2200      	movs	r2, #0
 80082ee:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494

    /* Init the low level hardware */
    hpcd->MspInitCallback(hpcd);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_PCD_MspInit(hpcd);
 80082f2:	6878      	ldr	r0, [r7, #4]
 80082f4:	f00a fb32 	bl	801295c <HAL_PCD_MspInit>
#endif /* (USE_HAL_PCD_REGISTER_CALLBACKS) */
  }

  hpcd->State = HAL_PCD_STATE_BUSY;
 80082f8:	687b      	ldr	r3, [r7, #4]
 80082fa:	2203      	movs	r2, #3
 80082fc:	f883 2495 	strb.w	r2, [r3, #1173]	@ 0x495

  /* Disable the Interrupts */
  __HAL_PCD_DISABLE(hpcd);
 8008300:	687b      	ldr	r3, [r7, #4]
 8008302:	681b      	ldr	r3, [r3, #0]
 8008304:	4618      	mov	r0, r3
 8008306:	f007 f888 	bl	800f41a <USB_DisableGlobalInt>

  /*Init the Core (common init.) */
  if (USB_CoreInit(hpcd->Instance, hpcd->Init) != HAL_OK)
 800830a:	687b      	ldr	r3, [r7, #4]
 800830c:	6818      	ldr	r0, [r3, #0]
 800830e:	687b      	ldr	r3, [r7, #4]
 8008310:	7c1a      	ldrb	r2, [r3, #16]
 8008312:	f88d 2000 	strb.w	r2, [sp]
 8008316:	3304      	adds	r3, #4
 8008318:	cb0e      	ldmia	r3, {r1, r2, r3}
 800831a:	f006 ff59 	bl	800f1d0 <USB_CoreInit>
 800831e:	4603      	mov	r3, r0
 8008320:	2b00      	cmp	r3, #0
 8008322:	d005      	beq.n	8008330 <HAL_PCD_Init+0x64>
  {
    hpcd->State = HAL_PCD_STATE_ERROR;
 8008324:	687b      	ldr	r3, [r7, #4]
 8008326:	2202      	movs	r2, #2
 8008328:	f883 2495 	strb.w	r2, [r3, #1173]	@ 0x495
    return HAL_ERROR;
 800832c:	2301      	movs	r3, #1
 800832e:	e0d5      	b.n	80084dc <HAL_PCD_Init+0x210>
  }

  /* Force Device Mode */
  if (USB_SetCurrentMode(hpcd->Instance, USB_DEVICE_MODE) != HAL_OK)
 8008330:	687b      	ldr	r3, [r7, #4]
 8008332:	681b      	ldr	r3, [r3, #0]
 8008334:	2100      	movs	r1, #0
 8008336:	4618      	mov	r0, r3
 8008338:	f007 f880 	bl	800f43c <USB_SetCurrentMode>
 800833c:	4603      	mov	r3, r0
 800833e:	2b00      	cmp	r3, #0
 8008340:	d005      	beq.n	800834e <HAL_PCD_Init+0x82>
  {
    hpcd->State = HAL_PCD_STATE_ERROR;
 8008342:	687b      	ldr	r3, [r7, #4]
 8008344:	2202      	movs	r2, #2
 8008346:	f883 2495 	strb.w	r2, [r3, #1173]	@ 0x495
    return HAL_ERROR;
 800834a:	2301      	movs	r3, #1
 800834c:	e0c6      	b.n	80084dc <HAL_PCD_Init+0x210>
  }

  /* Init endpoints structures */
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 800834e:	2300      	movs	r3, #0
 8008350:	73fb      	strb	r3, [r7, #15]
 8008352:	e04a      	b.n	80083ea <HAL_PCD_Init+0x11e>
  {
    /* Init ep structure */
    hpcd->IN_ep[i].is_in = 1U;
 8008354:	7bfa      	ldrb	r2, [r7, #15]
 8008356:	6879      	ldr	r1, [r7, #4]
 8008358:	4613      	mov	r3, r2
 800835a:	00db      	lsls	r3, r3, #3
 800835c:	4413      	add	r3, r2
 800835e:	009b      	lsls	r3, r3, #2
 8008360:	440b      	add	r3, r1
 8008362:	3315      	adds	r3, #21
 8008364:	2201      	movs	r2, #1
 8008366:	701a      	strb	r2, [r3, #0]
    hpcd->IN_ep[i].num = i;
 8008368:	7bfa      	ldrb	r2, [r7, #15]
 800836a:	6879      	ldr	r1, [r7, #4]
 800836c:	4613      	mov	r3, r2
 800836e:	00db      	lsls	r3, r3, #3
 8008370:	4413      	add	r3, r2
 8008372:	009b      	lsls	r3, r3, #2
 8008374:	440b      	add	r3, r1
 8008376:	3314      	adds	r3, #20
 8008378:	7bfa      	ldrb	r2, [r7, #15]
 800837a:	701a      	strb	r2, [r3, #0]
    hpcd->IN_ep[i].tx_fifo_num = i;
 800837c:	7bfa      	ldrb	r2, [r7, #15]
 800837e:	7bfb      	ldrb	r3, [r7, #15]
 8008380:	b298      	uxth	r0, r3
 8008382:	6879      	ldr	r1, [r7, #4]
 8008384:	4613      	mov	r3, r2
 8008386:	00db      	lsls	r3, r3, #3
 8008388:	4413      	add	r3, r2
 800838a:	009b      	lsls	r3, r3, #2
 800838c:	440b      	add	r3, r1
 800838e:	332e      	adds	r3, #46	@ 0x2e
 8008390:	4602      	mov	r2, r0
 8008392:	801a      	strh	r2, [r3, #0]
    /* Control until ep is activated */
    hpcd->IN_ep[i].type = EP_TYPE_CTRL;
 8008394:	7bfa      	ldrb	r2, [r7, #15]
 8008396:	6879      	ldr	r1, [r7, #4]
 8008398:	4613      	mov	r3, r2
 800839a:	00db      	lsls	r3, r3, #3
 800839c:	4413      	add	r3, r2
 800839e:	009b      	lsls	r3, r3, #2
 80083a0:	440b      	add	r3, r1
 80083a2:	3318      	adds	r3, #24
 80083a4:	2200      	movs	r2, #0
 80083a6:	701a      	strb	r2, [r3, #0]
    hpcd->IN_ep[i].maxpacket = 0U;
 80083a8:	7bfa      	ldrb	r2, [r7, #15]
 80083aa:	6879      	ldr	r1, [r7, #4]
 80083ac:	4613      	mov	r3, r2
 80083ae:	00db      	lsls	r3, r3, #3
 80083b0:	4413      	add	r3, r2
 80083b2:	009b      	lsls	r3, r3, #2
 80083b4:	440b      	add	r3, r1
 80083b6:	331c      	adds	r3, #28
 80083b8:	2200      	movs	r2, #0
 80083ba:	601a      	str	r2, [r3, #0]
    hpcd->IN_ep[i].xfer_buff = 0U;
 80083bc:	7bfa      	ldrb	r2, [r7, #15]
 80083be:	6879      	ldr	r1, [r7, #4]
 80083c0:	4613      	mov	r3, r2
 80083c2:	00db      	lsls	r3, r3, #3
 80083c4:	4413      	add	r3, r2
 80083c6:	009b      	lsls	r3, r3, #2
 80083c8:	440b      	add	r3, r1
 80083ca:	3320      	adds	r3, #32
 80083cc:	2200      	movs	r2, #0
 80083ce:	601a      	str	r2, [r3, #0]
    hpcd->IN_ep[i].xfer_len = 0U;
 80083d0:	7bfa      	ldrb	r2, [r7, #15]
 80083d2:	6879      	ldr	r1, [r7, #4]
 80083d4:	4613      	mov	r3, r2
 80083d6:	00db      	lsls	r3, r3, #3
 80083d8:	4413      	add	r3, r2
 80083da:	009b      	lsls	r3, r3, #2
 80083dc:	440b      	add	r3, r1
 80083de:	3324      	adds	r3, #36	@ 0x24
 80083e0:	2200      	movs	r2, #0
 80083e2:	601a      	str	r2, [r3, #0]
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 80083e4:	7bfb      	ldrb	r3, [r7, #15]
 80083e6:	3301      	adds	r3, #1
 80083e8:	73fb      	strb	r3, [r7, #15]
 80083ea:	687b      	ldr	r3, [r7, #4]
 80083ec:	791b      	ldrb	r3, [r3, #4]
 80083ee:	7bfa      	ldrb	r2, [r7, #15]
 80083f0:	429a      	cmp	r2, r3
 80083f2:	d3af      	bcc.n	8008354 <HAL_PCD_Init+0x88>
  }

  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 80083f4:	2300      	movs	r3, #0
 80083f6:	73fb      	strb	r3, [r7, #15]
 80083f8:	e044      	b.n	8008484 <HAL_PCD_Init+0x1b8>
  {
    hpcd->OUT_ep[i].is_in = 0U;
 80083fa:	7bfa      	ldrb	r2, [r7, #15]
 80083fc:	6879      	ldr	r1, [r7, #4]
 80083fe:	4613      	mov	r3, r2
 8008400:	00db      	lsls	r3, r3, #3
 8008402:	4413      	add	r3, r2
 8008404:	009b      	lsls	r3, r3, #2
 8008406:	440b      	add	r3, r1
 8008408:	f203 2355 	addw	r3, r3, #597	@ 0x255
 800840c:	2200      	movs	r2, #0
 800840e:	701a      	strb	r2, [r3, #0]
    hpcd->OUT_ep[i].num = i;
 8008410:	7bfa      	ldrb	r2, [r7, #15]
 8008412:	6879      	ldr	r1, [r7, #4]
 8008414:	4613      	mov	r3, r2
 8008416:	00db      	lsls	r3, r3, #3
 8008418:	4413      	add	r3, r2
 800841a:	009b      	lsls	r3, r3, #2
 800841c:	440b      	add	r3, r1
 800841e:	f503 7315 	add.w	r3, r3, #596	@ 0x254
 8008422:	7bfa      	ldrb	r2, [r7, #15]
 8008424:	701a      	strb	r2, [r3, #0]
    /* Control until ep is activated */
    hpcd->OUT_ep[i].type = EP_TYPE_CTRL;
 8008426:	7bfa      	ldrb	r2, [r7, #15]
 8008428:	6879      	ldr	r1, [r7, #4]
 800842a:	4613      	mov	r3, r2
 800842c:	00db      	lsls	r3, r3, #3
 800842e:	4413      	add	r3, r2
 8008430:	009b      	lsls	r3, r3, #2
 8008432:	440b      	add	r3, r1
 8008434:	f503 7316 	add.w	r3, r3, #600	@ 0x258
 8008438:	2200      	movs	r2, #0
 800843a:	701a      	strb	r2, [r3, #0]
    hpcd->OUT_ep[i].maxpacket = 0U;
 800843c:	7bfa      	ldrb	r2, [r7, #15]
 800843e:	6879      	ldr	r1, [r7, #4]
 8008440:	4613      	mov	r3, r2
 8008442:	00db      	lsls	r3, r3, #3
 8008444:	4413      	add	r3, r2
 8008446:	009b      	lsls	r3, r3, #2
 8008448:	440b      	add	r3, r1
 800844a:	f503 7317 	add.w	r3, r3, #604	@ 0x25c
 800844e:	2200      	movs	r2, #0
 8008450:	601a      	str	r2, [r3, #0]
    hpcd->OUT_ep[i].xfer_buff = 0U;
 8008452:	7bfa      	ldrb	r2, [r7, #15]
 8008454:	6879      	ldr	r1, [r7, #4]
 8008456:	4613      	mov	r3, r2
 8008458:	00db      	lsls	r3, r3, #3
 800845a:	4413      	add	r3, r2
 800845c:	009b      	lsls	r3, r3, #2
 800845e:	440b      	add	r3, r1
 8008460:	f503 7318 	add.w	r3, r3, #608	@ 0x260
 8008464:	2200      	movs	r2, #0
 8008466:	601a      	str	r2, [r3, #0]
    hpcd->OUT_ep[i].xfer_len = 0U;
 8008468:	7bfa      	ldrb	r2, [r7, #15]
 800846a:	6879      	ldr	r1, [r7, #4]
 800846c:	4613      	mov	r3, r2
 800846e:	00db      	lsls	r3, r3, #3
 8008470:	4413      	add	r3, r2
 8008472:	009b      	lsls	r3, r3, #2
 8008474:	440b      	add	r3, r1
 8008476:	f503 7319 	add.w	r3, r3, #612	@ 0x264
 800847a:	2200      	movs	r2, #0
 800847c:	601a      	str	r2, [r3, #0]
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 800847e:	7bfb      	ldrb	r3, [r7, #15]
 8008480:	3301      	adds	r3, #1
 8008482:	73fb      	strb	r3, [r7, #15]
 8008484:	687b      	ldr	r3, [r7, #4]
 8008486:	791b      	ldrb	r3, [r3, #4]
 8008488:	7bfa      	ldrb	r2, [r7, #15]
 800848a:	429a      	cmp	r2, r3
 800848c:	d3b5      	bcc.n	80083fa <HAL_PCD_Init+0x12e>
  }

  /* Init Device */
  if (USB_DevInit(hpcd->Instance, hpcd->Init) != HAL_OK)
 800848e:	687b      	ldr	r3, [r7, #4]
 8008490:	6818      	ldr	r0, [r3, #0]
 8008492:	687b      	ldr	r3, [r7, #4]
 8008494:	7c1a      	ldrb	r2, [r3, #16]
 8008496:	f88d 2000 	strb.w	r2, [sp]
 800849a:	3304      	adds	r3, #4
 800849c:	cb0e      	ldmia	r3, {r1, r2, r3}
 800849e:	f007 f819 	bl	800f4d4 <USB_DevInit>
 80084a2:	4603      	mov	r3, r0
 80084a4:	2b00      	cmp	r3, #0
 80084a6:	d005      	beq.n	80084b4 <HAL_PCD_Init+0x1e8>
  {
    hpcd->State = HAL_PCD_STATE_ERROR;
 80084a8:	687b      	ldr	r3, [r7, #4]
 80084aa:	2202      	movs	r2, #2
 80084ac:	f883 2495 	strb.w	r2, [r3, #1173]	@ 0x495
    return HAL_ERROR;
 80084b0:	2301      	movs	r3, #1
 80084b2:	e013      	b.n	80084dc <HAL_PCD_Init+0x210>
  }

  hpcd->USB_Address = 0U;
 80084b4:	687b      	ldr	r3, [r7, #4]
 80084b6:	2200      	movs	r2, #0
 80084b8:	745a      	strb	r2, [r3, #17]
  hpcd->State = HAL_PCD_STATE_READY;
 80084ba:	687b      	ldr	r3, [r7, #4]
 80084bc:	2201      	movs	r2, #1
 80084be:	f883 2495 	strb.w	r2, [r3, #1173]	@ 0x495

  /* Activate LPM */
  if (hpcd->Init.lpm_enable == 1U)
 80084c2:	687b      	ldr	r3, [r7, #4]
 80084c4:	7b1b      	ldrb	r3, [r3, #12]
 80084c6:	2b01      	cmp	r3, #1
 80084c8:	d102      	bne.n	80084d0 <HAL_PCD_Init+0x204>
  {
    (void)HAL_PCDEx_ActivateLPM(hpcd);
 80084ca:	6878      	ldr	r0, [r7, #4]
 80084cc:	f001 f96c 	bl	80097a8 <HAL_PCDEx_ActivateLPM>
  }

  (void)USB_DevDisconnect(hpcd->Instance);
 80084d0:	687b      	ldr	r3, [r7, #4]
 80084d2:	681b      	ldr	r3, [r3, #0]
 80084d4:	4618      	mov	r0, r3
 80084d6:	f008 f858 	bl	801058a <USB_DevDisconnect>

  return HAL_OK;
 80084da:	2300      	movs	r3, #0
}
 80084dc:	4618      	mov	r0, r3
 80084de:	3710      	adds	r7, #16
 80084e0:	46bd      	mov	sp, r7
 80084e2:	bd80      	pop	{r7, pc}

080084e4 <HAL_PCD_Start>:
  * @brief  Start the USB device
  * @param  hpcd PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Start(PCD_HandleTypeDef *hpcd)
{
 80084e4:	b580      	push	{r7, lr}
 80084e6:	b084      	sub	sp, #16
 80084e8:	af00      	add	r7, sp, #0
 80084ea:	6078      	str	r0, [r7, #4]
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 80084ec:	687b      	ldr	r3, [r7, #4]
 80084ee:	681b      	ldr	r3, [r3, #0]
 80084f0:	60fb      	str	r3, [r7, #12]

  __HAL_LOCK(hpcd);
 80084f2:	687b      	ldr	r3, [r7, #4]
 80084f4:	f893 3494 	ldrb.w	r3, [r3, #1172]	@ 0x494
 80084f8:	2b01      	cmp	r3, #1
 80084fa:	d101      	bne.n	8008500 <HAL_PCD_Start+0x1c>
 80084fc:	2302      	movs	r3, #2
 80084fe:	e022      	b.n	8008546 <HAL_PCD_Start+0x62>
 8008500:	687b      	ldr	r3, [r7, #4]
 8008502:	2201      	movs	r2, #1
 8008504:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494

  if (((USBx->GUSBCFG & USB_OTG_GUSBCFG_PHYSEL) != 0U) &&
 8008508:	68fb      	ldr	r3, [r7, #12]
 800850a:	68db      	ldr	r3, [r3, #12]
 800850c:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8008510:	2b00      	cmp	r3, #0
 8008512:	d009      	beq.n	8008528 <HAL_PCD_Start+0x44>
      (hpcd->Init.battery_charging_enable == 1U))
 8008514:	687b      	ldr	r3, [r7, #4]
 8008516:	7b5b      	ldrb	r3, [r3, #13]
  if (((USBx->GUSBCFG & USB_OTG_GUSBCFG_PHYSEL) != 0U) &&
 8008518:	2b01      	cmp	r3, #1
 800851a:	d105      	bne.n	8008528 <HAL_PCD_Start+0x44>
  {
    /* Enable USB Transceiver */
    USBx->GCCFG |= USB_OTG_GCCFG_PWRDWN;
 800851c:	68fb      	ldr	r3, [r7, #12]
 800851e:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8008520:	f443 3280 	orr.w	r2, r3, #65536	@ 0x10000
 8008524:	68fb      	ldr	r3, [r7, #12]
 8008526:	639a      	str	r2, [r3, #56]	@ 0x38
  }

  __HAL_PCD_ENABLE(hpcd);
 8008528:	687b      	ldr	r3, [r7, #4]
 800852a:	681b      	ldr	r3, [r3, #0]
 800852c:	4618      	mov	r0, r3
 800852e:	f006 ff63 	bl	800f3f8 <USB_EnableGlobalInt>
  (void)USB_DevConnect(hpcd->Instance);
 8008532:	687b      	ldr	r3, [r7, #4]
 8008534:	681b      	ldr	r3, [r3, #0]
 8008536:	4618      	mov	r0, r3
 8008538:	f008 f806 	bl	8010548 <USB_DevConnect>
  __HAL_UNLOCK(hpcd);
 800853c:	687b      	ldr	r3, [r7, #4]
 800853e:	2200      	movs	r2, #0
 8008540:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494

  return HAL_OK;
 8008544:	2300      	movs	r3, #0
}
 8008546:	4618      	mov	r0, r3
 8008548:	3710      	adds	r7, #16
 800854a:	46bd      	mov	sp, r7
 800854c:	bd80      	pop	{r7, pc}

0800854e <HAL_PCD_IRQHandler>:
  * @brief  Handles PCD interrupt request.
  * @param  hpcd PCD handle
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
 800854e:	b590      	push	{r4, r7, lr}
 8008550:	b08d      	sub	sp, #52	@ 0x34
 8008552:	af00      	add	r7, sp, #0
 8008554:	6078      	str	r0, [r7, #4]
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 8008556:	687b      	ldr	r3, [r7, #4]
 8008558:	681b      	ldr	r3, [r3, #0]
 800855a:	623b      	str	r3, [r7, #32]
  uint32_t USBx_BASE = (uint32_t)USBx;
 800855c:	6a3b      	ldr	r3, [r7, #32]
 800855e:	61fb      	str	r3, [r7, #28]
  uint32_t epnum;
  uint32_t fifoemptymsk;
  uint32_t RegVal;

  /* ensure that we are in device mode */
  if (USB_GetMode(hpcd->Instance) == USB_OTG_MODE_DEVICE)
 8008560:	687b      	ldr	r3, [r7, #4]
 8008562:	681b      	ldr	r3, [r3, #0]
 8008564:	4618      	mov	r0, r3
 8008566:	f008 f8c4 	bl	80106f2 <USB_GetMode>
 800856a:	4603      	mov	r3, r0
 800856c:	2b00      	cmp	r3, #0
 800856e:	f040 84b9 	bne.w	8008ee4 <HAL_PCD_IRQHandler+0x996>
  {
    /* avoid spurious interrupt */
    if (__HAL_PCD_IS_INVALID_INTERRUPT(hpcd))
 8008572:	687b      	ldr	r3, [r7, #4]
 8008574:	681b      	ldr	r3, [r3, #0]
 8008576:	4618      	mov	r0, r3
 8008578:	f008 f828 	bl	80105cc <USB_ReadInterrupts>
 800857c:	4603      	mov	r3, r0
 800857e:	2b00      	cmp	r3, #0
 8008580:	f000 84af 	beq.w	8008ee2 <HAL_PCD_IRQHandler+0x994>
    {
      return;
    }

    /* store current frame number */
    hpcd->FrameNumber = (USBx_DEVICE->DSTS & USB_OTG_DSTS_FNSOF_Msk) >> USB_OTG_DSTS_FNSOF_Pos;
 8008584:	69fb      	ldr	r3, [r7, #28]
 8008586:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 800858a:	689b      	ldr	r3, [r3, #8]
 800858c:	0a1b      	lsrs	r3, r3, #8
 800858e:	f3c3 020d 	ubfx	r2, r3, #0, #14
 8008592:	687b      	ldr	r3, [r7, #4]
 8008594:	f8c3 24d4 	str.w	r2, [r3, #1236]	@ 0x4d4

    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_MMIS))
 8008598:	687b      	ldr	r3, [r7, #4]
 800859a:	681b      	ldr	r3, [r3, #0]
 800859c:	4618      	mov	r0, r3
 800859e:	f008 f815 	bl	80105cc <USB_ReadInterrupts>
 80085a2:	4603      	mov	r3, r0
 80085a4:	f003 0302 	and.w	r3, r3, #2
 80085a8:	2b02      	cmp	r3, #2
 80085aa:	d107      	bne.n	80085bc <HAL_PCD_IRQHandler+0x6e>
    {
      /* incorrect mode, acknowledge the interrupt */
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_MMIS);
 80085ac:	687b      	ldr	r3, [r7, #4]
 80085ae:	681b      	ldr	r3, [r3, #0]
 80085b0:	695a      	ldr	r2, [r3, #20]
 80085b2:	687b      	ldr	r3, [r7, #4]
 80085b4:	681b      	ldr	r3, [r3, #0]
 80085b6:	f002 0202 	and.w	r2, r2, #2
 80085ba:	615a      	str	r2, [r3, #20]
    }

    /* Handle RxQLevel Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_RXFLVL))
 80085bc:	687b      	ldr	r3, [r7, #4]
 80085be:	681b      	ldr	r3, [r3, #0]
 80085c0:	4618      	mov	r0, r3
 80085c2:	f008 f803 	bl	80105cc <USB_ReadInterrupts>
 80085c6:	4603      	mov	r3, r0
 80085c8:	f003 0310 	and.w	r3, r3, #16
 80085cc:	2b10      	cmp	r3, #16
 80085ce:	d161      	bne.n	8008694 <HAL_PCD_IRQHandler+0x146>
    {
      USB_MASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 80085d0:	687b      	ldr	r3, [r7, #4]
 80085d2:	681b      	ldr	r3, [r3, #0]
 80085d4:	699a      	ldr	r2, [r3, #24]
 80085d6:	687b      	ldr	r3, [r7, #4]
 80085d8:	681b      	ldr	r3, [r3, #0]
 80085da:	f022 0210 	bic.w	r2, r2, #16
 80085de:	619a      	str	r2, [r3, #24]

      RegVal = USBx->GRXSTSP;
 80085e0:	6a3b      	ldr	r3, [r7, #32]
 80085e2:	6a1b      	ldr	r3, [r3, #32]
 80085e4:	61bb      	str	r3, [r7, #24]

      ep = &hpcd->OUT_ep[RegVal & USB_OTG_GRXSTSP_EPNUM];
 80085e6:	69bb      	ldr	r3, [r7, #24]
 80085e8:	f003 020f 	and.w	r2, r3, #15
 80085ec:	4613      	mov	r3, r2
 80085ee:	00db      	lsls	r3, r3, #3
 80085f0:	4413      	add	r3, r2
 80085f2:	009b      	lsls	r3, r3, #2
 80085f4:	f503 7314 	add.w	r3, r3, #592	@ 0x250
 80085f8:	687a      	ldr	r2, [r7, #4]
 80085fa:	4413      	add	r3, r2
 80085fc:	3304      	adds	r3, #4
 80085fe:	617b      	str	r3, [r7, #20]

      if (((RegVal & USB_OTG_GRXSTSP_PKTSTS) >> 17) ==  STS_DATA_UPDT)
 8008600:	69bb      	ldr	r3, [r7, #24]
 8008602:	0c5b      	lsrs	r3, r3, #17
 8008604:	f003 030f 	and.w	r3, r3, #15
 8008608:	2b02      	cmp	r3, #2
 800860a:	d124      	bne.n	8008656 <HAL_PCD_IRQHandler+0x108>
      {
        if ((RegVal & USB_OTG_GRXSTSP_BCNT) != 0U)
 800860c:	69ba      	ldr	r2, [r7, #24]
 800860e:	f647 73f0 	movw	r3, #32752	@ 0x7ff0
 8008612:	4013      	ands	r3, r2
 8008614:	2b00      	cmp	r3, #0
 8008616:	d035      	beq.n	8008684 <HAL_PCD_IRQHandler+0x136>
        {
          (void)USB_ReadPacket(USBx, ep->xfer_buff,
 8008618:	697b      	ldr	r3, [r7, #20]
 800861a:	68d9      	ldr	r1, [r3, #12]
                               (uint16_t)((RegVal & USB_OTG_GRXSTSP_BCNT) >> 4));
 800861c:	69bb      	ldr	r3, [r7, #24]
 800861e:	091b      	lsrs	r3, r3, #4
 8008620:	b29b      	uxth	r3, r3
          (void)USB_ReadPacket(USBx, ep->xfer_buff,
 8008622:	f3c3 030a 	ubfx	r3, r3, #0, #11
 8008626:	b29b      	uxth	r3, r3
 8008628:	461a      	mov	r2, r3
 800862a:	6a38      	ldr	r0, [r7, #32]
 800862c:	f007 fe3a 	bl	80102a4 <USB_ReadPacket>

          ep->xfer_buff += (RegVal & USB_OTG_GRXSTSP_BCNT) >> 4;
 8008630:	697b      	ldr	r3, [r7, #20]
 8008632:	68da      	ldr	r2, [r3, #12]
 8008634:	69bb      	ldr	r3, [r7, #24]
 8008636:	091b      	lsrs	r3, r3, #4
 8008638:	f3c3 030a 	ubfx	r3, r3, #0, #11
 800863c:	441a      	add	r2, r3
 800863e:	697b      	ldr	r3, [r7, #20]
 8008640:	60da      	str	r2, [r3, #12]
          ep->xfer_count += (RegVal & USB_OTG_GRXSTSP_BCNT) >> 4;
 8008642:	697b      	ldr	r3, [r7, #20]
 8008644:	695a      	ldr	r2, [r3, #20]
 8008646:	69bb      	ldr	r3, [r7, #24]
 8008648:	091b      	lsrs	r3, r3, #4
 800864a:	f3c3 030a 	ubfx	r3, r3, #0, #11
 800864e:	441a      	add	r2, r3
 8008650:	697b      	ldr	r3, [r7, #20]
 8008652:	615a      	str	r2, [r3, #20]
 8008654:	e016      	b.n	8008684 <HAL_PCD_IRQHandler+0x136>
        }
      }
      else if (((RegVal & USB_OTG_GRXSTSP_PKTSTS) >> 17) == STS_SETUP_UPDT)
 8008656:	69bb      	ldr	r3, [r7, #24]
 8008658:	0c5b      	lsrs	r3, r3, #17
 800865a:	f003 030f 	and.w	r3, r3, #15
 800865e:	2b06      	cmp	r3, #6
 8008660:	d110      	bne.n	8008684 <HAL_PCD_IRQHandler+0x136>
      {
        (void)USB_ReadPacket(USBx, (uint8_t *)hpcd->Setup, 8U);
 8008662:	687b      	ldr	r3, [r7, #4]
 8008664:	f203 439c 	addw	r3, r3, #1180	@ 0x49c
 8008668:	2208      	movs	r2, #8
 800866a:	4619      	mov	r1, r3
 800866c:	6a38      	ldr	r0, [r7, #32]
 800866e:	f007 fe19 	bl	80102a4 <USB_ReadPacket>
        ep->xfer_count += (RegVal & USB_OTG_GRXSTSP_BCNT) >> 4;
 8008672:	697b      	ldr	r3, [r7, #20]
 8008674:	695a      	ldr	r2, [r3, #20]
 8008676:	69bb      	ldr	r3, [r7, #24]
 8008678:	091b      	lsrs	r3, r3, #4
 800867a:	f3c3 030a 	ubfx	r3, r3, #0, #11
 800867e:	441a      	add	r2, r3
 8008680:	697b      	ldr	r3, [r7, #20]
 8008682:	615a      	str	r2, [r3, #20]
      else
      {
        /* ... */
      }

      USB_UNMASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 8008684:	687b      	ldr	r3, [r7, #4]
 8008686:	681b      	ldr	r3, [r3, #0]
 8008688:	699a      	ldr	r2, [r3, #24]
 800868a:	687b      	ldr	r3, [r7, #4]
 800868c:	681b      	ldr	r3, [r3, #0]
 800868e:	f042 0210 	orr.w	r2, r2, #16
 8008692:	619a      	str	r2, [r3, #24]
    }

    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OEPINT))
 8008694:	687b      	ldr	r3, [r7, #4]
 8008696:	681b      	ldr	r3, [r3, #0]
 8008698:	4618      	mov	r0, r3
 800869a:	f007 ff97 	bl	80105cc <USB_ReadInterrupts>
 800869e:	4603      	mov	r3, r0
 80086a0:	f403 2300 	and.w	r3, r3, #524288	@ 0x80000
 80086a4:	f5b3 2f00 	cmp.w	r3, #524288	@ 0x80000
 80086a8:	f040 80a7 	bne.w	80087fa <HAL_PCD_IRQHandler+0x2ac>
    {
      epnum = 0U;
 80086ac:	2300      	movs	r3, #0
 80086ae:	627b      	str	r3, [r7, #36]	@ 0x24

      /* Read in the device interrupt bits */
      ep_intr = USB_ReadDevAllOutEpInterrupt(hpcd->Instance);
 80086b0:	687b      	ldr	r3, [r7, #4]
 80086b2:	681b      	ldr	r3, [r3, #0]
 80086b4:	4618      	mov	r0, r3
 80086b6:	f007 ff9c 	bl	80105f2 <USB_ReadDevAllOutEpInterrupt>
 80086ba:	62b8      	str	r0, [r7, #40]	@ 0x28

      while (ep_intr != 0U)
 80086bc:	e099      	b.n	80087f2 <HAL_PCD_IRQHandler+0x2a4>
      {
        if ((ep_intr & 0x1U) != 0U)
 80086be:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80086c0:	f003 0301 	and.w	r3, r3, #1
 80086c4:	2b00      	cmp	r3, #0
 80086c6:	f000 808e 	beq.w	80087e6 <HAL_PCD_IRQHandler+0x298>
        {
          epint = USB_ReadDevOutEPInterrupt(hpcd->Instance, (uint8_t)epnum);
 80086ca:	687b      	ldr	r3, [r7, #4]
 80086cc:	681b      	ldr	r3, [r3, #0]
 80086ce:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 80086d0:	b2d2      	uxtb	r2, r2
 80086d2:	4611      	mov	r1, r2
 80086d4:	4618      	mov	r0, r3
 80086d6:	f007 ffc0 	bl	801065a <USB_ReadDevOutEPInterrupt>
 80086da:	6138      	str	r0, [r7, #16]

          if ((epint & USB_OTG_DOEPINT_XFRC) == USB_OTG_DOEPINT_XFRC)
 80086dc:	693b      	ldr	r3, [r7, #16]
 80086de:	f003 0301 	and.w	r3, r3, #1
 80086e2:	2b00      	cmp	r3, #0
 80086e4:	d00c      	beq.n	8008700 <HAL_PCD_IRQHandler+0x1b2>
          {
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_XFRC);
 80086e6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80086e8:	015a      	lsls	r2, r3, #5
 80086ea:	69fb      	ldr	r3, [r7, #28]
 80086ec:	4413      	add	r3, r2
 80086ee:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 80086f2:	461a      	mov	r2, r3
 80086f4:	2301      	movs	r3, #1
 80086f6:	6093      	str	r3, [r2, #8]
            (void)PCD_EP_OutXfrComplete_int(hpcd, epnum);
 80086f8:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 80086fa:	6878      	ldr	r0, [r7, #4]
 80086fc:	f000 fece 	bl	800949c <PCD_EP_OutXfrComplete_int>
          }

          if ((epint & USB_OTG_DOEPINT_STUP) == USB_OTG_DOEPINT_STUP)
 8008700:	693b      	ldr	r3, [r7, #16]
 8008702:	f003 0308 	and.w	r3, r3, #8
 8008706:	2b00      	cmp	r3, #0
 8008708:	d00c      	beq.n	8008724 <HAL_PCD_IRQHandler+0x1d6>
          {
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STUP);
 800870a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800870c:	015a      	lsls	r2, r3, #5
 800870e:	69fb      	ldr	r3, [r7, #28]
 8008710:	4413      	add	r3, r2
 8008712:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8008716:	461a      	mov	r2, r3
 8008718:	2308      	movs	r3, #8
 800871a:	6093      	str	r3, [r2, #8]
            /* Class B setup phase done for previous decoded setup */
            (void)PCD_EP_OutSetupPacket_int(hpcd, epnum);
 800871c:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 800871e:	6878      	ldr	r0, [r7, #4]
 8008720:	f000 ffa4 	bl	800966c <PCD_EP_OutSetupPacket_int>
          }

          if ((epint & USB_OTG_DOEPINT_OTEPDIS) == USB_OTG_DOEPINT_OTEPDIS)
 8008724:	693b      	ldr	r3, [r7, #16]
 8008726:	f003 0310 	and.w	r3, r3, #16
 800872a:	2b00      	cmp	r3, #0
 800872c:	d008      	beq.n	8008740 <HAL_PCD_IRQHandler+0x1f2>
          {
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPDIS);
 800872e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8008730:	015a      	lsls	r2, r3, #5
 8008732:	69fb      	ldr	r3, [r7, #28]
 8008734:	4413      	add	r3, r2
 8008736:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 800873a:	461a      	mov	r2, r3
 800873c:	2310      	movs	r3, #16
 800873e:	6093      	str	r3, [r2, #8]
          }

          /* Clear OUT Endpoint disable interrupt */
          if ((epint & USB_OTG_DOEPINT_EPDISD) == USB_OTG_DOEPINT_EPDISD)
 8008740:	693b      	ldr	r3, [r7, #16]
 8008742:	f003 0302 	and.w	r3, r3, #2
 8008746:	2b00      	cmp	r3, #0
 8008748:	d030      	beq.n	80087ac <HAL_PCD_IRQHandler+0x25e>
          {
            if ((USBx->GINTSTS & USB_OTG_GINTSTS_BOUTNAKEFF) == USB_OTG_GINTSTS_BOUTNAKEFF)
 800874a:	6a3b      	ldr	r3, [r7, #32]
 800874c:	695b      	ldr	r3, [r3, #20]
 800874e:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8008752:	2b80      	cmp	r3, #128	@ 0x80
 8008754:	d109      	bne.n	800876a <HAL_PCD_IRQHandler+0x21c>
            {
              USBx_DEVICE->DCTL |= USB_OTG_DCTL_CGONAK;
 8008756:	69fb      	ldr	r3, [r7, #28]
 8008758:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 800875c:	685b      	ldr	r3, [r3, #4]
 800875e:	69fa      	ldr	r2, [r7, #28]
 8008760:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 8008764:	f443 6380 	orr.w	r3, r3, #1024	@ 0x400
 8008768:	6053      	str	r3, [r2, #4]
            }

            ep = &hpcd->OUT_ep[epnum];
 800876a:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800876c:	4613      	mov	r3, r2
 800876e:	00db      	lsls	r3, r3, #3
 8008770:	4413      	add	r3, r2
 8008772:	009b      	lsls	r3, r3, #2
 8008774:	f503 7314 	add.w	r3, r3, #592	@ 0x250
 8008778:	687a      	ldr	r2, [r7, #4]
 800877a:	4413      	add	r3, r2
 800877c:	3304      	adds	r3, #4
 800877e:	617b      	str	r3, [r7, #20]

            if (ep->is_iso_incomplete == 1U)
 8008780:	697b      	ldr	r3, [r7, #20]
 8008782:	78db      	ldrb	r3, [r3, #3]
 8008784:	2b01      	cmp	r3, #1
 8008786:	d108      	bne.n	800879a <HAL_PCD_IRQHandler+0x24c>
            {
              ep->is_iso_incomplete = 0U;
 8008788:	697b      	ldr	r3, [r7, #20]
 800878a:	2200      	movs	r2, #0
 800878c:	70da      	strb	r2, [r3, #3]

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
              hpcd->ISOOUTIncompleteCallback(hpcd, (uint8_t)epnum);
#else
              HAL_PCD_ISOOUTIncompleteCallback(hpcd, (uint8_t)epnum);
 800878e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8008790:	b2db      	uxtb	r3, r3
 8008792:	4619      	mov	r1, r3
 8008794:	6878      	ldr	r0, [r7, #4]
 8008796:	f00a f9f5 	bl	8012b84 <HAL_PCD_ISOOUTIncompleteCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
            }

            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_EPDISD);
 800879a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800879c:	015a      	lsls	r2, r3, #5
 800879e:	69fb      	ldr	r3, [r7, #28]
 80087a0:	4413      	add	r3, r2
 80087a2:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 80087a6:	461a      	mov	r2, r3
 80087a8:	2302      	movs	r3, #2
 80087aa:	6093      	str	r3, [r2, #8]
          }

          /* Clear Status Phase Received interrupt */
          if ((epint & USB_OTG_DOEPINT_OTEPSPR) == USB_OTG_DOEPINT_OTEPSPR)
 80087ac:	693b      	ldr	r3, [r7, #16]
 80087ae:	f003 0320 	and.w	r3, r3, #32
 80087b2:	2b00      	cmp	r3, #0
 80087b4:	d008      	beq.n	80087c8 <HAL_PCD_IRQHandler+0x27a>
          {
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPSPR);
 80087b6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80087b8:	015a      	lsls	r2, r3, #5
 80087ba:	69fb      	ldr	r3, [r7, #28]
 80087bc:	4413      	add	r3, r2
 80087be:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 80087c2:	461a      	mov	r2, r3
 80087c4:	2320      	movs	r3, #32
 80087c6:	6093      	str	r3, [r2, #8]
          }

          /* Clear OUT NAK interrupt */
          if ((epint & USB_OTG_DOEPINT_NAK) == USB_OTG_DOEPINT_NAK)
 80087c8:	693b      	ldr	r3, [r7, #16]
 80087ca:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
 80087ce:	2b00      	cmp	r3, #0
 80087d0:	d009      	beq.n	80087e6 <HAL_PCD_IRQHandler+0x298>
          {
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_NAK);
 80087d2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80087d4:	015a      	lsls	r2, r3, #5
 80087d6:	69fb      	ldr	r3, [r7, #28]
 80087d8:	4413      	add	r3, r2
 80087da:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 80087de:	461a      	mov	r2, r3
 80087e0:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
 80087e4:	6093      	str	r3, [r2, #8]
          }
        }
        epnum++;
 80087e6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80087e8:	3301      	adds	r3, #1
 80087ea:	627b      	str	r3, [r7, #36]	@ 0x24
        ep_intr >>= 1U;
 80087ec:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80087ee:	085b      	lsrs	r3, r3, #1
 80087f0:	62bb      	str	r3, [r7, #40]	@ 0x28
      while (ep_intr != 0U)
 80087f2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80087f4:	2b00      	cmp	r3, #0
 80087f6:	f47f af62 	bne.w	80086be <HAL_PCD_IRQHandler+0x170>
      }
    }

    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IEPINT))
 80087fa:	687b      	ldr	r3, [r7, #4]
 80087fc:	681b      	ldr	r3, [r3, #0]
 80087fe:	4618      	mov	r0, r3
 8008800:	f007 fee4 	bl	80105cc <USB_ReadInterrupts>
 8008804:	4603      	mov	r3, r0
 8008806:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
 800880a:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
 800880e:	f040 80db 	bne.w	80089c8 <HAL_PCD_IRQHandler+0x47a>
    {
      /* Read in the device interrupt bits */
      ep_intr = USB_ReadDevAllInEpInterrupt(hpcd->Instance);
 8008812:	687b      	ldr	r3, [r7, #4]
 8008814:	681b      	ldr	r3, [r3, #0]
 8008816:	4618      	mov	r0, r3
 8008818:	f007 ff05 	bl	8010626 <USB_ReadDevAllInEpInterrupt>
 800881c:	62b8      	str	r0, [r7, #40]	@ 0x28

      epnum = 0U;
 800881e:	2300      	movs	r3, #0
 8008820:	627b      	str	r3, [r7, #36]	@ 0x24

      while (ep_intr != 0U)
 8008822:	e0cd      	b.n	80089c0 <HAL_PCD_IRQHandler+0x472>
      {
        if ((ep_intr & 0x1U) != 0U) /* In ITR */
 8008824:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8008826:	f003 0301 	and.w	r3, r3, #1
 800882a:	2b00      	cmp	r3, #0
 800882c:	f000 80c2 	beq.w	80089b4 <HAL_PCD_IRQHandler+0x466>
        {
          epint = USB_ReadDevInEPInterrupt(hpcd->Instance, (uint8_t)epnum);
 8008830:	687b      	ldr	r3, [r7, #4]
 8008832:	681b      	ldr	r3, [r3, #0]
 8008834:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8008836:	b2d2      	uxtb	r2, r2
 8008838:	4611      	mov	r1, r2
 800883a:	4618      	mov	r0, r3
 800883c:	f007 ff2b 	bl	8010696 <USB_ReadDevInEPInterrupt>
 8008840:	6138      	str	r0, [r7, #16]

          if ((epint & USB_OTG_DIEPINT_XFRC) == USB_OTG_DIEPINT_XFRC)
 8008842:	693b      	ldr	r3, [r7, #16]
 8008844:	f003 0301 	and.w	r3, r3, #1
 8008848:	2b00      	cmp	r3, #0
 800884a:	d057      	beq.n	80088fc <HAL_PCD_IRQHandler+0x3ae>
          {
            fifoemptymsk = (uint32_t)(0x1UL << (epnum & EP_ADDR_MSK));
 800884c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800884e:	f003 030f 	and.w	r3, r3, #15
 8008852:	2201      	movs	r2, #1
 8008854:	fa02 f303 	lsl.w	r3, r2, r3
 8008858:	60fb      	str	r3, [r7, #12]
            USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 800885a:	69fb      	ldr	r3, [r7, #28]
 800885c:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8008860:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 8008862:	68fb      	ldr	r3, [r7, #12]
 8008864:	43db      	mvns	r3, r3
 8008866:	69f9      	ldr	r1, [r7, #28]
 8008868:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
 800886c:	4013      	ands	r3, r2
 800886e:	634b      	str	r3, [r1, #52]	@ 0x34

            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_XFRC);
 8008870:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8008872:	015a      	lsls	r2, r3, #5
 8008874:	69fb      	ldr	r3, [r7, #28]
 8008876:	4413      	add	r3, r2
 8008878:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 800887c:	461a      	mov	r2, r3
 800887e:	2301      	movs	r3, #1
 8008880:	6093      	str	r3, [r2, #8]

            if (hpcd->Init.dma_enable == 1U)
 8008882:	687b      	ldr	r3, [r7, #4]
 8008884:	799b      	ldrb	r3, [r3, #6]
 8008886:	2b01      	cmp	r3, #1
 8008888:	d132      	bne.n	80088f0 <HAL_PCD_IRQHandler+0x3a2>
            {
              hpcd->IN_ep[epnum].xfer_buff += hpcd->IN_ep[epnum].maxpacket;
 800888a:	6879      	ldr	r1, [r7, #4]
 800888c:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800888e:	4613      	mov	r3, r2
 8008890:	00db      	lsls	r3, r3, #3
 8008892:	4413      	add	r3, r2
 8008894:	009b      	lsls	r3, r3, #2
 8008896:	440b      	add	r3, r1
 8008898:	3320      	adds	r3, #32
 800889a:	6819      	ldr	r1, [r3, #0]
 800889c:	6878      	ldr	r0, [r7, #4]
 800889e:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 80088a0:	4613      	mov	r3, r2
 80088a2:	00db      	lsls	r3, r3, #3
 80088a4:	4413      	add	r3, r2
 80088a6:	009b      	lsls	r3, r3, #2
 80088a8:	4403      	add	r3, r0
 80088aa:	331c      	adds	r3, #28
 80088ac:	681b      	ldr	r3, [r3, #0]
 80088ae:	4419      	add	r1, r3
 80088b0:	6878      	ldr	r0, [r7, #4]
 80088b2:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 80088b4:	4613      	mov	r3, r2
 80088b6:	00db      	lsls	r3, r3, #3
 80088b8:	4413      	add	r3, r2
 80088ba:	009b      	lsls	r3, r3, #2
 80088bc:	4403      	add	r3, r0
 80088be:	3320      	adds	r3, #32
 80088c0:	6019      	str	r1, [r3, #0]

              /* this is ZLP, so prepare EP0 for next setup */
              if ((epnum == 0U) && (hpcd->IN_ep[epnum].xfer_len == 0U))
 80088c2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80088c4:	2b00      	cmp	r3, #0
 80088c6:	d113      	bne.n	80088f0 <HAL_PCD_IRQHandler+0x3a2>
 80088c8:	6879      	ldr	r1, [r7, #4]
 80088ca:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 80088cc:	4613      	mov	r3, r2
 80088ce:	00db      	lsls	r3, r3, #3
 80088d0:	4413      	add	r3, r2
 80088d2:	009b      	lsls	r3, r3, #2
 80088d4:	440b      	add	r3, r1
 80088d6:	3324      	adds	r3, #36	@ 0x24
 80088d8:	681b      	ldr	r3, [r3, #0]
 80088da:	2b00      	cmp	r3, #0
 80088dc:	d108      	bne.n	80088f0 <HAL_PCD_IRQHandler+0x3a2>
              {
                /* prepare to rx more setup packets */
                (void)USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);
 80088de:	687b      	ldr	r3, [r7, #4]
 80088e0:	6818      	ldr	r0, [r3, #0]
 80088e2:	687b      	ldr	r3, [r7, #4]
 80088e4:	f203 439c 	addw	r3, r3, #1180	@ 0x49c
 80088e8:	461a      	mov	r2, r3
 80088ea:	2101      	movs	r1, #1
 80088ec:	f007 ff34 	bl	8010758 <USB_EP0_OutStart>
            }

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
            hpcd->DataInStageCallback(hpcd, (uint8_t)epnum);
#else
            HAL_PCD_DataInStageCallback(hpcd, (uint8_t)epnum);
 80088f0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80088f2:	b2db      	uxtb	r3, r3
 80088f4:	4619      	mov	r1, r3
 80088f6:	6878      	ldr	r0, [r7, #4]
 80088f8:	f00a f8bf 	bl	8012a7a <HAL_PCD_DataInStageCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
          }
          if ((epint & USB_OTG_DIEPINT_TOC) == USB_OTG_DIEPINT_TOC)
 80088fc:	693b      	ldr	r3, [r7, #16]
 80088fe:	f003 0308 	and.w	r3, r3, #8
 8008902:	2b00      	cmp	r3, #0
 8008904:	d008      	beq.n	8008918 <HAL_PCD_IRQHandler+0x3ca>
          {
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_TOC);
 8008906:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8008908:	015a      	lsls	r2, r3, #5
 800890a:	69fb      	ldr	r3, [r7, #28]
 800890c:	4413      	add	r3, r2
 800890e:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8008912:	461a      	mov	r2, r3
 8008914:	2308      	movs	r3, #8
 8008916:	6093      	str	r3, [r2, #8]
          }
          if ((epint & USB_OTG_DIEPINT_ITTXFE) == USB_OTG_DIEPINT_ITTXFE)
 8008918:	693b      	ldr	r3, [r7, #16]
 800891a:	f003 0310 	and.w	r3, r3, #16
 800891e:	2b00      	cmp	r3, #0
 8008920:	d008      	beq.n	8008934 <HAL_PCD_IRQHandler+0x3e6>
          {
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_ITTXFE);
 8008922:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8008924:	015a      	lsls	r2, r3, #5
 8008926:	69fb      	ldr	r3, [r7, #28]
 8008928:	4413      	add	r3, r2
 800892a:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 800892e:	461a      	mov	r2, r3
 8008930:	2310      	movs	r3, #16
 8008932:	6093      	str	r3, [r2, #8]
          }
          if ((epint & USB_OTG_DIEPINT_INEPNE) == USB_OTG_DIEPINT_INEPNE)
 8008934:	693b      	ldr	r3, [r7, #16]
 8008936:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 800893a:	2b00      	cmp	r3, #0
 800893c:	d008      	beq.n	8008950 <HAL_PCD_IRQHandler+0x402>
          {
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_INEPNE);
 800893e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8008940:	015a      	lsls	r2, r3, #5
 8008942:	69fb      	ldr	r3, [r7, #28]
 8008944:	4413      	add	r3, r2
 8008946:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 800894a:	461a      	mov	r2, r3
 800894c:	2340      	movs	r3, #64	@ 0x40
 800894e:	6093      	str	r3, [r2, #8]
          }
          if ((epint & USB_OTG_DIEPINT_EPDISD) == USB_OTG_DIEPINT_EPDISD)
 8008950:	693b      	ldr	r3, [r7, #16]
 8008952:	f003 0302 	and.w	r3, r3, #2
 8008956:	2b00      	cmp	r3, #0
 8008958:	d023      	beq.n	80089a2 <HAL_PCD_IRQHandler+0x454>
          {
            (void)USB_FlushTxFifo(USBx, epnum);
 800895a:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 800895c:	6a38      	ldr	r0, [r7, #32]
 800895e:	f006 ff17 	bl	800f790 <USB_FlushTxFifo>

            ep = &hpcd->IN_ep[epnum];
 8008962:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8008964:	4613      	mov	r3, r2
 8008966:	00db      	lsls	r3, r3, #3
 8008968:	4413      	add	r3, r2
 800896a:	009b      	lsls	r3, r3, #2
 800896c:	3310      	adds	r3, #16
 800896e:	687a      	ldr	r2, [r7, #4]
 8008970:	4413      	add	r3, r2
 8008972:	3304      	adds	r3, #4
 8008974:	617b      	str	r3, [r7, #20]

            if (ep->is_iso_incomplete == 1U)
 8008976:	697b      	ldr	r3, [r7, #20]
 8008978:	78db      	ldrb	r3, [r3, #3]
 800897a:	2b01      	cmp	r3, #1
 800897c:	d108      	bne.n	8008990 <HAL_PCD_IRQHandler+0x442>
            {
              ep->is_iso_incomplete = 0U;
 800897e:	697b      	ldr	r3, [r7, #20]
 8008980:	2200      	movs	r2, #0
 8008982:	70da      	strb	r2, [r3, #3]

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
              hpcd->ISOINIncompleteCallback(hpcd, (uint8_t)epnum);
#else
              HAL_PCD_ISOINIncompleteCallback(hpcd, (uint8_t)epnum);
 8008984:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8008986:	b2db      	uxtb	r3, r3
 8008988:	4619      	mov	r1, r3
 800898a:	6878      	ldr	r0, [r7, #4]
 800898c:	f00a f90c 	bl	8012ba8 <HAL_PCD_ISOINIncompleteCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
            }

            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_EPDISD);
 8008990:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8008992:	015a      	lsls	r2, r3, #5
 8008994:	69fb      	ldr	r3, [r7, #28]
 8008996:	4413      	add	r3, r2
 8008998:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 800899c:	461a      	mov	r2, r3
 800899e:	2302      	movs	r3, #2
 80089a0:	6093      	str	r3, [r2, #8]
          }
          if ((epint & USB_OTG_DIEPINT_TXFE) == USB_OTG_DIEPINT_TXFE)
 80089a2:	693b      	ldr	r3, [r7, #16]
 80089a4:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 80089a8:	2b00      	cmp	r3, #0
 80089aa:	d003      	beq.n	80089b4 <HAL_PCD_IRQHandler+0x466>
          {
            (void)PCD_WriteEmptyTxFifo(hpcd, epnum);
 80089ac:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 80089ae:	6878      	ldr	r0, [r7, #4]
 80089b0:	f000 fce8 	bl	8009384 <PCD_WriteEmptyTxFifo>
          }
        }
        epnum++;
 80089b4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80089b6:	3301      	adds	r3, #1
 80089b8:	627b      	str	r3, [r7, #36]	@ 0x24
        ep_intr >>= 1U;
 80089ba:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80089bc:	085b      	lsrs	r3, r3, #1
 80089be:	62bb      	str	r3, [r7, #40]	@ 0x28
      while (ep_intr != 0U)
 80089c0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80089c2:	2b00      	cmp	r3, #0
 80089c4:	f47f af2e 	bne.w	8008824 <HAL_PCD_IRQHandler+0x2d6>
      }
    }

    /* Handle Resume Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT))
 80089c8:	687b      	ldr	r3, [r7, #4]
 80089ca:	681b      	ldr	r3, [r3, #0]
 80089cc:	4618      	mov	r0, r3
 80089ce:	f007 fdfd 	bl	80105cc <USB_ReadInterrupts>
 80089d2:	4603      	mov	r3, r0
 80089d4:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
 80089d8:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 80089dc:	d122      	bne.n	8008a24 <HAL_PCD_IRQHandler+0x4d6>
    {
      /* Clear the Remote Wake-up Signaling */
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG;
 80089de:	69fb      	ldr	r3, [r7, #28]
 80089e0:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 80089e4:	685b      	ldr	r3, [r3, #4]
 80089e6:	69fa      	ldr	r2, [r7, #28]
 80089e8:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 80089ec:	f023 0301 	bic.w	r3, r3, #1
 80089f0:	6053      	str	r3, [r2, #4]

      if (hpcd->LPM_State == LPM_L1)
 80089f2:	687b      	ldr	r3, [r7, #4]
 80089f4:	f893 34cc 	ldrb.w	r3, [r3, #1228]	@ 0x4cc
 80089f8:	2b01      	cmp	r3, #1
 80089fa:	d108      	bne.n	8008a0e <HAL_PCD_IRQHandler+0x4c0>
      {
        hpcd->LPM_State = LPM_L0;
 80089fc:	687b      	ldr	r3, [r7, #4]
 80089fe:	2200      	movs	r2, #0
 8008a00:	f883 24cc 	strb.w	r2, [r3, #1228]	@ 0x4cc

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->LPMCallback(hpcd, PCD_LPM_L0_ACTIVE);
#else
        HAL_PCDEx_LPM_Callback(hpcd, PCD_LPM_L0_ACTIVE);
 8008a04:	2100      	movs	r1, #0
 8008a06:	6878      	ldr	r0, [r7, #4]
 8008a08:	f000 fef2 	bl	80097f0 <HAL_PCDEx_LPM_Callback>
 8008a0c:	e002      	b.n	8008a14 <HAL_PCD_IRQHandler+0x4c6>
      else
      {
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->ResumeCallback(hpcd);
#else
        HAL_PCD_ResumeCallback(hpcd);
 8008a0e:	6878      	ldr	r0, [r7, #4]
 8008a10:	f00a f8aa 	bl	8012b68 <HAL_PCD_ResumeCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
      }

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT);
 8008a14:	687b      	ldr	r3, [r7, #4]
 8008a16:	681b      	ldr	r3, [r3, #0]
 8008a18:	695a      	ldr	r2, [r3, #20]
 8008a1a:	687b      	ldr	r3, [r7, #4]
 8008a1c:	681b      	ldr	r3, [r3, #0]
 8008a1e:	f002 4200 	and.w	r2, r2, #2147483648	@ 0x80000000
 8008a22:	615a      	str	r2, [r3, #20]
    }

    /* Handle Suspend Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP))
 8008a24:	687b      	ldr	r3, [r7, #4]
 8008a26:	681b      	ldr	r3, [r3, #0]
 8008a28:	4618      	mov	r0, r3
 8008a2a:	f007 fdcf 	bl	80105cc <USB_ReadInterrupts>
 8008a2e:	4603      	mov	r3, r0
 8008a30:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
 8008a34:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
 8008a38:	d112      	bne.n	8008a60 <HAL_PCD_IRQHandler+0x512>
    {
      if ((USBx_DEVICE->DSTS & USB_OTG_DSTS_SUSPSTS) == USB_OTG_DSTS_SUSPSTS)
 8008a3a:	69fb      	ldr	r3, [r7, #28]
 8008a3c:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8008a40:	689b      	ldr	r3, [r3, #8]
 8008a42:	f003 0301 	and.w	r3, r3, #1
 8008a46:	2b01      	cmp	r3, #1
 8008a48:	d102      	bne.n	8008a50 <HAL_PCD_IRQHandler+0x502>
      {
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->SuspendCallback(hpcd);
#else
        HAL_PCD_SuspendCallback(hpcd);
 8008a4a:	6878      	ldr	r0, [r7, #4]
 8008a4c:	f00a f866 	bl	8012b1c <HAL_PCD_SuspendCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
      }
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP);
 8008a50:	687b      	ldr	r3, [r7, #4]
 8008a52:	681b      	ldr	r3, [r3, #0]
 8008a54:	695a      	ldr	r2, [r3, #20]
 8008a56:	687b      	ldr	r3, [r7, #4]
 8008a58:	681b      	ldr	r3, [r3, #0]
 8008a5a:	f402 6200 	and.w	r2, r2, #2048	@ 0x800
 8008a5e:	615a      	str	r2, [r3, #20]
    }

    /* Handle LPM Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_LPMINT))
 8008a60:	687b      	ldr	r3, [r7, #4]
 8008a62:	681b      	ldr	r3, [r3, #0]
 8008a64:	4618      	mov	r0, r3
 8008a66:	f007 fdb1 	bl	80105cc <USB_ReadInterrupts>
 8008a6a:	4603      	mov	r3, r0
 8008a6c:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 8008a70:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 8008a74:	d121      	bne.n	8008aba <HAL_PCD_IRQHandler+0x56c>
    {
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_LPMINT);
 8008a76:	687b      	ldr	r3, [r7, #4]
 8008a78:	681b      	ldr	r3, [r3, #0]
 8008a7a:	695a      	ldr	r2, [r3, #20]
 8008a7c:	687b      	ldr	r3, [r7, #4]
 8008a7e:	681b      	ldr	r3, [r3, #0]
 8008a80:	f002 6200 	and.w	r2, r2, #134217728	@ 0x8000000
 8008a84:	615a      	str	r2, [r3, #20]

      if (hpcd->LPM_State == LPM_L0)
 8008a86:	687b      	ldr	r3, [r7, #4]
 8008a88:	f893 34cc 	ldrb.w	r3, [r3, #1228]	@ 0x4cc
 8008a8c:	2b00      	cmp	r3, #0
 8008a8e:	d111      	bne.n	8008ab4 <HAL_PCD_IRQHandler+0x566>
      {
        hpcd->LPM_State = LPM_L1;
 8008a90:	687b      	ldr	r3, [r7, #4]
 8008a92:	2201      	movs	r2, #1
 8008a94:	f883 24cc 	strb.w	r2, [r3, #1228]	@ 0x4cc
        hpcd->BESL = (hpcd->Instance->GLPMCFG & USB_OTG_GLPMCFG_BESL) >> 2U;
 8008a98:	687b      	ldr	r3, [r7, #4]
 8008a9a:	681b      	ldr	r3, [r3, #0]
 8008a9c:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8008a9e:	089b      	lsrs	r3, r3, #2
 8008aa0:	f003 020f 	and.w	r2, r3, #15
 8008aa4:	687b      	ldr	r3, [r7, #4]
 8008aa6:	f8c3 24d0 	str.w	r2, [r3, #1232]	@ 0x4d0

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->LPMCallback(hpcd, PCD_LPM_L1_ACTIVE);
#else
        HAL_PCDEx_LPM_Callback(hpcd, PCD_LPM_L1_ACTIVE);
 8008aaa:	2101      	movs	r1, #1
 8008aac:	6878      	ldr	r0, [r7, #4]
 8008aae:	f000 fe9f 	bl	80097f0 <HAL_PCDEx_LPM_Callback>
 8008ab2:	e002      	b.n	8008aba <HAL_PCD_IRQHandler+0x56c>
      else
      {
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->SuspendCallback(hpcd);
#else
        HAL_PCD_SuspendCallback(hpcd);
 8008ab4:	6878      	ldr	r0, [r7, #4]
 8008ab6:	f00a f831 	bl	8012b1c <HAL_PCD_SuspendCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
      }
    }

    /* Handle Reset Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBRST))
 8008aba:	687b      	ldr	r3, [r7, #4]
 8008abc:	681b      	ldr	r3, [r3, #0]
 8008abe:	4618      	mov	r0, r3
 8008ac0:	f007 fd84 	bl	80105cc <USB_ReadInterrupts>
 8008ac4:	4603      	mov	r3, r0
 8008ac6:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
 8008aca:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 8008ace:	f040 80b7 	bne.w	8008c40 <HAL_PCD_IRQHandler+0x6f2>
    {
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG;
 8008ad2:	69fb      	ldr	r3, [r7, #28]
 8008ad4:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8008ad8:	685b      	ldr	r3, [r3, #4]
 8008ada:	69fa      	ldr	r2, [r7, #28]
 8008adc:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 8008ae0:	f023 0301 	bic.w	r3, r3, #1
 8008ae4:	6053      	str	r3, [r2, #4]
      (void)USB_FlushTxFifo(hpcd->Instance, 0x10U);
 8008ae6:	687b      	ldr	r3, [r7, #4]
 8008ae8:	681b      	ldr	r3, [r3, #0]
 8008aea:	2110      	movs	r1, #16
 8008aec:	4618      	mov	r0, r3
 8008aee:	f006 fe4f 	bl	800f790 <USB_FlushTxFifo>

      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8008af2:	2300      	movs	r3, #0
 8008af4:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8008af6:	e046      	b.n	8008b86 <HAL_PCD_IRQHandler+0x638>
      {
        USBx_INEP(i)->DIEPINT = 0xFB7FU;
 8008af8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8008afa:	015a      	lsls	r2, r3, #5
 8008afc:	69fb      	ldr	r3, [r7, #28]
 8008afe:	4413      	add	r3, r2
 8008b00:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8008b04:	461a      	mov	r2, r3
 8008b06:	f64f 337f 	movw	r3, #64383	@ 0xfb7f
 8008b0a:	6093      	str	r3, [r2, #8]
        USBx_INEP(i)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
 8008b0c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8008b0e:	015a      	lsls	r2, r3, #5
 8008b10:	69fb      	ldr	r3, [r7, #28]
 8008b12:	4413      	add	r3, r2
 8008b14:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8008b18:	681b      	ldr	r3, [r3, #0]
 8008b1a:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8008b1c:	0151      	lsls	r1, r2, #5
 8008b1e:	69fa      	ldr	r2, [r7, #28]
 8008b20:	440a      	add	r2, r1
 8008b22:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 8008b26:	f423 1300 	bic.w	r3, r3, #2097152	@ 0x200000
 8008b2a:	6013      	str	r3, [r2, #0]
        USBx_OUTEP(i)->DOEPINT = 0xFB7FU;
 8008b2c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8008b2e:	015a      	lsls	r2, r3, #5
 8008b30:	69fb      	ldr	r3, [r7, #28]
 8008b32:	4413      	add	r3, r2
 8008b34:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8008b38:	461a      	mov	r2, r3
 8008b3a:	f64f 337f 	movw	r3, #64383	@ 0xfb7f
 8008b3e:	6093      	str	r3, [r2, #8]
        USBx_OUTEP(i)->DOEPCTL &= ~USB_OTG_DOEPCTL_STALL;
 8008b40:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8008b42:	015a      	lsls	r2, r3, #5
 8008b44:	69fb      	ldr	r3, [r7, #28]
 8008b46:	4413      	add	r3, r2
 8008b48:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8008b4c:	681b      	ldr	r3, [r3, #0]
 8008b4e:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8008b50:	0151      	lsls	r1, r2, #5
 8008b52:	69fa      	ldr	r2, [r7, #28]
 8008b54:	440a      	add	r2, r1
 8008b56:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 8008b5a:	f423 1300 	bic.w	r3, r3, #2097152	@ 0x200000
 8008b5e:	6013      	str	r3, [r2, #0]
        USBx_OUTEP(i)->DOEPCTL |= USB_OTG_DOEPCTL_SNAK;
 8008b60:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8008b62:	015a      	lsls	r2, r3, #5
 8008b64:	69fb      	ldr	r3, [r7, #28]
 8008b66:	4413      	add	r3, r2
 8008b68:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8008b6c:	681b      	ldr	r3, [r3, #0]
 8008b6e:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8008b70:	0151      	lsls	r1, r2, #5
 8008b72:	69fa      	ldr	r2, [r7, #28]
 8008b74:	440a      	add	r2, r1
 8008b76:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 8008b7a:	f043 6300 	orr.w	r3, r3, #134217728	@ 0x8000000
 8008b7e:	6013      	str	r3, [r2, #0]
      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8008b80:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8008b82:	3301      	adds	r3, #1
 8008b84:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8008b86:	687b      	ldr	r3, [r7, #4]
 8008b88:	791b      	ldrb	r3, [r3, #4]
 8008b8a:	461a      	mov	r2, r3
 8008b8c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8008b8e:	4293      	cmp	r3, r2
 8008b90:	d3b2      	bcc.n	8008af8 <HAL_PCD_IRQHandler+0x5aa>
      }
      USBx_DEVICE->DAINTMSK |= 0x10001U;
 8008b92:	69fb      	ldr	r3, [r7, #28]
 8008b94:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8008b98:	69db      	ldr	r3, [r3, #28]
 8008b9a:	69fa      	ldr	r2, [r7, #28]
 8008b9c:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 8008ba0:	f043 1301 	orr.w	r3, r3, #65537	@ 0x10001
 8008ba4:	61d3      	str	r3, [r2, #28]

      if (hpcd->Init.use_dedicated_ep1 != 0U)
 8008ba6:	687b      	ldr	r3, [r7, #4]
 8008ba8:	7bdb      	ldrb	r3, [r3, #15]
 8008baa:	2b00      	cmp	r3, #0
 8008bac:	d016      	beq.n	8008bdc <HAL_PCD_IRQHandler+0x68e>
      {
        USBx_DEVICE->DOUTEP1MSK |= USB_OTG_DOEPMSK_STUPM |
 8008bae:	69fb      	ldr	r3, [r7, #28]
 8008bb0:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8008bb4:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 8008bb8:	69fa      	ldr	r2, [r7, #28]
 8008bba:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 8008bbe:	f043 030b 	orr.w	r3, r3, #11
 8008bc2:	f8c2 3084 	str.w	r3, [r2, #132]	@ 0x84
                                   USB_OTG_DOEPMSK_XFRCM |
                                   USB_OTG_DOEPMSK_EPDM;

        USBx_DEVICE->DINEP1MSK |= USB_OTG_DIEPMSK_TOM |
 8008bc6:	69fb      	ldr	r3, [r7, #28]
 8008bc8:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8008bcc:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8008bce:	69fa      	ldr	r2, [r7, #28]
 8008bd0:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 8008bd4:	f043 030b 	orr.w	r3, r3, #11
 8008bd8:	6453      	str	r3, [r2, #68]	@ 0x44
 8008bda:	e015      	b.n	8008c08 <HAL_PCD_IRQHandler+0x6ba>
                                  USB_OTG_DIEPMSK_XFRCM |
                                  USB_OTG_DIEPMSK_EPDM;
      }
      else
      {
        USBx_DEVICE->DOEPMSK |= USB_OTG_DOEPMSK_STUPM |
 8008bdc:	69fb      	ldr	r3, [r7, #28]
 8008bde:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8008be2:	695a      	ldr	r2, [r3, #20]
 8008be4:	69fb      	ldr	r3, [r7, #28]
 8008be6:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8008bea:	4619      	mov	r1, r3
 8008bec:	f242 032b 	movw	r3, #8235	@ 0x202b
 8008bf0:	4313      	orrs	r3, r2
 8008bf2:	614b      	str	r3, [r1, #20]
                                USB_OTG_DOEPMSK_XFRCM |
                                USB_OTG_DOEPMSK_EPDM |
                                USB_OTG_DOEPMSK_OTEPSPRM |
                                USB_OTG_DOEPMSK_NAKM;

        USBx_DEVICE->DIEPMSK |= USB_OTG_DIEPMSK_TOM |
 8008bf4:	69fb      	ldr	r3, [r7, #28]
 8008bf6:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8008bfa:	691b      	ldr	r3, [r3, #16]
 8008bfc:	69fa      	ldr	r2, [r7, #28]
 8008bfe:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 8008c02:	f043 030b 	orr.w	r3, r3, #11
 8008c06:	6113      	str	r3, [r2, #16]
                                USB_OTG_DIEPMSK_XFRCM |
                                USB_OTG_DIEPMSK_EPDM;
      }

      /* Set Default Address to 0 */
      USBx_DEVICE->DCFG &= ~USB_OTG_DCFG_DAD;
 8008c08:	69fb      	ldr	r3, [r7, #28]
 8008c0a:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8008c0e:	681b      	ldr	r3, [r3, #0]
 8008c10:	69fa      	ldr	r2, [r7, #28]
 8008c12:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 8008c16:	f423 63fe 	bic.w	r3, r3, #2032	@ 0x7f0
 8008c1a:	6013      	str	r3, [r2, #0]

      /* setup EP0 to receive SETUP packets */
      (void)USB_EP0_OutStart(hpcd->Instance, (uint8_t)hpcd->Init.dma_enable,
 8008c1c:	687b      	ldr	r3, [r7, #4]
 8008c1e:	6818      	ldr	r0, [r3, #0]
 8008c20:	687b      	ldr	r3, [r7, #4]
 8008c22:	7999      	ldrb	r1, [r3, #6]
                             (uint8_t *)hpcd->Setup);
 8008c24:	687b      	ldr	r3, [r7, #4]
 8008c26:	f203 439c 	addw	r3, r3, #1180	@ 0x49c
      (void)USB_EP0_OutStart(hpcd->Instance, (uint8_t)hpcd->Init.dma_enable,
 8008c2a:	461a      	mov	r2, r3
 8008c2c:	f007 fd94 	bl	8010758 <USB_EP0_OutStart>

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBRST);
 8008c30:	687b      	ldr	r3, [r7, #4]
 8008c32:	681b      	ldr	r3, [r3, #0]
 8008c34:	695a      	ldr	r2, [r3, #20]
 8008c36:	687b      	ldr	r3, [r7, #4]
 8008c38:	681b      	ldr	r3, [r3, #0]
 8008c3a:	f402 5280 	and.w	r2, r2, #4096	@ 0x1000
 8008c3e:	615a      	str	r2, [r3, #20]
    }

    /* Handle Enumeration done Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE))
 8008c40:	687b      	ldr	r3, [r7, #4]
 8008c42:	681b      	ldr	r3, [r3, #0]
 8008c44:	4618      	mov	r0, r3
 8008c46:	f007 fcc1 	bl	80105cc <USB_ReadInterrupts>
 8008c4a:	4603      	mov	r3, r0
 8008c4c:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
 8008c50:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 8008c54:	d123      	bne.n	8008c9e <HAL_PCD_IRQHandler+0x750>
    {
      (void)USB_ActivateSetup(hpcd->Instance);
 8008c56:	687b      	ldr	r3, [r7, #4]
 8008c58:	681b      	ldr	r3, [r3, #0]
 8008c5a:	4618      	mov	r0, r3
 8008c5c:	f007 fd58 	bl	8010710 <USB_ActivateSetup>
      hpcd->Init.speed = USB_GetDevSpeed(hpcd->Instance);
 8008c60:	687b      	ldr	r3, [r7, #4]
 8008c62:	681b      	ldr	r3, [r3, #0]
 8008c64:	4618      	mov	r0, r3
 8008c66:	f006 fe0c 	bl	800f882 <USB_GetDevSpeed>
 8008c6a:	4603      	mov	r3, r0
 8008c6c:	461a      	mov	r2, r3
 8008c6e:	687b      	ldr	r3, [r7, #4]
 8008c70:	71da      	strb	r2, [r3, #7]

      /* Set USB Turnaround time */
      (void)USB_SetTurnaroundTime(hpcd->Instance,
 8008c72:	687b      	ldr	r3, [r7, #4]
 8008c74:	681c      	ldr	r4, [r3, #0]
 8008c76:	f001 fd73 	bl	800a760 <HAL_RCC_GetHCLKFreq>
 8008c7a:	4601      	mov	r1, r0
                                  HAL_RCC_GetHCLKFreq(),
                                  (uint8_t)hpcd->Init.speed);
 8008c7c:	687b      	ldr	r3, [r7, #4]
 8008c7e:	79db      	ldrb	r3, [r3, #7]
      (void)USB_SetTurnaroundTime(hpcd->Instance,
 8008c80:	461a      	mov	r2, r3
 8008c82:	4620      	mov	r0, r4
 8008c84:	f006 fb16 	bl	800f2b4 <USB_SetTurnaroundTime>

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
      hpcd->ResetCallback(hpcd);
#else
      HAL_PCD_ResetCallback(hpcd);
 8008c88:	6878      	ldr	r0, [r7, #4]
 8008c8a:	f009 ff1e 	bl	8012aca <HAL_PCD_ResetCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE);
 8008c8e:	687b      	ldr	r3, [r7, #4]
 8008c90:	681b      	ldr	r3, [r3, #0]
 8008c92:	695a      	ldr	r2, [r3, #20]
 8008c94:	687b      	ldr	r3, [r7, #4]
 8008c96:	681b      	ldr	r3, [r3, #0]
 8008c98:	f402 5200 	and.w	r2, r2, #8192	@ 0x2000
 8008c9c:	615a      	str	r2, [r3, #20]
    }

    /* Handle SOF Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_SOF))
 8008c9e:	687b      	ldr	r3, [r7, #4]
 8008ca0:	681b      	ldr	r3, [r3, #0]
 8008ca2:	4618      	mov	r0, r3
 8008ca4:	f007 fc92 	bl	80105cc <USB_ReadInterrupts>
 8008ca8:	4603      	mov	r3, r0
 8008caa:	f003 0308 	and.w	r3, r3, #8
 8008cae:	2b08      	cmp	r3, #8
 8008cb0:	d10a      	bne.n	8008cc8 <HAL_PCD_IRQHandler+0x77a>
    {
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
      hpcd->SOFCallback(hpcd);
#else
      HAL_PCD_SOFCallback(hpcd);
 8008cb2:	6878      	ldr	r0, [r7, #4]
 8008cb4:	f009 fefb 	bl	8012aae <HAL_PCD_SOFCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SOF);
 8008cb8:	687b      	ldr	r3, [r7, #4]
 8008cba:	681b      	ldr	r3, [r3, #0]
 8008cbc:	695a      	ldr	r2, [r3, #20]
 8008cbe:	687b      	ldr	r3, [r7, #4]
 8008cc0:	681b      	ldr	r3, [r3, #0]
 8008cc2:	f002 0208 	and.w	r2, r2, #8
 8008cc6:	615a      	str	r2, [r3, #20]
    }

    /* Handle Global OUT NAK effective Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_BOUTNAKEFF))
 8008cc8:	687b      	ldr	r3, [r7, #4]
 8008cca:	681b      	ldr	r3, [r3, #0]
 8008ccc:	4618      	mov	r0, r3
 8008cce:	f007 fc7d 	bl	80105cc <USB_ReadInterrupts>
 8008cd2:	4603      	mov	r3, r0
 8008cd4:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8008cd8:	2b80      	cmp	r3, #128	@ 0x80
 8008cda:	d123      	bne.n	8008d24 <HAL_PCD_IRQHandler+0x7d6>
    {
      USBx->GINTMSK &= ~USB_OTG_GINTMSK_GONAKEFFM;
 8008cdc:	6a3b      	ldr	r3, [r7, #32]
 8008cde:	699b      	ldr	r3, [r3, #24]
 8008ce0:	f023 0280 	bic.w	r2, r3, #128	@ 0x80
 8008ce4:	6a3b      	ldr	r3, [r7, #32]
 8008ce6:	619a      	str	r2, [r3, #24]

      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8008ce8:	2301      	movs	r3, #1
 8008cea:	627b      	str	r3, [r7, #36]	@ 0x24
 8008cec:	e014      	b.n	8008d18 <HAL_PCD_IRQHandler+0x7ca>
      {
        if (hpcd->OUT_ep[epnum].is_iso_incomplete == 1U)
 8008cee:	6879      	ldr	r1, [r7, #4]
 8008cf0:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8008cf2:	4613      	mov	r3, r2
 8008cf4:	00db      	lsls	r3, r3, #3
 8008cf6:	4413      	add	r3, r2
 8008cf8:	009b      	lsls	r3, r3, #2
 8008cfa:	440b      	add	r3, r1
 8008cfc:	f203 2357 	addw	r3, r3, #599	@ 0x257
 8008d00:	781b      	ldrb	r3, [r3, #0]
 8008d02:	2b01      	cmp	r3, #1
 8008d04:	d105      	bne.n	8008d12 <HAL_PCD_IRQHandler+0x7c4>
        {
          /* Abort current transaction and disable the EP */
          (void)HAL_PCD_EP_Abort(hpcd, (uint8_t)epnum);
 8008d06:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8008d08:	b2db      	uxtb	r3, r3
 8008d0a:	4619      	mov	r1, r3
 8008d0c:	6878      	ldr	r0, [r7, #4]
 8008d0e:	f000 fb08 	bl	8009322 <HAL_PCD_EP_Abort>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8008d12:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8008d14:	3301      	adds	r3, #1
 8008d16:	627b      	str	r3, [r7, #36]	@ 0x24
 8008d18:	687b      	ldr	r3, [r7, #4]
 8008d1a:	791b      	ldrb	r3, [r3, #4]
 8008d1c:	461a      	mov	r2, r3
 8008d1e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8008d20:	4293      	cmp	r3, r2
 8008d22:	d3e4      	bcc.n	8008cee <HAL_PCD_IRQHandler+0x7a0>
        }
      }
    }

    /* Handle Incomplete ISO IN Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR))
 8008d24:	687b      	ldr	r3, [r7, #4]
 8008d26:	681b      	ldr	r3, [r3, #0]
 8008d28:	4618      	mov	r0, r3
 8008d2a:	f007 fc4f 	bl	80105cc <USB_ReadInterrupts>
 8008d2e:	4603      	mov	r3, r0
 8008d30:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
 8008d34:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
 8008d38:	d13c      	bne.n	8008db4 <HAL_PCD_IRQHandler+0x866>
    {
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8008d3a:	2301      	movs	r3, #1
 8008d3c:	627b      	str	r3, [r7, #36]	@ 0x24
 8008d3e:	e02b      	b.n	8008d98 <HAL_PCD_IRQHandler+0x84a>
      {
        RegVal = USBx_INEP(epnum)->DIEPCTL;
 8008d40:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8008d42:	015a      	lsls	r2, r3, #5
 8008d44:	69fb      	ldr	r3, [r7, #28]
 8008d46:	4413      	add	r3, r2
 8008d48:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8008d4c:	681b      	ldr	r3, [r3, #0]
 8008d4e:	61bb      	str	r3, [r7, #24]

        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 8008d50:	6879      	ldr	r1, [r7, #4]
 8008d52:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8008d54:	4613      	mov	r3, r2
 8008d56:	00db      	lsls	r3, r3, #3
 8008d58:	4413      	add	r3, r2
 8008d5a:	009b      	lsls	r3, r3, #2
 8008d5c:	440b      	add	r3, r1
 8008d5e:	3318      	adds	r3, #24
 8008d60:	781b      	ldrb	r3, [r3, #0]
 8008d62:	2b01      	cmp	r3, #1
 8008d64:	d115      	bne.n	8008d92 <HAL_PCD_IRQHandler+0x844>
            ((RegVal & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA))
 8008d66:	69bb      	ldr	r3, [r7, #24]
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 8008d68:	2b00      	cmp	r3, #0
 8008d6a:	da12      	bge.n	8008d92 <HAL_PCD_IRQHandler+0x844>
        {
          hpcd->IN_ep[epnum].is_iso_incomplete = 1U;
 8008d6c:	6879      	ldr	r1, [r7, #4]
 8008d6e:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8008d70:	4613      	mov	r3, r2
 8008d72:	00db      	lsls	r3, r3, #3
 8008d74:	4413      	add	r3, r2
 8008d76:	009b      	lsls	r3, r3, #2
 8008d78:	440b      	add	r3, r1
 8008d7a:	3317      	adds	r3, #23
 8008d7c:	2201      	movs	r2, #1
 8008d7e:	701a      	strb	r2, [r3, #0]

          /* Abort current transaction and disable the EP */
          (void)HAL_PCD_EP_Abort(hpcd, (uint8_t)(epnum | 0x80U));
 8008d80:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8008d82:	b2db      	uxtb	r3, r3
 8008d84:	f063 037f 	orn	r3, r3, #127	@ 0x7f
 8008d88:	b2db      	uxtb	r3, r3
 8008d8a:	4619      	mov	r1, r3
 8008d8c:	6878      	ldr	r0, [r7, #4]
 8008d8e:	f000 fac8 	bl	8009322 <HAL_PCD_EP_Abort>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8008d92:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8008d94:	3301      	adds	r3, #1
 8008d96:	627b      	str	r3, [r7, #36]	@ 0x24
 8008d98:	687b      	ldr	r3, [r7, #4]
 8008d9a:	791b      	ldrb	r3, [r3, #4]
 8008d9c:	461a      	mov	r2, r3
 8008d9e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8008da0:	4293      	cmp	r3, r2
 8008da2:	d3cd      	bcc.n	8008d40 <HAL_PCD_IRQHandler+0x7f2>
        }
      }

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR);
 8008da4:	687b      	ldr	r3, [r7, #4]
 8008da6:	681b      	ldr	r3, [r3, #0]
 8008da8:	695a      	ldr	r2, [r3, #20]
 8008daa:	687b      	ldr	r3, [r7, #4]
 8008dac:	681b      	ldr	r3, [r3, #0]
 8008dae:	f402 1280 	and.w	r2, r2, #1048576	@ 0x100000
 8008db2:	615a      	str	r2, [r3, #20]
    }

    /* Handle Incomplete ISO OUT Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT))
 8008db4:	687b      	ldr	r3, [r7, #4]
 8008db6:	681b      	ldr	r3, [r3, #0]
 8008db8:	4618      	mov	r0, r3
 8008dba:	f007 fc07 	bl	80105cc <USB_ReadInterrupts>
 8008dbe:	4603      	mov	r3, r0
 8008dc0:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
 8008dc4:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
 8008dc8:	d156      	bne.n	8008e78 <HAL_PCD_IRQHandler+0x92a>
    {
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8008dca:	2301      	movs	r3, #1
 8008dcc:	627b      	str	r3, [r7, #36]	@ 0x24
 8008dce:	e045      	b.n	8008e5c <HAL_PCD_IRQHandler+0x90e>
      {
        RegVal = USBx_OUTEP(epnum)->DOEPCTL;
 8008dd0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8008dd2:	015a      	lsls	r2, r3, #5
 8008dd4:	69fb      	ldr	r3, [r7, #28]
 8008dd6:	4413      	add	r3, r2
 8008dd8:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8008ddc:	681b      	ldr	r3, [r3, #0]
 8008dde:	61bb      	str	r3, [r7, #24]

        if ((hpcd->OUT_ep[epnum].type == EP_TYPE_ISOC) &&
 8008de0:	6879      	ldr	r1, [r7, #4]
 8008de2:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8008de4:	4613      	mov	r3, r2
 8008de6:	00db      	lsls	r3, r3, #3
 8008de8:	4413      	add	r3, r2
 8008dea:	009b      	lsls	r3, r3, #2
 8008dec:	440b      	add	r3, r1
 8008dee:	f503 7316 	add.w	r3, r3, #600	@ 0x258
 8008df2:	781b      	ldrb	r3, [r3, #0]
 8008df4:	2b01      	cmp	r3, #1
 8008df6:	d12e      	bne.n	8008e56 <HAL_PCD_IRQHandler+0x908>
            ((RegVal & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA) &&
 8008df8:	69bb      	ldr	r3, [r7, #24]
        if ((hpcd->OUT_ep[epnum].type == EP_TYPE_ISOC) &&
 8008dfa:	2b00      	cmp	r3, #0
 8008dfc:	da2b      	bge.n	8008e56 <HAL_PCD_IRQHandler+0x908>
            ((RegVal & (0x1U << 16)) == (hpcd->FrameNumber & 0x1U)))
 8008dfe:	69bb      	ldr	r3, [r7, #24]
 8008e00:	f403 3280 	and.w	r2, r3, #65536	@ 0x10000
 8008e04:	687b      	ldr	r3, [r7, #4]
 8008e06:	f8d3 34d4 	ldr.w	r3, [r3, #1236]	@ 0x4d4
 8008e0a:	f003 0301 	and.w	r3, r3, #1
            ((RegVal & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA) &&
 8008e0e:	429a      	cmp	r2, r3
 8008e10:	d121      	bne.n	8008e56 <HAL_PCD_IRQHandler+0x908>
        {
          hpcd->OUT_ep[epnum].is_iso_incomplete = 1U;
 8008e12:	6879      	ldr	r1, [r7, #4]
 8008e14:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8008e16:	4613      	mov	r3, r2
 8008e18:	00db      	lsls	r3, r3, #3
 8008e1a:	4413      	add	r3, r2
 8008e1c:	009b      	lsls	r3, r3, #2
 8008e1e:	440b      	add	r3, r1
 8008e20:	f203 2357 	addw	r3, r3, #599	@ 0x257
 8008e24:	2201      	movs	r2, #1
 8008e26:	701a      	strb	r2, [r3, #0]

          USBx->GINTMSK |= USB_OTG_GINTMSK_GONAKEFFM;
 8008e28:	6a3b      	ldr	r3, [r7, #32]
 8008e2a:	699b      	ldr	r3, [r3, #24]
 8008e2c:	f043 0280 	orr.w	r2, r3, #128	@ 0x80
 8008e30:	6a3b      	ldr	r3, [r7, #32]
 8008e32:	619a      	str	r2, [r3, #24]

          if ((USBx->GINTSTS & USB_OTG_GINTSTS_BOUTNAKEFF) == 0U)
 8008e34:	6a3b      	ldr	r3, [r7, #32]
 8008e36:	695b      	ldr	r3, [r3, #20]
 8008e38:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8008e3c:	2b00      	cmp	r3, #0
 8008e3e:	d10a      	bne.n	8008e56 <HAL_PCD_IRQHandler+0x908>
          {
            USBx_DEVICE->DCTL |= USB_OTG_DCTL_SGONAK;
 8008e40:	69fb      	ldr	r3, [r7, #28]
 8008e42:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8008e46:	685b      	ldr	r3, [r3, #4]
 8008e48:	69fa      	ldr	r2, [r7, #28]
 8008e4a:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 8008e4e:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
 8008e52:	6053      	str	r3, [r2, #4]
            break;
 8008e54:	e008      	b.n	8008e68 <HAL_PCD_IRQHandler+0x91a>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 8008e56:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8008e58:	3301      	adds	r3, #1
 8008e5a:	627b      	str	r3, [r7, #36]	@ 0x24
 8008e5c:	687b      	ldr	r3, [r7, #4]
 8008e5e:	791b      	ldrb	r3, [r3, #4]
 8008e60:	461a      	mov	r2, r3
 8008e62:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8008e64:	4293      	cmp	r3, r2
 8008e66:	d3b3      	bcc.n	8008dd0 <HAL_PCD_IRQHandler+0x882>
          }
        }
      }

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT);
 8008e68:	687b      	ldr	r3, [r7, #4]
 8008e6a:	681b      	ldr	r3, [r3, #0]
 8008e6c:	695a      	ldr	r2, [r3, #20]
 8008e6e:	687b      	ldr	r3, [r7, #4]
 8008e70:	681b      	ldr	r3, [r3, #0]
 8008e72:	f402 1200 	and.w	r2, r2, #2097152	@ 0x200000
 8008e76:	615a      	str	r2, [r3, #20]
    }

    /* Handle Connection event Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT))
 8008e78:	687b      	ldr	r3, [r7, #4]
 8008e7a:	681b      	ldr	r3, [r3, #0]
 8008e7c:	4618      	mov	r0, r3
 8008e7e:	f007 fba5 	bl	80105cc <USB_ReadInterrupts>
 8008e82:	4603      	mov	r3, r0
 8008e84:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
 8008e88:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 8008e8c:	d10a      	bne.n	8008ea4 <HAL_PCD_IRQHandler+0x956>
    {
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
      hpcd->ConnectCallback(hpcd);
#else
      HAL_PCD_ConnectCallback(hpcd);
 8008e8e:	6878      	ldr	r0, [r7, #4]
 8008e90:	f009 fe9c 	bl	8012bcc <HAL_PCD_ConnectCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT);
 8008e94:	687b      	ldr	r3, [r7, #4]
 8008e96:	681b      	ldr	r3, [r3, #0]
 8008e98:	695a      	ldr	r2, [r3, #20]
 8008e9a:	687b      	ldr	r3, [r7, #4]
 8008e9c:	681b      	ldr	r3, [r3, #0]
 8008e9e:	f002 4280 	and.w	r2, r2, #1073741824	@ 0x40000000
 8008ea2:	615a      	str	r2, [r3, #20]
    }

    /* Handle Disconnection event Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OTGINT))
 8008ea4:	687b      	ldr	r3, [r7, #4]
 8008ea6:	681b      	ldr	r3, [r3, #0]
 8008ea8:	4618      	mov	r0, r3
 8008eaa:	f007 fb8f 	bl	80105cc <USB_ReadInterrupts>
 8008eae:	4603      	mov	r3, r0
 8008eb0:	f003 0304 	and.w	r3, r3, #4
 8008eb4:	2b04      	cmp	r3, #4
 8008eb6:	d115      	bne.n	8008ee4 <HAL_PCD_IRQHandler+0x996>
    {
      RegVal = hpcd->Instance->GOTGINT;
 8008eb8:	687b      	ldr	r3, [r7, #4]
 8008eba:	681b      	ldr	r3, [r3, #0]
 8008ebc:	685b      	ldr	r3, [r3, #4]
 8008ebe:	61bb      	str	r3, [r7, #24]

      if ((RegVal & USB_OTG_GOTGINT_SEDET) == USB_OTG_GOTGINT_SEDET)
 8008ec0:	69bb      	ldr	r3, [r7, #24]
 8008ec2:	f003 0304 	and.w	r3, r3, #4
 8008ec6:	2b00      	cmp	r3, #0
 8008ec8:	d002      	beq.n	8008ed0 <HAL_PCD_IRQHandler+0x982>
      {
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->DisconnectCallback(hpcd);
#else
        HAL_PCD_DisconnectCallback(hpcd);
 8008eca:	6878      	ldr	r0, [r7, #4]
 8008ecc:	f009 fe8c 	bl	8012be8 <HAL_PCD_DisconnectCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
      }
      hpcd->Instance->GOTGINT |= RegVal;
 8008ed0:	687b      	ldr	r3, [r7, #4]
 8008ed2:	681b      	ldr	r3, [r3, #0]
 8008ed4:	6859      	ldr	r1, [r3, #4]
 8008ed6:	687b      	ldr	r3, [r7, #4]
 8008ed8:	681b      	ldr	r3, [r3, #0]
 8008eda:	69ba      	ldr	r2, [r7, #24]
 8008edc:	430a      	orrs	r2, r1
 8008ede:	605a      	str	r2, [r3, #4]
 8008ee0:	e000      	b.n	8008ee4 <HAL_PCD_IRQHandler+0x996>
      return;
 8008ee2:	bf00      	nop
    }
  }
}
 8008ee4:	3734      	adds	r7, #52	@ 0x34
 8008ee6:	46bd      	mov	sp, r7
 8008ee8:	bd90      	pop	{r4, r7, pc}

08008eea <HAL_PCD_SetAddress>:
  * @param  hpcd PCD handle
  * @param  address new device address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_SetAddress(PCD_HandleTypeDef *hpcd, uint8_t address)
{
 8008eea:	b580      	push	{r7, lr}
 8008eec:	b082      	sub	sp, #8
 8008eee:	af00      	add	r7, sp, #0
 8008ef0:	6078      	str	r0, [r7, #4]
 8008ef2:	460b      	mov	r3, r1
 8008ef4:	70fb      	strb	r3, [r7, #3]
  __HAL_LOCK(hpcd);
 8008ef6:	687b      	ldr	r3, [r7, #4]
 8008ef8:	f893 3494 	ldrb.w	r3, [r3, #1172]	@ 0x494
 8008efc:	2b01      	cmp	r3, #1
 8008efe:	d101      	bne.n	8008f04 <HAL_PCD_SetAddress+0x1a>
 8008f00:	2302      	movs	r3, #2
 8008f02:	e012      	b.n	8008f2a <HAL_PCD_SetAddress+0x40>
 8008f04:	687b      	ldr	r3, [r7, #4]
 8008f06:	2201      	movs	r2, #1
 8008f08:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494
  hpcd->USB_Address = address;
 8008f0c:	687b      	ldr	r3, [r7, #4]
 8008f0e:	78fa      	ldrb	r2, [r7, #3]
 8008f10:	745a      	strb	r2, [r3, #17]
  (void)USB_SetDevAddress(hpcd->Instance, address);
 8008f12:	687b      	ldr	r3, [r7, #4]
 8008f14:	681b      	ldr	r3, [r3, #0]
 8008f16:	78fa      	ldrb	r2, [r7, #3]
 8008f18:	4611      	mov	r1, r2
 8008f1a:	4618      	mov	r0, r3
 8008f1c:	f007 faee 	bl	80104fc <USB_SetDevAddress>
  __HAL_UNLOCK(hpcd);
 8008f20:	687b      	ldr	r3, [r7, #4]
 8008f22:	2200      	movs	r2, #0
 8008f24:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494

  return HAL_OK;
 8008f28:	2300      	movs	r3, #0
}
 8008f2a:	4618      	mov	r0, r3
 8008f2c:	3708      	adds	r7, #8
 8008f2e:	46bd      	mov	sp, r7
 8008f30:	bd80      	pop	{r7, pc}

08008f32 <HAL_PCD_EP_Open>:
  * @param  ep_type endpoint type
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Open(PCD_HandleTypeDef *hpcd, uint8_t ep_addr,
                                  uint16_t ep_mps, uint8_t ep_type)
{
 8008f32:	b580      	push	{r7, lr}
 8008f34:	b084      	sub	sp, #16
 8008f36:	af00      	add	r7, sp, #0
 8008f38:	6078      	str	r0, [r7, #4]
 8008f3a:	4608      	mov	r0, r1
 8008f3c:	4611      	mov	r1, r2
 8008f3e:	461a      	mov	r2, r3
 8008f40:	4603      	mov	r3, r0
 8008f42:	70fb      	strb	r3, [r7, #3]
 8008f44:	460b      	mov	r3, r1
 8008f46:	803b      	strh	r3, [r7, #0]
 8008f48:	4613      	mov	r3, r2
 8008f4a:	70bb      	strb	r3, [r7, #2]
  HAL_StatusTypeDef  ret = HAL_OK;
 8008f4c:	2300      	movs	r3, #0
 8008f4e:	72fb      	strb	r3, [r7, #11]
  PCD_EPTypeDef *ep;

  if ((ep_addr & 0x80U) == 0x80U)
 8008f50:	f997 3003 	ldrsb.w	r3, [r7, #3]
 8008f54:	2b00      	cmp	r3, #0
 8008f56:	da0f      	bge.n	8008f78 <HAL_PCD_EP_Open+0x46>
  {
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8008f58:	78fb      	ldrb	r3, [r7, #3]
 8008f5a:	f003 020f 	and.w	r2, r3, #15
 8008f5e:	4613      	mov	r3, r2
 8008f60:	00db      	lsls	r3, r3, #3
 8008f62:	4413      	add	r3, r2
 8008f64:	009b      	lsls	r3, r3, #2
 8008f66:	3310      	adds	r3, #16
 8008f68:	687a      	ldr	r2, [r7, #4]
 8008f6a:	4413      	add	r3, r2
 8008f6c:	3304      	adds	r3, #4
 8008f6e:	60fb      	str	r3, [r7, #12]
    ep->is_in = 1U;
 8008f70:	68fb      	ldr	r3, [r7, #12]
 8008f72:	2201      	movs	r2, #1
 8008f74:	705a      	strb	r2, [r3, #1]
 8008f76:	e00f      	b.n	8008f98 <HAL_PCD_EP_Open+0x66>
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 8008f78:	78fb      	ldrb	r3, [r7, #3]
 8008f7a:	f003 020f 	and.w	r2, r3, #15
 8008f7e:	4613      	mov	r3, r2
 8008f80:	00db      	lsls	r3, r3, #3
 8008f82:	4413      	add	r3, r2
 8008f84:	009b      	lsls	r3, r3, #2
 8008f86:	f503 7314 	add.w	r3, r3, #592	@ 0x250
 8008f8a:	687a      	ldr	r2, [r7, #4]
 8008f8c:	4413      	add	r3, r2
 8008f8e:	3304      	adds	r3, #4
 8008f90:	60fb      	str	r3, [r7, #12]
    ep->is_in = 0U;
 8008f92:	68fb      	ldr	r3, [r7, #12]
 8008f94:	2200      	movs	r2, #0
 8008f96:	705a      	strb	r2, [r3, #1]
  }

  ep->num = ep_addr & EP_ADDR_MSK;
 8008f98:	78fb      	ldrb	r3, [r7, #3]
 8008f9a:	f003 030f 	and.w	r3, r3, #15
 8008f9e:	b2da      	uxtb	r2, r3
 8008fa0:	68fb      	ldr	r3, [r7, #12]
 8008fa2:	701a      	strb	r2, [r3, #0]
  ep->maxpacket = ep_mps;
 8008fa4:	883a      	ldrh	r2, [r7, #0]
 8008fa6:	68fb      	ldr	r3, [r7, #12]
 8008fa8:	609a      	str	r2, [r3, #8]
  ep->type = ep_type;
 8008faa:	68fb      	ldr	r3, [r7, #12]
 8008fac:	78ba      	ldrb	r2, [r7, #2]
 8008fae:	711a      	strb	r2, [r3, #4]

  if (ep->is_in != 0U)
 8008fb0:	68fb      	ldr	r3, [r7, #12]
 8008fb2:	785b      	ldrb	r3, [r3, #1]
 8008fb4:	2b00      	cmp	r3, #0
 8008fb6:	d004      	beq.n	8008fc2 <HAL_PCD_EP_Open+0x90>
  {
    /* Assign a Tx FIFO */
    ep->tx_fifo_num = ep->num;
 8008fb8:	68fb      	ldr	r3, [r7, #12]
 8008fba:	781b      	ldrb	r3, [r3, #0]
 8008fbc:	461a      	mov	r2, r3
 8008fbe:	68fb      	ldr	r3, [r7, #12]
 8008fc0:	835a      	strh	r2, [r3, #26]
  }

  /* Set initial data PID. */
  if (ep_type == EP_TYPE_BULK)
 8008fc2:	78bb      	ldrb	r3, [r7, #2]
 8008fc4:	2b02      	cmp	r3, #2
 8008fc6:	d102      	bne.n	8008fce <HAL_PCD_EP_Open+0x9c>
  {
    ep->data_pid_start = 0U;
 8008fc8:	68fb      	ldr	r3, [r7, #12]
 8008fca:	2200      	movs	r2, #0
 8008fcc:	715a      	strb	r2, [r3, #5]
  }

  __HAL_LOCK(hpcd);
 8008fce:	687b      	ldr	r3, [r7, #4]
 8008fd0:	f893 3494 	ldrb.w	r3, [r3, #1172]	@ 0x494
 8008fd4:	2b01      	cmp	r3, #1
 8008fd6:	d101      	bne.n	8008fdc <HAL_PCD_EP_Open+0xaa>
 8008fd8:	2302      	movs	r3, #2
 8008fda:	e00e      	b.n	8008ffa <HAL_PCD_EP_Open+0xc8>
 8008fdc:	687b      	ldr	r3, [r7, #4]
 8008fde:	2201      	movs	r2, #1
 8008fe0:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494
  (void)USB_ActivateEndpoint(hpcd->Instance, ep);
 8008fe4:	687b      	ldr	r3, [r7, #4]
 8008fe6:	681b      	ldr	r3, [r3, #0]
 8008fe8:	68f9      	ldr	r1, [r7, #12]
 8008fea:	4618      	mov	r0, r3
 8008fec:	f006 fc6e 	bl	800f8cc <USB_ActivateEndpoint>
  __HAL_UNLOCK(hpcd);
 8008ff0:	687b      	ldr	r3, [r7, #4]
 8008ff2:	2200      	movs	r2, #0
 8008ff4:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494

  return ret;
 8008ff8:	7afb      	ldrb	r3, [r7, #11]
}
 8008ffa:	4618      	mov	r0, r3
 8008ffc:	3710      	adds	r7, #16
 8008ffe:	46bd      	mov	sp, r7
 8009000:	bd80      	pop	{r7, pc}

08009002 <HAL_PCD_EP_Close>:
  * @param  hpcd PCD handle
  * @param  ep_addr endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Close(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
 8009002:	b580      	push	{r7, lr}
 8009004:	b084      	sub	sp, #16
 8009006:	af00      	add	r7, sp, #0
 8009008:	6078      	str	r0, [r7, #4]
 800900a:	460b      	mov	r3, r1
 800900c:	70fb      	strb	r3, [r7, #3]
  PCD_EPTypeDef *ep;

  if ((ep_addr & 0x80U) == 0x80U)
 800900e:	f997 3003 	ldrsb.w	r3, [r7, #3]
 8009012:	2b00      	cmp	r3, #0
 8009014:	da0f      	bge.n	8009036 <HAL_PCD_EP_Close+0x34>
  {
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8009016:	78fb      	ldrb	r3, [r7, #3]
 8009018:	f003 020f 	and.w	r2, r3, #15
 800901c:	4613      	mov	r3, r2
 800901e:	00db      	lsls	r3, r3, #3
 8009020:	4413      	add	r3, r2
 8009022:	009b      	lsls	r3, r3, #2
 8009024:	3310      	adds	r3, #16
 8009026:	687a      	ldr	r2, [r7, #4]
 8009028:	4413      	add	r3, r2
 800902a:	3304      	adds	r3, #4
 800902c:	60fb      	str	r3, [r7, #12]
    ep->is_in = 1U;
 800902e:	68fb      	ldr	r3, [r7, #12]
 8009030:	2201      	movs	r2, #1
 8009032:	705a      	strb	r2, [r3, #1]
 8009034:	e00f      	b.n	8009056 <HAL_PCD_EP_Close+0x54>
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 8009036:	78fb      	ldrb	r3, [r7, #3]
 8009038:	f003 020f 	and.w	r2, r3, #15
 800903c:	4613      	mov	r3, r2
 800903e:	00db      	lsls	r3, r3, #3
 8009040:	4413      	add	r3, r2
 8009042:	009b      	lsls	r3, r3, #2
 8009044:	f503 7314 	add.w	r3, r3, #592	@ 0x250
 8009048:	687a      	ldr	r2, [r7, #4]
 800904a:	4413      	add	r3, r2
 800904c:	3304      	adds	r3, #4
 800904e:	60fb      	str	r3, [r7, #12]
    ep->is_in = 0U;
 8009050:	68fb      	ldr	r3, [r7, #12]
 8009052:	2200      	movs	r2, #0
 8009054:	705a      	strb	r2, [r3, #1]
  }
  ep->num = ep_addr & EP_ADDR_MSK;
 8009056:	78fb      	ldrb	r3, [r7, #3]
 8009058:	f003 030f 	and.w	r3, r3, #15
 800905c:	b2da      	uxtb	r2, r3
 800905e:	68fb      	ldr	r3, [r7, #12]
 8009060:	701a      	strb	r2, [r3, #0]

  __HAL_LOCK(hpcd);
 8009062:	687b      	ldr	r3, [r7, #4]
 8009064:	f893 3494 	ldrb.w	r3, [r3, #1172]	@ 0x494
 8009068:	2b01      	cmp	r3, #1
 800906a:	d101      	bne.n	8009070 <HAL_PCD_EP_Close+0x6e>
 800906c:	2302      	movs	r3, #2
 800906e:	e00e      	b.n	800908e <HAL_PCD_EP_Close+0x8c>
 8009070:	687b      	ldr	r3, [r7, #4]
 8009072:	2201      	movs	r2, #1
 8009074:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494
  (void)USB_DeactivateEndpoint(hpcd->Instance, ep);
 8009078:	687b      	ldr	r3, [r7, #4]
 800907a:	681b      	ldr	r3, [r3, #0]
 800907c:	68f9      	ldr	r1, [r7, #12]
 800907e:	4618      	mov	r0, r3
 8009080:	f006 fcac 	bl	800f9dc <USB_DeactivateEndpoint>
  __HAL_UNLOCK(hpcd);
 8009084:	687b      	ldr	r3, [r7, #4]
 8009086:	2200      	movs	r2, #0
 8009088:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494
  return HAL_OK;
 800908c:	2300      	movs	r3, #0
}
 800908e:	4618      	mov	r0, r3
 8009090:	3710      	adds	r7, #16
 8009092:	46bd      	mov	sp, r7
 8009094:	bd80      	pop	{r7, pc}

08009096 <HAL_PCD_EP_Receive>:
  * @param  pBuf pointer to the reception buffer
  * @param  len amount of data to be received
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Receive(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
{
 8009096:	b580      	push	{r7, lr}
 8009098:	b086      	sub	sp, #24
 800909a:	af00      	add	r7, sp, #0
 800909c:	60f8      	str	r0, [r7, #12]
 800909e:	607a      	str	r2, [r7, #4]
 80090a0:	603b      	str	r3, [r7, #0]
 80090a2:	460b      	mov	r3, r1
 80090a4:	72fb      	strb	r3, [r7, #11]
  PCD_EPTypeDef *ep;

  ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 80090a6:	7afb      	ldrb	r3, [r7, #11]
 80090a8:	f003 020f 	and.w	r2, r3, #15
 80090ac:	4613      	mov	r3, r2
 80090ae:	00db      	lsls	r3, r3, #3
 80090b0:	4413      	add	r3, r2
 80090b2:	009b      	lsls	r3, r3, #2
 80090b4:	f503 7314 	add.w	r3, r3, #592	@ 0x250
 80090b8:	68fa      	ldr	r2, [r7, #12]
 80090ba:	4413      	add	r3, r2
 80090bc:	3304      	adds	r3, #4
 80090be:	617b      	str	r3, [r7, #20]

  /*setup and start the Xfer */
  ep->xfer_buff = pBuf;
 80090c0:	697b      	ldr	r3, [r7, #20]
 80090c2:	687a      	ldr	r2, [r7, #4]
 80090c4:	60da      	str	r2, [r3, #12]
  ep->xfer_len = len;
 80090c6:	697b      	ldr	r3, [r7, #20]
 80090c8:	683a      	ldr	r2, [r7, #0]
 80090ca:	611a      	str	r2, [r3, #16]
  ep->xfer_count = 0U;
 80090cc:	697b      	ldr	r3, [r7, #20]
 80090ce:	2200      	movs	r2, #0
 80090d0:	615a      	str	r2, [r3, #20]
  ep->is_in = 0U;
 80090d2:	697b      	ldr	r3, [r7, #20]
 80090d4:	2200      	movs	r2, #0
 80090d6:	705a      	strb	r2, [r3, #1]
  ep->num = ep_addr & EP_ADDR_MSK;
 80090d8:	7afb      	ldrb	r3, [r7, #11]
 80090da:	f003 030f 	and.w	r3, r3, #15
 80090de:	b2da      	uxtb	r2, r3
 80090e0:	697b      	ldr	r3, [r7, #20]
 80090e2:	701a      	strb	r2, [r3, #0]

  if (hpcd->Init.dma_enable == 1U)
 80090e4:	68fb      	ldr	r3, [r7, #12]
 80090e6:	799b      	ldrb	r3, [r3, #6]
 80090e8:	2b01      	cmp	r3, #1
 80090ea:	d102      	bne.n	80090f2 <HAL_PCD_EP_Receive+0x5c>
  {
    ep->dma_addr = (uint32_t)pBuf;
 80090ec:	687a      	ldr	r2, [r7, #4]
 80090ee:	697b      	ldr	r3, [r7, #20]
 80090f0:	61da      	str	r2, [r3, #28]
  }

  (void)USB_EPStartXfer(hpcd->Instance, ep, (uint8_t)hpcd->Init.dma_enable);
 80090f2:	68fb      	ldr	r3, [r7, #12]
 80090f4:	6818      	ldr	r0, [r3, #0]
 80090f6:	68fb      	ldr	r3, [r7, #12]
 80090f8:	799b      	ldrb	r3, [r3, #6]
 80090fa:	461a      	mov	r2, r3
 80090fc:	6979      	ldr	r1, [r7, #20]
 80090fe:	f006 fd49 	bl	800fb94 <USB_EPStartXfer>

  return HAL_OK;
 8009102:	2300      	movs	r3, #0
}
 8009104:	4618      	mov	r0, r3
 8009106:	3718      	adds	r7, #24
 8009108:	46bd      	mov	sp, r7
 800910a:	bd80      	pop	{r7, pc}

0800910c <HAL_PCD_EP_GetRxCount>:
  * @param  hpcd PCD handle
  * @param  ep_addr endpoint address
  * @retval Data Size
  */
uint32_t HAL_PCD_EP_GetRxCount(PCD_HandleTypeDef const *hpcd, uint8_t ep_addr)
{
 800910c:	b480      	push	{r7}
 800910e:	b083      	sub	sp, #12
 8009110:	af00      	add	r7, sp, #0
 8009112:	6078      	str	r0, [r7, #4]
 8009114:	460b      	mov	r3, r1
 8009116:	70fb      	strb	r3, [r7, #3]
  return hpcd->OUT_ep[ep_addr & EP_ADDR_MSK].xfer_count;
 8009118:	78fb      	ldrb	r3, [r7, #3]
 800911a:	f003 020f 	and.w	r2, r3, #15
 800911e:	6879      	ldr	r1, [r7, #4]
 8009120:	4613      	mov	r3, r2
 8009122:	00db      	lsls	r3, r3, #3
 8009124:	4413      	add	r3, r2
 8009126:	009b      	lsls	r3, r3, #2
 8009128:	440b      	add	r3, r1
 800912a:	f503 731a 	add.w	r3, r3, #616	@ 0x268
 800912e:	681b      	ldr	r3, [r3, #0]
}
 8009130:	4618      	mov	r0, r3
 8009132:	370c      	adds	r7, #12
 8009134:	46bd      	mov	sp, r7
 8009136:	f85d 7b04 	ldr.w	r7, [sp], #4
 800913a:	4770      	bx	lr

0800913c <HAL_PCD_EP_Transmit>:
  * @param  pBuf pointer to the transmission buffer
  * @param  len amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Transmit(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
{
 800913c:	b580      	push	{r7, lr}
 800913e:	b086      	sub	sp, #24
 8009140:	af00      	add	r7, sp, #0
 8009142:	60f8      	str	r0, [r7, #12]
 8009144:	607a      	str	r2, [r7, #4]
 8009146:	603b      	str	r3, [r7, #0]
 8009148:	460b      	mov	r3, r1
 800914a:	72fb      	strb	r3, [r7, #11]
  PCD_EPTypeDef *ep;

  ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 800914c:	7afb      	ldrb	r3, [r7, #11]
 800914e:	f003 020f 	and.w	r2, r3, #15
 8009152:	4613      	mov	r3, r2
 8009154:	00db      	lsls	r3, r3, #3
 8009156:	4413      	add	r3, r2
 8009158:	009b      	lsls	r3, r3, #2
 800915a:	3310      	adds	r3, #16
 800915c:	68fa      	ldr	r2, [r7, #12]
 800915e:	4413      	add	r3, r2
 8009160:	3304      	adds	r3, #4
 8009162:	617b      	str	r3, [r7, #20]

  /*setup and start the Xfer */
  ep->xfer_buff = pBuf;
 8009164:	697b      	ldr	r3, [r7, #20]
 8009166:	687a      	ldr	r2, [r7, #4]
 8009168:	60da      	str	r2, [r3, #12]
  ep->xfer_len = len;
 800916a:	697b      	ldr	r3, [r7, #20]
 800916c:	683a      	ldr	r2, [r7, #0]
 800916e:	611a      	str	r2, [r3, #16]
  ep->xfer_count = 0U;
 8009170:	697b      	ldr	r3, [r7, #20]
 8009172:	2200      	movs	r2, #0
 8009174:	615a      	str	r2, [r3, #20]
  ep->is_in = 1U;
 8009176:	697b      	ldr	r3, [r7, #20]
 8009178:	2201      	movs	r2, #1
 800917a:	705a      	strb	r2, [r3, #1]
  ep->num = ep_addr & EP_ADDR_MSK;
 800917c:	7afb      	ldrb	r3, [r7, #11]
 800917e:	f003 030f 	and.w	r3, r3, #15
 8009182:	b2da      	uxtb	r2, r3
 8009184:	697b      	ldr	r3, [r7, #20]
 8009186:	701a      	strb	r2, [r3, #0]

  if (hpcd->Init.dma_enable == 1U)
 8009188:	68fb      	ldr	r3, [r7, #12]
 800918a:	799b      	ldrb	r3, [r3, #6]
 800918c:	2b01      	cmp	r3, #1
 800918e:	d102      	bne.n	8009196 <HAL_PCD_EP_Transmit+0x5a>
  {
    ep->dma_addr = (uint32_t)pBuf;
 8009190:	687a      	ldr	r2, [r7, #4]
 8009192:	697b      	ldr	r3, [r7, #20]
 8009194:	61da      	str	r2, [r3, #28]
  }

  (void)USB_EPStartXfer(hpcd->Instance, ep, (uint8_t)hpcd->Init.dma_enable);
 8009196:	68fb      	ldr	r3, [r7, #12]
 8009198:	6818      	ldr	r0, [r3, #0]
 800919a:	68fb      	ldr	r3, [r7, #12]
 800919c:	799b      	ldrb	r3, [r3, #6]
 800919e:	461a      	mov	r2, r3
 80091a0:	6979      	ldr	r1, [r7, #20]
 80091a2:	f006 fcf7 	bl	800fb94 <USB_EPStartXfer>

  return HAL_OK;
 80091a6:	2300      	movs	r3, #0
}
 80091a8:	4618      	mov	r0, r3
 80091aa:	3718      	adds	r7, #24
 80091ac:	46bd      	mov	sp, r7
 80091ae:	bd80      	pop	{r7, pc}

080091b0 <HAL_PCD_EP_SetStall>:
  * @param  hpcd PCD handle
  * @param  ep_addr endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_SetStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
 80091b0:	b580      	push	{r7, lr}
 80091b2:	b084      	sub	sp, #16
 80091b4:	af00      	add	r7, sp, #0
 80091b6:	6078      	str	r0, [r7, #4]
 80091b8:	460b      	mov	r3, r1
 80091ba:	70fb      	strb	r3, [r7, #3]
  PCD_EPTypeDef *ep;

  if (((uint32_t)ep_addr & EP_ADDR_MSK) > hpcd->Init.dev_endpoints)
 80091bc:	78fb      	ldrb	r3, [r7, #3]
 80091be:	f003 030f 	and.w	r3, r3, #15
 80091c2:	687a      	ldr	r2, [r7, #4]
 80091c4:	7912      	ldrb	r2, [r2, #4]
 80091c6:	4293      	cmp	r3, r2
 80091c8:	d901      	bls.n	80091ce <HAL_PCD_EP_SetStall+0x1e>
  {
    return HAL_ERROR;
 80091ca:	2301      	movs	r3, #1
 80091cc:	e04f      	b.n	800926e <HAL_PCD_EP_SetStall+0xbe>
  }

  if ((0x80U & ep_addr) == 0x80U)
 80091ce:	f997 3003 	ldrsb.w	r3, [r7, #3]
 80091d2:	2b00      	cmp	r3, #0
 80091d4:	da0f      	bge.n	80091f6 <HAL_PCD_EP_SetStall+0x46>
  {
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 80091d6:	78fb      	ldrb	r3, [r7, #3]
 80091d8:	f003 020f 	and.w	r2, r3, #15
 80091dc:	4613      	mov	r3, r2
 80091de:	00db      	lsls	r3, r3, #3
 80091e0:	4413      	add	r3, r2
 80091e2:	009b      	lsls	r3, r3, #2
 80091e4:	3310      	adds	r3, #16
 80091e6:	687a      	ldr	r2, [r7, #4]
 80091e8:	4413      	add	r3, r2
 80091ea:	3304      	adds	r3, #4
 80091ec:	60fb      	str	r3, [r7, #12]
    ep->is_in = 1U;
 80091ee:	68fb      	ldr	r3, [r7, #12]
 80091f0:	2201      	movs	r2, #1
 80091f2:	705a      	strb	r2, [r3, #1]
 80091f4:	e00d      	b.n	8009212 <HAL_PCD_EP_SetStall+0x62>
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr];
 80091f6:	78fa      	ldrb	r2, [r7, #3]
 80091f8:	4613      	mov	r3, r2
 80091fa:	00db      	lsls	r3, r3, #3
 80091fc:	4413      	add	r3, r2
 80091fe:	009b      	lsls	r3, r3, #2
 8009200:	f503 7314 	add.w	r3, r3, #592	@ 0x250
 8009204:	687a      	ldr	r2, [r7, #4]
 8009206:	4413      	add	r3, r2
 8009208:	3304      	adds	r3, #4
 800920a:	60fb      	str	r3, [r7, #12]
    ep->is_in = 0U;
 800920c:	68fb      	ldr	r3, [r7, #12]
 800920e:	2200      	movs	r2, #0
 8009210:	705a      	strb	r2, [r3, #1]
  }

  ep->is_stall = 1U;
 8009212:	68fb      	ldr	r3, [r7, #12]
 8009214:	2201      	movs	r2, #1
 8009216:	709a      	strb	r2, [r3, #2]
  ep->num = ep_addr & EP_ADDR_MSK;
 8009218:	78fb      	ldrb	r3, [r7, #3]
 800921a:	f003 030f 	and.w	r3, r3, #15
 800921e:	b2da      	uxtb	r2, r3
 8009220:	68fb      	ldr	r3, [r7, #12]
 8009222:	701a      	strb	r2, [r3, #0]

  __HAL_LOCK(hpcd);
 8009224:	687b      	ldr	r3, [r7, #4]
 8009226:	f893 3494 	ldrb.w	r3, [r3, #1172]	@ 0x494
 800922a:	2b01      	cmp	r3, #1
 800922c:	d101      	bne.n	8009232 <HAL_PCD_EP_SetStall+0x82>
 800922e:	2302      	movs	r3, #2
 8009230:	e01d      	b.n	800926e <HAL_PCD_EP_SetStall+0xbe>
 8009232:	687b      	ldr	r3, [r7, #4]
 8009234:	2201      	movs	r2, #1
 8009236:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494

  (void)USB_EPSetStall(hpcd->Instance, ep);
 800923a:	687b      	ldr	r3, [r7, #4]
 800923c:	681b      	ldr	r3, [r3, #0]
 800923e:	68f9      	ldr	r1, [r7, #12]
 8009240:	4618      	mov	r0, r3
 8009242:	f007 f887 	bl	8010354 <USB_EPSetStall>

  if ((ep_addr & EP_ADDR_MSK) == 0U)
 8009246:	78fb      	ldrb	r3, [r7, #3]
 8009248:	f003 030f 	and.w	r3, r3, #15
 800924c:	2b00      	cmp	r3, #0
 800924e:	d109      	bne.n	8009264 <HAL_PCD_EP_SetStall+0xb4>
  {
    (void)USB_EP0_OutStart(hpcd->Instance, (uint8_t)hpcd->Init.dma_enable, (uint8_t *)hpcd->Setup);
 8009250:	687b      	ldr	r3, [r7, #4]
 8009252:	6818      	ldr	r0, [r3, #0]
 8009254:	687b      	ldr	r3, [r7, #4]
 8009256:	7999      	ldrb	r1, [r3, #6]
 8009258:	687b      	ldr	r3, [r7, #4]
 800925a:	f203 439c 	addw	r3, r3, #1180	@ 0x49c
 800925e:	461a      	mov	r2, r3
 8009260:	f007 fa7a 	bl	8010758 <USB_EP0_OutStart>
  }

  __HAL_UNLOCK(hpcd);
 8009264:	687b      	ldr	r3, [r7, #4]
 8009266:	2200      	movs	r2, #0
 8009268:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494

  return HAL_OK;
 800926c:	2300      	movs	r3, #0
}
 800926e:	4618      	mov	r0, r3
 8009270:	3710      	adds	r7, #16
 8009272:	46bd      	mov	sp, r7
 8009274:	bd80      	pop	{r7, pc}

08009276 <HAL_PCD_EP_ClrStall>:
  * @param  hpcd PCD handle
  * @param  ep_addr endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_ClrStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
 8009276:	b580      	push	{r7, lr}
 8009278:	b084      	sub	sp, #16
 800927a:	af00      	add	r7, sp, #0
 800927c:	6078      	str	r0, [r7, #4]
 800927e:	460b      	mov	r3, r1
 8009280:	70fb      	strb	r3, [r7, #3]
  PCD_EPTypeDef *ep;

  if (((uint32_t)ep_addr & 0x0FU) > hpcd->Init.dev_endpoints)
 8009282:	78fb      	ldrb	r3, [r7, #3]
 8009284:	f003 030f 	and.w	r3, r3, #15
 8009288:	687a      	ldr	r2, [r7, #4]
 800928a:	7912      	ldrb	r2, [r2, #4]
 800928c:	4293      	cmp	r3, r2
 800928e:	d901      	bls.n	8009294 <HAL_PCD_EP_ClrStall+0x1e>
  {
    return HAL_ERROR;
 8009290:	2301      	movs	r3, #1
 8009292:	e042      	b.n	800931a <HAL_PCD_EP_ClrStall+0xa4>
  }

  if ((0x80U & ep_addr) == 0x80U)
 8009294:	f997 3003 	ldrsb.w	r3, [r7, #3]
 8009298:	2b00      	cmp	r3, #0
 800929a:	da0f      	bge.n	80092bc <HAL_PCD_EP_ClrStall+0x46>
  {
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 800929c:	78fb      	ldrb	r3, [r7, #3]
 800929e:	f003 020f 	and.w	r2, r3, #15
 80092a2:	4613      	mov	r3, r2
 80092a4:	00db      	lsls	r3, r3, #3
 80092a6:	4413      	add	r3, r2
 80092a8:	009b      	lsls	r3, r3, #2
 80092aa:	3310      	adds	r3, #16
 80092ac:	687a      	ldr	r2, [r7, #4]
 80092ae:	4413      	add	r3, r2
 80092b0:	3304      	adds	r3, #4
 80092b2:	60fb      	str	r3, [r7, #12]
    ep->is_in = 1U;
 80092b4:	68fb      	ldr	r3, [r7, #12]
 80092b6:	2201      	movs	r2, #1
 80092b8:	705a      	strb	r2, [r3, #1]
 80092ba:	e00f      	b.n	80092dc <HAL_PCD_EP_ClrStall+0x66>
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 80092bc:	78fb      	ldrb	r3, [r7, #3]
 80092be:	f003 020f 	and.w	r2, r3, #15
 80092c2:	4613      	mov	r3, r2
 80092c4:	00db      	lsls	r3, r3, #3
 80092c6:	4413      	add	r3, r2
 80092c8:	009b      	lsls	r3, r3, #2
 80092ca:	f503 7314 	add.w	r3, r3, #592	@ 0x250
 80092ce:	687a      	ldr	r2, [r7, #4]
 80092d0:	4413      	add	r3, r2
 80092d2:	3304      	adds	r3, #4
 80092d4:	60fb      	str	r3, [r7, #12]
    ep->is_in = 0U;
 80092d6:	68fb      	ldr	r3, [r7, #12]
 80092d8:	2200      	movs	r2, #0
 80092da:	705a      	strb	r2, [r3, #1]
  }

  ep->is_stall = 0U;
 80092dc:	68fb      	ldr	r3, [r7, #12]
 80092de:	2200      	movs	r2, #0
 80092e0:	709a      	strb	r2, [r3, #2]
  ep->num = ep_addr & EP_ADDR_MSK;
 80092e2:	78fb      	ldrb	r3, [r7, #3]
 80092e4:	f003 030f 	and.w	r3, r3, #15
 80092e8:	b2da      	uxtb	r2, r3
 80092ea:	68fb      	ldr	r3, [r7, #12]
 80092ec:	701a      	strb	r2, [r3, #0]

  __HAL_LOCK(hpcd);
 80092ee:	687b      	ldr	r3, [r7, #4]
 80092f0:	f893 3494 	ldrb.w	r3, [r3, #1172]	@ 0x494
 80092f4:	2b01      	cmp	r3, #1
 80092f6:	d101      	bne.n	80092fc <HAL_PCD_EP_ClrStall+0x86>
 80092f8:	2302      	movs	r3, #2
 80092fa:	e00e      	b.n	800931a <HAL_PCD_EP_ClrStall+0xa4>
 80092fc:	687b      	ldr	r3, [r7, #4]
 80092fe:	2201      	movs	r2, #1
 8009300:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494
  (void)USB_EPClearStall(hpcd->Instance, ep);
 8009304:	687b      	ldr	r3, [r7, #4]
 8009306:	681b      	ldr	r3, [r3, #0]
 8009308:	68f9      	ldr	r1, [r7, #12]
 800930a:	4618      	mov	r0, r3
 800930c:	f007 f890 	bl	8010430 <USB_EPClearStall>
  __HAL_UNLOCK(hpcd);
 8009310:	687b      	ldr	r3, [r7, #4]
 8009312:	2200      	movs	r2, #0
 8009314:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494

  return HAL_OK;
 8009318:	2300      	movs	r3, #0
}
 800931a:	4618      	mov	r0, r3
 800931c:	3710      	adds	r7, #16
 800931e:	46bd      	mov	sp, r7
 8009320:	bd80      	pop	{r7, pc}

08009322 <HAL_PCD_EP_Abort>:
   * @param  hpcd PCD handle
   * @param  ep_addr endpoint address
   * @retval HAL status
   */
HAL_StatusTypeDef HAL_PCD_EP_Abort(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
 8009322:	b580      	push	{r7, lr}
 8009324:	b084      	sub	sp, #16
 8009326:	af00      	add	r7, sp, #0
 8009328:	6078      	str	r0, [r7, #4]
 800932a:	460b      	mov	r3, r1
 800932c:	70fb      	strb	r3, [r7, #3]
  HAL_StatusTypeDef ret;
  PCD_EPTypeDef *ep;

  if ((0x80U & ep_addr) == 0x80U)
 800932e:	f997 3003 	ldrsb.w	r3, [r7, #3]
 8009332:	2b00      	cmp	r3, #0
 8009334:	da0c      	bge.n	8009350 <HAL_PCD_EP_Abort+0x2e>
  {
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8009336:	78fb      	ldrb	r3, [r7, #3]
 8009338:	f003 020f 	and.w	r2, r3, #15
 800933c:	4613      	mov	r3, r2
 800933e:	00db      	lsls	r3, r3, #3
 8009340:	4413      	add	r3, r2
 8009342:	009b      	lsls	r3, r3, #2
 8009344:	3310      	adds	r3, #16
 8009346:	687a      	ldr	r2, [r7, #4]
 8009348:	4413      	add	r3, r2
 800934a:	3304      	adds	r3, #4
 800934c:	60fb      	str	r3, [r7, #12]
 800934e:	e00c      	b.n	800936a <HAL_PCD_EP_Abort+0x48>
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 8009350:	78fb      	ldrb	r3, [r7, #3]
 8009352:	f003 020f 	and.w	r2, r3, #15
 8009356:	4613      	mov	r3, r2
 8009358:	00db      	lsls	r3, r3, #3
 800935a:	4413      	add	r3, r2
 800935c:	009b      	lsls	r3, r3, #2
 800935e:	f503 7314 	add.w	r3, r3, #592	@ 0x250
 8009362:	687a      	ldr	r2, [r7, #4]
 8009364:	4413      	add	r3, r2
 8009366:	3304      	adds	r3, #4
 8009368:	60fb      	str	r3, [r7, #12]
  }

  /* Stop Xfer */
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 800936a:	687b      	ldr	r3, [r7, #4]
 800936c:	681b      	ldr	r3, [r3, #0]
 800936e:	68f9      	ldr	r1, [r7, #12]
 8009370:	4618      	mov	r0, r3
 8009372:	f006 feaf 	bl	80100d4 <USB_EPStopXfer>
 8009376:	4603      	mov	r3, r0
 8009378:	72fb      	strb	r3, [r7, #11]

  return ret;
 800937a:	7afb      	ldrb	r3, [r7, #11]
}
 800937c:	4618      	mov	r0, r3
 800937e:	3710      	adds	r7, #16
 8009380:	46bd      	mov	sp, r7
 8009382:	bd80      	pop	{r7, pc}

08009384 <PCD_WriteEmptyTxFifo>:
  * @param  hpcd PCD handle
  * @param  epnum endpoint number
  * @retval HAL status
  */
static HAL_StatusTypeDef PCD_WriteEmptyTxFifo(PCD_HandleTypeDef *hpcd, uint32_t epnum)
{
 8009384:	b580      	push	{r7, lr}
 8009386:	b08a      	sub	sp, #40	@ 0x28
 8009388:	af02      	add	r7, sp, #8
 800938a:	6078      	str	r0, [r7, #4]
 800938c:	6039      	str	r1, [r7, #0]
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 800938e:	687b      	ldr	r3, [r7, #4]
 8009390:	681b      	ldr	r3, [r3, #0]
 8009392:	617b      	str	r3, [r7, #20]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8009394:	697b      	ldr	r3, [r7, #20]
 8009396:	613b      	str	r3, [r7, #16]
  USB_OTG_EPTypeDef *ep;
  uint32_t len;
  uint32_t len32b;
  uint32_t fifoemptymsk;

  ep = &hpcd->IN_ep[epnum];
 8009398:	683a      	ldr	r2, [r7, #0]
 800939a:	4613      	mov	r3, r2
 800939c:	00db      	lsls	r3, r3, #3
 800939e:	4413      	add	r3, r2
 80093a0:	009b      	lsls	r3, r3, #2
 80093a2:	3310      	adds	r3, #16
 80093a4:	687a      	ldr	r2, [r7, #4]
 80093a6:	4413      	add	r3, r2
 80093a8:	3304      	adds	r3, #4
 80093aa:	60fb      	str	r3, [r7, #12]

  if (ep->xfer_count > ep->xfer_len)
 80093ac:	68fb      	ldr	r3, [r7, #12]
 80093ae:	695a      	ldr	r2, [r3, #20]
 80093b0:	68fb      	ldr	r3, [r7, #12]
 80093b2:	691b      	ldr	r3, [r3, #16]
 80093b4:	429a      	cmp	r2, r3
 80093b6:	d901      	bls.n	80093bc <PCD_WriteEmptyTxFifo+0x38>
  {
    return HAL_ERROR;
 80093b8:	2301      	movs	r3, #1
 80093ba:	e06b      	b.n	8009494 <PCD_WriteEmptyTxFifo+0x110>
  }

  len = ep->xfer_len - ep->xfer_count;
 80093bc:	68fb      	ldr	r3, [r7, #12]
 80093be:	691a      	ldr	r2, [r3, #16]
 80093c0:	68fb      	ldr	r3, [r7, #12]
 80093c2:	695b      	ldr	r3, [r3, #20]
 80093c4:	1ad3      	subs	r3, r2, r3
 80093c6:	61fb      	str	r3, [r7, #28]

  if (len > ep->maxpacket)
 80093c8:	68fb      	ldr	r3, [r7, #12]
 80093ca:	689b      	ldr	r3, [r3, #8]
 80093cc:	69fa      	ldr	r2, [r7, #28]
 80093ce:	429a      	cmp	r2, r3
 80093d0:	d902      	bls.n	80093d8 <PCD_WriteEmptyTxFifo+0x54>
  {
    len = ep->maxpacket;
 80093d2:	68fb      	ldr	r3, [r7, #12]
 80093d4:	689b      	ldr	r3, [r3, #8]
 80093d6:	61fb      	str	r3, [r7, #28]
  }

  len32b = (len + 3U) / 4U;
 80093d8:	69fb      	ldr	r3, [r7, #28]
 80093da:	3303      	adds	r3, #3
 80093dc:	089b      	lsrs	r3, r3, #2
 80093de:	61bb      	str	r3, [r7, #24]

  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 80093e0:	e02a      	b.n	8009438 <PCD_WriteEmptyTxFifo+0xb4>
         (ep->xfer_count < ep->xfer_len) && (ep->xfer_len != 0U))
  {
    /* Write the FIFO */
    len = ep->xfer_len - ep->xfer_count;
 80093e2:	68fb      	ldr	r3, [r7, #12]
 80093e4:	691a      	ldr	r2, [r3, #16]
 80093e6:	68fb      	ldr	r3, [r7, #12]
 80093e8:	695b      	ldr	r3, [r3, #20]
 80093ea:	1ad3      	subs	r3, r2, r3
 80093ec:	61fb      	str	r3, [r7, #28]

    if (len > ep->maxpacket)
 80093ee:	68fb      	ldr	r3, [r7, #12]
 80093f0:	689b      	ldr	r3, [r3, #8]
 80093f2:	69fa      	ldr	r2, [r7, #28]
 80093f4:	429a      	cmp	r2, r3
 80093f6:	d902      	bls.n	80093fe <PCD_WriteEmptyTxFifo+0x7a>
    {
      len = ep->maxpacket;
 80093f8:	68fb      	ldr	r3, [r7, #12]
 80093fa:	689b      	ldr	r3, [r3, #8]
 80093fc:	61fb      	str	r3, [r7, #28]
    }
    len32b = (len + 3U) / 4U;
 80093fe:	69fb      	ldr	r3, [r7, #28]
 8009400:	3303      	adds	r3, #3
 8009402:	089b      	lsrs	r3, r3, #2
 8009404:	61bb      	str	r3, [r7, #24]

    (void)USB_WritePacket(USBx, ep->xfer_buff, (uint8_t)epnum, (uint16_t)len,
 8009406:	68fb      	ldr	r3, [r7, #12]
 8009408:	68d9      	ldr	r1, [r3, #12]
 800940a:	683b      	ldr	r3, [r7, #0]
 800940c:	b2da      	uxtb	r2, r3
 800940e:	69fb      	ldr	r3, [r7, #28]
 8009410:	b298      	uxth	r0, r3
                          (uint8_t)hpcd->Init.dma_enable);
 8009412:	687b      	ldr	r3, [r7, #4]
 8009414:	799b      	ldrb	r3, [r3, #6]
    (void)USB_WritePacket(USBx, ep->xfer_buff, (uint8_t)epnum, (uint16_t)len,
 8009416:	9300      	str	r3, [sp, #0]
 8009418:	4603      	mov	r3, r0
 800941a:	6978      	ldr	r0, [r7, #20]
 800941c:	f006 ff04 	bl	8010228 <USB_WritePacket>

    ep->xfer_buff  += len;
 8009420:	68fb      	ldr	r3, [r7, #12]
 8009422:	68da      	ldr	r2, [r3, #12]
 8009424:	69fb      	ldr	r3, [r7, #28]
 8009426:	441a      	add	r2, r3
 8009428:	68fb      	ldr	r3, [r7, #12]
 800942a:	60da      	str	r2, [r3, #12]
    ep->xfer_count += len;
 800942c:	68fb      	ldr	r3, [r7, #12]
 800942e:	695a      	ldr	r2, [r3, #20]
 8009430:	69fb      	ldr	r3, [r7, #28]
 8009432:	441a      	add	r2, r3
 8009434:	68fb      	ldr	r3, [r7, #12]
 8009436:	615a      	str	r2, [r3, #20]
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 8009438:	683b      	ldr	r3, [r7, #0]
 800943a:	015a      	lsls	r2, r3, #5
 800943c:	693b      	ldr	r3, [r7, #16]
 800943e:	4413      	add	r3, r2
 8009440:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8009444:	699b      	ldr	r3, [r3, #24]
 8009446:	b29b      	uxth	r3, r3
         (ep->xfer_count < ep->xfer_len) && (ep->xfer_len != 0U))
 8009448:	69ba      	ldr	r2, [r7, #24]
 800944a:	429a      	cmp	r2, r3
 800944c:	d809      	bhi.n	8009462 <PCD_WriteEmptyTxFifo+0xde>
 800944e:	68fb      	ldr	r3, [r7, #12]
 8009450:	695a      	ldr	r2, [r3, #20]
 8009452:	68fb      	ldr	r3, [r7, #12]
 8009454:	691b      	ldr	r3, [r3, #16]
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 8009456:	429a      	cmp	r2, r3
 8009458:	d203      	bcs.n	8009462 <PCD_WriteEmptyTxFifo+0xde>
         (ep->xfer_count < ep->xfer_len) && (ep->xfer_len != 0U))
 800945a:	68fb      	ldr	r3, [r7, #12]
 800945c:	691b      	ldr	r3, [r3, #16]
 800945e:	2b00      	cmp	r3, #0
 8009460:	d1bf      	bne.n	80093e2 <PCD_WriteEmptyTxFifo+0x5e>
  }

  if (ep->xfer_len <= ep->xfer_count)
 8009462:	68fb      	ldr	r3, [r7, #12]
 8009464:	691a      	ldr	r2, [r3, #16]
 8009466:	68fb      	ldr	r3, [r7, #12]
 8009468:	695b      	ldr	r3, [r3, #20]
 800946a:	429a      	cmp	r2, r3
 800946c:	d811      	bhi.n	8009492 <PCD_WriteEmptyTxFifo+0x10e>
  {
    fifoemptymsk = (uint32_t)(0x1UL << (epnum & EP_ADDR_MSK));
 800946e:	683b      	ldr	r3, [r7, #0]
 8009470:	f003 030f 	and.w	r3, r3, #15
 8009474:	2201      	movs	r2, #1
 8009476:	fa02 f303 	lsl.w	r3, r2, r3
 800947a:	60bb      	str	r3, [r7, #8]
    USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 800947c:	693b      	ldr	r3, [r7, #16]
 800947e:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8009482:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 8009484:	68bb      	ldr	r3, [r7, #8]
 8009486:	43db      	mvns	r3, r3
 8009488:	6939      	ldr	r1, [r7, #16]
 800948a:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
 800948e:	4013      	ands	r3, r2
 8009490:	634b      	str	r3, [r1, #52]	@ 0x34
  }

  return HAL_OK;
 8009492:	2300      	movs	r3, #0
}
 8009494:	4618      	mov	r0, r3
 8009496:	3720      	adds	r7, #32
 8009498:	46bd      	mov	sp, r7
 800949a:	bd80      	pop	{r7, pc}

0800949c <PCD_EP_OutXfrComplete_int>:
  * @param  hpcd PCD handle
  * @param  epnum endpoint number
  * @retval HAL status
  */
static HAL_StatusTypeDef PCD_EP_OutXfrComplete_int(PCD_HandleTypeDef *hpcd, uint32_t epnum)
{
 800949c:	b580      	push	{r7, lr}
 800949e:	b088      	sub	sp, #32
 80094a0:	af00      	add	r7, sp, #0
 80094a2:	6078      	str	r0, [r7, #4]
 80094a4:	6039      	str	r1, [r7, #0]
  USB_OTG_EPTypeDef *ep;
  const USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 80094a6:	687b      	ldr	r3, [r7, #4]
 80094a8:	681b      	ldr	r3, [r3, #0]
 80094aa:	61fb      	str	r3, [r7, #28]
  uint32_t USBx_BASE = (uint32_t)USBx;
 80094ac:	69fb      	ldr	r3, [r7, #28]
 80094ae:	61bb      	str	r3, [r7, #24]
  uint32_t gSNPSiD = *(__IO const uint32_t *)(&USBx->CID + 0x1U);
 80094b0:	69fb      	ldr	r3, [r7, #28]
 80094b2:	333c      	adds	r3, #60	@ 0x3c
 80094b4:	3304      	adds	r3, #4
 80094b6:	681b      	ldr	r3, [r3, #0]
 80094b8:	617b      	str	r3, [r7, #20]
  uint32_t DoepintReg = USBx_OUTEP(epnum)->DOEPINT;
 80094ba:	683b      	ldr	r3, [r7, #0]
 80094bc:	015a      	lsls	r2, r3, #5
 80094be:	69bb      	ldr	r3, [r7, #24]
 80094c0:	4413      	add	r3, r2
 80094c2:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 80094c6:	689b      	ldr	r3, [r3, #8]
 80094c8:	613b      	str	r3, [r7, #16]

  if (hpcd->Init.dma_enable == 1U)
 80094ca:	687b      	ldr	r3, [r7, #4]
 80094cc:	799b      	ldrb	r3, [r3, #6]
 80094ce:	2b01      	cmp	r3, #1
 80094d0:	d17b      	bne.n	80095ca <PCD_EP_OutXfrComplete_int+0x12e>
  {
    if ((DoepintReg & USB_OTG_DOEPINT_STUP) == USB_OTG_DOEPINT_STUP) /* Class C */
 80094d2:	693b      	ldr	r3, [r7, #16]
 80094d4:	f003 0308 	and.w	r3, r3, #8
 80094d8:	2b00      	cmp	r3, #0
 80094da:	d015      	beq.n	8009508 <PCD_EP_OutXfrComplete_int+0x6c>
    {
      /* StupPktRcvd = 1 this is a setup packet */
      if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 80094dc:	697b      	ldr	r3, [r7, #20]
 80094de:	4a61      	ldr	r2, [pc, #388]	@ (8009664 <PCD_EP_OutXfrComplete_int+0x1c8>)
 80094e0:	4293      	cmp	r3, r2
 80094e2:	f240 80b9 	bls.w	8009658 <PCD_EP_OutXfrComplete_int+0x1bc>
          ((DoepintReg & USB_OTG_DOEPINT_STPKTRX) == USB_OTG_DOEPINT_STPKTRX))
 80094e6:	693b      	ldr	r3, [r7, #16]
 80094e8:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
      if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 80094ec:	2b00      	cmp	r3, #0
 80094ee:	f000 80b3 	beq.w	8009658 <PCD_EP_OutXfrComplete_int+0x1bc>
      {
        CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STPKTRX);
 80094f2:	683b      	ldr	r3, [r7, #0]
 80094f4:	015a      	lsls	r2, r3, #5
 80094f6:	69bb      	ldr	r3, [r7, #24]
 80094f8:	4413      	add	r3, r2
 80094fa:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 80094fe:	461a      	mov	r2, r3
 8009500:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
 8009504:	6093      	str	r3, [r2, #8]
 8009506:	e0a7      	b.n	8009658 <PCD_EP_OutXfrComplete_int+0x1bc>
      }
    }
    else if ((DoepintReg & USB_OTG_DOEPINT_OTEPSPR) == USB_OTG_DOEPINT_OTEPSPR) /* Class E */
 8009508:	693b      	ldr	r3, [r7, #16]
 800950a:	f003 0320 	and.w	r3, r3, #32
 800950e:	2b00      	cmp	r3, #0
 8009510:	d009      	beq.n	8009526 <PCD_EP_OutXfrComplete_int+0x8a>
    {
      CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPSPR);
 8009512:	683b      	ldr	r3, [r7, #0]
 8009514:	015a      	lsls	r2, r3, #5
 8009516:	69bb      	ldr	r3, [r7, #24]
 8009518:	4413      	add	r3, r2
 800951a:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 800951e:	461a      	mov	r2, r3
 8009520:	2320      	movs	r3, #32
 8009522:	6093      	str	r3, [r2, #8]
 8009524:	e098      	b.n	8009658 <PCD_EP_OutXfrComplete_int+0x1bc>
    }
    else if ((DoepintReg & (USB_OTG_DOEPINT_STUP | USB_OTG_DOEPINT_OTEPSPR)) == 0U)
 8009526:	693b      	ldr	r3, [r7, #16]
 8009528:	f003 0328 	and.w	r3, r3, #40	@ 0x28
 800952c:	2b00      	cmp	r3, #0
 800952e:	f040 8093 	bne.w	8009658 <PCD_EP_OutXfrComplete_int+0x1bc>
    {
      /* StupPktRcvd = 1 this is a setup packet */
      if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 8009532:	697b      	ldr	r3, [r7, #20]
 8009534:	4a4b      	ldr	r2, [pc, #300]	@ (8009664 <PCD_EP_OutXfrComplete_int+0x1c8>)
 8009536:	4293      	cmp	r3, r2
 8009538:	d90f      	bls.n	800955a <PCD_EP_OutXfrComplete_int+0xbe>
          ((DoepintReg & USB_OTG_DOEPINT_STPKTRX) == USB_OTG_DOEPINT_STPKTRX))
 800953a:	693b      	ldr	r3, [r7, #16]
 800953c:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
      if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 8009540:	2b00      	cmp	r3, #0
 8009542:	d00a      	beq.n	800955a <PCD_EP_OutXfrComplete_int+0xbe>
      {
        CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STPKTRX);
 8009544:	683b      	ldr	r3, [r7, #0]
 8009546:	015a      	lsls	r2, r3, #5
 8009548:	69bb      	ldr	r3, [r7, #24]
 800954a:	4413      	add	r3, r2
 800954c:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8009550:	461a      	mov	r2, r3
 8009552:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
 8009556:	6093      	str	r3, [r2, #8]
 8009558:	e07e      	b.n	8009658 <PCD_EP_OutXfrComplete_int+0x1bc>
      }
      else
      {
        ep = &hpcd->OUT_ep[epnum];
 800955a:	683a      	ldr	r2, [r7, #0]
 800955c:	4613      	mov	r3, r2
 800955e:	00db      	lsls	r3, r3, #3
 8009560:	4413      	add	r3, r2
 8009562:	009b      	lsls	r3, r3, #2
 8009564:	f503 7314 	add.w	r3, r3, #592	@ 0x250
 8009568:	687a      	ldr	r2, [r7, #4]
 800956a:	4413      	add	r3, r2
 800956c:	3304      	adds	r3, #4
 800956e:	60fb      	str	r3, [r7, #12]

        /* out data packet received over EP */
        ep->xfer_count = ep->xfer_size - (USBx_OUTEP(epnum)->DOEPTSIZ & USB_OTG_DOEPTSIZ_XFRSIZ);
 8009570:	68fb      	ldr	r3, [r7, #12]
 8009572:	6a1a      	ldr	r2, [r3, #32]
 8009574:	683b      	ldr	r3, [r7, #0]
 8009576:	0159      	lsls	r1, r3, #5
 8009578:	69bb      	ldr	r3, [r7, #24]
 800957a:	440b      	add	r3, r1
 800957c:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8009580:	691b      	ldr	r3, [r3, #16]
 8009582:	f3c3 0312 	ubfx	r3, r3, #0, #19
 8009586:	1ad2      	subs	r2, r2, r3
 8009588:	68fb      	ldr	r3, [r7, #12]
 800958a:	615a      	str	r2, [r3, #20]

        if (epnum == 0U)
 800958c:	683b      	ldr	r3, [r7, #0]
 800958e:	2b00      	cmp	r3, #0
 8009590:	d114      	bne.n	80095bc <PCD_EP_OutXfrComplete_int+0x120>
        {
          if (ep->xfer_len == 0U)
 8009592:	68fb      	ldr	r3, [r7, #12]
 8009594:	691b      	ldr	r3, [r3, #16]
 8009596:	2b00      	cmp	r3, #0
 8009598:	d109      	bne.n	80095ae <PCD_EP_OutXfrComplete_int+0x112>
          {
            /* this is ZLP, so prepare EP0 for next setup */
            (void)USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);
 800959a:	687b      	ldr	r3, [r7, #4]
 800959c:	6818      	ldr	r0, [r3, #0]
 800959e:	687b      	ldr	r3, [r7, #4]
 80095a0:	f203 439c 	addw	r3, r3, #1180	@ 0x49c
 80095a4:	461a      	mov	r2, r3
 80095a6:	2101      	movs	r1, #1
 80095a8:	f007 f8d6 	bl	8010758 <USB_EP0_OutStart>
 80095ac:	e006      	b.n	80095bc <PCD_EP_OutXfrComplete_int+0x120>
          }
          else
          {
            ep->xfer_buff += ep->xfer_count;
 80095ae:	68fb      	ldr	r3, [r7, #12]
 80095b0:	68da      	ldr	r2, [r3, #12]
 80095b2:	68fb      	ldr	r3, [r7, #12]
 80095b4:	695b      	ldr	r3, [r3, #20]
 80095b6:	441a      	add	r2, r3
 80095b8:	68fb      	ldr	r3, [r7, #12]
 80095ba:	60da      	str	r2, [r3, #12]
        }

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->DataOutStageCallback(hpcd, (uint8_t)epnum);
#else
        HAL_PCD_DataOutStageCallback(hpcd, (uint8_t)epnum);
 80095bc:	683b      	ldr	r3, [r7, #0]
 80095be:	b2db      	uxtb	r3, r3
 80095c0:	4619      	mov	r1, r3
 80095c2:	6878      	ldr	r0, [r7, #4]
 80095c4:	f009 fa3e 	bl	8012a44 <HAL_PCD_DataOutStageCallback>
 80095c8:	e046      	b.n	8009658 <PCD_EP_OutXfrComplete_int+0x1bc>
      /* ... */
    }
  }
  else
  {
    if (gSNPSiD == USB_OTG_CORE_ID_310A)
 80095ca:	697b      	ldr	r3, [r7, #20]
 80095cc:	4a26      	ldr	r2, [pc, #152]	@ (8009668 <PCD_EP_OutXfrComplete_int+0x1cc>)
 80095ce:	4293      	cmp	r3, r2
 80095d0:	d124      	bne.n	800961c <PCD_EP_OutXfrComplete_int+0x180>
    {
      /* StupPktRcvd = 1 this is a setup packet */
      if ((DoepintReg & USB_OTG_DOEPINT_STPKTRX) == USB_OTG_DOEPINT_STPKTRX)
 80095d2:	693b      	ldr	r3, [r7, #16]
 80095d4:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
 80095d8:	2b00      	cmp	r3, #0
 80095da:	d00a      	beq.n	80095f2 <PCD_EP_OutXfrComplete_int+0x156>
      {
        CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STPKTRX);
 80095dc:	683b      	ldr	r3, [r7, #0]
 80095de:	015a      	lsls	r2, r3, #5
 80095e0:	69bb      	ldr	r3, [r7, #24]
 80095e2:	4413      	add	r3, r2
 80095e4:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 80095e8:	461a      	mov	r2, r3
 80095ea:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
 80095ee:	6093      	str	r3, [r2, #8]
 80095f0:	e032      	b.n	8009658 <PCD_EP_OutXfrComplete_int+0x1bc>
      }
      else
      {
        if ((DoepintReg & USB_OTG_DOEPINT_OTEPSPR) == USB_OTG_DOEPINT_OTEPSPR)
 80095f2:	693b      	ldr	r3, [r7, #16]
 80095f4:	f003 0320 	and.w	r3, r3, #32
 80095f8:	2b00      	cmp	r3, #0
 80095fa:	d008      	beq.n	800960e <PCD_EP_OutXfrComplete_int+0x172>
        {
          CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPSPR);
 80095fc:	683b      	ldr	r3, [r7, #0]
 80095fe:	015a      	lsls	r2, r3, #5
 8009600:	69bb      	ldr	r3, [r7, #24]
 8009602:	4413      	add	r3, r2
 8009604:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8009608:	461a      	mov	r2, r3
 800960a:	2320      	movs	r3, #32
 800960c:	6093      	str	r3, [r2, #8]
        }

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->DataOutStageCallback(hpcd, (uint8_t)epnum);
#else
        HAL_PCD_DataOutStageCallback(hpcd, (uint8_t)epnum);
 800960e:	683b      	ldr	r3, [r7, #0]
 8009610:	b2db      	uxtb	r3, r3
 8009612:	4619      	mov	r1, r3
 8009614:	6878      	ldr	r0, [r7, #4]
 8009616:	f009 fa15 	bl	8012a44 <HAL_PCD_DataOutStageCallback>
 800961a:	e01d      	b.n	8009658 <PCD_EP_OutXfrComplete_int+0x1bc>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
      }
    }
    else
    {
      if ((epnum == 0U) && (hpcd->OUT_ep[epnum].xfer_len == 0U))
 800961c:	683b      	ldr	r3, [r7, #0]
 800961e:	2b00      	cmp	r3, #0
 8009620:	d114      	bne.n	800964c <PCD_EP_OutXfrComplete_int+0x1b0>
 8009622:	6879      	ldr	r1, [r7, #4]
 8009624:	683a      	ldr	r2, [r7, #0]
 8009626:	4613      	mov	r3, r2
 8009628:	00db      	lsls	r3, r3, #3
 800962a:	4413      	add	r3, r2
 800962c:	009b      	lsls	r3, r3, #2
 800962e:	440b      	add	r3, r1
 8009630:	f503 7319 	add.w	r3, r3, #612	@ 0x264
 8009634:	681b      	ldr	r3, [r3, #0]
 8009636:	2b00      	cmp	r3, #0
 8009638:	d108      	bne.n	800964c <PCD_EP_OutXfrComplete_int+0x1b0>
      {
        /* this is ZLP, so prepare EP0 for next setup */
        (void)USB_EP0_OutStart(hpcd->Instance, 0U, (uint8_t *)hpcd->Setup);
 800963a:	687b      	ldr	r3, [r7, #4]
 800963c:	6818      	ldr	r0, [r3, #0]
 800963e:	687b      	ldr	r3, [r7, #4]
 8009640:	f203 439c 	addw	r3, r3, #1180	@ 0x49c
 8009644:	461a      	mov	r2, r3
 8009646:	2100      	movs	r1, #0
 8009648:	f007 f886 	bl	8010758 <USB_EP0_OutStart>
      }

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
      hpcd->DataOutStageCallback(hpcd, (uint8_t)epnum);
#else
      HAL_PCD_DataOutStageCallback(hpcd, (uint8_t)epnum);
 800964c:	683b      	ldr	r3, [r7, #0]
 800964e:	b2db      	uxtb	r3, r3
 8009650:	4619      	mov	r1, r3
 8009652:	6878      	ldr	r0, [r7, #4]
 8009654:	f009 f9f6 	bl	8012a44 <HAL_PCD_DataOutStageCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
    }
  }

  return HAL_OK;
 8009658:	2300      	movs	r3, #0
}
 800965a:	4618      	mov	r0, r3
 800965c:	3720      	adds	r7, #32
 800965e:	46bd      	mov	sp, r7
 8009660:	bd80      	pop	{r7, pc}
 8009662:	bf00      	nop
 8009664:	4f54300a 	.word	0x4f54300a
 8009668:	4f54310a 	.word	0x4f54310a

0800966c <PCD_EP_OutSetupPacket_int>:
  * @param  hpcd PCD handle
  * @param  epnum endpoint number
  * @retval HAL status
  */
static HAL_StatusTypeDef PCD_EP_OutSetupPacket_int(PCD_HandleTypeDef *hpcd, uint32_t epnum)
{
 800966c:	b580      	push	{r7, lr}
 800966e:	b086      	sub	sp, #24
 8009670:	af00      	add	r7, sp, #0
 8009672:	6078      	str	r0, [r7, #4]
 8009674:	6039      	str	r1, [r7, #0]
  const USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 8009676:	687b      	ldr	r3, [r7, #4]
 8009678:	681b      	ldr	r3, [r3, #0]
 800967a:	617b      	str	r3, [r7, #20]
  uint32_t USBx_BASE = (uint32_t)USBx;
 800967c:	697b      	ldr	r3, [r7, #20]
 800967e:	613b      	str	r3, [r7, #16]
  uint32_t gSNPSiD = *(__IO const uint32_t *)(&USBx->CID + 0x1U);
 8009680:	697b      	ldr	r3, [r7, #20]
 8009682:	333c      	adds	r3, #60	@ 0x3c
 8009684:	3304      	adds	r3, #4
 8009686:	681b      	ldr	r3, [r3, #0]
 8009688:	60fb      	str	r3, [r7, #12]
  uint32_t DoepintReg = USBx_OUTEP(epnum)->DOEPINT;
 800968a:	683b      	ldr	r3, [r7, #0]
 800968c:	015a      	lsls	r2, r3, #5
 800968e:	693b      	ldr	r3, [r7, #16]
 8009690:	4413      	add	r3, r2
 8009692:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8009696:	689b      	ldr	r3, [r3, #8]
 8009698:	60bb      	str	r3, [r7, #8]

  if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 800969a:	68fb      	ldr	r3, [r7, #12]
 800969c:	4a15      	ldr	r2, [pc, #84]	@ (80096f4 <PCD_EP_OutSetupPacket_int+0x88>)
 800969e:	4293      	cmp	r3, r2
 80096a0:	d90e      	bls.n	80096c0 <PCD_EP_OutSetupPacket_int+0x54>
      ((DoepintReg & USB_OTG_DOEPINT_STPKTRX) == USB_OTG_DOEPINT_STPKTRX))
 80096a2:	68bb      	ldr	r3, [r7, #8]
 80096a4:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
  if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 80096a8:	2b00      	cmp	r3, #0
 80096aa:	d009      	beq.n	80096c0 <PCD_EP_OutSetupPacket_int+0x54>
  {
    CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STPKTRX);
 80096ac:	683b      	ldr	r3, [r7, #0]
 80096ae:	015a      	lsls	r2, r3, #5
 80096b0:	693b      	ldr	r3, [r7, #16]
 80096b2:	4413      	add	r3, r2
 80096b4:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 80096b8:	461a      	mov	r2, r3
 80096ba:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
 80096be:	6093      	str	r3, [r2, #8]

  /* Inform the upper layer that a setup packet is available */
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
  hpcd->SetupStageCallback(hpcd);
#else
  HAL_PCD_SetupStageCallback(hpcd);
 80096c0:	6878      	ldr	r0, [r7, #4]
 80096c2:	f009 f9ad 	bl	8012a20 <HAL_PCD_SetupStageCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

  if ((gSNPSiD > USB_OTG_CORE_ID_300A) && (hpcd->Init.dma_enable == 1U))
 80096c6:	68fb      	ldr	r3, [r7, #12]
 80096c8:	4a0a      	ldr	r2, [pc, #40]	@ (80096f4 <PCD_EP_OutSetupPacket_int+0x88>)
 80096ca:	4293      	cmp	r3, r2
 80096cc:	d90c      	bls.n	80096e8 <PCD_EP_OutSetupPacket_int+0x7c>
 80096ce:	687b      	ldr	r3, [r7, #4]
 80096d0:	799b      	ldrb	r3, [r3, #6]
 80096d2:	2b01      	cmp	r3, #1
 80096d4:	d108      	bne.n	80096e8 <PCD_EP_OutSetupPacket_int+0x7c>
  {
    (void)USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);
 80096d6:	687b      	ldr	r3, [r7, #4]
 80096d8:	6818      	ldr	r0, [r3, #0]
 80096da:	687b      	ldr	r3, [r7, #4]
 80096dc:	f203 439c 	addw	r3, r3, #1180	@ 0x49c
 80096e0:	461a      	mov	r2, r3
 80096e2:	2101      	movs	r1, #1
 80096e4:	f007 f838 	bl	8010758 <USB_EP0_OutStart>
  }

  return HAL_OK;
 80096e8:	2300      	movs	r3, #0
}
 80096ea:	4618      	mov	r0, r3
 80096ec:	3718      	adds	r7, #24
 80096ee:	46bd      	mov	sp, r7
 80096f0:	bd80      	pop	{r7, pc}
 80096f2:	bf00      	nop
 80096f4:	4f54300a 	.word	0x4f54300a

080096f8 <HAL_PCDEx_SetTxFiFo>:
  * @param  fifo The number of Tx fifo
  * @param  size Fifo size
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_SetTxFiFo(PCD_HandleTypeDef *hpcd, uint8_t fifo, uint16_t size)
{
 80096f8:	b480      	push	{r7}
 80096fa:	b085      	sub	sp, #20
 80096fc:	af00      	add	r7, sp, #0
 80096fe:	6078      	str	r0, [r7, #4]
 8009700:	460b      	mov	r3, r1
 8009702:	70fb      	strb	r3, [r7, #3]
 8009704:	4613      	mov	r3, r2
 8009706:	803b      	strh	r3, [r7, #0]
         --> Txn should be configured with the minimum space of 16 words
     The FIFO is used optimally when used TxFIFOs are allocated in the top
         of the FIFO.Ex: use EP1 and EP2 as IN instead of EP1 and EP3 as IN ones.
     When DMA is used 3n * FIFO locations should be reserved for internal DMA registers */

  Tx_Offset = hpcd->Instance->GRXFSIZ;
 8009708:	687b      	ldr	r3, [r7, #4]
 800970a:	681b      	ldr	r3, [r3, #0]
 800970c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800970e:	60bb      	str	r3, [r7, #8]

  if (fifo == 0U)
 8009710:	78fb      	ldrb	r3, [r7, #3]
 8009712:	2b00      	cmp	r3, #0
 8009714:	d107      	bne.n	8009726 <HAL_PCDEx_SetTxFiFo+0x2e>
  {
    hpcd->Instance->DIEPTXF0_HNPTXFSIZ = ((uint32_t)size << 16) | Tx_Offset;
 8009716:	883b      	ldrh	r3, [r7, #0]
 8009718:	0419      	lsls	r1, r3, #16
 800971a:	687b      	ldr	r3, [r7, #4]
 800971c:	681b      	ldr	r3, [r3, #0]
 800971e:	68ba      	ldr	r2, [r7, #8]
 8009720:	430a      	orrs	r2, r1
 8009722:	629a      	str	r2, [r3, #40]	@ 0x28
 8009724:	e028      	b.n	8009778 <HAL_PCDEx_SetTxFiFo+0x80>
  }
  else
  {
    Tx_Offset += (hpcd->Instance->DIEPTXF0_HNPTXFSIZ) >> 16;
 8009726:	687b      	ldr	r3, [r7, #4]
 8009728:	681b      	ldr	r3, [r3, #0]
 800972a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800972c:	0c1b      	lsrs	r3, r3, #16
 800972e:	68ba      	ldr	r2, [r7, #8]
 8009730:	4413      	add	r3, r2
 8009732:	60bb      	str	r3, [r7, #8]
    for (i = 0U; i < (fifo - 1U); i++)
 8009734:	2300      	movs	r3, #0
 8009736:	73fb      	strb	r3, [r7, #15]
 8009738:	e00d      	b.n	8009756 <HAL_PCDEx_SetTxFiFo+0x5e>
    {
      Tx_Offset += (hpcd->Instance->DIEPTXF[i] >> 16);
 800973a:	687b      	ldr	r3, [r7, #4]
 800973c:	681a      	ldr	r2, [r3, #0]
 800973e:	7bfb      	ldrb	r3, [r7, #15]
 8009740:	3340      	adds	r3, #64	@ 0x40
 8009742:	009b      	lsls	r3, r3, #2
 8009744:	4413      	add	r3, r2
 8009746:	685b      	ldr	r3, [r3, #4]
 8009748:	0c1b      	lsrs	r3, r3, #16
 800974a:	68ba      	ldr	r2, [r7, #8]
 800974c:	4413      	add	r3, r2
 800974e:	60bb      	str	r3, [r7, #8]
    for (i = 0U; i < (fifo - 1U); i++)
 8009750:	7bfb      	ldrb	r3, [r7, #15]
 8009752:	3301      	adds	r3, #1
 8009754:	73fb      	strb	r3, [r7, #15]
 8009756:	7bfa      	ldrb	r2, [r7, #15]
 8009758:	78fb      	ldrb	r3, [r7, #3]
 800975a:	3b01      	subs	r3, #1
 800975c:	429a      	cmp	r2, r3
 800975e:	d3ec      	bcc.n	800973a <HAL_PCDEx_SetTxFiFo+0x42>
    }

    /* Multiply Tx_Size by 2 to get higher performance */
    hpcd->Instance->DIEPTXF[fifo - 1U] = ((uint32_t)size << 16) | Tx_Offset;
 8009760:	883b      	ldrh	r3, [r7, #0]
 8009762:	0418      	lsls	r0, r3, #16
 8009764:	687b      	ldr	r3, [r7, #4]
 8009766:	6819      	ldr	r1, [r3, #0]
 8009768:	78fb      	ldrb	r3, [r7, #3]
 800976a:	3b01      	subs	r3, #1
 800976c:	68ba      	ldr	r2, [r7, #8]
 800976e:	4302      	orrs	r2, r0
 8009770:	3340      	adds	r3, #64	@ 0x40
 8009772:	009b      	lsls	r3, r3, #2
 8009774:	440b      	add	r3, r1
 8009776:	605a      	str	r2, [r3, #4]
  }

  return HAL_OK;
 8009778:	2300      	movs	r3, #0
}
 800977a:	4618      	mov	r0, r3
 800977c:	3714      	adds	r7, #20
 800977e:	46bd      	mov	sp, r7
 8009780:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009784:	4770      	bx	lr

08009786 <HAL_PCDEx_SetRxFiFo>:
  * @param  hpcd PCD handle
  * @param  size Size of Rx fifo
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_SetRxFiFo(PCD_HandleTypeDef *hpcd, uint16_t size)
{
 8009786:	b480      	push	{r7}
 8009788:	b083      	sub	sp, #12
 800978a:	af00      	add	r7, sp, #0
 800978c:	6078      	str	r0, [r7, #4]
 800978e:	460b      	mov	r3, r1
 8009790:	807b      	strh	r3, [r7, #2]
  hpcd->Instance->GRXFSIZ = size;
 8009792:	687b      	ldr	r3, [r7, #4]
 8009794:	681b      	ldr	r3, [r3, #0]
 8009796:	887a      	ldrh	r2, [r7, #2]
 8009798:	625a      	str	r2, [r3, #36]	@ 0x24

  return HAL_OK;
 800979a:	2300      	movs	r3, #0
}
 800979c:	4618      	mov	r0, r3
 800979e:	370c      	adds	r7, #12
 80097a0:	46bd      	mov	sp, r7
 80097a2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80097a6:	4770      	bx	lr

080097a8 <HAL_PCDEx_ActivateLPM>:
  * @brief  Activate LPM feature.
  * @param  hpcd PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_ActivateLPM(PCD_HandleTypeDef *hpcd)
{
 80097a8:	b480      	push	{r7}
 80097aa:	b085      	sub	sp, #20
 80097ac:	af00      	add	r7, sp, #0
 80097ae:	6078      	str	r0, [r7, #4]
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 80097b0:	687b      	ldr	r3, [r7, #4]
 80097b2:	681b      	ldr	r3, [r3, #0]
 80097b4:	60fb      	str	r3, [r7, #12]

  hpcd->lpm_active = 1U;
 80097b6:	687b      	ldr	r3, [r7, #4]
 80097b8:	2201      	movs	r2, #1
 80097ba:	f8c3 24d8 	str.w	r2, [r3, #1240]	@ 0x4d8
  hpcd->LPM_State = LPM_L0;
 80097be:	687b      	ldr	r3, [r7, #4]
 80097c0:	2200      	movs	r2, #0
 80097c2:	f883 24cc 	strb.w	r2, [r3, #1228]	@ 0x4cc
  USBx->GINTMSK |= USB_OTG_GINTMSK_LPMINTM;
 80097c6:	68fb      	ldr	r3, [r7, #12]
 80097c8:	699b      	ldr	r3, [r3, #24]
 80097ca:	f043 6200 	orr.w	r2, r3, #134217728	@ 0x8000000
 80097ce:	68fb      	ldr	r3, [r7, #12]
 80097d0:	619a      	str	r2, [r3, #24]
  USBx->GLPMCFG |= (USB_OTG_GLPMCFG_LPMEN | USB_OTG_GLPMCFG_LPMACK | USB_OTG_GLPMCFG_ENBESL);
 80097d2:	68fb      	ldr	r3, [r7, #12]
 80097d4:	6d5a      	ldr	r2, [r3, #84]	@ 0x54
 80097d6:	4b05      	ldr	r3, [pc, #20]	@ (80097ec <HAL_PCDEx_ActivateLPM+0x44>)
 80097d8:	4313      	orrs	r3, r2
 80097da:	68fa      	ldr	r2, [r7, #12]
 80097dc:	6553      	str	r3, [r2, #84]	@ 0x54

  return HAL_OK;
 80097de:	2300      	movs	r3, #0
}
 80097e0:	4618      	mov	r0, r3
 80097e2:	3714      	adds	r7, #20
 80097e4:	46bd      	mov	sp, r7
 80097e6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80097ea:	4770      	bx	lr
 80097ec:	10000003 	.word	0x10000003

080097f0 <HAL_PCDEx_LPM_Callback>:
  * @param  hpcd PCD handle
  * @param  msg LPM message
  * @retval HAL status
  */
__weak void HAL_PCDEx_LPM_Callback(PCD_HandleTypeDef *hpcd, PCD_LPM_MsgTypeDef msg)
{
 80097f0:	b480      	push	{r7}
 80097f2:	b083      	sub	sp, #12
 80097f4:	af00      	add	r7, sp, #0
 80097f6:	6078      	str	r0, [r7, #4]
 80097f8:	460b      	mov	r3, r1
 80097fa:	70fb      	strb	r3, [r7, #3]
  UNUSED(msg);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_PCDEx_LPM_Callback could be implemented in the user file
   */
}
 80097fc:	bf00      	nop
 80097fe:	370c      	adds	r7, #12
 8009800:	46bd      	mov	sp, r7
 8009802:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009806:	4770      	bx	lr

08009808 <HAL_PWREx_ConfigSupply>:
  *         PWR_SMPS_2V5_SUPPLIES_EXT are used only for lines that supports SMPS
  *         regulator.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_PWREx_ConfigSupply (uint32_t SupplySource)
{
 8009808:	b580      	push	{r7, lr}
 800980a:	b084      	sub	sp, #16
 800980c:	af00      	add	r7, sp, #0
 800980e:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param (IS_PWR_SUPPLY (SupplySource));

  /* Check if supply source was configured */
#if defined (PWR_FLAG_SCUEN)
  if (__HAL_PWR_GET_FLAG (PWR_FLAG_SCUEN) == 0U)
 8009810:	4b19      	ldr	r3, [pc, #100]	@ (8009878 <HAL_PWREx_ConfigSupply+0x70>)
 8009812:	68db      	ldr	r3, [r3, #12]
 8009814:	f003 0304 	and.w	r3, r3, #4
 8009818:	2b04      	cmp	r3, #4
 800981a:	d00a      	beq.n	8009832 <HAL_PWREx_ConfigSupply+0x2a>
#else
  if ((PWR->CR3 & (PWR_CR3_SMPSEN | PWR_CR3_LDOEN | PWR_CR3_BYPASS)) != (PWR_CR3_SMPSEN | PWR_CR3_LDOEN))
#endif /* defined (PWR_FLAG_SCUEN) */
  {
    /* Check supply configuration */
    if ((PWR->CR3 & PWR_SUPPLY_CONFIG_MASK) != SupplySource)
 800981c:	4b16      	ldr	r3, [pc, #88]	@ (8009878 <HAL_PWREx_ConfigSupply+0x70>)
 800981e:	68db      	ldr	r3, [r3, #12]
 8009820:	f003 0307 	and.w	r3, r3, #7
 8009824:	687a      	ldr	r2, [r7, #4]
 8009826:	429a      	cmp	r2, r3
 8009828:	d001      	beq.n	800982e <HAL_PWREx_ConfigSupply+0x26>
    {
      /* Supply configuration update locked, can't apply a new supply config */
      return HAL_ERROR;
 800982a:	2301      	movs	r3, #1
 800982c:	e01f      	b.n	800986e <HAL_PWREx_ConfigSupply+0x66>
    else
    {
      /* Supply configuration update locked, but new supply configuration
         matches with old supply configuration : nothing to do
      */
      return HAL_OK;
 800982e:	2300      	movs	r3, #0
 8009830:	e01d      	b.n	800986e <HAL_PWREx_ConfigSupply+0x66>
    }
  }

  /* Set the power supply configuration */
  MODIFY_REG (PWR->CR3, PWR_SUPPLY_CONFIG_MASK, SupplySource);
 8009832:	4b11      	ldr	r3, [pc, #68]	@ (8009878 <HAL_PWREx_ConfigSupply+0x70>)
 8009834:	68db      	ldr	r3, [r3, #12]
 8009836:	f023 0207 	bic.w	r2, r3, #7
 800983a:	490f      	ldr	r1, [pc, #60]	@ (8009878 <HAL_PWREx_ConfigSupply+0x70>)
 800983c:	687b      	ldr	r3, [r7, #4]
 800983e:	4313      	orrs	r3, r2
 8009840:	60cb      	str	r3, [r1, #12]

  /* Get tick */
  tickstart = HAL_GetTick ();
 8009842:	f7f9 f88d 	bl	8002960 <HAL_GetTick>
 8009846:	60f8      	str	r0, [r7, #12]

  /* Wait till voltage level flag is set */
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_ACTVOSRDY) == 0U)
 8009848:	e009      	b.n	800985e <HAL_PWREx_ConfigSupply+0x56>
  {
    if ((HAL_GetTick () - tickstart) > PWR_FLAG_SETTING_DELAY)
 800984a:	f7f9 f889 	bl	8002960 <HAL_GetTick>
 800984e:	4602      	mov	r2, r0
 8009850:	68fb      	ldr	r3, [r7, #12]
 8009852:	1ad3      	subs	r3, r2, r3
 8009854:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
 8009858:	d901      	bls.n	800985e <HAL_PWREx_ConfigSupply+0x56>
    {
      return HAL_ERROR;
 800985a:	2301      	movs	r3, #1
 800985c:	e007      	b.n	800986e <HAL_PWREx_ConfigSupply+0x66>
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_ACTVOSRDY) == 0U)
 800985e:	4b06      	ldr	r3, [pc, #24]	@ (8009878 <HAL_PWREx_ConfigSupply+0x70>)
 8009860:	685b      	ldr	r3, [r3, #4]
 8009862:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
 8009866:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 800986a:	d1ee      	bne.n	800984a <HAL_PWREx_ConfigSupply+0x42>
      }
    }
  }
#endif /* defined (SMPS) */

  return HAL_OK;
 800986c:	2300      	movs	r3, #0
}
 800986e:	4618      	mov	r0, r3
 8009870:	3710      	adds	r7, #16
 8009872:	46bd      	mov	sp, r7
 8009874:	bd80      	pop	{r7, pc}
 8009876:	bf00      	nop
 8009878:	58024800 	.word	0x58024800

0800987c <HAL_PWREx_EnableUSBVoltageDetector>:
/**
  * @brief Enable the USB voltage level detector.
  * @retval None.
  */
void HAL_PWREx_EnableUSBVoltageDetector (void)
{
 800987c:	b480      	push	{r7}
 800987e:	af00      	add	r7, sp, #0
  /* Enable the USB voltage detector */
  SET_BIT (PWR->CR3, PWR_CR3_USB33DEN);
 8009880:	4b05      	ldr	r3, [pc, #20]	@ (8009898 <HAL_PWREx_EnableUSBVoltageDetector+0x1c>)
 8009882:	68db      	ldr	r3, [r3, #12]
 8009884:	4a04      	ldr	r2, [pc, #16]	@ (8009898 <HAL_PWREx_EnableUSBVoltageDetector+0x1c>)
 8009886:	f043 7380 	orr.w	r3, r3, #16777216	@ 0x1000000
 800988a:	60d3      	str	r3, [r2, #12]
}
 800988c:	bf00      	nop
 800988e:	46bd      	mov	sp, r7
 8009890:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009894:	4770      	bx	lr
 8009896:	bf00      	nop
 8009898:	58024800 	.word	0x58024800

0800989c <HAL_RCC_OscConfig>:
  *         supported by this function. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 800989c:	b580      	push	{r7, lr}
 800989e:	b08c      	sub	sp, #48	@ 0x30
 80098a0:	af00      	add	r7, sp, #0
 80098a2:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;
  uint32_t temp1_pllckcfg, temp2_pllckcfg;

  /* Check Null pointer */
  if (RCC_OscInitStruct == NULL)
 80098a4:	687b      	ldr	r3, [r7, #4]
 80098a6:	2b00      	cmp	r3, #0
 80098a8:	d102      	bne.n	80098b0 <HAL_RCC_OscConfig+0x14>
  {
    return HAL_ERROR;
 80098aa:	2301      	movs	r3, #1
 80098ac:	f000 bc1f 	b.w	800a0ee <HAL_RCC_OscConfig+0x852>
  }

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 80098b0:	687b      	ldr	r3, [r7, #4]
 80098b2:	681b      	ldr	r3, [r3, #0]
 80098b4:	f003 0301 	and.w	r3, r3, #1
 80098b8:	2b00      	cmp	r3, #0
 80098ba:	f000 80b3 	beq.w	8009a24 <HAL_RCC_OscConfig+0x188>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));

    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 80098be:	4b95      	ldr	r3, [pc, #596]	@ (8009b14 <HAL_RCC_OscConfig+0x278>)
 80098c0:	691b      	ldr	r3, [r3, #16]
 80098c2:	f003 0338 	and.w	r3, r3, #56	@ 0x38
 80098c6:	62fb      	str	r3, [r7, #44]	@ 0x2c
    const uint32_t temp_pllckselr = RCC->PLLCKSELR;
 80098c8:	4b92      	ldr	r3, [pc, #584]	@ (8009b14 <HAL_RCC_OscConfig+0x278>)
 80098ca:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80098cc:	62bb      	str	r3, [r7, #40]	@ 0x28
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if ((temp_sysclksrc == RCC_CFGR_SWS_HSE) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_HSE)))
 80098ce:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80098d0:	2b10      	cmp	r3, #16
 80098d2:	d007      	beq.n	80098e4 <HAL_RCC_OscConfig+0x48>
 80098d4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80098d6:	2b18      	cmp	r3, #24
 80098d8:	d112      	bne.n	8009900 <HAL_RCC_OscConfig+0x64>
 80098da:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80098dc:	f003 0303 	and.w	r3, r3, #3
 80098e0:	2b02      	cmp	r3, #2
 80098e2:	d10d      	bne.n	8009900 <HAL_RCC_OscConfig+0x64>
    {
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 80098e4:	4b8b      	ldr	r3, [pc, #556]	@ (8009b14 <HAL_RCC_OscConfig+0x278>)
 80098e6:	681b      	ldr	r3, [r3, #0]
 80098e8:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 80098ec:	2b00      	cmp	r3, #0
 80098ee:	f000 8098 	beq.w	8009a22 <HAL_RCC_OscConfig+0x186>
 80098f2:	687b      	ldr	r3, [r7, #4]
 80098f4:	685b      	ldr	r3, [r3, #4]
 80098f6:	2b00      	cmp	r3, #0
 80098f8:	f040 8093 	bne.w	8009a22 <HAL_RCC_OscConfig+0x186>
      {
        return HAL_ERROR;
 80098fc:	2301      	movs	r3, #1
 80098fe:	e3f6      	b.n	800a0ee <HAL_RCC_OscConfig+0x852>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8009900:	687b      	ldr	r3, [r7, #4]
 8009902:	685b      	ldr	r3, [r3, #4]
 8009904:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 8009908:	d106      	bne.n	8009918 <HAL_RCC_OscConfig+0x7c>
 800990a:	4b82      	ldr	r3, [pc, #520]	@ (8009b14 <HAL_RCC_OscConfig+0x278>)
 800990c:	681b      	ldr	r3, [r3, #0]
 800990e:	4a81      	ldr	r2, [pc, #516]	@ (8009b14 <HAL_RCC_OscConfig+0x278>)
 8009910:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 8009914:	6013      	str	r3, [r2, #0]
 8009916:	e058      	b.n	80099ca <HAL_RCC_OscConfig+0x12e>
 8009918:	687b      	ldr	r3, [r7, #4]
 800991a:	685b      	ldr	r3, [r3, #4]
 800991c:	2b00      	cmp	r3, #0
 800991e:	d112      	bne.n	8009946 <HAL_RCC_OscConfig+0xaa>
 8009920:	4b7c      	ldr	r3, [pc, #496]	@ (8009b14 <HAL_RCC_OscConfig+0x278>)
 8009922:	681b      	ldr	r3, [r3, #0]
 8009924:	4a7b      	ldr	r2, [pc, #492]	@ (8009b14 <HAL_RCC_OscConfig+0x278>)
 8009926:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
 800992a:	6013      	str	r3, [r2, #0]
 800992c:	4b79      	ldr	r3, [pc, #484]	@ (8009b14 <HAL_RCC_OscConfig+0x278>)
 800992e:	681b      	ldr	r3, [r3, #0]
 8009930:	4a78      	ldr	r2, [pc, #480]	@ (8009b14 <HAL_RCC_OscConfig+0x278>)
 8009932:	f423 1380 	bic.w	r3, r3, #1048576	@ 0x100000
 8009936:	6013      	str	r3, [r2, #0]
 8009938:	4b76      	ldr	r3, [pc, #472]	@ (8009b14 <HAL_RCC_OscConfig+0x278>)
 800993a:	681b      	ldr	r3, [r3, #0]
 800993c:	4a75      	ldr	r2, [pc, #468]	@ (8009b14 <HAL_RCC_OscConfig+0x278>)
 800993e:	f423 2380 	bic.w	r3, r3, #262144	@ 0x40000
 8009942:	6013      	str	r3, [r2, #0]
 8009944:	e041      	b.n	80099ca <HAL_RCC_OscConfig+0x12e>
 8009946:	687b      	ldr	r3, [r7, #4]
 8009948:	685b      	ldr	r3, [r3, #4]
 800994a:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
 800994e:	d112      	bne.n	8009976 <HAL_RCC_OscConfig+0xda>
 8009950:	4b70      	ldr	r3, [pc, #448]	@ (8009b14 <HAL_RCC_OscConfig+0x278>)
 8009952:	681b      	ldr	r3, [r3, #0]
 8009954:	4a6f      	ldr	r2, [pc, #444]	@ (8009b14 <HAL_RCC_OscConfig+0x278>)
 8009956:	f443 2380 	orr.w	r3, r3, #262144	@ 0x40000
 800995a:	6013      	str	r3, [r2, #0]
 800995c:	4b6d      	ldr	r3, [pc, #436]	@ (8009b14 <HAL_RCC_OscConfig+0x278>)
 800995e:	681b      	ldr	r3, [r3, #0]
 8009960:	4a6c      	ldr	r2, [pc, #432]	@ (8009b14 <HAL_RCC_OscConfig+0x278>)
 8009962:	f423 1380 	bic.w	r3, r3, #1048576	@ 0x100000
 8009966:	6013      	str	r3, [r2, #0]
 8009968:	4b6a      	ldr	r3, [pc, #424]	@ (8009b14 <HAL_RCC_OscConfig+0x278>)
 800996a:	681b      	ldr	r3, [r3, #0]
 800996c:	4a69      	ldr	r2, [pc, #420]	@ (8009b14 <HAL_RCC_OscConfig+0x278>)
 800996e:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 8009972:	6013      	str	r3, [r2, #0]
 8009974:	e029      	b.n	80099ca <HAL_RCC_OscConfig+0x12e>
 8009976:	687b      	ldr	r3, [r7, #4]
 8009978:	685b      	ldr	r3, [r3, #4]
 800997a:	f5b3 1fa8 	cmp.w	r3, #1376256	@ 0x150000
 800997e:	d112      	bne.n	80099a6 <HAL_RCC_OscConfig+0x10a>
 8009980:	4b64      	ldr	r3, [pc, #400]	@ (8009b14 <HAL_RCC_OscConfig+0x278>)
 8009982:	681b      	ldr	r3, [r3, #0]
 8009984:	4a63      	ldr	r2, [pc, #396]	@ (8009b14 <HAL_RCC_OscConfig+0x278>)
 8009986:	f443 2380 	orr.w	r3, r3, #262144	@ 0x40000
 800998a:	6013      	str	r3, [r2, #0]
 800998c:	4b61      	ldr	r3, [pc, #388]	@ (8009b14 <HAL_RCC_OscConfig+0x278>)
 800998e:	681b      	ldr	r3, [r3, #0]
 8009990:	4a60      	ldr	r2, [pc, #384]	@ (8009b14 <HAL_RCC_OscConfig+0x278>)
 8009992:	f443 1380 	orr.w	r3, r3, #1048576	@ 0x100000
 8009996:	6013      	str	r3, [r2, #0]
 8009998:	4b5e      	ldr	r3, [pc, #376]	@ (8009b14 <HAL_RCC_OscConfig+0x278>)
 800999a:	681b      	ldr	r3, [r3, #0]
 800999c:	4a5d      	ldr	r2, [pc, #372]	@ (8009b14 <HAL_RCC_OscConfig+0x278>)
 800999e:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 80099a2:	6013      	str	r3, [r2, #0]
 80099a4:	e011      	b.n	80099ca <HAL_RCC_OscConfig+0x12e>
 80099a6:	4b5b      	ldr	r3, [pc, #364]	@ (8009b14 <HAL_RCC_OscConfig+0x278>)
 80099a8:	681b      	ldr	r3, [r3, #0]
 80099aa:	4a5a      	ldr	r2, [pc, #360]	@ (8009b14 <HAL_RCC_OscConfig+0x278>)
 80099ac:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
 80099b0:	6013      	str	r3, [r2, #0]
 80099b2:	4b58      	ldr	r3, [pc, #352]	@ (8009b14 <HAL_RCC_OscConfig+0x278>)
 80099b4:	681b      	ldr	r3, [r3, #0]
 80099b6:	4a57      	ldr	r2, [pc, #348]	@ (8009b14 <HAL_RCC_OscConfig+0x278>)
 80099b8:	f423 2380 	bic.w	r3, r3, #262144	@ 0x40000
 80099bc:	6013      	str	r3, [r2, #0]
 80099be:	4b55      	ldr	r3, [pc, #340]	@ (8009b14 <HAL_RCC_OscConfig+0x278>)
 80099c0:	681b      	ldr	r3, [r3, #0]
 80099c2:	4a54      	ldr	r2, [pc, #336]	@ (8009b14 <HAL_RCC_OscConfig+0x278>)
 80099c4:	f423 1380 	bic.w	r3, r3, #1048576	@ 0x100000
 80099c8:	6013      	str	r3, [r2, #0]

      /* Check the HSE State */
      if (RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 80099ca:	687b      	ldr	r3, [r7, #4]
 80099cc:	685b      	ldr	r3, [r3, #4]
 80099ce:	2b00      	cmp	r3, #0
 80099d0:	d013      	beq.n	80099fa <HAL_RCC_OscConfig+0x15e>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80099d2:	f7f8 ffc5 	bl	8002960 <HAL_GetTick>
 80099d6:	6278      	str	r0, [r7, #36]	@ 0x24

        /* Wait till HSE is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
 80099d8:	e008      	b.n	80099ec <HAL_RCC_OscConfig+0x150>
        {
          if ((uint32_t)(HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 80099da:	f7f8 ffc1 	bl	8002960 <HAL_GetTick>
 80099de:	4602      	mov	r2, r0
 80099e0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80099e2:	1ad3      	subs	r3, r2, r3
 80099e4:	2b64      	cmp	r3, #100	@ 0x64
 80099e6:	d901      	bls.n	80099ec <HAL_RCC_OscConfig+0x150>
          {
            return HAL_TIMEOUT;
 80099e8:	2303      	movs	r3, #3
 80099ea:	e380      	b.n	800a0ee <HAL_RCC_OscConfig+0x852>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
 80099ec:	4b49      	ldr	r3, [pc, #292]	@ (8009b14 <HAL_RCC_OscConfig+0x278>)
 80099ee:	681b      	ldr	r3, [r3, #0]
 80099f0:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 80099f4:	2b00      	cmp	r3, #0
 80099f6:	d0f0      	beq.n	80099da <HAL_RCC_OscConfig+0x13e>
 80099f8:	e014      	b.n	8009a24 <HAL_RCC_OscConfig+0x188>
        }
      }
      else
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80099fa:	f7f8 ffb1 	bl	8002960 <HAL_GetTick>
 80099fe:	6278      	str	r0, [r7, #36]	@ 0x24

        /* Wait till HSE is disabled */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U)
 8009a00:	e008      	b.n	8009a14 <HAL_RCC_OscConfig+0x178>
        {
          if ((uint32_t)(HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8009a02:	f7f8 ffad 	bl	8002960 <HAL_GetTick>
 8009a06:	4602      	mov	r2, r0
 8009a08:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8009a0a:	1ad3      	subs	r3, r2, r3
 8009a0c:	2b64      	cmp	r3, #100	@ 0x64
 8009a0e:	d901      	bls.n	8009a14 <HAL_RCC_OscConfig+0x178>
          {
            return HAL_TIMEOUT;
 8009a10:	2303      	movs	r3, #3
 8009a12:	e36c      	b.n	800a0ee <HAL_RCC_OscConfig+0x852>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U)
 8009a14:	4b3f      	ldr	r3, [pc, #252]	@ (8009b14 <HAL_RCC_OscConfig+0x278>)
 8009a16:	681b      	ldr	r3, [r3, #0]
 8009a18:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 8009a1c:	2b00      	cmp	r3, #0
 8009a1e:	d1f0      	bne.n	8009a02 <HAL_RCC_OscConfig+0x166>
 8009a20:	e000      	b.n	8009a24 <HAL_RCC_OscConfig+0x188>
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8009a22:	bf00      	nop
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 8009a24:	687b      	ldr	r3, [r7, #4]
 8009a26:	681b      	ldr	r3, [r3, #0]
 8009a28:	f003 0302 	and.w	r3, r3, #2
 8009a2c:	2b00      	cmp	r3, #0
 8009a2e:	f000 808c 	beq.w	8009b4a <HAL_RCC_OscConfig+0x2ae>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_HSICALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* When the HSI is used as system clock it will not be disabled */
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 8009a32:	4b38      	ldr	r3, [pc, #224]	@ (8009b14 <HAL_RCC_OscConfig+0x278>)
 8009a34:	691b      	ldr	r3, [r3, #16]
 8009a36:	f003 0338 	and.w	r3, r3, #56	@ 0x38
 8009a3a:	623b      	str	r3, [r7, #32]
    const uint32_t temp_pllckselr = RCC->PLLCKSELR;
 8009a3c:	4b35      	ldr	r3, [pc, #212]	@ (8009b14 <HAL_RCC_OscConfig+0x278>)
 8009a3e:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8009a40:	61fb      	str	r3, [r7, #28]
    if ((temp_sysclksrc == RCC_CFGR_SWS_HSI) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_HSI)))
 8009a42:	6a3b      	ldr	r3, [r7, #32]
 8009a44:	2b00      	cmp	r3, #0
 8009a46:	d007      	beq.n	8009a58 <HAL_RCC_OscConfig+0x1bc>
 8009a48:	6a3b      	ldr	r3, [r7, #32]
 8009a4a:	2b18      	cmp	r3, #24
 8009a4c:	d137      	bne.n	8009abe <HAL_RCC_OscConfig+0x222>
 8009a4e:	69fb      	ldr	r3, [r7, #28]
 8009a50:	f003 0303 	and.w	r3, r3, #3
 8009a54:	2b00      	cmp	r3, #0
 8009a56:	d132      	bne.n	8009abe <HAL_RCC_OscConfig+0x222>
    {
      /* When HSI is used as system clock it will not be disabled */
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 8009a58:	4b2e      	ldr	r3, [pc, #184]	@ (8009b14 <HAL_RCC_OscConfig+0x278>)
 8009a5a:	681b      	ldr	r3, [r3, #0]
 8009a5c:	f003 0304 	and.w	r3, r3, #4
 8009a60:	2b00      	cmp	r3, #0
 8009a62:	d005      	beq.n	8009a70 <HAL_RCC_OscConfig+0x1d4>
 8009a64:	687b      	ldr	r3, [r7, #4]
 8009a66:	68db      	ldr	r3, [r3, #12]
 8009a68:	2b00      	cmp	r3, #0
 8009a6a:	d101      	bne.n	8009a70 <HAL_RCC_OscConfig+0x1d4>
      {
        return HAL_ERROR;
 8009a6c:	2301      	movs	r3, #1
 8009a6e:	e33e      	b.n	800a0ee <HAL_RCC_OscConfig+0x852>
      }
      /* Otherwise, only HSI division and calibration are allowed */
      else
      {
        /* Enable the Internal High Speed oscillator (HSI, HSIDIV2, HSIDIV4, or HSIDIV8) */
        __HAL_RCC_HSI_CONFIG(RCC_OscInitStruct->HSIState);
 8009a70:	4b28      	ldr	r3, [pc, #160]	@ (8009b14 <HAL_RCC_OscConfig+0x278>)
 8009a72:	681b      	ldr	r3, [r3, #0]
 8009a74:	f023 0219 	bic.w	r2, r3, #25
 8009a78:	687b      	ldr	r3, [r7, #4]
 8009a7a:	68db      	ldr	r3, [r3, #12]
 8009a7c:	4925      	ldr	r1, [pc, #148]	@ (8009b14 <HAL_RCC_OscConfig+0x278>)
 8009a7e:	4313      	orrs	r3, r2
 8009a80:	600b      	str	r3, [r1, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8009a82:	f7f8 ff6d 	bl	8002960 <HAL_GetTick>
 8009a86:	6278      	str	r0, [r7, #36]	@ 0x24

        /* Wait till HSI is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
 8009a88:	e008      	b.n	8009a9c <HAL_RCC_OscConfig+0x200>
        {
          if ((uint32_t)(HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8009a8a:	f7f8 ff69 	bl	8002960 <HAL_GetTick>
 8009a8e:	4602      	mov	r2, r0
 8009a90:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8009a92:	1ad3      	subs	r3, r2, r3
 8009a94:	2b02      	cmp	r3, #2
 8009a96:	d901      	bls.n	8009a9c <HAL_RCC_OscConfig+0x200>
          {
            return HAL_TIMEOUT;
 8009a98:	2303      	movs	r3, #3
 8009a9a:	e328      	b.n	800a0ee <HAL_RCC_OscConfig+0x852>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
 8009a9c:	4b1d      	ldr	r3, [pc, #116]	@ (8009b14 <HAL_RCC_OscConfig+0x278>)
 8009a9e:	681b      	ldr	r3, [r3, #0]
 8009aa0:	f003 0304 	and.w	r3, r3, #4
 8009aa4:	2b00      	cmp	r3, #0
 8009aa6:	d0f0      	beq.n	8009a8a <HAL_RCC_OscConfig+0x1ee>
          }
        }
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8009aa8:	4b1a      	ldr	r3, [pc, #104]	@ (8009b14 <HAL_RCC_OscConfig+0x278>)
 8009aaa:	685b      	ldr	r3, [r3, #4]
 8009aac:	f023 42fe 	bic.w	r2, r3, #2130706432	@ 0x7f000000
 8009ab0:	687b      	ldr	r3, [r7, #4]
 8009ab2:	691b      	ldr	r3, [r3, #16]
 8009ab4:	061b      	lsls	r3, r3, #24
 8009ab6:	4917      	ldr	r1, [pc, #92]	@ (8009b14 <HAL_RCC_OscConfig+0x278>)
 8009ab8:	4313      	orrs	r3, r2
 8009aba:	604b      	str	r3, [r1, #4]
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 8009abc:	e045      	b.n	8009b4a <HAL_RCC_OscConfig+0x2ae>
    }

    else
    {
      /* Check the HSI State */
      if ((RCC_OscInitStruct->HSIState) != RCC_HSI_OFF)
 8009abe:	687b      	ldr	r3, [r7, #4]
 8009ac0:	68db      	ldr	r3, [r3, #12]
 8009ac2:	2b00      	cmp	r3, #0
 8009ac4:	d028      	beq.n	8009b18 <HAL_RCC_OscConfig+0x27c>
      {
        /* Enable the Internal High Speed oscillator (HSI, HSIDIV2,HSIDIV4, or HSIDIV8) */
        __HAL_RCC_HSI_CONFIG(RCC_OscInitStruct->HSIState);
 8009ac6:	4b13      	ldr	r3, [pc, #76]	@ (8009b14 <HAL_RCC_OscConfig+0x278>)
 8009ac8:	681b      	ldr	r3, [r3, #0]
 8009aca:	f023 0219 	bic.w	r2, r3, #25
 8009ace:	687b      	ldr	r3, [r7, #4]
 8009ad0:	68db      	ldr	r3, [r3, #12]
 8009ad2:	4910      	ldr	r1, [pc, #64]	@ (8009b14 <HAL_RCC_OscConfig+0x278>)
 8009ad4:	4313      	orrs	r3, r2
 8009ad6:	600b      	str	r3, [r1, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8009ad8:	f7f8 ff42 	bl	8002960 <HAL_GetTick>
 8009adc:	6278      	str	r0, [r7, #36]	@ 0x24

        /* Wait till HSI is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
 8009ade:	e008      	b.n	8009af2 <HAL_RCC_OscConfig+0x256>
        {
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8009ae0:	f7f8 ff3e 	bl	8002960 <HAL_GetTick>
 8009ae4:	4602      	mov	r2, r0
 8009ae6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8009ae8:	1ad3      	subs	r3, r2, r3
 8009aea:	2b02      	cmp	r3, #2
 8009aec:	d901      	bls.n	8009af2 <HAL_RCC_OscConfig+0x256>
          {
            return HAL_TIMEOUT;
 8009aee:	2303      	movs	r3, #3
 8009af0:	e2fd      	b.n	800a0ee <HAL_RCC_OscConfig+0x852>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
 8009af2:	4b08      	ldr	r3, [pc, #32]	@ (8009b14 <HAL_RCC_OscConfig+0x278>)
 8009af4:	681b      	ldr	r3, [r3, #0]
 8009af6:	f003 0304 	and.w	r3, r3, #4
 8009afa:	2b00      	cmp	r3, #0
 8009afc:	d0f0      	beq.n	8009ae0 <HAL_RCC_OscConfig+0x244>
          }
        }

        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8009afe:	4b05      	ldr	r3, [pc, #20]	@ (8009b14 <HAL_RCC_OscConfig+0x278>)
 8009b00:	685b      	ldr	r3, [r3, #4]
 8009b02:	f023 42fe 	bic.w	r2, r3, #2130706432	@ 0x7f000000
 8009b06:	687b      	ldr	r3, [r7, #4]
 8009b08:	691b      	ldr	r3, [r3, #16]
 8009b0a:	061b      	lsls	r3, r3, #24
 8009b0c:	4901      	ldr	r1, [pc, #4]	@ (8009b14 <HAL_RCC_OscConfig+0x278>)
 8009b0e:	4313      	orrs	r3, r2
 8009b10:	604b      	str	r3, [r1, #4]
 8009b12:	e01a      	b.n	8009b4a <HAL_RCC_OscConfig+0x2ae>
 8009b14:	58024400 	.word	0x58024400
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
 8009b18:	4b97      	ldr	r3, [pc, #604]	@ (8009d78 <HAL_RCC_OscConfig+0x4dc>)
 8009b1a:	681b      	ldr	r3, [r3, #0]
 8009b1c:	4a96      	ldr	r2, [pc, #600]	@ (8009d78 <HAL_RCC_OscConfig+0x4dc>)
 8009b1e:	f023 0301 	bic.w	r3, r3, #1
 8009b22:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8009b24:	f7f8 ff1c 	bl	8002960 <HAL_GetTick>
 8009b28:	6278      	str	r0, [r7, #36]	@ 0x24

        /* Wait till HSI is disabled */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U)
 8009b2a:	e008      	b.n	8009b3e <HAL_RCC_OscConfig+0x2a2>
        {
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8009b2c:	f7f8 ff18 	bl	8002960 <HAL_GetTick>
 8009b30:	4602      	mov	r2, r0
 8009b32:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8009b34:	1ad3      	subs	r3, r2, r3
 8009b36:	2b02      	cmp	r3, #2
 8009b38:	d901      	bls.n	8009b3e <HAL_RCC_OscConfig+0x2a2>
          {
            return HAL_TIMEOUT;
 8009b3a:	2303      	movs	r3, #3
 8009b3c:	e2d7      	b.n	800a0ee <HAL_RCC_OscConfig+0x852>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U)
 8009b3e:	4b8e      	ldr	r3, [pc, #568]	@ (8009d78 <HAL_RCC_OscConfig+0x4dc>)
 8009b40:	681b      	ldr	r3, [r3, #0]
 8009b42:	f003 0304 	and.w	r3, r3, #4
 8009b46:	2b00      	cmp	r3, #0
 8009b48:	d1f0      	bne.n	8009b2c <HAL_RCC_OscConfig+0x290>
        }
      }
    }
  }
  /*----------------------------- CSI Configuration --------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_CSI) == RCC_OSCILLATORTYPE_CSI)
 8009b4a:	687b      	ldr	r3, [r7, #4]
 8009b4c:	681b      	ldr	r3, [r3, #0]
 8009b4e:	f003 0310 	and.w	r3, r3, #16
 8009b52:	2b00      	cmp	r3, #0
 8009b54:	d06a      	beq.n	8009c2c <HAL_RCC_OscConfig+0x390>
    /* Check the parameters */
    assert_param(IS_RCC_CSI(RCC_OscInitStruct->CSIState));
    assert_param(IS_RCC_CSICALIBRATION_VALUE(RCC_OscInitStruct->CSICalibrationValue));

    /* When the CSI is used as system clock it will not disabled */
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 8009b56:	4b88      	ldr	r3, [pc, #544]	@ (8009d78 <HAL_RCC_OscConfig+0x4dc>)
 8009b58:	691b      	ldr	r3, [r3, #16]
 8009b5a:	f003 0338 	and.w	r3, r3, #56	@ 0x38
 8009b5e:	61bb      	str	r3, [r7, #24]
    const uint32_t temp_pllckselr = RCC->PLLCKSELR;
 8009b60:	4b85      	ldr	r3, [pc, #532]	@ (8009d78 <HAL_RCC_OscConfig+0x4dc>)
 8009b62:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8009b64:	617b      	str	r3, [r7, #20]
    if ((temp_sysclksrc == RCC_CFGR_SWS_CSI) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_CSI)))
 8009b66:	69bb      	ldr	r3, [r7, #24]
 8009b68:	2b08      	cmp	r3, #8
 8009b6a:	d007      	beq.n	8009b7c <HAL_RCC_OscConfig+0x2e0>
 8009b6c:	69bb      	ldr	r3, [r7, #24]
 8009b6e:	2b18      	cmp	r3, #24
 8009b70:	d11b      	bne.n	8009baa <HAL_RCC_OscConfig+0x30e>
 8009b72:	697b      	ldr	r3, [r7, #20]
 8009b74:	f003 0303 	and.w	r3, r3, #3
 8009b78:	2b01      	cmp	r3, #1
 8009b7a:	d116      	bne.n	8009baa <HAL_RCC_OscConfig+0x30e>
    {
      /* When CSI is used as system clock it will not disabled */
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U) && (RCC_OscInitStruct->CSIState != RCC_CSI_ON))
 8009b7c:	4b7e      	ldr	r3, [pc, #504]	@ (8009d78 <HAL_RCC_OscConfig+0x4dc>)
 8009b7e:	681b      	ldr	r3, [r3, #0]
 8009b80:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8009b84:	2b00      	cmp	r3, #0
 8009b86:	d005      	beq.n	8009b94 <HAL_RCC_OscConfig+0x2f8>
 8009b88:	687b      	ldr	r3, [r7, #4]
 8009b8a:	69db      	ldr	r3, [r3, #28]
 8009b8c:	2b80      	cmp	r3, #128	@ 0x80
 8009b8e:	d001      	beq.n	8009b94 <HAL_RCC_OscConfig+0x2f8>
      {
        return HAL_ERROR;
 8009b90:	2301      	movs	r3, #1
 8009b92:	e2ac      	b.n	800a0ee <HAL_RCC_OscConfig+0x852>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (CSI) calibration value.*/
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
 8009b94:	4b78      	ldr	r3, [pc, #480]	@ (8009d78 <HAL_RCC_OscConfig+0x4dc>)
 8009b96:	68db      	ldr	r3, [r3, #12]
 8009b98:	f023 527c 	bic.w	r2, r3, #1056964608	@ 0x3f000000
 8009b9c:	687b      	ldr	r3, [r7, #4]
 8009b9e:	6a1b      	ldr	r3, [r3, #32]
 8009ba0:	061b      	lsls	r3, r3, #24
 8009ba2:	4975      	ldr	r1, [pc, #468]	@ (8009d78 <HAL_RCC_OscConfig+0x4dc>)
 8009ba4:	4313      	orrs	r3, r2
 8009ba6:	60cb      	str	r3, [r1, #12]
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U) && (RCC_OscInitStruct->CSIState != RCC_CSI_ON))
 8009ba8:	e040      	b.n	8009c2c <HAL_RCC_OscConfig+0x390>
      }
    }
    else
    {
      /* Check the CSI State */
      if ((RCC_OscInitStruct->CSIState) != RCC_CSI_OFF)
 8009baa:	687b      	ldr	r3, [r7, #4]
 8009bac:	69db      	ldr	r3, [r3, #28]
 8009bae:	2b00      	cmp	r3, #0
 8009bb0:	d023      	beq.n	8009bfa <HAL_RCC_OscConfig+0x35e>
      {
        /* Enable the Internal High Speed oscillator (CSI). */
        __HAL_RCC_CSI_ENABLE();
 8009bb2:	4b71      	ldr	r3, [pc, #452]	@ (8009d78 <HAL_RCC_OscConfig+0x4dc>)
 8009bb4:	681b      	ldr	r3, [r3, #0]
 8009bb6:	4a70      	ldr	r2, [pc, #448]	@ (8009d78 <HAL_RCC_OscConfig+0x4dc>)
 8009bb8:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 8009bbc:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8009bbe:	f7f8 fecf 	bl	8002960 <HAL_GetTick>
 8009bc2:	6278      	str	r0, [r7, #36]	@ 0x24

        /* Wait till CSI is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) == 0U)
 8009bc4:	e008      	b.n	8009bd8 <HAL_RCC_OscConfig+0x33c>
        {
          if ((HAL_GetTick() - tickstart) > CSI_TIMEOUT_VALUE)
 8009bc6:	f7f8 fecb 	bl	8002960 <HAL_GetTick>
 8009bca:	4602      	mov	r2, r0
 8009bcc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8009bce:	1ad3      	subs	r3, r2, r3
 8009bd0:	2b02      	cmp	r3, #2
 8009bd2:	d901      	bls.n	8009bd8 <HAL_RCC_OscConfig+0x33c>
          {
            return HAL_TIMEOUT;
 8009bd4:	2303      	movs	r3, #3
 8009bd6:	e28a      	b.n	800a0ee <HAL_RCC_OscConfig+0x852>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) == 0U)
 8009bd8:	4b67      	ldr	r3, [pc, #412]	@ (8009d78 <HAL_RCC_OscConfig+0x4dc>)
 8009bda:	681b      	ldr	r3, [r3, #0]
 8009bdc:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8009be0:	2b00      	cmp	r3, #0
 8009be2:	d0f0      	beq.n	8009bc6 <HAL_RCC_OscConfig+0x32a>
          }
        }

        /* Adjusts the Internal High Speed oscillator (CSI) calibration value.*/
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
 8009be4:	4b64      	ldr	r3, [pc, #400]	@ (8009d78 <HAL_RCC_OscConfig+0x4dc>)
 8009be6:	68db      	ldr	r3, [r3, #12]
 8009be8:	f023 527c 	bic.w	r2, r3, #1056964608	@ 0x3f000000
 8009bec:	687b      	ldr	r3, [r7, #4]
 8009bee:	6a1b      	ldr	r3, [r3, #32]
 8009bf0:	061b      	lsls	r3, r3, #24
 8009bf2:	4961      	ldr	r1, [pc, #388]	@ (8009d78 <HAL_RCC_OscConfig+0x4dc>)
 8009bf4:	4313      	orrs	r3, r2
 8009bf6:	60cb      	str	r3, [r1, #12]
 8009bf8:	e018      	b.n	8009c2c <HAL_RCC_OscConfig+0x390>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (CSI). */
        __HAL_RCC_CSI_DISABLE();
 8009bfa:	4b5f      	ldr	r3, [pc, #380]	@ (8009d78 <HAL_RCC_OscConfig+0x4dc>)
 8009bfc:	681b      	ldr	r3, [r3, #0]
 8009bfe:	4a5e      	ldr	r2, [pc, #376]	@ (8009d78 <HAL_RCC_OscConfig+0x4dc>)
 8009c00:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
 8009c04:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8009c06:	f7f8 feab 	bl	8002960 <HAL_GetTick>
 8009c0a:	6278      	str	r0, [r7, #36]	@ 0x24

        /* Wait till CSI is disabled */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U)
 8009c0c:	e008      	b.n	8009c20 <HAL_RCC_OscConfig+0x384>
        {
          if ((HAL_GetTick() - tickstart) > CSI_TIMEOUT_VALUE)
 8009c0e:	f7f8 fea7 	bl	8002960 <HAL_GetTick>
 8009c12:	4602      	mov	r2, r0
 8009c14:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8009c16:	1ad3      	subs	r3, r2, r3
 8009c18:	2b02      	cmp	r3, #2
 8009c1a:	d901      	bls.n	8009c20 <HAL_RCC_OscConfig+0x384>
          {
            return HAL_TIMEOUT;
 8009c1c:	2303      	movs	r3, #3
 8009c1e:	e266      	b.n	800a0ee <HAL_RCC_OscConfig+0x852>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U)
 8009c20:	4b55      	ldr	r3, [pc, #340]	@ (8009d78 <HAL_RCC_OscConfig+0x4dc>)
 8009c22:	681b      	ldr	r3, [r3, #0]
 8009c24:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8009c28:	2b00      	cmp	r3, #0
 8009c2a:	d1f0      	bne.n	8009c0e <HAL_RCC_OscConfig+0x372>
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8009c2c:	687b      	ldr	r3, [r7, #4]
 8009c2e:	681b      	ldr	r3, [r3, #0]
 8009c30:	f003 0308 	and.w	r3, r3, #8
 8009c34:	2b00      	cmp	r3, #0
 8009c36:	d036      	beq.n	8009ca6 <HAL_RCC_OscConfig+0x40a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if ((RCC_OscInitStruct->LSIState) != RCC_LSI_OFF)
 8009c38:	687b      	ldr	r3, [r7, #4]
 8009c3a:	695b      	ldr	r3, [r3, #20]
 8009c3c:	2b00      	cmp	r3, #0
 8009c3e:	d019      	beq.n	8009c74 <HAL_RCC_OscConfig+0x3d8>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 8009c40:	4b4d      	ldr	r3, [pc, #308]	@ (8009d78 <HAL_RCC_OscConfig+0x4dc>)
 8009c42:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
 8009c44:	4a4c      	ldr	r2, [pc, #304]	@ (8009d78 <HAL_RCC_OscConfig+0x4dc>)
 8009c46:	f043 0301 	orr.w	r3, r3, #1
 8009c4a:	6753      	str	r3, [r2, #116]	@ 0x74

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8009c4c:	f7f8 fe88 	bl	8002960 <HAL_GetTick>
 8009c50:	6278      	str	r0, [r7, #36]	@ 0x24

      /* Wait till LSI is ready */
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == 0U)
 8009c52:	e008      	b.n	8009c66 <HAL_RCC_OscConfig+0x3ca>
      {
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 8009c54:	f7f8 fe84 	bl	8002960 <HAL_GetTick>
 8009c58:	4602      	mov	r2, r0
 8009c5a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8009c5c:	1ad3      	subs	r3, r2, r3
 8009c5e:	2b02      	cmp	r3, #2
 8009c60:	d901      	bls.n	8009c66 <HAL_RCC_OscConfig+0x3ca>
        {
          return HAL_TIMEOUT;
 8009c62:	2303      	movs	r3, #3
 8009c64:	e243      	b.n	800a0ee <HAL_RCC_OscConfig+0x852>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == 0U)
 8009c66:	4b44      	ldr	r3, [pc, #272]	@ (8009d78 <HAL_RCC_OscConfig+0x4dc>)
 8009c68:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
 8009c6a:	f003 0302 	and.w	r3, r3, #2
 8009c6e:	2b00      	cmp	r3, #0
 8009c70:	d0f0      	beq.n	8009c54 <HAL_RCC_OscConfig+0x3b8>
 8009c72:	e018      	b.n	8009ca6 <HAL_RCC_OscConfig+0x40a>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 8009c74:	4b40      	ldr	r3, [pc, #256]	@ (8009d78 <HAL_RCC_OscConfig+0x4dc>)
 8009c76:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
 8009c78:	4a3f      	ldr	r2, [pc, #252]	@ (8009d78 <HAL_RCC_OscConfig+0x4dc>)
 8009c7a:	f023 0301 	bic.w	r3, r3, #1
 8009c7e:	6753      	str	r3, [r2, #116]	@ 0x74

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8009c80:	f7f8 fe6e 	bl	8002960 <HAL_GetTick>
 8009c84:	6278      	str	r0, [r7, #36]	@ 0x24

      /* Wait till LSI is ready */
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != 0U)
 8009c86:	e008      	b.n	8009c9a <HAL_RCC_OscConfig+0x3fe>
      {
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 8009c88:	f7f8 fe6a 	bl	8002960 <HAL_GetTick>
 8009c8c:	4602      	mov	r2, r0
 8009c8e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8009c90:	1ad3      	subs	r3, r2, r3
 8009c92:	2b02      	cmp	r3, #2
 8009c94:	d901      	bls.n	8009c9a <HAL_RCC_OscConfig+0x3fe>
        {
          return HAL_TIMEOUT;
 8009c96:	2303      	movs	r3, #3
 8009c98:	e229      	b.n	800a0ee <HAL_RCC_OscConfig+0x852>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != 0U)
 8009c9a:	4b37      	ldr	r3, [pc, #220]	@ (8009d78 <HAL_RCC_OscConfig+0x4dc>)
 8009c9c:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
 8009c9e:	f003 0302 	and.w	r3, r3, #2
 8009ca2:	2b00      	cmp	r3, #0
 8009ca4:	d1f0      	bne.n	8009c88 <HAL_RCC_OscConfig+0x3ec>
      }
    }
  }

  /*------------------------------ HSI48 Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI48) == RCC_OSCILLATORTYPE_HSI48)
 8009ca6:	687b      	ldr	r3, [r7, #4]
 8009ca8:	681b      	ldr	r3, [r3, #0]
 8009caa:	f003 0320 	and.w	r3, r3, #32
 8009cae:	2b00      	cmp	r3, #0
 8009cb0:	d036      	beq.n	8009d20 <HAL_RCC_OscConfig+0x484>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSI48(RCC_OscInitStruct->HSI48State));

    /* Check the HSI48 State */
    if ((RCC_OscInitStruct->HSI48State) != RCC_HSI48_OFF)
 8009cb2:	687b      	ldr	r3, [r7, #4]
 8009cb4:	699b      	ldr	r3, [r3, #24]
 8009cb6:	2b00      	cmp	r3, #0
 8009cb8:	d019      	beq.n	8009cee <HAL_RCC_OscConfig+0x452>
    {
      /* Enable the Internal Low Speed oscillator (HSI48). */
      __HAL_RCC_HSI48_ENABLE();
 8009cba:	4b2f      	ldr	r3, [pc, #188]	@ (8009d78 <HAL_RCC_OscConfig+0x4dc>)
 8009cbc:	681b      	ldr	r3, [r3, #0]
 8009cbe:	4a2e      	ldr	r2, [pc, #184]	@ (8009d78 <HAL_RCC_OscConfig+0x4dc>)
 8009cc0:	f443 5380 	orr.w	r3, r3, #4096	@ 0x1000
 8009cc4:	6013      	str	r3, [r2, #0]

      /* Get time-out */
      tickstart = HAL_GetTick();
 8009cc6:	f7f8 fe4b 	bl	8002960 <HAL_GetTick>
 8009cca:	6278      	str	r0, [r7, #36]	@ 0x24

      /* Wait till HSI48 is ready */
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) == 0U)
 8009ccc:	e008      	b.n	8009ce0 <HAL_RCC_OscConfig+0x444>
      {
        if ((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 8009cce:	f7f8 fe47 	bl	8002960 <HAL_GetTick>
 8009cd2:	4602      	mov	r2, r0
 8009cd4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8009cd6:	1ad3      	subs	r3, r2, r3
 8009cd8:	2b02      	cmp	r3, #2
 8009cda:	d901      	bls.n	8009ce0 <HAL_RCC_OscConfig+0x444>
        {
          return HAL_TIMEOUT;
 8009cdc:	2303      	movs	r3, #3
 8009cde:	e206      	b.n	800a0ee <HAL_RCC_OscConfig+0x852>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) == 0U)
 8009ce0:	4b25      	ldr	r3, [pc, #148]	@ (8009d78 <HAL_RCC_OscConfig+0x4dc>)
 8009ce2:	681b      	ldr	r3, [r3, #0]
 8009ce4:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
 8009ce8:	2b00      	cmp	r3, #0
 8009cea:	d0f0      	beq.n	8009cce <HAL_RCC_OscConfig+0x432>
 8009cec:	e018      	b.n	8009d20 <HAL_RCC_OscConfig+0x484>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (HSI48). */
      __HAL_RCC_HSI48_DISABLE();
 8009cee:	4b22      	ldr	r3, [pc, #136]	@ (8009d78 <HAL_RCC_OscConfig+0x4dc>)
 8009cf0:	681b      	ldr	r3, [r3, #0]
 8009cf2:	4a21      	ldr	r2, [pc, #132]	@ (8009d78 <HAL_RCC_OscConfig+0x4dc>)
 8009cf4:	f423 5380 	bic.w	r3, r3, #4096	@ 0x1000
 8009cf8:	6013      	str	r3, [r2, #0]

      /* Get time-out */
      tickstart = HAL_GetTick();
 8009cfa:	f7f8 fe31 	bl	8002960 <HAL_GetTick>
 8009cfe:	6278      	str	r0, [r7, #36]	@ 0x24

      /* Wait till HSI48 is ready */
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) != 0U)
 8009d00:	e008      	b.n	8009d14 <HAL_RCC_OscConfig+0x478>
      {
        if ((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 8009d02:	f7f8 fe2d 	bl	8002960 <HAL_GetTick>
 8009d06:	4602      	mov	r2, r0
 8009d08:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8009d0a:	1ad3      	subs	r3, r2, r3
 8009d0c:	2b02      	cmp	r3, #2
 8009d0e:	d901      	bls.n	8009d14 <HAL_RCC_OscConfig+0x478>
        {
          return HAL_TIMEOUT;
 8009d10:	2303      	movs	r3, #3
 8009d12:	e1ec      	b.n	800a0ee <HAL_RCC_OscConfig+0x852>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) != 0U)
 8009d14:	4b18      	ldr	r3, [pc, #96]	@ (8009d78 <HAL_RCC_OscConfig+0x4dc>)
 8009d16:	681b      	ldr	r3, [r3, #0]
 8009d18:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
 8009d1c:	2b00      	cmp	r3, #0
 8009d1e:	d1f0      	bne.n	8009d02 <HAL_RCC_OscConfig+0x466>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8009d20:	687b      	ldr	r3, [r7, #4]
 8009d22:	681b      	ldr	r3, [r3, #0]
 8009d24:	f003 0304 	and.w	r3, r3, #4
 8009d28:	2b00      	cmp	r3, #0
 8009d2a:	f000 80af 	beq.w	8009e8c <HAL_RCC_OscConfig+0x5f0>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Enable write access to Backup domain */
    PWR->CR1 |= PWR_CR1_DBP;
 8009d2e:	4b13      	ldr	r3, [pc, #76]	@ (8009d7c <HAL_RCC_OscConfig+0x4e0>)
 8009d30:	681b      	ldr	r3, [r3, #0]
 8009d32:	4a12      	ldr	r2, [pc, #72]	@ (8009d7c <HAL_RCC_OscConfig+0x4e0>)
 8009d34:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 8009d38:	6013      	str	r3, [r2, #0]

    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
 8009d3a:	f7f8 fe11 	bl	8002960 <HAL_GetTick>
 8009d3e:	6278      	str	r0, [r7, #36]	@ 0x24

    while ((PWR->CR1 & PWR_CR1_DBP) == 0U)
 8009d40:	e008      	b.n	8009d54 <HAL_RCC_OscConfig+0x4b8>
    {
      if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8009d42:	f7f8 fe0d 	bl	8002960 <HAL_GetTick>
 8009d46:	4602      	mov	r2, r0
 8009d48:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8009d4a:	1ad3      	subs	r3, r2, r3
 8009d4c:	2b64      	cmp	r3, #100	@ 0x64
 8009d4e:	d901      	bls.n	8009d54 <HAL_RCC_OscConfig+0x4b8>
      {
        return HAL_TIMEOUT;
 8009d50:	2303      	movs	r3, #3
 8009d52:	e1cc      	b.n	800a0ee <HAL_RCC_OscConfig+0x852>
    while ((PWR->CR1 & PWR_CR1_DBP) == 0U)
 8009d54:	4b09      	ldr	r3, [pc, #36]	@ (8009d7c <HAL_RCC_OscConfig+0x4e0>)
 8009d56:	681b      	ldr	r3, [r3, #0]
 8009d58:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8009d5c:	2b00      	cmp	r3, #0
 8009d5e:	d0f0      	beq.n	8009d42 <HAL_RCC_OscConfig+0x4a6>
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8009d60:	687b      	ldr	r3, [r7, #4]
 8009d62:	689b      	ldr	r3, [r3, #8]
 8009d64:	2b01      	cmp	r3, #1
 8009d66:	d10b      	bne.n	8009d80 <HAL_RCC_OscConfig+0x4e4>
 8009d68:	4b03      	ldr	r3, [pc, #12]	@ (8009d78 <HAL_RCC_OscConfig+0x4dc>)
 8009d6a:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8009d6c:	4a02      	ldr	r2, [pc, #8]	@ (8009d78 <HAL_RCC_OscConfig+0x4dc>)
 8009d6e:	f043 0301 	orr.w	r3, r3, #1
 8009d72:	6713      	str	r3, [r2, #112]	@ 0x70
 8009d74:	e05b      	b.n	8009e2e <HAL_RCC_OscConfig+0x592>
 8009d76:	bf00      	nop
 8009d78:	58024400 	.word	0x58024400
 8009d7c:	58024800 	.word	0x58024800
 8009d80:	687b      	ldr	r3, [r7, #4]
 8009d82:	689b      	ldr	r3, [r3, #8]
 8009d84:	2b00      	cmp	r3, #0
 8009d86:	d112      	bne.n	8009dae <HAL_RCC_OscConfig+0x512>
 8009d88:	4b9d      	ldr	r3, [pc, #628]	@ (800a000 <HAL_RCC_OscConfig+0x764>)
 8009d8a:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8009d8c:	4a9c      	ldr	r2, [pc, #624]	@ (800a000 <HAL_RCC_OscConfig+0x764>)
 8009d8e:	f023 0301 	bic.w	r3, r3, #1
 8009d92:	6713      	str	r3, [r2, #112]	@ 0x70
 8009d94:	4b9a      	ldr	r3, [pc, #616]	@ (800a000 <HAL_RCC_OscConfig+0x764>)
 8009d96:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8009d98:	4a99      	ldr	r2, [pc, #612]	@ (800a000 <HAL_RCC_OscConfig+0x764>)
 8009d9a:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
 8009d9e:	6713      	str	r3, [r2, #112]	@ 0x70
 8009da0:	4b97      	ldr	r3, [pc, #604]	@ (800a000 <HAL_RCC_OscConfig+0x764>)
 8009da2:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8009da4:	4a96      	ldr	r2, [pc, #600]	@ (800a000 <HAL_RCC_OscConfig+0x764>)
 8009da6:	f023 0304 	bic.w	r3, r3, #4
 8009daa:	6713      	str	r3, [r2, #112]	@ 0x70
 8009dac:	e03f      	b.n	8009e2e <HAL_RCC_OscConfig+0x592>
 8009dae:	687b      	ldr	r3, [r7, #4]
 8009db0:	689b      	ldr	r3, [r3, #8]
 8009db2:	2b05      	cmp	r3, #5
 8009db4:	d112      	bne.n	8009ddc <HAL_RCC_OscConfig+0x540>
 8009db6:	4b92      	ldr	r3, [pc, #584]	@ (800a000 <HAL_RCC_OscConfig+0x764>)
 8009db8:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8009dba:	4a91      	ldr	r2, [pc, #580]	@ (800a000 <HAL_RCC_OscConfig+0x764>)
 8009dbc:	f043 0304 	orr.w	r3, r3, #4
 8009dc0:	6713      	str	r3, [r2, #112]	@ 0x70
 8009dc2:	4b8f      	ldr	r3, [pc, #572]	@ (800a000 <HAL_RCC_OscConfig+0x764>)
 8009dc4:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8009dc6:	4a8e      	ldr	r2, [pc, #568]	@ (800a000 <HAL_RCC_OscConfig+0x764>)
 8009dc8:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
 8009dcc:	6713      	str	r3, [r2, #112]	@ 0x70
 8009dce:	4b8c      	ldr	r3, [pc, #560]	@ (800a000 <HAL_RCC_OscConfig+0x764>)
 8009dd0:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8009dd2:	4a8b      	ldr	r2, [pc, #556]	@ (800a000 <HAL_RCC_OscConfig+0x764>)
 8009dd4:	f043 0301 	orr.w	r3, r3, #1
 8009dd8:	6713      	str	r3, [r2, #112]	@ 0x70
 8009dda:	e028      	b.n	8009e2e <HAL_RCC_OscConfig+0x592>
 8009ddc:	687b      	ldr	r3, [r7, #4]
 8009dde:	689b      	ldr	r3, [r3, #8]
 8009de0:	2b85      	cmp	r3, #133	@ 0x85
 8009de2:	d112      	bne.n	8009e0a <HAL_RCC_OscConfig+0x56e>
 8009de4:	4b86      	ldr	r3, [pc, #536]	@ (800a000 <HAL_RCC_OscConfig+0x764>)
 8009de6:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8009de8:	4a85      	ldr	r2, [pc, #532]	@ (800a000 <HAL_RCC_OscConfig+0x764>)
 8009dea:	f043 0304 	orr.w	r3, r3, #4
 8009dee:	6713      	str	r3, [r2, #112]	@ 0x70
 8009df0:	4b83      	ldr	r3, [pc, #524]	@ (800a000 <HAL_RCC_OscConfig+0x764>)
 8009df2:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8009df4:	4a82      	ldr	r2, [pc, #520]	@ (800a000 <HAL_RCC_OscConfig+0x764>)
 8009df6:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 8009dfa:	6713      	str	r3, [r2, #112]	@ 0x70
 8009dfc:	4b80      	ldr	r3, [pc, #512]	@ (800a000 <HAL_RCC_OscConfig+0x764>)
 8009dfe:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8009e00:	4a7f      	ldr	r2, [pc, #508]	@ (800a000 <HAL_RCC_OscConfig+0x764>)
 8009e02:	f043 0301 	orr.w	r3, r3, #1
 8009e06:	6713      	str	r3, [r2, #112]	@ 0x70
 8009e08:	e011      	b.n	8009e2e <HAL_RCC_OscConfig+0x592>
 8009e0a:	4b7d      	ldr	r3, [pc, #500]	@ (800a000 <HAL_RCC_OscConfig+0x764>)
 8009e0c:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8009e0e:	4a7c      	ldr	r2, [pc, #496]	@ (800a000 <HAL_RCC_OscConfig+0x764>)
 8009e10:	f023 0301 	bic.w	r3, r3, #1
 8009e14:	6713      	str	r3, [r2, #112]	@ 0x70
 8009e16:	4b7a      	ldr	r3, [pc, #488]	@ (800a000 <HAL_RCC_OscConfig+0x764>)
 8009e18:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8009e1a:	4a79      	ldr	r2, [pc, #484]	@ (800a000 <HAL_RCC_OscConfig+0x764>)
 8009e1c:	f023 0304 	bic.w	r3, r3, #4
 8009e20:	6713      	str	r3, [r2, #112]	@ 0x70
 8009e22:	4b77      	ldr	r3, [pc, #476]	@ (800a000 <HAL_RCC_OscConfig+0x764>)
 8009e24:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8009e26:	4a76      	ldr	r2, [pc, #472]	@ (800a000 <HAL_RCC_OscConfig+0x764>)
 8009e28:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
 8009e2c:	6713      	str	r3, [r2, #112]	@ 0x70
    /* Check the LSE State */
    if ((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
 8009e2e:	687b      	ldr	r3, [r7, #4]
 8009e30:	689b      	ldr	r3, [r3, #8]
 8009e32:	2b00      	cmp	r3, #0
 8009e34:	d015      	beq.n	8009e62 <HAL_RCC_OscConfig+0x5c6>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8009e36:	f7f8 fd93 	bl	8002960 <HAL_GetTick>
 8009e3a:	6278      	str	r0, [r7, #36]	@ 0x24

      /* Wait till LSE is ready */
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
 8009e3c:	e00a      	b.n	8009e54 <HAL_RCC_OscConfig+0x5b8>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8009e3e:	f7f8 fd8f 	bl	8002960 <HAL_GetTick>
 8009e42:	4602      	mov	r2, r0
 8009e44:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8009e46:	1ad3      	subs	r3, r2, r3
 8009e48:	f241 3288 	movw	r2, #5000	@ 0x1388
 8009e4c:	4293      	cmp	r3, r2
 8009e4e:	d901      	bls.n	8009e54 <HAL_RCC_OscConfig+0x5b8>
        {
          return HAL_TIMEOUT;
 8009e50:	2303      	movs	r3, #3
 8009e52:	e14c      	b.n	800a0ee <HAL_RCC_OscConfig+0x852>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
 8009e54:	4b6a      	ldr	r3, [pc, #424]	@ (800a000 <HAL_RCC_OscConfig+0x764>)
 8009e56:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8009e58:	f003 0302 	and.w	r3, r3, #2
 8009e5c:	2b00      	cmp	r3, #0
 8009e5e:	d0ee      	beq.n	8009e3e <HAL_RCC_OscConfig+0x5a2>
 8009e60:	e014      	b.n	8009e8c <HAL_RCC_OscConfig+0x5f0>
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8009e62:	f7f8 fd7d 	bl	8002960 <HAL_GetTick>
 8009e66:	6278      	str	r0, [r7, #36]	@ 0x24

      /* Wait till LSE is disabled */
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != 0U)
 8009e68:	e00a      	b.n	8009e80 <HAL_RCC_OscConfig+0x5e4>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8009e6a:	f7f8 fd79 	bl	8002960 <HAL_GetTick>
 8009e6e:	4602      	mov	r2, r0
 8009e70:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8009e72:	1ad3      	subs	r3, r2, r3
 8009e74:	f241 3288 	movw	r2, #5000	@ 0x1388
 8009e78:	4293      	cmp	r3, r2
 8009e7a:	d901      	bls.n	8009e80 <HAL_RCC_OscConfig+0x5e4>
        {
          return HAL_TIMEOUT;
 8009e7c:	2303      	movs	r3, #3
 8009e7e:	e136      	b.n	800a0ee <HAL_RCC_OscConfig+0x852>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != 0U)
 8009e80:	4b5f      	ldr	r3, [pc, #380]	@ (800a000 <HAL_RCC_OscConfig+0x764>)
 8009e82:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8009e84:	f003 0302 	and.w	r3, r3, #2
 8009e88:	2b00      	cmp	r3, #0
 8009e8a:	d1ee      	bne.n	8009e6a <HAL_RCC_OscConfig+0x5ce>
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 8009e8c:	687b      	ldr	r3, [r7, #4]
 8009e8e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8009e90:	2b00      	cmp	r3, #0
 8009e92:	f000 812b 	beq.w	800a0ec <HAL_RCC_OscConfig+0x850>
  {
    /* Check if the PLL is used as system clock or not */
    if (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL1)
 8009e96:	4b5a      	ldr	r3, [pc, #360]	@ (800a000 <HAL_RCC_OscConfig+0x764>)
 8009e98:	691b      	ldr	r3, [r3, #16]
 8009e9a:	f003 0338 	and.w	r3, r3, #56	@ 0x38
 8009e9e:	2b18      	cmp	r3, #24
 8009ea0:	f000 80bb 	beq.w	800a01a <HAL_RCC_OscConfig+0x77e>
    {
      if ((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 8009ea4:	687b      	ldr	r3, [r7, #4]
 8009ea6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8009ea8:	2b02      	cmp	r3, #2
 8009eaa:	f040 8095 	bne.w	8009fd8 <HAL_RCC_OscConfig+0x73c>
        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
        assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));
        assert_param(IS_RCC_PLLFRACN_VALUE(RCC_OscInitStruct->PLL.PLLFRACN));

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 8009eae:	4b54      	ldr	r3, [pc, #336]	@ (800a000 <HAL_RCC_OscConfig+0x764>)
 8009eb0:	681b      	ldr	r3, [r3, #0]
 8009eb2:	4a53      	ldr	r2, [pc, #332]	@ (800a000 <HAL_RCC_OscConfig+0x764>)
 8009eb4:	f023 7380 	bic.w	r3, r3, #16777216	@ 0x1000000
 8009eb8:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8009eba:	f7f8 fd51 	bl	8002960 <HAL_GetTick>
 8009ebe:	6278      	str	r0, [r7, #36]	@ 0x24

        /* Wait till PLL is disabled */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
 8009ec0:	e008      	b.n	8009ed4 <HAL_RCC_OscConfig+0x638>
        {
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8009ec2:	f7f8 fd4d 	bl	8002960 <HAL_GetTick>
 8009ec6:	4602      	mov	r2, r0
 8009ec8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8009eca:	1ad3      	subs	r3, r2, r3
 8009ecc:	2b02      	cmp	r3, #2
 8009ece:	d901      	bls.n	8009ed4 <HAL_RCC_OscConfig+0x638>
          {
            return HAL_TIMEOUT;
 8009ed0:	2303      	movs	r3, #3
 8009ed2:	e10c      	b.n	800a0ee <HAL_RCC_OscConfig+0x852>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
 8009ed4:	4b4a      	ldr	r3, [pc, #296]	@ (800a000 <HAL_RCC_OscConfig+0x764>)
 8009ed6:	681b      	ldr	r3, [r3, #0]
 8009ed8:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 8009edc:	2b00      	cmp	r3, #0
 8009ede:	d1f0      	bne.n	8009ec2 <HAL_RCC_OscConfig+0x626>
          }
        }

        /* Configure the main PLL clock source, multiplication and division factors. */
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8009ee0:	4b47      	ldr	r3, [pc, #284]	@ (800a000 <HAL_RCC_OscConfig+0x764>)
 8009ee2:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 8009ee4:	4b47      	ldr	r3, [pc, #284]	@ (800a004 <HAL_RCC_OscConfig+0x768>)
 8009ee6:	4013      	ands	r3, r2
 8009ee8:	687a      	ldr	r2, [r7, #4]
 8009eea:	6a91      	ldr	r1, [r2, #40]	@ 0x28
 8009eec:	687a      	ldr	r2, [r7, #4]
 8009eee:	6ad2      	ldr	r2, [r2, #44]	@ 0x2c
 8009ef0:	0112      	lsls	r2, r2, #4
 8009ef2:	430a      	orrs	r2, r1
 8009ef4:	4942      	ldr	r1, [pc, #264]	@ (800a000 <HAL_RCC_OscConfig+0x764>)
 8009ef6:	4313      	orrs	r3, r2
 8009ef8:	628b      	str	r3, [r1, #40]	@ 0x28
 8009efa:	687b      	ldr	r3, [r7, #4]
 8009efc:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8009efe:	3b01      	subs	r3, #1
 8009f00:	f3c3 0208 	ubfx	r2, r3, #0, #9
 8009f04:	687b      	ldr	r3, [r7, #4]
 8009f06:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8009f08:	3b01      	subs	r3, #1
 8009f0a:	025b      	lsls	r3, r3, #9
 8009f0c:	b29b      	uxth	r3, r3
 8009f0e:	431a      	orrs	r2, r3
 8009f10:	687b      	ldr	r3, [r7, #4]
 8009f12:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8009f14:	3b01      	subs	r3, #1
 8009f16:	041b      	lsls	r3, r3, #16
 8009f18:	f403 03fe 	and.w	r3, r3, #8323072	@ 0x7f0000
 8009f1c:	431a      	orrs	r2, r3
 8009f1e:	687b      	ldr	r3, [r7, #4]
 8009f20:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8009f22:	3b01      	subs	r3, #1
 8009f24:	061b      	lsls	r3, r3, #24
 8009f26:	f003 43fe 	and.w	r3, r3, #2130706432	@ 0x7f000000
 8009f2a:	4935      	ldr	r1, [pc, #212]	@ (800a000 <HAL_RCC_OscConfig+0x764>)
 8009f2c:	4313      	orrs	r3, r2
 8009f2e:	630b      	str	r3, [r1, #48]	@ 0x30
                             RCC_OscInitStruct->PLL.PLLP,
                             RCC_OscInitStruct->PLL.PLLQ,
                             RCC_OscInitStruct->PLL.PLLR);

        /* Disable PLLFRACN . */
        __HAL_RCC_PLLFRACN_DISABLE();
 8009f30:	4b33      	ldr	r3, [pc, #204]	@ (800a000 <HAL_RCC_OscConfig+0x764>)
 8009f32:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8009f34:	4a32      	ldr	r2, [pc, #200]	@ (800a000 <HAL_RCC_OscConfig+0x764>)
 8009f36:	f023 0301 	bic.w	r3, r3, #1
 8009f3a:	62d3      	str	r3, [r2, #44]	@ 0x2c

        /* Configure PLL PLL1FRACN */
        __HAL_RCC_PLLFRACN_CONFIG(RCC_OscInitStruct->PLL.PLLFRACN);
 8009f3c:	4b30      	ldr	r3, [pc, #192]	@ (800a000 <HAL_RCC_OscConfig+0x764>)
 8009f3e:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 8009f40:	4b31      	ldr	r3, [pc, #196]	@ (800a008 <HAL_RCC_OscConfig+0x76c>)
 8009f42:	4013      	ands	r3, r2
 8009f44:	687a      	ldr	r2, [r7, #4]
 8009f46:	6c92      	ldr	r2, [r2, #72]	@ 0x48
 8009f48:	00d2      	lsls	r2, r2, #3
 8009f4a:	492d      	ldr	r1, [pc, #180]	@ (800a000 <HAL_RCC_OscConfig+0x764>)
 8009f4c:	4313      	orrs	r3, r2
 8009f4e:	634b      	str	r3, [r1, #52]	@ 0x34

        /* Select PLL1 input reference frequency range: VCI */
        __HAL_RCC_PLL_VCIRANGE(RCC_OscInitStruct->PLL.PLLRGE) ;
 8009f50:	4b2b      	ldr	r3, [pc, #172]	@ (800a000 <HAL_RCC_OscConfig+0x764>)
 8009f52:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8009f54:	f023 020c 	bic.w	r2, r3, #12
 8009f58:	687b      	ldr	r3, [r7, #4]
 8009f5a:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8009f5c:	4928      	ldr	r1, [pc, #160]	@ (800a000 <HAL_RCC_OscConfig+0x764>)
 8009f5e:	4313      	orrs	r3, r2
 8009f60:	62cb      	str	r3, [r1, #44]	@ 0x2c

        /* Select PLL1 output frequency range : VCO */
        __HAL_RCC_PLL_VCORANGE(RCC_OscInitStruct->PLL.PLLVCOSEL) ;
 8009f62:	4b27      	ldr	r3, [pc, #156]	@ (800a000 <HAL_RCC_OscConfig+0x764>)
 8009f64:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8009f66:	f023 0202 	bic.w	r2, r3, #2
 8009f6a:	687b      	ldr	r3, [r7, #4]
 8009f6c:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8009f6e:	4924      	ldr	r1, [pc, #144]	@ (800a000 <HAL_RCC_OscConfig+0x764>)
 8009f70:	4313      	orrs	r3, r2
 8009f72:	62cb      	str	r3, [r1, #44]	@ 0x2c

        /* Enable PLL System Clock output. */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVP);
 8009f74:	4b22      	ldr	r3, [pc, #136]	@ (800a000 <HAL_RCC_OscConfig+0x764>)
 8009f76:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8009f78:	4a21      	ldr	r2, [pc, #132]	@ (800a000 <HAL_RCC_OscConfig+0x764>)
 8009f7a:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 8009f7e:	62d3      	str	r3, [r2, #44]	@ 0x2c

        /* Enable PLL1Q Clock output. */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 8009f80:	4b1f      	ldr	r3, [pc, #124]	@ (800a000 <HAL_RCC_OscConfig+0x764>)
 8009f82:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8009f84:	4a1e      	ldr	r2, [pc, #120]	@ (800a000 <HAL_RCC_OscConfig+0x764>)
 8009f86:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 8009f8a:	62d3      	str	r3, [r2, #44]	@ 0x2c

        /* Enable PLL1R  Clock output. */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVR);
 8009f8c:	4b1c      	ldr	r3, [pc, #112]	@ (800a000 <HAL_RCC_OscConfig+0x764>)
 8009f8e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8009f90:	4a1b      	ldr	r2, [pc, #108]	@ (800a000 <HAL_RCC_OscConfig+0x764>)
 8009f92:	f443 2380 	orr.w	r3, r3, #262144	@ 0x40000
 8009f96:	62d3      	str	r3, [r2, #44]	@ 0x2c

        /* Enable PLL1FRACN . */
        __HAL_RCC_PLLFRACN_ENABLE();
 8009f98:	4b19      	ldr	r3, [pc, #100]	@ (800a000 <HAL_RCC_OscConfig+0x764>)
 8009f9a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8009f9c:	4a18      	ldr	r2, [pc, #96]	@ (800a000 <HAL_RCC_OscConfig+0x764>)
 8009f9e:	f043 0301 	orr.w	r3, r3, #1
 8009fa2:	62d3      	str	r3, [r2, #44]	@ 0x2c

        /* Enable the main PLL. */
        __HAL_RCC_PLL_ENABLE();
 8009fa4:	4b16      	ldr	r3, [pc, #88]	@ (800a000 <HAL_RCC_OscConfig+0x764>)
 8009fa6:	681b      	ldr	r3, [r3, #0]
 8009fa8:	4a15      	ldr	r2, [pc, #84]	@ (800a000 <HAL_RCC_OscConfig+0x764>)
 8009faa:	f043 7380 	orr.w	r3, r3, #16777216	@ 0x1000000
 8009fae:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8009fb0:	f7f8 fcd6 	bl	8002960 <HAL_GetTick>
 8009fb4:	6278      	str	r0, [r7, #36]	@ 0x24

        /* Wait till PLL is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
 8009fb6:	e008      	b.n	8009fca <HAL_RCC_OscConfig+0x72e>
        {
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8009fb8:	f7f8 fcd2 	bl	8002960 <HAL_GetTick>
 8009fbc:	4602      	mov	r2, r0
 8009fbe:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8009fc0:	1ad3      	subs	r3, r2, r3
 8009fc2:	2b02      	cmp	r3, #2
 8009fc4:	d901      	bls.n	8009fca <HAL_RCC_OscConfig+0x72e>
          {
            return HAL_TIMEOUT;
 8009fc6:	2303      	movs	r3, #3
 8009fc8:	e091      	b.n	800a0ee <HAL_RCC_OscConfig+0x852>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
 8009fca:	4b0d      	ldr	r3, [pc, #52]	@ (800a000 <HAL_RCC_OscConfig+0x764>)
 8009fcc:	681b      	ldr	r3, [r3, #0]
 8009fce:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 8009fd2:	2b00      	cmp	r3, #0
 8009fd4:	d0f0      	beq.n	8009fb8 <HAL_RCC_OscConfig+0x71c>
 8009fd6:	e089      	b.n	800a0ec <HAL_RCC_OscConfig+0x850>
        }
      }
      else
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 8009fd8:	4b09      	ldr	r3, [pc, #36]	@ (800a000 <HAL_RCC_OscConfig+0x764>)
 8009fda:	681b      	ldr	r3, [r3, #0]
 8009fdc:	4a08      	ldr	r2, [pc, #32]	@ (800a000 <HAL_RCC_OscConfig+0x764>)
 8009fde:	f023 7380 	bic.w	r3, r3, #16777216	@ 0x1000000
 8009fe2:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8009fe4:	f7f8 fcbc 	bl	8002960 <HAL_GetTick>
 8009fe8:	6278      	str	r0, [r7, #36]	@ 0x24

        /* Wait till PLL is disabled */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
 8009fea:	e00f      	b.n	800a00c <HAL_RCC_OscConfig+0x770>
        {
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8009fec:	f7f8 fcb8 	bl	8002960 <HAL_GetTick>
 8009ff0:	4602      	mov	r2, r0
 8009ff2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8009ff4:	1ad3      	subs	r3, r2, r3
 8009ff6:	2b02      	cmp	r3, #2
 8009ff8:	d908      	bls.n	800a00c <HAL_RCC_OscConfig+0x770>
          {
            return HAL_TIMEOUT;
 8009ffa:	2303      	movs	r3, #3
 8009ffc:	e077      	b.n	800a0ee <HAL_RCC_OscConfig+0x852>
 8009ffe:	bf00      	nop
 800a000:	58024400 	.word	0x58024400
 800a004:	fffffc0c 	.word	0xfffffc0c
 800a008:	ffff0007 	.word	0xffff0007
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
 800a00c:	4b3a      	ldr	r3, [pc, #232]	@ (800a0f8 <HAL_RCC_OscConfig+0x85c>)
 800a00e:	681b      	ldr	r3, [r3, #0]
 800a010:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 800a014:	2b00      	cmp	r3, #0
 800a016:	d1e9      	bne.n	8009fec <HAL_RCC_OscConfig+0x750>
 800a018:	e068      	b.n	800a0ec <HAL_RCC_OscConfig+0x850>
      }
    }
    else
    {
      /* Do not return HAL_ERROR if request repeats the current configuration */
      temp1_pllckcfg = RCC->PLLCKSELR;
 800a01a:	4b37      	ldr	r3, [pc, #220]	@ (800a0f8 <HAL_RCC_OscConfig+0x85c>)
 800a01c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800a01e:	613b      	str	r3, [r7, #16]
      temp2_pllckcfg = RCC->PLL1DIVR;
 800a020:	4b35      	ldr	r3, [pc, #212]	@ (800a0f8 <HAL_RCC_OscConfig+0x85c>)
 800a022:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800a024:	60fb      	str	r3, [r7, #12]
      if (((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 800a026:	687b      	ldr	r3, [r7, #4]
 800a028:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800a02a:	2b01      	cmp	r3, #1
 800a02c:	d031      	beq.n	800a092 <HAL_RCC_OscConfig+0x7f6>
          (READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 800a02e:	693b      	ldr	r3, [r7, #16]
 800a030:	f003 0203 	and.w	r2, r3, #3
 800a034:	687b      	ldr	r3, [r7, #4]
 800a036:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
      if (((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 800a038:	429a      	cmp	r2, r3
 800a03a:	d12a      	bne.n	800a092 <HAL_RCC_OscConfig+0x7f6>
          ((READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_DIVM1) >> RCC_PLLCKSELR_DIVM1_Pos) != RCC_OscInitStruct->PLL.PLLM) ||
 800a03c:	693b      	ldr	r3, [r7, #16]
 800a03e:	091b      	lsrs	r3, r3, #4
 800a040:	f003 023f 	and.w	r2, r3, #63	@ 0x3f
 800a044:	687b      	ldr	r3, [r7, #4]
 800a046:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
          (READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 800a048:	429a      	cmp	r2, r3
 800a04a:	d122      	bne.n	800a092 <HAL_RCC_OscConfig+0x7f6>
          (READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_N1) != (RCC_OscInitStruct->PLL.PLLN - 1U)) ||
 800a04c:	68fb      	ldr	r3, [r7, #12]
 800a04e:	f3c3 0208 	ubfx	r2, r3, #0, #9
 800a052:	687b      	ldr	r3, [r7, #4]
 800a054:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800a056:	3b01      	subs	r3, #1
          ((READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_DIVM1) >> RCC_PLLCKSELR_DIVM1_Pos) != RCC_OscInitStruct->PLL.PLLM) ||
 800a058:	429a      	cmp	r2, r3
 800a05a:	d11a      	bne.n	800a092 <HAL_RCC_OscConfig+0x7f6>
          ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_P1) >> RCC_PLL1DIVR_P1_Pos) != (RCC_OscInitStruct->PLL.PLLP - 1U)) ||
 800a05c:	68fb      	ldr	r3, [r7, #12]
 800a05e:	0a5b      	lsrs	r3, r3, #9
 800a060:	f003 027f 	and.w	r2, r3, #127	@ 0x7f
 800a064:	687b      	ldr	r3, [r7, #4]
 800a066:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 800a068:	3b01      	subs	r3, #1
          (READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_N1) != (RCC_OscInitStruct->PLL.PLLN - 1U)) ||
 800a06a:	429a      	cmp	r2, r3
 800a06c:	d111      	bne.n	800a092 <HAL_RCC_OscConfig+0x7f6>
          ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_Q1) >> RCC_PLL1DIVR_Q1_Pos) != (RCC_OscInitStruct->PLL.PLLQ - 1U)) ||
 800a06e:	68fb      	ldr	r3, [r7, #12]
 800a070:	0c1b      	lsrs	r3, r3, #16
 800a072:	f003 027f 	and.w	r2, r3, #127	@ 0x7f
 800a076:	687b      	ldr	r3, [r7, #4]
 800a078:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800a07a:	3b01      	subs	r3, #1
          ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_P1) >> RCC_PLL1DIVR_P1_Pos) != (RCC_OscInitStruct->PLL.PLLP - 1U)) ||
 800a07c:	429a      	cmp	r2, r3
 800a07e:	d108      	bne.n	800a092 <HAL_RCC_OscConfig+0x7f6>
          ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_R1) >> RCC_PLL1DIVR_R1_Pos) != (RCC_OscInitStruct->PLL.PLLR - 1U)))
 800a080:	68fb      	ldr	r3, [r7, #12]
 800a082:	0e1b      	lsrs	r3, r3, #24
 800a084:	f003 027f 	and.w	r2, r3, #127	@ 0x7f
 800a088:	687b      	ldr	r3, [r7, #4]
 800a08a:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 800a08c:	3b01      	subs	r3, #1
          ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_Q1) >> RCC_PLL1DIVR_Q1_Pos) != (RCC_OscInitStruct->PLL.PLLQ - 1U)) ||
 800a08e:	429a      	cmp	r2, r3
 800a090:	d001      	beq.n	800a096 <HAL_RCC_OscConfig+0x7fa>
      {
        return HAL_ERROR;
 800a092:	2301      	movs	r3, #1
 800a094:	e02b      	b.n	800a0ee <HAL_RCC_OscConfig+0x852>
      }
      else
      {
        /* Check if only fractional part needs to be updated  */
        temp1_pllckcfg = ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1) >> RCC_PLL1FRACR_FRACN1_Pos);
 800a096:	4b18      	ldr	r3, [pc, #96]	@ (800a0f8 <HAL_RCC_OscConfig+0x85c>)
 800a098:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 800a09a:	08db      	lsrs	r3, r3, #3
 800a09c:	f3c3 030c 	ubfx	r3, r3, #0, #13
 800a0a0:	613b      	str	r3, [r7, #16]
        if (RCC_OscInitStruct->PLL.PLLFRACN != temp1_pllckcfg)
 800a0a2:	687b      	ldr	r3, [r7, #4]
 800a0a4:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 800a0a6:	693a      	ldr	r2, [r7, #16]
 800a0a8:	429a      	cmp	r2, r3
 800a0aa:	d01f      	beq.n	800a0ec <HAL_RCC_OscConfig+0x850>
        {
          assert_param(IS_RCC_PLLFRACN_VALUE(RCC_OscInitStruct->PLL.PLLFRACN));
          /* Disable PLL1FRACEN */
          __HAL_RCC_PLLFRACN_DISABLE();
 800a0ac:	4b12      	ldr	r3, [pc, #72]	@ (800a0f8 <HAL_RCC_OscConfig+0x85c>)
 800a0ae:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800a0b0:	4a11      	ldr	r2, [pc, #68]	@ (800a0f8 <HAL_RCC_OscConfig+0x85c>)
 800a0b2:	f023 0301 	bic.w	r3, r3, #1
 800a0b6:	62d3      	str	r3, [r2, #44]	@ 0x2c
          /* Get Start Tick*/
          tickstart = HAL_GetTick();
 800a0b8:	f7f8 fc52 	bl	8002960 <HAL_GetTick>
 800a0bc:	6278      	str	r0, [r7, #36]	@ 0x24
          /* Wait at least 2 CK_REF (PLL input source divided by M) period to make sure next latched value will be taken into account. */
          while ((HAL_GetTick() - tickstart) < PLL_FRAC_TIMEOUT_VALUE)
 800a0be:	bf00      	nop
 800a0c0:	f7f8 fc4e 	bl	8002960 <HAL_GetTick>
 800a0c4:	4602      	mov	r2, r0
 800a0c6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800a0c8:	4293      	cmp	r3, r2
 800a0ca:	d0f9      	beq.n	800a0c0 <HAL_RCC_OscConfig+0x824>
          {
          }
          /* Configure PLL1 PLL1FRACN */
          __HAL_RCC_PLLFRACN_CONFIG(RCC_OscInitStruct->PLL.PLLFRACN);
 800a0cc:	4b0a      	ldr	r3, [pc, #40]	@ (800a0f8 <HAL_RCC_OscConfig+0x85c>)
 800a0ce:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 800a0d0:	4b0a      	ldr	r3, [pc, #40]	@ (800a0fc <HAL_RCC_OscConfig+0x860>)
 800a0d2:	4013      	ands	r3, r2
 800a0d4:	687a      	ldr	r2, [r7, #4]
 800a0d6:	6c92      	ldr	r2, [r2, #72]	@ 0x48
 800a0d8:	00d2      	lsls	r2, r2, #3
 800a0da:	4907      	ldr	r1, [pc, #28]	@ (800a0f8 <HAL_RCC_OscConfig+0x85c>)
 800a0dc:	4313      	orrs	r3, r2
 800a0de:	634b      	str	r3, [r1, #52]	@ 0x34
          /* Enable PLL1FRACEN to latch new value. */
          __HAL_RCC_PLLFRACN_ENABLE();
 800a0e0:	4b05      	ldr	r3, [pc, #20]	@ (800a0f8 <HAL_RCC_OscConfig+0x85c>)
 800a0e2:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800a0e4:	4a04      	ldr	r2, [pc, #16]	@ (800a0f8 <HAL_RCC_OscConfig+0x85c>)
 800a0e6:	f043 0301 	orr.w	r3, r3, #1
 800a0ea:	62d3      	str	r3, [r2, #44]	@ 0x2c
        }
      }
    }
  }
  return HAL_OK;
 800a0ec:	2300      	movs	r3, #0
}
 800a0ee:	4618      	mov	r0, r3
 800a0f0:	3730      	adds	r7, #48	@ 0x30
 800a0f2:	46bd      	mov	sp, r7
 800a0f4:	bd80      	pop	{r7, pc}
 800a0f6:	bf00      	nop
 800a0f8:	58024400 	.word	0x58024400
 800a0fc:	ffff0007 	.word	0xffff0007

0800a100 <HAL_RCC_ClockConfig>:
  *         D1CPRE[3:0] bits to ensure that  Domain1 core clock not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 800a100:	b580      	push	{r7, lr}
 800a102:	b086      	sub	sp, #24
 800a104:	af00      	add	r7, sp, #0
 800a106:	6078      	str	r0, [r7, #4]
 800a108:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef halstatus;
  uint32_t tickstart;
  uint32_t common_system_clock;

  /* Check Null pointer */
  if (RCC_ClkInitStruct == NULL)
 800a10a:	687b      	ldr	r3, [r7, #4]
 800a10c:	2b00      	cmp	r3, #0
 800a10e:	d101      	bne.n	800a114 <HAL_RCC_ClockConfig+0x14>
  {
    return HAL_ERROR;
 800a110:	2301      	movs	r3, #1
 800a112:	e19c      	b.n	800a44e <HAL_RCC_ClockConfig+0x34e>
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
    must be correctly programmed according to the frequency of the CPU clock
    (HCLK) and the supply voltage of the device. */

  /* Increasing the CPU frequency */
  if (FLatency > __HAL_FLASH_GET_LATENCY())
 800a114:	4b8a      	ldr	r3, [pc, #552]	@ (800a340 <HAL_RCC_ClockConfig+0x240>)
 800a116:	681b      	ldr	r3, [r3, #0]
 800a118:	f003 030f 	and.w	r3, r3, #15
 800a11c:	683a      	ldr	r2, [r7, #0]
 800a11e:	429a      	cmp	r2, r3
 800a120:	d910      	bls.n	800a144 <HAL_RCC_ClockConfig+0x44>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 800a122:	4b87      	ldr	r3, [pc, #540]	@ (800a340 <HAL_RCC_ClockConfig+0x240>)
 800a124:	681b      	ldr	r3, [r3, #0]
 800a126:	f023 020f 	bic.w	r2, r3, #15
 800a12a:	4985      	ldr	r1, [pc, #532]	@ (800a340 <HAL_RCC_ClockConfig+0x240>)
 800a12c:	683b      	ldr	r3, [r7, #0]
 800a12e:	4313      	orrs	r3, r2
 800a130:	600b      	str	r3, [r1, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
 800a132:	4b83      	ldr	r3, [pc, #524]	@ (800a340 <HAL_RCC_ClockConfig+0x240>)
 800a134:	681b      	ldr	r3, [r3, #0]
 800a136:	f003 030f 	and.w	r3, r3, #15
 800a13a:	683a      	ldr	r2, [r7, #0]
 800a13c:	429a      	cmp	r2, r3
 800a13e:	d001      	beq.n	800a144 <HAL_RCC_ClockConfig+0x44>
    {
      return HAL_ERROR;
 800a140:	2301      	movs	r3, #1
 800a142:	e184      	b.n	800a44e <HAL_RCC_ClockConfig+0x34e>

  }

  /* Increasing the BUS frequency divider */
  /*-------------------------- D1PCLK1/CDPCLK1 Configuration ---------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D1PCLK1) == RCC_CLOCKTYPE_D1PCLK1)
 800a144:	687b      	ldr	r3, [r7, #4]
 800a146:	681b      	ldr	r3, [r3, #0]
 800a148:	f003 0304 	and.w	r3, r3, #4
 800a14c:	2b00      	cmp	r3, #0
 800a14e:	d010      	beq.n	800a172 <HAL_RCC_ClockConfig+0x72>
    {
      assert_param(IS_RCC_D1PCLK1(RCC_ClkInitStruct->APB3CLKDivider));
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1PPRE, RCC_ClkInitStruct->APB3CLKDivider);
    }
#else
    if ((RCC_ClkInitStruct->APB3CLKDivider) > (RCC->CDCFGR1 & RCC_CDCFGR1_CDPPRE))
 800a150:	687b      	ldr	r3, [r7, #4]
 800a152:	691a      	ldr	r2, [r3, #16]
 800a154:	4b7b      	ldr	r3, [pc, #492]	@ (800a344 <HAL_RCC_ClockConfig+0x244>)
 800a156:	699b      	ldr	r3, [r3, #24]
 800a158:	f003 0370 	and.w	r3, r3, #112	@ 0x70
 800a15c:	429a      	cmp	r2, r3
 800a15e:	d908      	bls.n	800a172 <HAL_RCC_ClockConfig+0x72>
    {
      assert_param(IS_RCC_CDPCLK1(RCC_ClkInitStruct->APB3CLKDivider));
      MODIFY_REG(RCC->CDCFGR1, RCC_CDCFGR1_CDPPRE, RCC_ClkInitStruct->APB3CLKDivider);
 800a160:	4b78      	ldr	r3, [pc, #480]	@ (800a344 <HAL_RCC_ClockConfig+0x244>)
 800a162:	699b      	ldr	r3, [r3, #24]
 800a164:	f023 0270 	bic.w	r2, r3, #112	@ 0x70
 800a168:	687b      	ldr	r3, [r7, #4]
 800a16a:	691b      	ldr	r3, [r3, #16]
 800a16c:	4975      	ldr	r1, [pc, #468]	@ (800a344 <HAL_RCC_ClockConfig+0x244>)
 800a16e:	4313      	orrs	r3, r2
 800a170:	618b      	str	r3, [r1, #24]
    }
#endif
  }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 800a172:	687b      	ldr	r3, [r7, #4]
 800a174:	681b      	ldr	r3, [r3, #0]
 800a176:	f003 0308 	and.w	r3, r3, #8
 800a17a:	2b00      	cmp	r3, #0
 800a17c:	d010      	beq.n	800a1a0 <HAL_RCC_ClockConfig+0xa0>
    {
      assert_param(IS_RCC_PCLK1(RCC_ClkInitStruct->APB1CLKDivider));
      MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE1, (RCC_ClkInitStruct->APB1CLKDivider));
    }
#else
    if ((RCC_ClkInitStruct->APB1CLKDivider) > (RCC->CDCFGR2 & RCC_CDCFGR2_CDPPRE1))
 800a17e:	687b      	ldr	r3, [r7, #4]
 800a180:	695a      	ldr	r2, [r3, #20]
 800a182:	4b70      	ldr	r3, [pc, #448]	@ (800a344 <HAL_RCC_ClockConfig+0x244>)
 800a184:	69db      	ldr	r3, [r3, #28]
 800a186:	f003 0370 	and.w	r3, r3, #112	@ 0x70
 800a18a:	429a      	cmp	r2, r3
 800a18c:	d908      	bls.n	800a1a0 <HAL_RCC_ClockConfig+0xa0>
    {
      assert_param(IS_RCC_PCLK1(RCC_ClkInitStruct->APB1CLKDivider));
      MODIFY_REG(RCC->CDCFGR2, RCC_CDCFGR2_CDPPRE1, (RCC_ClkInitStruct->APB1CLKDivider));
 800a18e:	4b6d      	ldr	r3, [pc, #436]	@ (800a344 <HAL_RCC_ClockConfig+0x244>)
 800a190:	69db      	ldr	r3, [r3, #28]
 800a192:	f023 0270 	bic.w	r2, r3, #112	@ 0x70
 800a196:	687b      	ldr	r3, [r7, #4]
 800a198:	695b      	ldr	r3, [r3, #20]
 800a19a:	496a      	ldr	r1, [pc, #424]	@ (800a344 <HAL_RCC_ClockConfig+0x244>)
 800a19c:	4313      	orrs	r3, r2
 800a19e:	61cb      	str	r3, [r1, #28]
    }
#endif
  }
  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 800a1a0:	687b      	ldr	r3, [r7, #4]
 800a1a2:	681b      	ldr	r3, [r3, #0]
 800a1a4:	f003 0310 	and.w	r3, r3, #16
 800a1a8:	2b00      	cmp	r3, #0
 800a1aa:	d010      	beq.n	800a1ce <HAL_RCC_ClockConfig+0xce>
    {
      assert_param(IS_RCC_PCLK2(RCC_ClkInitStruct->APB2CLKDivider));
      MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE2, (RCC_ClkInitStruct->APB2CLKDivider));
    }
#else
    if ((RCC_ClkInitStruct->APB2CLKDivider) > (RCC->CDCFGR2 & RCC_CDCFGR2_CDPPRE2))
 800a1ac:	687b      	ldr	r3, [r7, #4]
 800a1ae:	699a      	ldr	r2, [r3, #24]
 800a1b0:	4b64      	ldr	r3, [pc, #400]	@ (800a344 <HAL_RCC_ClockConfig+0x244>)
 800a1b2:	69db      	ldr	r3, [r3, #28]
 800a1b4:	f403 63e0 	and.w	r3, r3, #1792	@ 0x700
 800a1b8:	429a      	cmp	r2, r3
 800a1ba:	d908      	bls.n	800a1ce <HAL_RCC_ClockConfig+0xce>
    {
      assert_param(IS_RCC_PCLK2(RCC_ClkInitStruct->APB2CLKDivider));
      MODIFY_REG(RCC->CDCFGR2, RCC_CDCFGR2_CDPPRE2, (RCC_ClkInitStruct->APB2CLKDivider));
 800a1bc:	4b61      	ldr	r3, [pc, #388]	@ (800a344 <HAL_RCC_ClockConfig+0x244>)
 800a1be:	69db      	ldr	r3, [r3, #28]
 800a1c0:	f423 62e0 	bic.w	r2, r3, #1792	@ 0x700
 800a1c4:	687b      	ldr	r3, [r7, #4]
 800a1c6:	699b      	ldr	r3, [r3, #24]
 800a1c8:	495e      	ldr	r1, [pc, #376]	@ (800a344 <HAL_RCC_ClockConfig+0x244>)
 800a1ca:	4313      	orrs	r3, r2
 800a1cc:	61cb      	str	r3, [r1, #28]
    }
#endif
  }

  /*-------------------------- D3PCLK1 Configuration ---------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D3PCLK1) == RCC_CLOCKTYPE_D3PCLK1)
 800a1ce:	687b      	ldr	r3, [r7, #4]
 800a1d0:	681b      	ldr	r3, [r3, #0]
 800a1d2:	f003 0320 	and.w	r3, r3, #32
 800a1d6:	2b00      	cmp	r3, #0
 800a1d8:	d010      	beq.n	800a1fc <HAL_RCC_ClockConfig+0xfc>
    {
      assert_param(IS_RCC_D3PCLK1(RCC_ClkInitStruct->APB4CLKDivider));
      MODIFY_REG(RCC->D3CFGR, RCC_D3CFGR_D3PPRE, (RCC_ClkInitStruct->APB4CLKDivider));
    }
#else
    if ((RCC_ClkInitStruct->APB4CLKDivider) > (RCC->SRDCFGR & RCC_SRDCFGR_SRDPPRE))
 800a1da:	687b      	ldr	r3, [r7, #4]
 800a1dc:	69da      	ldr	r2, [r3, #28]
 800a1de:	4b59      	ldr	r3, [pc, #356]	@ (800a344 <HAL_RCC_ClockConfig+0x244>)
 800a1e0:	6a1b      	ldr	r3, [r3, #32]
 800a1e2:	f003 0370 	and.w	r3, r3, #112	@ 0x70
 800a1e6:	429a      	cmp	r2, r3
 800a1e8:	d908      	bls.n	800a1fc <HAL_RCC_ClockConfig+0xfc>
    {
      assert_param(IS_RCC_D3PCLK1(RCC_ClkInitStruct->APB4CLKDivider));
      MODIFY_REG(RCC->SRDCFGR, RCC_SRDCFGR_SRDPPRE, (RCC_ClkInitStruct->APB4CLKDivider));
 800a1ea:	4b56      	ldr	r3, [pc, #344]	@ (800a344 <HAL_RCC_ClockConfig+0x244>)
 800a1ec:	6a1b      	ldr	r3, [r3, #32]
 800a1ee:	f023 0270 	bic.w	r2, r3, #112	@ 0x70
 800a1f2:	687b      	ldr	r3, [r7, #4]
 800a1f4:	69db      	ldr	r3, [r3, #28]
 800a1f6:	4953      	ldr	r1, [pc, #332]	@ (800a344 <HAL_RCC_ClockConfig+0x244>)
 800a1f8:	4313      	orrs	r3, r2
 800a1fa:	620b      	str	r3, [r1, #32]
    }
#endif
  }

  /*-------------------------- HCLK Configuration --------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 800a1fc:	687b      	ldr	r3, [r7, #4]
 800a1fe:	681b      	ldr	r3, [r3, #0]
 800a200:	f003 0302 	and.w	r3, r3, #2
 800a204:	2b00      	cmp	r3, #0
 800a206:	d010      	beq.n	800a22a <HAL_RCC_ClockConfig+0x12a>
      /* Set the new HCLK clock divider */
      assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
    }
#else
    if ((RCC_ClkInitStruct->AHBCLKDivider) > (RCC->CDCFGR1 & RCC_CDCFGR1_HPRE))
 800a208:	687b      	ldr	r3, [r7, #4]
 800a20a:	68da      	ldr	r2, [r3, #12]
 800a20c:	4b4d      	ldr	r3, [pc, #308]	@ (800a344 <HAL_RCC_ClockConfig+0x244>)
 800a20e:	699b      	ldr	r3, [r3, #24]
 800a210:	f003 030f 	and.w	r3, r3, #15
 800a214:	429a      	cmp	r2, r3
 800a216:	d908      	bls.n	800a22a <HAL_RCC_ClockConfig+0x12a>
    {
      /* Set the new HCLK clock divider */
      assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
      MODIFY_REG(RCC->CDCFGR1, RCC_CDCFGR1_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 800a218:	4b4a      	ldr	r3, [pc, #296]	@ (800a344 <HAL_RCC_ClockConfig+0x244>)
 800a21a:	699b      	ldr	r3, [r3, #24]
 800a21c:	f023 020f 	bic.w	r2, r3, #15
 800a220:	687b      	ldr	r3, [r7, #4]
 800a222:	68db      	ldr	r3, [r3, #12]
 800a224:	4947      	ldr	r1, [pc, #284]	@ (800a344 <HAL_RCC_ClockConfig+0x244>)
 800a226:	4313      	orrs	r3, r2
 800a228:	618b      	str	r3, [r1, #24]
    }
#endif
  }

  /*------------------------- SYSCLK Configuration -------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 800a22a:	687b      	ldr	r3, [r7, #4]
 800a22c:	681b      	ldr	r3, [r3, #0]
 800a22e:	f003 0301 	and.w	r3, r3, #1
 800a232:	2b00      	cmp	r3, #0
 800a234:	d055      	beq.n	800a2e2 <HAL_RCC_ClockConfig+0x1e2>
    assert_param(IS_RCC_SYSCLK(RCC_ClkInitStruct->SYSCLKDivider));
    assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
#if defined(RCC_D1CFGR_D1CPRE)
    MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1CPRE, RCC_ClkInitStruct->SYSCLKDivider);
#else
    MODIFY_REG(RCC->CDCFGR1, RCC_CDCFGR1_CDCPRE, RCC_ClkInitStruct->SYSCLKDivider);
 800a236:	4b43      	ldr	r3, [pc, #268]	@ (800a344 <HAL_RCC_ClockConfig+0x244>)
 800a238:	699b      	ldr	r3, [r3, #24]
 800a23a:	f423 6270 	bic.w	r2, r3, #3840	@ 0xf00
 800a23e:	687b      	ldr	r3, [r7, #4]
 800a240:	689b      	ldr	r3, [r3, #8]
 800a242:	4940      	ldr	r1, [pc, #256]	@ (800a344 <HAL_RCC_ClockConfig+0x244>)
 800a244:	4313      	orrs	r3, r2
 800a246:	618b      	str	r3, [r1, #24]
#endif
    /* HSE is selected as System Clock Source */
    if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 800a248:	687b      	ldr	r3, [r7, #4]
 800a24a:	685b      	ldr	r3, [r3, #4]
 800a24c:	2b02      	cmp	r3, #2
 800a24e:	d107      	bne.n	800a260 <HAL_RCC_ClockConfig+0x160>
    {
      /* Check the HSE ready flag */
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
 800a250:	4b3c      	ldr	r3, [pc, #240]	@ (800a344 <HAL_RCC_ClockConfig+0x244>)
 800a252:	681b      	ldr	r3, [r3, #0]
 800a254:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 800a258:	2b00      	cmp	r3, #0
 800a25a:	d121      	bne.n	800a2a0 <HAL_RCC_ClockConfig+0x1a0>
      {
        return HAL_ERROR;
 800a25c:	2301      	movs	r3, #1
 800a25e:	e0f6      	b.n	800a44e <HAL_RCC_ClockConfig+0x34e>
      }
    }
    /* PLL is selected as System Clock Source */
    else if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 800a260:	687b      	ldr	r3, [r7, #4]
 800a262:	685b      	ldr	r3, [r3, #4]
 800a264:	2b03      	cmp	r3, #3
 800a266:	d107      	bne.n	800a278 <HAL_RCC_ClockConfig+0x178>
    {
      /* Check the PLL ready flag */
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
 800a268:	4b36      	ldr	r3, [pc, #216]	@ (800a344 <HAL_RCC_ClockConfig+0x244>)
 800a26a:	681b      	ldr	r3, [r3, #0]
 800a26c:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 800a270:	2b00      	cmp	r3, #0
 800a272:	d115      	bne.n	800a2a0 <HAL_RCC_ClockConfig+0x1a0>
      {
        return HAL_ERROR;
 800a274:	2301      	movs	r3, #1
 800a276:	e0ea      	b.n	800a44e <HAL_RCC_ClockConfig+0x34e>
      }
    }
    /* CSI is selected as System Clock Source */
    else if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_CSI)
 800a278:	687b      	ldr	r3, [r7, #4]
 800a27a:	685b      	ldr	r3, [r3, #4]
 800a27c:	2b01      	cmp	r3, #1
 800a27e:	d107      	bne.n	800a290 <HAL_RCC_ClockConfig+0x190>
    {
      /* Check the PLL ready flag */
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) == 0U)
 800a280:	4b30      	ldr	r3, [pc, #192]	@ (800a344 <HAL_RCC_ClockConfig+0x244>)
 800a282:	681b      	ldr	r3, [r3, #0]
 800a284:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 800a288:	2b00      	cmp	r3, #0
 800a28a:	d109      	bne.n	800a2a0 <HAL_RCC_ClockConfig+0x1a0>
      {
        return HAL_ERROR;
 800a28c:	2301      	movs	r3, #1
 800a28e:	e0de      	b.n	800a44e <HAL_RCC_ClockConfig+0x34e>
    }
    /* HSI is selected as System Clock Source */
    else
    {
      /* Check the HSI ready flag */
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
 800a290:	4b2c      	ldr	r3, [pc, #176]	@ (800a344 <HAL_RCC_ClockConfig+0x244>)
 800a292:	681b      	ldr	r3, [r3, #0]
 800a294:	f003 0304 	and.w	r3, r3, #4
 800a298:	2b00      	cmp	r3, #0
 800a29a:	d101      	bne.n	800a2a0 <HAL_RCC_ClockConfig+0x1a0>
      {
        return HAL_ERROR;
 800a29c:	2301      	movs	r3, #1
 800a29e:	e0d6      	b.n	800a44e <HAL_RCC_ClockConfig+0x34e>
      }
    }
    MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
 800a2a0:	4b28      	ldr	r3, [pc, #160]	@ (800a344 <HAL_RCC_ClockConfig+0x244>)
 800a2a2:	691b      	ldr	r3, [r3, #16]
 800a2a4:	f023 0207 	bic.w	r2, r3, #7
 800a2a8:	687b      	ldr	r3, [r7, #4]
 800a2aa:	685b      	ldr	r3, [r3, #4]
 800a2ac:	4925      	ldr	r1, [pc, #148]	@ (800a344 <HAL_RCC_ClockConfig+0x244>)
 800a2ae:	4313      	orrs	r3, r2
 800a2b0:	610b      	str	r3, [r1, #16]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 800a2b2:	f7f8 fb55 	bl	8002960 <HAL_GetTick>
 800a2b6:	6178      	str	r0, [r7, #20]

    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 800a2b8:	e00a      	b.n	800a2d0 <HAL_RCC_ClockConfig+0x1d0>
    {
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 800a2ba:	f7f8 fb51 	bl	8002960 <HAL_GetTick>
 800a2be:	4602      	mov	r2, r0
 800a2c0:	697b      	ldr	r3, [r7, #20]
 800a2c2:	1ad3      	subs	r3, r2, r3
 800a2c4:	f241 3288 	movw	r2, #5000	@ 0x1388
 800a2c8:	4293      	cmp	r3, r2
 800a2ca:	d901      	bls.n	800a2d0 <HAL_RCC_ClockConfig+0x1d0>
      {
        return HAL_TIMEOUT;
 800a2cc:	2303      	movs	r3, #3
 800a2ce:	e0be      	b.n	800a44e <HAL_RCC_ClockConfig+0x34e>
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 800a2d0:	4b1c      	ldr	r3, [pc, #112]	@ (800a344 <HAL_RCC_ClockConfig+0x244>)
 800a2d2:	691b      	ldr	r3, [r3, #16]
 800a2d4:	f003 0238 	and.w	r2, r3, #56	@ 0x38
 800a2d8:	687b      	ldr	r3, [r7, #4]
 800a2da:	685b      	ldr	r3, [r3, #4]
 800a2dc:	00db      	lsls	r3, r3, #3
 800a2de:	429a      	cmp	r2, r3
 800a2e0:	d1eb      	bne.n	800a2ba <HAL_RCC_ClockConfig+0x1ba>

  }

  /* Decreasing the BUS frequency divider */
  /*-------------------------- HCLK Configuration --------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 800a2e2:	687b      	ldr	r3, [r7, #4]
 800a2e4:	681b      	ldr	r3, [r3, #0]
 800a2e6:	f003 0302 	and.w	r3, r3, #2
 800a2ea:	2b00      	cmp	r3, #0
 800a2ec:	d010      	beq.n	800a310 <HAL_RCC_ClockConfig+0x210>
      /* Set the new HCLK clock divider */
      assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
    }
#else
    if ((RCC_ClkInitStruct->AHBCLKDivider) < (RCC->CDCFGR1 & RCC_CDCFGR1_HPRE))
 800a2ee:	687b      	ldr	r3, [r7, #4]
 800a2f0:	68da      	ldr	r2, [r3, #12]
 800a2f2:	4b14      	ldr	r3, [pc, #80]	@ (800a344 <HAL_RCC_ClockConfig+0x244>)
 800a2f4:	699b      	ldr	r3, [r3, #24]
 800a2f6:	f003 030f 	and.w	r3, r3, #15
 800a2fa:	429a      	cmp	r2, r3
 800a2fc:	d208      	bcs.n	800a310 <HAL_RCC_ClockConfig+0x210>
    {
      /* Set the new HCLK clock divider */
      assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
      MODIFY_REG(RCC->CDCFGR1, RCC_CDCFGR1_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 800a2fe:	4b11      	ldr	r3, [pc, #68]	@ (800a344 <HAL_RCC_ClockConfig+0x244>)
 800a300:	699b      	ldr	r3, [r3, #24]
 800a302:	f023 020f 	bic.w	r2, r3, #15
 800a306:	687b      	ldr	r3, [r7, #4]
 800a308:	68db      	ldr	r3, [r3, #12]
 800a30a:	490e      	ldr	r1, [pc, #56]	@ (800a344 <HAL_RCC_ClockConfig+0x244>)
 800a30c:	4313      	orrs	r3, r2
 800a30e:	618b      	str	r3, [r1, #24]
    }
#endif
  }

  /* Decreasing the number of wait states because of lower CPU frequency */
  if (FLatency < __HAL_FLASH_GET_LATENCY())
 800a310:	4b0b      	ldr	r3, [pc, #44]	@ (800a340 <HAL_RCC_ClockConfig+0x240>)
 800a312:	681b      	ldr	r3, [r3, #0]
 800a314:	f003 030f 	and.w	r3, r3, #15
 800a318:	683a      	ldr	r2, [r7, #0]
 800a31a:	429a      	cmp	r2, r3
 800a31c:	d214      	bcs.n	800a348 <HAL_RCC_ClockConfig+0x248>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 800a31e:	4b08      	ldr	r3, [pc, #32]	@ (800a340 <HAL_RCC_ClockConfig+0x240>)
 800a320:	681b      	ldr	r3, [r3, #0]
 800a322:	f023 020f 	bic.w	r2, r3, #15
 800a326:	4906      	ldr	r1, [pc, #24]	@ (800a340 <HAL_RCC_ClockConfig+0x240>)
 800a328:	683b      	ldr	r3, [r7, #0]
 800a32a:	4313      	orrs	r3, r2
 800a32c:	600b      	str	r3, [r1, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
 800a32e:	4b04      	ldr	r3, [pc, #16]	@ (800a340 <HAL_RCC_ClockConfig+0x240>)
 800a330:	681b      	ldr	r3, [r3, #0]
 800a332:	f003 030f 	and.w	r3, r3, #15
 800a336:	683a      	ldr	r2, [r7, #0]
 800a338:	429a      	cmp	r2, r3
 800a33a:	d005      	beq.n	800a348 <HAL_RCC_ClockConfig+0x248>
    {
      return HAL_ERROR;
 800a33c:	2301      	movs	r3, #1
 800a33e:	e086      	b.n	800a44e <HAL_RCC_ClockConfig+0x34e>
 800a340:	52002000 	.word	0x52002000
 800a344:	58024400 	.word	0x58024400
    }
  }

  /*-------------------------- D1PCLK1/CDPCLK Configuration ---------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D1PCLK1) == RCC_CLOCKTYPE_D1PCLK1)
 800a348:	687b      	ldr	r3, [r7, #4]
 800a34a:	681b      	ldr	r3, [r3, #0]
 800a34c:	f003 0304 	and.w	r3, r3, #4
 800a350:	2b00      	cmp	r3, #0
 800a352:	d010      	beq.n	800a376 <HAL_RCC_ClockConfig+0x276>
    {
      assert_param(IS_RCC_D1PCLK1(RCC_ClkInitStruct->APB3CLKDivider));
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1PPRE, RCC_ClkInitStruct->APB3CLKDivider);
    }
#else
    if ((RCC_ClkInitStruct->APB3CLKDivider) < (RCC->CDCFGR1 & RCC_CDCFGR1_CDPPRE))
 800a354:	687b      	ldr	r3, [r7, #4]
 800a356:	691a      	ldr	r2, [r3, #16]
 800a358:	4b3f      	ldr	r3, [pc, #252]	@ (800a458 <HAL_RCC_ClockConfig+0x358>)
 800a35a:	699b      	ldr	r3, [r3, #24]
 800a35c:	f003 0370 	and.w	r3, r3, #112	@ 0x70
 800a360:	429a      	cmp	r2, r3
 800a362:	d208      	bcs.n	800a376 <HAL_RCC_ClockConfig+0x276>
    {
      assert_param(IS_RCC_CDPCLK1(RCC_ClkInitStruct->APB3CLKDivider));
      MODIFY_REG(RCC->CDCFGR1, RCC_CDCFGR1_CDPPRE, RCC_ClkInitStruct->APB3CLKDivider);
 800a364:	4b3c      	ldr	r3, [pc, #240]	@ (800a458 <HAL_RCC_ClockConfig+0x358>)
 800a366:	699b      	ldr	r3, [r3, #24]
 800a368:	f023 0270 	bic.w	r2, r3, #112	@ 0x70
 800a36c:	687b      	ldr	r3, [r7, #4]
 800a36e:	691b      	ldr	r3, [r3, #16]
 800a370:	4939      	ldr	r1, [pc, #228]	@ (800a458 <HAL_RCC_ClockConfig+0x358>)
 800a372:	4313      	orrs	r3, r2
 800a374:	618b      	str	r3, [r1, #24]
    }
#endif
  }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 800a376:	687b      	ldr	r3, [r7, #4]
 800a378:	681b      	ldr	r3, [r3, #0]
 800a37a:	f003 0308 	and.w	r3, r3, #8
 800a37e:	2b00      	cmp	r3, #0
 800a380:	d010      	beq.n	800a3a4 <HAL_RCC_ClockConfig+0x2a4>
    {
      assert_param(IS_RCC_PCLK1(RCC_ClkInitStruct->APB1CLKDivider));
      MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE1, (RCC_ClkInitStruct->APB1CLKDivider));
    }
#else
    if ((RCC_ClkInitStruct->APB1CLKDivider) < (RCC->CDCFGR2 & RCC_CDCFGR2_CDPPRE1))
 800a382:	687b      	ldr	r3, [r7, #4]
 800a384:	695a      	ldr	r2, [r3, #20]
 800a386:	4b34      	ldr	r3, [pc, #208]	@ (800a458 <HAL_RCC_ClockConfig+0x358>)
 800a388:	69db      	ldr	r3, [r3, #28]
 800a38a:	f003 0370 	and.w	r3, r3, #112	@ 0x70
 800a38e:	429a      	cmp	r2, r3
 800a390:	d208      	bcs.n	800a3a4 <HAL_RCC_ClockConfig+0x2a4>
    {
      assert_param(IS_RCC_PCLK1(RCC_ClkInitStruct->APB1CLKDivider));
      MODIFY_REG(RCC->CDCFGR2, RCC_CDCFGR2_CDPPRE1, (RCC_ClkInitStruct->APB1CLKDivider));
 800a392:	4b31      	ldr	r3, [pc, #196]	@ (800a458 <HAL_RCC_ClockConfig+0x358>)
 800a394:	69db      	ldr	r3, [r3, #28]
 800a396:	f023 0270 	bic.w	r2, r3, #112	@ 0x70
 800a39a:	687b      	ldr	r3, [r7, #4]
 800a39c:	695b      	ldr	r3, [r3, #20]
 800a39e:	492e      	ldr	r1, [pc, #184]	@ (800a458 <HAL_RCC_ClockConfig+0x358>)
 800a3a0:	4313      	orrs	r3, r2
 800a3a2:	61cb      	str	r3, [r1, #28]
    }
#endif
  }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 800a3a4:	687b      	ldr	r3, [r7, #4]
 800a3a6:	681b      	ldr	r3, [r3, #0]
 800a3a8:	f003 0310 	and.w	r3, r3, #16
 800a3ac:	2b00      	cmp	r3, #0
 800a3ae:	d010      	beq.n	800a3d2 <HAL_RCC_ClockConfig+0x2d2>
    {
      assert_param(IS_RCC_PCLK2(RCC_ClkInitStruct->APB2CLKDivider));
      MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE2, (RCC_ClkInitStruct->APB2CLKDivider));
    }
#else
    if ((RCC_ClkInitStruct->APB2CLKDivider) < (RCC->CDCFGR2 & RCC_CDCFGR2_CDPPRE2))
 800a3b0:	687b      	ldr	r3, [r7, #4]
 800a3b2:	699a      	ldr	r2, [r3, #24]
 800a3b4:	4b28      	ldr	r3, [pc, #160]	@ (800a458 <HAL_RCC_ClockConfig+0x358>)
 800a3b6:	69db      	ldr	r3, [r3, #28]
 800a3b8:	f403 63e0 	and.w	r3, r3, #1792	@ 0x700
 800a3bc:	429a      	cmp	r2, r3
 800a3be:	d208      	bcs.n	800a3d2 <HAL_RCC_ClockConfig+0x2d2>
    {
      assert_param(IS_RCC_PCLK2(RCC_ClkInitStruct->APB2CLKDivider));
      MODIFY_REG(RCC->CDCFGR2, RCC_CDCFGR2_CDPPRE2, (RCC_ClkInitStruct->APB2CLKDivider));
 800a3c0:	4b25      	ldr	r3, [pc, #148]	@ (800a458 <HAL_RCC_ClockConfig+0x358>)
 800a3c2:	69db      	ldr	r3, [r3, #28]
 800a3c4:	f423 62e0 	bic.w	r2, r3, #1792	@ 0x700
 800a3c8:	687b      	ldr	r3, [r7, #4]
 800a3ca:	699b      	ldr	r3, [r3, #24]
 800a3cc:	4922      	ldr	r1, [pc, #136]	@ (800a458 <HAL_RCC_ClockConfig+0x358>)
 800a3ce:	4313      	orrs	r3, r2
 800a3d0:	61cb      	str	r3, [r1, #28]
    }
#endif
  }

  /*-------------------------- D3PCLK1/SRDPCLK1 Configuration ---------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D3PCLK1) == RCC_CLOCKTYPE_D3PCLK1)
 800a3d2:	687b      	ldr	r3, [r7, #4]
 800a3d4:	681b      	ldr	r3, [r3, #0]
 800a3d6:	f003 0320 	and.w	r3, r3, #32
 800a3da:	2b00      	cmp	r3, #0
 800a3dc:	d010      	beq.n	800a400 <HAL_RCC_ClockConfig+0x300>
    {
      assert_param(IS_RCC_D3PCLK1(RCC_ClkInitStruct->APB4CLKDivider));
      MODIFY_REG(RCC->D3CFGR, RCC_D3CFGR_D3PPRE, (RCC_ClkInitStruct->APB4CLKDivider));
    }
#else
    if ((RCC_ClkInitStruct->APB4CLKDivider) < (RCC->SRDCFGR & RCC_SRDCFGR_SRDPPRE))
 800a3de:	687b      	ldr	r3, [r7, #4]
 800a3e0:	69da      	ldr	r2, [r3, #28]
 800a3e2:	4b1d      	ldr	r3, [pc, #116]	@ (800a458 <HAL_RCC_ClockConfig+0x358>)
 800a3e4:	6a1b      	ldr	r3, [r3, #32]
 800a3e6:	f003 0370 	and.w	r3, r3, #112	@ 0x70
 800a3ea:	429a      	cmp	r2, r3
 800a3ec:	d208      	bcs.n	800a400 <HAL_RCC_ClockConfig+0x300>
    {
      assert_param(IS_RCC_SRDPCLK1(RCC_ClkInitStruct->APB4CLKDivider));
      MODIFY_REG(RCC->SRDCFGR, RCC_SRDCFGR_SRDPPRE, (RCC_ClkInitStruct->APB4CLKDivider));
 800a3ee:	4b1a      	ldr	r3, [pc, #104]	@ (800a458 <HAL_RCC_ClockConfig+0x358>)
 800a3f0:	6a1b      	ldr	r3, [r3, #32]
 800a3f2:	f023 0270 	bic.w	r2, r3, #112	@ 0x70
 800a3f6:	687b      	ldr	r3, [r7, #4]
 800a3f8:	69db      	ldr	r3, [r3, #28]
 800a3fa:	4917      	ldr	r1, [pc, #92]	@ (800a458 <HAL_RCC_ClockConfig+0x358>)
 800a3fc:	4313      	orrs	r3, r2
 800a3fe:	620b      	str	r3, [r1, #32]

  /* Update the SystemCoreClock global variable */
#if defined(RCC_D1CFGR_D1CPRE)
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE) >> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
#else
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_CDCPRE) >> RCC_CDCFGR1_CDCPRE_Pos]) & 0x1FU);
 800a400:	f000 f834 	bl	800a46c <HAL_RCC_GetSysClockFreq>
 800a404:	4602      	mov	r2, r0
 800a406:	4b14      	ldr	r3, [pc, #80]	@ (800a458 <HAL_RCC_ClockConfig+0x358>)
 800a408:	699b      	ldr	r3, [r3, #24]
 800a40a:	0a1b      	lsrs	r3, r3, #8
 800a40c:	f003 030f 	and.w	r3, r3, #15
 800a410:	4912      	ldr	r1, [pc, #72]	@ (800a45c <HAL_RCC_ClockConfig+0x35c>)
 800a412:	5ccb      	ldrb	r3, [r1, r3]
 800a414:	f003 031f 	and.w	r3, r3, #31
 800a418:	fa22 f303 	lsr.w	r3, r2, r3
 800a41c:	613b      	str	r3, [r7, #16]
#endif

#if defined(RCC_D1CFGR_HPRE)
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE) >> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
#else
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_HPRE) >> RCC_CDCFGR1_HPRE_Pos]) & 0x1FU));
 800a41e:	4b0e      	ldr	r3, [pc, #56]	@ (800a458 <HAL_RCC_ClockConfig+0x358>)
 800a420:	699b      	ldr	r3, [r3, #24]
 800a422:	f003 030f 	and.w	r3, r3, #15
 800a426:	4a0d      	ldr	r2, [pc, #52]	@ (800a45c <HAL_RCC_ClockConfig+0x35c>)
 800a428:	5cd3      	ldrb	r3, [r2, r3]
 800a42a:	f003 031f 	and.w	r3, r3, #31
 800a42e:	693a      	ldr	r2, [r7, #16]
 800a430:	fa22 f303 	lsr.w	r3, r2, r3
 800a434:	4a0a      	ldr	r2, [pc, #40]	@ (800a460 <HAL_RCC_ClockConfig+0x360>)
 800a436:	6013      	str	r3, [r2, #0]
#endif

#if defined(DUAL_CORE) && defined(CORE_CM4)
  SystemCoreClock = SystemD2Clock;
#else
  SystemCoreClock = common_system_clock;
 800a438:	4a0a      	ldr	r2, [pc, #40]	@ (800a464 <HAL_RCC_ClockConfig+0x364>)
 800a43a:	693b      	ldr	r3, [r7, #16]
 800a43c:	6013      	str	r3, [r2, #0]
#endif /* DUAL_CORE && CORE_CM4 */

  /* Configure the source of time base considering new system clocks settings*/
  halstatus = HAL_InitTick(uwTickPrio);
 800a43e:	4b0a      	ldr	r3, [pc, #40]	@ (800a468 <HAL_RCC_ClockConfig+0x368>)
 800a440:	681b      	ldr	r3, [r3, #0]
 800a442:	4618      	mov	r0, r3
 800a444:	f7f8 fa42 	bl	80028cc <HAL_InitTick>
 800a448:	4603      	mov	r3, r0
 800a44a:	73fb      	strb	r3, [r7, #15]

  return halstatus;
 800a44c:	7bfb      	ldrb	r3, [r7, #15]
}
 800a44e:	4618      	mov	r0, r3
 800a450:	3718      	adds	r7, #24
 800a452:	46bd      	mov	sp, r7
 800a454:	bd80      	pop	{r7, pc}
 800a456:	bf00      	nop
 800a458:	58024400 	.word	0x58024400
 800a45c:	080131a4 	.word	0x080131a4
 800a460:	24000120 	.word	0x24000120
 800a464:	2400011c 	.word	0x2400011c
 800a468:	24000124 	.word	0x24000124

0800a46c <HAL_RCC_GetSysClockFreq>:
  *
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
 800a46c:	b480      	push	{r7}
 800a46e:	b089      	sub	sp, #36	@ 0x24
 800a470:	af00      	add	r7, sp, #0
  float_t fracn1, pllvco;
  uint32_t sysclockfreq;

  /* Get SYSCLK source -------------------------------------------------------*/

  switch (RCC->CFGR & RCC_CFGR_SWS)
 800a472:	4bb3      	ldr	r3, [pc, #716]	@ (800a740 <HAL_RCC_GetSysClockFreq+0x2d4>)
 800a474:	691b      	ldr	r3, [r3, #16]
 800a476:	f003 0338 	and.w	r3, r3, #56	@ 0x38
 800a47a:	2b18      	cmp	r3, #24
 800a47c:	f200 8155 	bhi.w	800a72a <HAL_RCC_GetSysClockFreq+0x2be>
 800a480:	a201      	add	r2, pc, #4	@ (adr r2, 800a488 <HAL_RCC_GetSysClockFreq+0x1c>)
 800a482:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800a486:	bf00      	nop
 800a488:	0800a4ed 	.word	0x0800a4ed
 800a48c:	0800a72b 	.word	0x0800a72b
 800a490:	0800a72b 	.word	0x0800a72b
 800a494:	0800a72b 	.word	0x0800a72b
 800a498:	0800a72b 	.word	0x0800a72b
 800a49c:	0800a72b 	.word	0x0800a72b
 800a4a0:	0800a72b 	.word	0x0800a72b
 800a4a4:	0800a72b 	.word	0x0800a72b
 800a4a8:	0800a513 	.word	0x0800a513
 800a4ac:	0800a72b 	.word	0x0800a72b
 800a4b0:	0800a72b 	.word	0x0800a72b
 800a4b4:	0800a72b 	.word	0x0800a72b
 800a4b8:	0800a72b 	.word	0x0800a72b
 800a4bc:	0800a72b 	.word	0x0800a72b
 800a4c0:	0800a72b 	.word	0x0800a72b
 800a4c4:	0800a72b 	.word	0x0800a72b
 800a4c8:	0800a519 	.word	0x0800a519
 800a4cc:	0800a72b 	.word	0x0800a72b
 800a4d0:	0800a72b 	.word	0x0800a72b
 800a4d4:	0800a72b 	.word	0x0800a72b
 800a4d8:	0800a72b 	.word	0x0800a72b
 800a4dc:	0800a72b 	.word	0x0800a72b
 800a4e0:	0800a72b 	.word	0x0800a72b
 800a4e4:	0800a72b 	.word	0x0800a72b
 800a4e8:	0800a51f 	.word	0x0800a51f
  {
    case RCC_CFGR_SWS_HSI:  /* HSI used as system clock source */

      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 800a4ec:	4b94      	ldr	r3, [pc, #592]	@ (800a740 <HAL_RCC_GetSysClockFreq+0x2d4>)
 800a4ee:	681b      	ldr	r3, [r3, #0]
 800a4f0:	f003 0320 	and.w	r3, r3, #32
 800a4f4:	2b00      	cmp	r3, #0
 800a4f6:	d009      	beq.n	800a50c <HAL_RCC_GetSysClockFreq+0xa0>
      {
        sysclockfreq = (uint32_t)(HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
 800a4f8:	4b91      	ldr	r3, [pc, #580]	@ (800a740 <HAL_RCC_GetSysClockFreq+0x2d4>)
 800a4fa:	681b      	ldr	r3, [r3, #0]
 800a4fc:	08db      	lsrs	r3, r3, #3
 800a4fe:	f003 0303 	and.w	r3, r3, #3
 800a502:	4a90      	ldr	r2, [pc, #576]	@ (800a744 <HAL_RCC_GetSysClockFreq+0x2d8>)
 800a504:	fa22 f303 	lsr.w	r3, r2, r3
 800a508:	61bb      	str	r3, [r7, #24]
      else
      {
        sysclockfreq = (uint32_t) HSI_VALUE;
      }

      break;
 800a50a:	e111      	b.n	800a730 <HAL_RCC_GetSysClockFreq+0x2c4>
        sysclockfreq = (uint32_t) HSI_VALUE;
 800a50c:	4b8d      	ldr	r3, [pc, #564]	@ (800a744 <HAL_RCC_GetSysClockFreq+0x2d8>)
 800a50e:	61bb      	str	r3, [r7, #24]
      break;
 800a510:	e10e      	b.n	800a730 <HAL_RCC_GetSysClockFreq+0x2c4>

    case RCC_CFGR_SWS_CSI:  /* CSI used as system clock  source */
      sysclockfreq = CSI_VALUE;
 800a512:	4b8d      	ldr	r3, [pc, #564]	@ (800a748 <HAL_RCC_GetSysClockFreq+0x2dc>)
 800a514:	61bb      	str	r3, [r7, #24]
      break;
 800a516:	e10b      	b.n	800a730 <HAL_RCC_GetSysClockFreq+0x2c4>

    case RCC_CFGR_SWS_HSE:  /* HSE used as system clock  source */
      sysclockfreq = HSE_VALUE;
 800a518:	4b8c      	ldr	r3, [pc, #560]	@ (800a74c <HAL_RCC_GetSysClockFreq+0x2e0>)
 800a51a:	61bb      	str	r3, [r7, #24]
      break;
 800a51c:	e108      	b.n	800a730 <HAL_RCC_GetSysClockFreq+0x2c4>
    case RCC_CFGR_SWS_PLL1:  /* PLL1 used as system clock  source */

      /* PLL_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLR
      */
      pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 800a51e:	4b88      	ldr	r3, [pc, #544]	@ (800a740 <HAL_RCC_GetSysClockFreq+0x2d4>)
 800a520:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800a522:	f003 0303 	and.w	r3, r3, #3
 800a526:	617b      	str	r3, [r7, #20]
      pllm = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1) >> 4)  ;
 800a528:	4b85      	ldr	r3, [pc, #532]	@ (800a740 <HAL_RCC_GetSysClockFreq+0x2d4>)
 800a52a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800a52c:	091b      	lsrs	r3, r3, #4
 800a52e:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 800a532:	613b      	str	r3, [r7, #16]
      pllfracen = ((RCC-> PLLCFGR & RCC_PLLCFGR_PLL1FRACEN) >> RCC_PLLCFGR_PLL1FRACEN_Pos);
 800a534:	4b82      	ldr	r3, [pc, #520]	@ (800a740 <HAL_RCC_GetSysClockFreq+0x2d4>)
 800a536:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800a538:	f003 0301 	and.w	r3, r3, #1
 800a53c:	60fb      	str	r3, [r7, #12]
      fracn1 = (float_t)(uint32_t)(pllfracen * ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1) >> 3));
 800a53e:	4b80      	ldr	r3, [pc, #512]	@ (800a740 <HAL_RCC_GetSysClockFreq+0x2d4>)
 800a540:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 800a542:	08db      	lsrs	r3, r3, #3
 800a544:	f3c3 030c 	ubfx	r3, r3, #0, #13
 800a548:	68fa      	ldr	r2, [r7, #12]
 800a54a:	fb02 f303 	mul.w	r3, r2, r3
 800a54e:	ee07 3a90 	vmov	s15, r3
 800a552:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800a556:	edc7 7a02 	vstr	s15, [r7, #8]

      if (pllm != 0U)
 800a55a:	693b      	ldr	r3, [r7, #16]
 800a55c:	2b00      	cmp	r3, #0
 800a55e:	f000 80e1 	beq.w	800a724 <HAL_RCC_GetSysClockFreq+0x2b8>
 800a562:	697b      	ldr	r3, [r7, #20]
 800a564:	2b02      	cmp	r3, #2
 800a566:	f000 8083 	beq.w	800a670 <HAL_RCC_GetSysClockFreq+0x204>
 800a56a:	697b      	ldr	r3, [r7, #20]
 800a56c:	2b02      	cmp	r3, #2
 800a56e:	f200 80a1 	bhi.w	800a6b4 <HAL_RCC_GetSysClockFreq+0x248>
 800a572:	697b      	ldr	r3, [r7, #20]
 800a574:	2b00      	cmp	r3, #0
 800a576:	d003      	beq.n	800a580 <HAL_RCC_GetSysClockFreq+0x114>
 800a578:	697b      	ldr	r3, [r7, #20]
 800a57a:	2b01      	cmp	r3, #1
 800a57c:	d056      	beq.n	800a62c <HAL_RCC_GetSysClockFreq+0x1c0>
 800a57e:	e099      	b.n	800a6b4 <HAL_RCC_GetSysClockFreq+0x248>
      {
        switch (pllsource)
        {
          case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */

            if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 800a580:	4b6f      	ldr	r3, [pc, #444]	@ (800a740 <HAL_RCC_GetSysClockFreq+0x2d4>)
 800a582:	681b      	ldr	r3, [r3, #0]
 800a584:	f003 0320 	and.w	r3, r3, #32
 800a588:	2b00      	cmp	r3, #0
 800a58a:	d02d      	beq.n	800a5e8 <HAL_RCC_GetSysClockFreq+0x17c>
            {
              hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
 800a58c:	4b6c      	ldr	r3, [pc, #432]	@ (800a740 <HAL_RCC_GetSysClockFreq+0x2d4>)
 800a58e:	681b      	ldr	r3, [r3, #0]
 800a590:	08db      	lsrs	r3, r3, #3
 800a592:	f003 0303 	and.w	r3, r3, #3
 800a596:	4a6b      	ldr	r2, [pc, #428]	@ (800a744 <HAL_RCC_GetSysClockFreq+0x2d8>)
 800a598:	fa22 f303 	lsr.w	r3, r2, r3
 800a59c:	607b      	str	r3, [r7, #4]
              pllvco = ((float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
 800a59e:	687b      	ldr	r3, [r7, #4]
 800a5a0:	ee07 3a90 	vmov	s15, r3
 800a5a4:	eef8 6a67 	vcvt.f32.u32	s13, s15
 800a5a8:	693b      	ldr	r3, [r7, #16]
 800a5aa:	ee07 3a90 	vmov	s15, r3
 800a5ae:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800a5b2:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 800a5b6:	4b62      	ldr	r3, [pc, #392]	@ (800a740 <HAL_RCC_GetSysClockFreq+0x2d4>)
 800a5b8:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800a5ba:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800a5be:	ee07 3a90 	vmov	s15, r3
 800a5c2:	eef8 6a67 	vcvt.f32.u32	s13, s15
 800a5c6:	ed97 6a02 	vldr	s12, [r7, #8]
 800a5ca:	eddf 5a61 	vldr	s11, [pc, #388]	@ 800a750 <HAL_RCC_GetSysClockFreq+0x2e4>
 800a5ce:	eec6 7a25 	vdiv.f32	s15, s12, s11
 800a5d2:	ee76 7aa7 	vadd.f32	s15, s13, s15
 800a5d6:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 800a5da:	ee77 7aa6 	vadd.f32	s15, s15, s13
 800a5de:	ee67 7a27 	vmul.f32	s15, s14, s15
 800a5e2:	edc7 7a07 	vstr	s15, [r7, #28]
            }
            else
            {
              pllvco = ((float_t)HSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
            }
            break;
 800a5e6:	e087      	b.n	800a6f8 <HAL_RCC_GetSysClockFreq+0x28c>
              pllvco = ((float_t)HSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
 800a5e8:	693b      	ldr	r3, [r7, #16]
 800a5ea:	ee07 3a90 	vmov	s15, r3
 800a5ee:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800a5f2:	eddf 6a58 	vldr	s13, [pc, #352]	@ 800a754 <HAL_RCC_GetSysClockFreq+0x2e8>
 800a5f6:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 800a5fa:	4b51      	ldr	r3, [pc, #324]	@ (800a740 <HAL_RCC_GetSysClockFreq+0x2d4>)
 800a5fc:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800a5fe:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800a602:	ee07 3a90 	vmov	s15, r3
 800a606:	eef8 6a67 	vcvt.f32.u32	s13, s15
 800a60a:	ed97 6a02 	vldr	s12, [r7, #8]
 800a60e:	eddf 5a50 	vldr	s11, [pc, #320]	@ 800a750 <HAL_RCC_GetSysClockFreq+0x2e4>
 800a612:	eec6 7a25 	vdiv.f32	s15, s12, s11
 800a616:	ee76 7aa7 	vadd.f32	s15, s13, s15
 800a61a:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 800a61e:	ee77 7aa6 	vadd.f32	s15, s15, s13
 800a622:	ee67 7a27 	vmul.f32	s15, s14, s15
 800a626:	edc7 7a07 	vstr	s15, [r7, #28]
            break;
 800a62a:	e065      	b.n	800a6f8 <HAL_RCC_GetSysClockFreq+0x28c>

          case RCC_PLLSOURCE_CSI:  /* CSI used as PLL clock source */
            pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
 800a62c:	693b      	ldr	r3, [r7, #16]
 800a62e:	ee07 3a90 	vmov	s15, r3
 800a632:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800a636:	eddf 6a48 	vldr	s13, [pc, #288]	@ 800a758 <HAL_RCC_GetSysClockFreq+0x2ec>
 800a63a:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 800a63e:	4b40      	ldr	r3, [pc, #256]	@ (800a740 <HAL_RCC_GetSysClockFreq+0x2d4>)
 800a640:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800a642:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800a646:	ee07 3a90 	vmov	s15, r3
 800a64a:	eef8 6a67 	vcvt.f32.u32	s13, s15
 800a64e:	ed97 6a02 	vldr	s12, [r7, #8]
 800a652:	eddf 5a3f 	vldr	s11, [pc, #252]	@ 800a750 <HAL_RCC_GetSysClockFreq+0x2e4>
 800a656:	eec6 7a25 	vdiv.f32	s15, s12, s11
 800a65a:	ee76 7aa7 	vadd.f32	s15, s13, s15
 800a65e:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 800a662:	ee77 7aa6 	vadd.f32	s15, s15, s13
 800a666:	ee67 7a27 	vmul.f32	s15, s14, s15
 800a66a:	edc7 7a07 	vstr	s15, [r7, #28]
            break;
 800a66e:	e043      	b.n	800a6f8 <HAL_RCC_GetSysClockFreq+0x28c>

          case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
            pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
 800a670:	693b      	ldr	r3, [r7, #16]
 800a672:	ee07 3a90 	vmov	s15, r3
 800a676:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800a67a:	eddf 6a38 	vldr	s13, [pc, #224]	@ 800a75c <HAL_RCC_GetSysClockFreq+0x2f0>
 800a67e:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 800a682:	4b2f      	ldr	r3, [pc, #188]	@ (800a740 <HAL_RCC_GetSysClockFreq+0x2d4>)
 800a684:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800a686:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800a68a:	ee07 3a90 	vmov	s15, r3
 800a68e:	eef8 6a67 	vcvt.f32.u32	s13, s15
 800a692:	ed97 6a02 	vldr	s12, [r7, #8]
 800a696:	eddf 5a2e 	vldr	s11, [pc, #184]	@ 800a750 <HAL_RCC_GetSysClockFreq+0x2e4>
 800a69a:	eec6 7a25 	vdiv.f32	s15, s12, s11
 800a69e:	ee76 7aa7 	vadd.f32	s15, s13, s15
 800a6a2:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 800a6a6:	ee77 7aa6 	vadd.f32	s15, s15, s13
 800a6aa:	ee67 7a27 	vmul.f32	s15, s14, s15
 800a6ae:	edc7 7a07 	vstr	s15, [r7, #28]
            break;
 800a6b2:	e021      	b.n	800a6f8 <HAL_RCC_GetSysClockFreq+0x28c>

          default:
            pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
 800a6b4:	693b      	ldr	r3, [r7, #16]
 800a6b6:	ee07 3a90 	vmov	s15, r3
 800a6ba:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800a6be:	eddf 6a26 	vldr	s13, [pc, #152]	@ 800a758 <HAL_RCC_GetSysClockFreq+0x2ec>
 800a6c2:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 800a6c6:	4b1e      	ldr	r3, [pc, #120]	@ (800a740 <HAL_RCC_GetSysClockFreq+0x2d4>)
 800a6c8:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800a6ca:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800a6ce:	ee07 3a90 	vmov	s15, r3
 800a6d2:	eef8 6a67 	vcvt.f32.u32	s13, s15
 800a6d6:	ed97 6a02 	vldr	s12, [r7, #8]
 800a6da:	eddf 5a1d 	vldr	s11, [pc, #116]	@ 800a750 <HAL_RCC_GetSysClockFreq+0x2e4>
 800a6de:	eec6 7a25 	vdiv.f32	s15, s12, s11
 800a6e2:	ee76 7aa7 	vadd.f32	s15, s13, s15
 800a6e6:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 800a6ea:	ee77 7aa6 	vadd.f32	s15, s15, s13
 800a6ee:	ee67 7a27 	vmul.f32	s15, s14, s15
 800a6f2:	edc7 7a07 	vstr	s15, [r7, #28]
            break;
 800a6f6:	bf00      	nop
        }
        pllp = (((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >> 9) + 1U) ;
 800a6f8:	4b11      	ldr	r3, [pc, #68]	@ (800a740 <HAL_RCC_GetSysClockFreq+0x2d4>)
 800a6fa:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800a6fc:	0a5b      	lsrs	r3, r3, #9
 800a6fe:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 800a702:	3301      	adds	r3, #1
 800a704:	603b      	str	r3, [r7, #0]
        sysclockfreq = (uint32_t)(float_t)(pllvco / (float_t)pllp);
 800a706:	683b      	ldr	r3, [r7, #0]
 800a708:	ee07 3a90 	vmov	s15, r3
 800a70c:	eeb8 7a67 	vcvt.f32.u32	s14, s15
 800a710:	edd7 6a07 	vldr	s13, [r7, #28]
 800a714:	eec6 7a87 	vdiv.f32	s15, s13, s14
 800a718:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 800a71c:	ee17 3a90 	vmov	r3, s15
 800a720:	61bb      	str	r3, [r7, #24]
      }
      else
      {
        sysclockfreq = 0U;
      }
      break;
 800a722:	e005      	b.n	800a730 <HAL_RCC_GetSysClockFreq+0x2c4>
        sysclockfreq = 0U;
 800a724:	2300      	movs	r3, #0
 800a726:	61bb      	str	r3, [r7, #24]
      break;
 800a728:	e002      	b.n	800a730 <HAL_RCC_GetSysClockFreq+0x2c4>

    default:
      sysclockfreq = CSI_VALUE;
 800a72a:	4b07      	ldr	r3, [pc, #28]	@ (800a748 <HAL_RCC_GetSysClockFreq+0x2dc>)
 800a72c:	61bb      	str	r3, [r7, #24]
      break;
 800a72e:	bf00      	nop
  }

  return sysclockfreq;
 800a730:	69bb      	ldr	r3, [r7, #24]
}
 800a732:	4618      	mov	r0, r3
 800a734:	3724      	adds	r7, #36	@ 0x24
 800a736:	46bd      	mov	sp, r7
 800a738:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a73c:	4770      	bx	lr
 800a73e:	bf00      	nop
 800a740:	58024400 	.word	0x58024400
 800a744:	03d09000 	.word	0x03d09000
 800a748:	003d0900 	.word	0x003d0900
 800a74c:	016e3600 	.word	0x016e3600
 800a750:	46000000 	.word	0x46000000
 800a754:	4c742400 	.word	0x4c742400
 800a758:	4a742400 	.word	0x4a742400
 800a75c:	4bb71b00 	.word	0x4bb71b00

0800a760 <HAL_RCC_GetHCLKFreq>:
  * @note   The SystemD2Clock CMSIS variable is used to store System domain2 Clock Frequency
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
 800a760:	b580      	push	{r7, lr}
 800a762:	b082      	sub	sp, #8
 800a764:	af00      	add	r7, sp, #0
  uint32_t common_system_clock;

#if defined(RCC_D1CFGR_D1CPRE)
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE) >> RCC_D1CFGR_D1CPRE_Pos] & 0x1FU);
#else
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_CDCPRE) >> RCC_CDCFGR1_CDCPRE_Pos] & 0x1FU);
 800a766:	f7ff fe81 	bl	800a46c <HAL_RCC_GetSysClockFreq>
 800a76a:	4602      	mov	r2, r0
 800a76c:	4b10      	ldr	r3, [pc, #64]	@ (800a7b0 <HAL_RCC_GetHCLKFreq+0x50>)
 800a76e:	699b      	ldr	r3, [r3, #24]
 800a770:	0a1b      	lsrs	r3, r3, #8
 800a772:	f003 030f 	and.w	r3, r3, #15
 800a776:	490f      	ldr	r1, [pc, #60]	@ (800a7b4 <HAL_RCC_GetHCLKFreq+0x54>)
 800a778:	5ccb      	ldrb	r3, [r1, r3]
 800a77a:	f003 031f 	and.w	r3, r3, #31
 800a77e:	fa22 f303 	lsr.w	r3, r2, r3
 800a782:	607b      	str	r3, [r7, #4]
#endif

#if defined(RCC_D1CFGR_HPRE)
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE) >> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
#else
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_HPRE) >> RCC_CDCFGR1_HPRE_Pos]) & 0x1FU));
 800a784:	4b0a      	ldr	r3, [pc, #40]	@ (800a7b0 <HAL_RCC_GetHCLKFreq+0x50>)
 800a786:	699b      	ldr	r3, [r3, #24]
 800a788:	f003 030f 	and.w	r3, r3, #15
 800a78c:	4a09      	ldr	r2, [pc, #36]	@ (800a7b4 <HAL_RCC_GetHCLKFreq+0x54>)
 800a78e:	5cd3      	ldrb	r3, [r2, r3]
 800a790:	f003 031f 	and.w	r3, r3, #31
 800a794:	687a      	ldr	r2, [r7, #4]
 800a796:	fa22 f303 	lsr.w	r3, r2, r3
 800a79a:	4a07      	ldr	r2, [pc, #28]	@ (800a7b8 <HAL_RCC_GetHCLKFreq+0x58>)
 800a79c:	6013      	str	r3, [r2, #0]
#endif

#if defined(DUAL_CORE) && defined(CORE_CM4)
  SystemCoreClock = SystemD2Clock;
#else
  SystemCoreClock = common_system_clock;
 800a79e:	4a07      	ldr	r2, [pc, #28]	@ (800a7bc <HAL_RCC_GetHCLKFreq+0x5c>)
 800a7a0:	687b      	ldr	r3, [r7, #4]
 800a7a2:	6013      	str	r3, [r2, #0]
#endif /* DUAL_CORE && CORE_CM4 */

  return SystemD2Clock;
 800a7a4:	4b04      	ldr	r3, [pc, #16]	@ (800a7b8 <HAL_RCC_GetHCLKFreq+0x58>)
 800a7a6:	681b      	ldr	r3, [r3, #0]
}
 800a7a8:	4618      	mov	r0, r3
 800a7aa:	3708      	adds	r7, #8
 800a7ac:	46bd      	mov	sp, r7
 800a7ae:	bd80      	pop	{r7, pc}
 800a7b0:	58024400 	.word	0x58024400
 800a7b4:	080131a4 	.word	0x080131a4
 800a7b8:	24000120 	.word	0x24000120
 800a7bc:	2400011c 	.word	0x2400011c

0800a7c0 <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
 800a7c0:	b580      	push	{r7, lr}
 800a7c2:	af00      	add	r7, sp, #0
#if defined (RCC_D2CFGR_D2PPRE1)
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> ((D1CorePrescTable[(RCC->D2CFGR & RCC_D2CFGR_D2PPRE1) >> RCC_D2CFGR_D2PPRE1_Pos]) & 0x1FU));
#else
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> ((D1CorePrescTable[(RCC->CDCFGR2 & RCC_CDCFGR2_CDPPRE1) >> RCC_CDCFGR2_CDPPRE1_Pos]) & 0x1FU));
 800a7c4:	f7ff ffcc 	bl	800a760 <HAL_RCC_GetHCLKFreq>
 800a7c8:	4602      	mov	r2, r0
 800a7ca:	4b06      	ldr	r3, [pc, #24]	@ (800a7e4 <HAL_RCC_GetPCLK1Freq+0x24>)
 800a7cc:	69db      	ldr	r3, [r3, #28]
 800a7ce:	091b      	lsrs	r3, r3, #4
 800a7d0:	f003 0307 	and.w	r3, r3, #7
 800a7d4:	4904      	ldr	r1, [pc, #16]	@ (800a7e8 <HAL_RCC_GetPCLK1Freq+0x28>)
 800a7d6:	5ccb      	ldrb	r3, [r1, r3]
 800a7d8:	f003 031f 	and.w	r3, r3, #31
 800a7dc:	fa22 f303 	lsr.w	r3, r2, r3
#endif
}
 800a7e0:	4618      	mov	r0, r3
 800a7e2:	bd80      	pop	{r7, pc}
 800a7e4:	58024400 	.word	0x58024400
 800a7e8:	080131a4 	.word	0x080131a4

0800a7ec <HAL_RCCEx_PeriphCLKConfig>:
  * (*) : Available on some STM32H7 lines only.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 800a7ec:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 800a7f0:	b0c8      	sub	sp, #288	@ 0x120
 800a7f2:	af00      	add	r7, sp, #0
 800a7f4:	f8c7 010c 	str.w	r0, [r7, #268]	@ 0x10c
  uint32_t tmpreg;
  uint32_t tickstart;
  HAL_StatusTypeDef ret = HAL_OK;      /* Intermediate status */
 800a7f8:	2300      	movs	r3, #0
 800a7fa:	f887 311f 	strb.w	r3, [r7, #287]	@ 0x11f
  HAL_StatusTypeDef status = HAL_OK;   /* Final status */
 800a7fe:	2300      	movs	r3, #0
 800a800:	f887 311e 	strb.w	r3, [r7, #286]	@ 0x11e

  /*---------------------------- SPDIFRX configuration -------------------------------*/

  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX)
 800a804:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800a808:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a80c:	f002 6400 	and.w	r4, r2, #134217728	@ 0x8000000
 800a810:	2500      	movs	r5, #0
 800a812:	ea54 0305 	orrs.w	r3, r4, r5
 800a816:	d049      	beq.n	800a8ac <HAL_RCCEx_PeriphCLKConfig+0xc0>
  {

    switch (PeriphClkInit->SpdifrxClockSelection)
 800a818:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800a81c:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 800a81e:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
 800a822:	d02f      	beq.n	800a884 <HAL_RCCEx_PeriphCLKConfig+0x98>
 800a824:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
 800a828:	d828      	bhi.n	800a87c <HAL_RCCEx_PeriphCLKConfig+0x90>
 800a82a:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
 800a82e:	d01a      	beq.n	800a866 <HAL_RCCEx_PeriphCLKConfig+0x7a>
 800a830:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
 800a834:	d822      	bhi.n	800a87c <HAL_RCCEx_PeriphCLKConfig+0x90>
 800a836:	2b00      	cmp	r3, #0
 800a838:	d003      	beq.n	800a842 <HAL_RCCEx_PeriphCLKConfig+0x56>
 800a83a:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
 800a83e:	d007      	beq.n	800a850 <HAL_RCCEx_PeriphCLKConfig+0x64>
 800a840:	e01c      	b.n	800a87c <HAL_RCCEx_PeriphCLKConfig+0x90>
    {
      case RCC_SPDIFRXCLKSOURCE_PLL:      /* PLL is used as clock source for SPDIFRX*/
        /* Enable PLL1Q Clock output generated form System PLL . */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 800a842:	4ba7      	ldr	r3, [pc, #668]	@ (800aae0 <HAL_RCCEx_PeriphCLKConfig+0x2f4>)
 800a844:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800a846:	4aa6      	ldr	r2, [pc, #664]	@ (800aae0 <HAL_RCCEx_PeriphCLKConfig+0x2f4>)
 800a848:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 800a84c:	62d3      	str	r3, [r2, #44]	@ 0x2c

        /* SPDIFRX clock source configuration done later after clock selection check */
        break;
 800a84e:	e01a      	b.n	800a886 <HAL_RCCEx_PeriphCLKConfig+0x9a>

      case RCC_SPDIFRXCLKSOURCE_PLL2: /* PLL2 is used as clock source for SPDIFRX*/

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_R_UPDATE);
 800a850:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800a854:	3308      	adds	r3, #8
 800a856:	2102      	movs	r1, #2
 800a858:	4618      	mov	r0, r3
 800a85a:	f002 fa6d 	bl	800cd38 <RCCEx_PLL2_Config>
 800a85e:	4603      	mov	r3, r0
 800a860:	f887 311f 	strb.w	r3, [r7, #287]	@ 0x11f

        /* SPDIFRX clock source configuration done later after clock selection check */
        break;
 800a864:	e00f      	b.n	800a886 <HAL_RCCEx_PeriphCLKConfig+0x9a>

      case RCC_SPDIFRXCLKSOURCE_PLL3:  /* PLL3 is used as clock source for SPDIFRX*/
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_R_UPDATE);
 800a866:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800a86a:	3328      	adds	r3, #40	@ 0x28
 800a86c:	2102      	movs	r1, #2
 800a86e:	4618      	mov	r0, r3
 800a870:	f002 fb14 	bl	800ce9c <RCCEx_PLL3_Config>
 800a874:	4603      	mov	r3, r0
 800a876:	f887 311f 	strb.w	r3, [r7, #287]	@ 0x11f

        /* SPDIFRX clock source configuration done later after clock selection check */
        break;
 800a87a:	e004      	b.n	800a886 <HAL_RCCEx_PeriphCLKConfig+0x9a>
        /* Internal OSC clock is used as source of SPDIFRX clock*/
        /* SPDIFRX clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 800a87c:	2301      	movs	r3, #1
 800a87e:	f887 311f 	strb.w	r3, [r7, #287]	@ 0x11f
        break;
 800a882:	e000      	b.n	800a886 <HAL_RCCEx_PeriphCLKConfig+0x9a>
        break;
 800a884:	bf00      	nop
    }

    if (ret == HAL_OK)
 800a886:	f897 311f 	ldrb.w	r3, [r7, #287]	@ 0x11f
 800a88a:	2b00      	cmp	r3, #0
 800a88c:	d10a      	bne.n	800a8a4 <HAL_RCCEx_PeriphCLKConfig+0xb8>
    {
      /* Set the source of SPDIFRX clock*/
      __HAL_RCC_SPDIFRX_CONFIG(PeriphClkInit->SpdifrxClockSelection);
 800a88e:	4b94      	ldr	r3, [pc, #592]	@ (800aae0 <HAL_RCCEx_PeriphCLKConfig+0x2f4>)
 800a890:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800a892:	f423 1140 	bic.w	r1, r3, #3145728	@ 0x300000
 800a896:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800a89a:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 800a89c:	4a90      	ldr	r2, [pc, #576]	@ (800aae0 <HAL_RCCEx_PeriphCLKConfig+0x2f4>)
 800a89e:	430b      	orrs	r3, r1
 800a8a0:	6513      	str	r3, [r2, #80]	@ 0x50
 800a8a2:	e003      	b.n	800a8ac <HAL_RCCEx_PeriphCLKConfig+0xc0>
    }
    else
    {
      /* set overall return value */
      status = ret;
 800a8a4:	f897 311f 	ldrb.w	r3, [r7, #287]	@ 0x11f
 800a8a8:	f887 311e 	strb.w	r3, [r7, #286]	@ 0x11e
    }
  }

  /*---------------------------- SAI1 configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1)
 800a8ac:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800a8b0:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a8b4:	f402 7880 	and.w	r8, r2, #256	@ 0x100
 800a8b8:	f04f 0900 	mov.w	r9, #0
 800a8bc:	ea58 0309 	orrs.w	r3, r8, r9
 800a8c0:	d047      	beq.n	800a952 <HAL_RCCEx_PeriphCLKConfig+0x166>
  {
    switch (PeriphClkInit->Sai1ClockSelection)
 800a8c2:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800a8c6:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 800a8c8:	2b04      	cmp	r3, #4
 800a8ca:	d82a      	bhi.n	800a922 <HAL_RCCEx_PeriphCLKConfig+0x136>
 800a8cc:	a201      	add	r2, pc, #4	@ (adr r2, 800a8d4 <HAL_RCCEx_PeriphCLKConfig+0xe8>)
 800a8ce:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800a8d2:	bf00      	nop
 800a8d4:	0800a8e9 	.word	0x0800a8e9
 800a8d8:	0800a8f7 	.word	0x0800a8f7
 800a8dc:	0800a90d 	.word	0x0800a90d
 800a8e0:	0800a92b 	.word	0x0800a92b
 800a8e4:	0800a92b 	.word	0x0800a92b
    {
      case RCC_SAI1CLKSOURCE_PLL:      /* PLL is used as clock source for SAI1*/
        /* Enable SAI Clock output generated form System PLL . */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 800a8e8:	4b7d      	ldr	r3, [pc, #500]	@ (800aae0 <HAL_RCCEx_PeriphCLKConfig+0x2f4>)
 800a8ea:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800a8ec:	4a7c      	ldr	r2, [pc, #496]	@ (800aae0 <HAL_RCCEx_PeriphCLKConfig+0x2f4>)
 800a8ee:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 800a8f2:	62d3      	str	r3, [r2, #44]	@ 0x2c

        /* SAI1 clock source configuration done later after clock selection check */
        break;
 800a8f4:	e01a      	b.n	800a92c <HAL_RCCEx_PeriphCLKConfig+0x140>

      case RCC_SAI1CLKSOURCE_PLL2: /* PLL2 is used as clock source for SAI1*/

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_P_UPDATE);
 800a8f6:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800a8fa:	3308      	adds	r3, #8
 800a8fc:	2100      	movs	r1, #0
 800a8fe:	4618      	mov	r0, r3
 800a900:	f002 fa1a 	bl	800cd38 <RCCEx_PLL2_Config>
 800a904:	4603      	mov	r3, r0
 800a906:	f887 311f 	strb.w	r3, [r7, #287]	@ 0x11f

        /* SAI1 clock source configuration done later after clock selection check */
        break;
 800a90a:	e00f      	b.n	800a92c <HAL_RCCEx_PeriphCLKConfig+0x140>

      case RCC_SAI1CLKSOURCE_PLL3:  /* PLL3 is used as clock source for SAI1*/
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_P_UPDATE);
 800a90c:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800a910:	3328      	adds	r3, #40	@ 0x28
 800a912:	2100      	movs	r1, #0
 800a914:	4618      	mov	r0, r3
 800a916:	f002 fac1 	bl	800ce9c <RCCEx_PLL3_Config>
 800a91a:	4603      	mov	r3, r0
 800a91c:	f887 311f 	strb.w	r3, [r7, #287]	@ 0x11f

        /* SAI1 clock source configuration done later after clock selection check */
        break;
 800a920:	e004      	b.n	800a92c <HAL_RCCEx_PeriphCLKConfig+0x140>
        /* HSI, HSE, or CSI oscillator is used as source of SAI1 clock */
        /* SAI1 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 800a922:	2301      	movs	r3, #1
 800a924:	f887 311f 	strb.w	r3, [r7, #287]	@ 0x11f
        break;
 800a928:	e000      	b.n	800a92c <HAL_RCCEx_PeriphCLKConfig+0x140>
        break;
 800a92a:	bf00      	nop
    }

    if (ret == HAL_OK)
 800a92c:	f897 311f 	ldrb.w	r3, [r7, #287]	@ 0x11f
 800a930:	2b00      	cmp	r3, #0
 800a932:	d10a      	bne.n	800a94a <HAL_RCCEx_PeriphCLKConfig+0x15e>
    {
      /* Set the source of SAI1 clock*/
      __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 800a934:	4b6a      	ldr	r3, [pc, #424]	@ (800aae0 <HAL_RCCEx_PeriphCLKConfig+0x2f4>)
 800a936:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800a938:	f023 0107 	bic.w	r1, r3, #7
 800a93c:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800a940:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 800a942:	4a67      	ldr	r2, [pc, #412]	@ (800aae0 <HAL_RCCEx_PeriphCLKConfig+0x2f4>)
 800a944:	430b      	orrs	r3, r1
 800a946:	6513      	str	r3, [r2, #80]	@ 0x50
 800a948:	e003      	b.n	800a952 <HAL_RCCEx_PeriphCLKConfig+0x166>
    }
    else
    {
      /* set overall return value */
      status = ret;
 800a94a:	f897 311f 	ldrb.w	r3, [r7, #287]	@ 0x11f
 800a94e:	f887 311e 	strb.w	r3, [r7, #286]	@ 0x11e

#endif /* SAI3 */

#if defined(RCC_CDCCIP1R_SAI2ASEL)
  /*---------------------------- SAI2A configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2A) == RCC_PERIPHCLK_SAI2A)
 800a952:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800a956:	e9d3 2300 	ldrd	r2, r3, [r3]
 800a95a:	f402 7a00 	and.w	sl, r2, #512	@ 0x200
 800a95e:	f04f 0b00 	mov.w	fp, #0
 800a962:	ea5a 030b 	orrs.w	r3, sl, fp
 800a966:	d054      	beq.n	800aa12 <HAL_RCCEx_PeriphCLKConfig+0x226>
  {
    switch (PeriphClkInit->Sai2AClockSelection)
 800a968:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800a96c:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 800a96e:	f5b3 7fa0 	cmp.w	r3, #320	@ 0x140
 800a972:	d036      	beq.n	800a9e2 <HAL_RCCEx_PeriphCLKConfig+0x1f6>
 800a974:	f5b3 7fa0 	cmp.w	r3, #320	@ 0x140
 800a978:	d82f      	bhi.n	800a9da <HAL_RCCEx_PeriphCLKConfig+0x1ee>
 800a97a:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 800a97e:	d032      	beq.n	800a9e6 <HAL_RCCEx_PeriphCLKConfig+0x1fa>
 800a980:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 800a984:	d829      	bhi.n	800a9da <HAL_RCCEx_PeriphCLKConfig+0x1ee>
 800a986:	2bc0      	cmp	r3, #192	@ 0xc0
 800a988:	d02f      	beq.n	800a9ea <HAL_RCCEx_PeriphCLKConfig+0x1fe>
 800a98a:	2bc0      	cmp	r3, #192	@ 0xc0
 800a98c:	d825      	bhi.n	800a9da <HAL_RCCEx_PeriphCLKConfig+0x1ee>
 800a98e:	2b80      	cmp	r3, #128	@ 0x80
 800a990:	d018      	beq.n	800a9c4 <HAL_RCCEx_PeriphCLKConfig+0x1d8>
 800a992:	2b80      	cmp	r3, #128	@ 0x80
 800a994:	d821      	bhi.n	800a9da <HAL_RCCEx_PeriphCLKConfig+0x1ee>
 800a996:	2b00      	cmp	r3, #0
 800a998:	d002      	beq.n	800a9a0 <HAL_RCCEx_PeriphCLKConfig+0x1b4>
 800a99a:	2b40      	cmp	r3, #64	@ 0x40
 800a99c:	d007      	beq.n	800a9ae <HAL_RCCEx_PeriphCLKConfig+0x1c2>
 800a99e:	e01c      	b.n	800a9da <HAL_RCCEx_PeriphCLKConfig+0x1ee>
    {
      case RCC_SAI2ACLKSOURCE_PLL:      /* PLL is used as clock source for SAI2A */
        /* Enable SAI2A Clock output generated form System PLL . */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 800a9a0:	4b4f      	ldr	r3, [pc, #316]	@ (800aae0 <HAL_RCCEx_PeriphCLKConfig+0x2f4>)
 800a9a2:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800a9a4:	4a4e      	ldr	r2, [pc, #312]	@ (800aae0 <HAL_RCCEx_PeriphCLKConfig+0x2f4>)
 800a9a6:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 800a9aa:	62d3      	str	r3, [r2, #44]	@ 0x2c

        /* SAI2A clock source configuration done later after clock selection check */
        break;
 800a9ac:	e01e      	b.n	800a9ec <HAL_RCCEx_PeriphCLKConfig+0x200>

      case RCC_SAI2ACLKSOURCE_PLL2: /* PLL2 is used as clock source for SAI2A */

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_P_UPDATE);
 800a9ae:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800a9b2:	3308      	adds	r3, #8
 800a9b4:	2100      	movs	r1, #0
 800a9b6:	4618      	mov	r0, r3
 800a9b8:	f002 f9be 	bl	800cd38 <RCCEx_PLL2_Config>
 800a9bc:	4603      	mov	r3, r0
 800a9be:	f887 311f 	strb.w	r3, [r7, #287]	@ 0x11f

        /* SAI2A clock source configuration done later after clock selection check */
        break;
 800a9c2:	e013      	b.n	800a9ec <HAL_RCCEx_PeriphCLKConfig+0x200>

      case RCC_SAI2ACLKSOURCE_PLL3:  /* PLL3 is used as clock source for SAI2A */
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_P_UPDATE);
 800a9c4:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800a9c8:	3328      	adds	r3, #40	@ 0x28
 800a9ca:	2100      	movs	r1, #0
 800a9cc:	4618      	mov	r0, r3
 800a9ce:	f002 fa65 	bl	800ce9c <RCCEx_PLL3_Config>
 800a9d2:	4603      	mov	r3, r0
 800a9d4:	f887 311f 	strb.w	r3, [r7, #287]	@ 0x11f

        /* SAI2A clock source configuration done later after clock selection check */
        break;
 800a9d8:	e008      	b.n	800a9ec <HAL_RCCEx_PeriphCLKConfig+0x200>
        /* SPDIF clock is used as source of SAI2A clock */
        /* SAI2A clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 800a9da:	2301      	movs	r3, #1
 800a9dc:	f887 311f 	strb.w	r3, [r7, #287]	@ 0x11f
        break;
 800a9e0:	e004      	b.n	800a9ec <HAL_RCCEx_PeriphCLKConfig+0x200>
        break;
 800a9e2:	bf00      	nop
 800a9e4:	e002      	b.n	800a9ec <HAL_RCCEx_PeriphCLKConfig+0x200>
        break;
 800a9e6:	bf00      	nop
 800a9e8:	e000      	b.n	800a9ec <HAL_RCCEx_PeriphCLKConfig+0x200>
        break;
 800a9ea:	bf00      	nop
    }

    if (ret == HAL_OK)
 800a9ec:	f897 311f 	ldrb.w	r3, [r7, #287]	@ 0x11f
 800a9f0:	2b00      	cmp	r3, #0
 800a9f2:	d10a      	bne.n	800aa0a <HAL_RCCEx_PeriphCLKConfig+0x21e>
    {
      /* Set the source of SAI2A clock*/
      __HAL_RCC_SAI2A_CONFIG(PeriphClkInit->Sai2AClockSelection);
 800a9f4:	4b3a      	ldr	r3, [pc, #232]	@ (800aae0 <HAL_RCCEx_PeriphCLKConfig+0x2f4>)
 800a9f6:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800a9f8:	f423 71e0 	bic.w	r1, r3, #448	@ 0x1c0
 800a9fc:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800aa00:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 800aa02:	4a37      	ldr	r2, [pc, #220]	@ (800aae0 <HAL_RCCEx_PeriphCLKConfig+0x2f4>)
 800aa04:	430b      	orrs	r3, r1
 800aa06:	6513      	str	r3, [r2, #80]	@ 0x50
 800aa08:	e003      	b.n	800aa12 <HAL_RCCEx_PeriphCLKConfig+0x226>
    }
    else
    {
      /* set overall return value */
      status = ret;
 800aa0a:	f897 311f 	ldrb.w	r3, [r7, #287]	@ 0x11f
 800aa0e:	f887 311e 	strb.w	r3, [r7, #286]	@ 0x11e
#endif  /*SAI2A*/

#if defined(RCC_CDCCIP1R_SAI2BSEL)

  /*---------------------------- SAI2B configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2B) == RCC_PERIPHCLK_SAI2B)
 800aa12:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800aa16:	e9d3 2300 	ldrd	r2, r3, [r3]
 800aa1a:	f402 6380 	and.w	r3, r2, #1024	@ 0x400
 800aa1e:	f8c7 3100 	str.w	r3, [r7, #256]	@ 0x100
 800aa22:	2300      	movs	r3, #0
 800aa24:	f8c7 3104 	str.w	r3, [r7, #260]	@ 0x104
 800aa28:	e9d7 1240 	ldrd	r1, r2, [r7, #256]	@ 0x100
 800aa2c:	460b      	mov	r3, r1
 800aa2e:	4313      	orrs	r3, r2
 800aa30:	d05c      	beq.n	800aaec <HAL_RCCEx_PeriphCLKConfig+0x300>
  {
    switch (PeriphClkInit->Sai2BClockSelection)
 800aa32:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800aa36:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 800aa38:	f5b3 6f20 	cmp.w	r3, #2560	@ 0xa00
 800aa3c:	d03b      	beq.n	800aab6 <HAL_RCCEx_PeriphCLKConfig+0x2ca>
 800aa3e:	f5b3 6f20 	cmp.w	r3, #2560	@ 0xa00
 800aa42:	d834      	bhi.n	800aaae <HAL_RCCEx_PeriphCLKConfig+0x2c2>
 800aa44:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
 800aa48:	d037      	beq.n	800aaba <HAL_RCCEx_PeriphCLKConfig+0x2ce>
 800aa4a:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
 800aa4e:	d82e      	bhi.n	800aaae <HAL_RCCEx_PeriphCLKConfig+0x2c2>
 800aa50:	f5b3 6fc0 	cmp.w	r3, #1536	@ 0x600
 800aa54:	d033      	beq.n	800aabe <HAL_RCCEx_PeriphCLKConfig+0x2d2>
 800aa56:	f5b3 6fc0 	cmp.w	r3, #1536	@ 0x600
 800aa5a:	d828      	bhi.n	800aaae <HAL_RCCEx_PeriphCLKConfig+0x2c2>
 800aa5c:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 800aa60:	d01a      	beq.n	800aa98 <HAL_RCCEx_PeriphCLKConfig+0x2ac>
 800aa62:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 800aa66:	d822      	bhi.n	800aaae <HAL_RCCEx_PeriphCLKConfig+0x2c2>
 800aa68:	2b00      	cmp	r3, #0
 800aa6a:	d003      	beq.n	800aa74 <HAL_RCCEx_PeriphCLKConfig+0x288>
 800aa6c:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 800aa70:	d007      	beq.n	800aa82 <HAL_RCCEx_PeriphCLKConfig+0x296>
 800aa72:	e01c      	b.n	800aaae <HAL_RCCEx_PeriphCLKConfig+0x2c2>
    {
      case RCC_SAI2BCLKSOURCE_PLL:      /* PLL is used as clock source for SAI2B */
        /* Enable SAI Clock output generated form System PLL . */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 800aa74:	4b1a      	ldr	r3, [pc, #104]	@ (800aae0 <HAL_RCCEx_PeriphCLKConfig+0x2f4>)
 800aa76:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800aa78:	4a19      	ldr	r2, [pc, #100]	@ (800aae0 <HAL_RCCEx_PeriphCLKConfig+0x2f4>)
 800aa7a:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 800aa7e:	62d3      	str	r3, [r2, #44]	@ 0x2c

        /* SAI2B clock source configuration done later after clock selection check */
        break;
 800aa80:	e01e      	b.n	800aac0 <HAL_RCCEx_PeriphCLKConfig+0x2d4>

      case RCC_SAI2BCLKSOURCE_PLL2: /* PLL2 is used as clock source for SAI2B */

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_P_UPDATE);
 800aa82:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800aa86:	3308      	adds	r3, #8
 800aa88:	2100      	movs	r1, #0
 800aa8a:	4618      	mov	r0, r3
 800aa8c:	f002 f954 	bl	800cd38 <RCCEx_PLL2_Config>
 800aa90:	4603      	mov	r3, r0
 800aa92:	f887 311f 	strb.w	r3, [r7, #287]	@ 0x11f

        /* SAI2B clock source configuration done later after clock selection check */
        break;
 800aa96:	e013      	b.n	800aac0 <HAL_RCCEx_PeriphCLKConfig+0x2d4>

      case RCC_SAI2BCLKSOURCE_PLL3:  /* PLL3 is used as clock source for SAI2B */
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_P_UPDATE);
 800aa98:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800aa9c:	3328      	adds	r3, #40	@ 0x28
 800aa9e:	2100      	movs	r1, #0
 800aaa0:	4618      	mov	r0, r3
 800aaa2:	f002 f9fb 	bl	800ce9c <RCCEx_PLL3_Config>
 800aaa6:	4603      	mov	r3, r0
 800aaa8:	f887 311f 	strb.w	r3, [r7, #287]	@ 0x11f

        /* SAI2B clock source configuration done later after clock selection check */
        break;
 800aaac:	e008      	b.n	800aac0 <HAL_RCCEx_PeriphCLKConfig+0x2d4>
        /* SPDIF clock is used as source of SAI2B clock */
        /* SAI2B clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 800aaae:	2301      	movs	r3, #1
 800aab0:	f887 311f 	strb.w	r3, [r7, #287]	@ 0x11f
        break;
 800aab4:	e004      	b.n	800aac0 <HAL_RCCEx_PeriphCLKConfig+0x2d4>
        break;
 800aab6:	bf00      	nop
 800aab8:	e002      	b.n	800aac0 <HAL_RCCEx_PeriphCLKConfig+0x2d4>
        break;
 800aaba:	bf00      	nop
 800aabc:	e000      	b.n	800aac0 <HAL_RCCEx_PeriphCLKConfig+0x2d4>
        break;
 800aabe:	bf00      	nop
    }

    if (ret == HAL_OK)
 800aac0:	f897 311f 	ldrb.w	r3, [r7, #287]	@ 0x11f
 800aac4:	2b00      	cmp	r3, #0
 800aac6:	d10d      	bne.n	800aae4 <HAL_RCCEx_PeriphCLKConfig+0x2f8>
    {
      /* Set the source of SAI2B clock*/
      __HAL_RCC_SAI2B_CONFIG(PeriphClkInit->Sai2BClockSelection);
 800aac8:	4b05      	ldr	r3, [pc, #20]	@ (800aae0 <HAL_RCCEx_PeriphCLKConfig+0x2f4>)
 800aaca:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800aacc:	f423 6160 	bic.w	r1, r3, #3584	@ 0xe00
 800aad0:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800aad4:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 800aad6:	4a02      	ldr	r2, [pc, #8]	@ (800aae0 <HAL_RCCEx_PeriphCLKConfig+0x2f4>)
 800aad8:	430b      	orrs	r3, r1
 800aada:	6513      	str	r3, [r2, #80]	@ 0x50
 800aadc:	e006      	b.n	800aaec <HAL_RCCEx_PeriphCLKConfig+0x300>
 800aade:	bf00      	nop
 800aae0:	58024400 	.word	0x58024400
    }
    else
    {
      /* set overall return value */
      status = ret;
 800aae4:	f897 311f 	ldrb.w	r3, [r7, #287]	@ 0x11f
 800aae8:	f887 311e 	strb.w	r3, [r7, #286]	@ 0x11e
  }
#endif  /*QUADSPI*/

#if defined(OCTOSPI1) || defined(OCTOSPI2)
  /*---------------------------- OCTOSPI configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_OSPI) == RCC_PERIPHCLK_OSPI)
 800aaec:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800aaf0:	e9d3 2300 	ldrd	r2, r3, [r3]
 800aaf4:	f002 7300 	and.w	r3, r2, #33554432	@ 0x2000000
 800aaf8:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
 800aafc:	2300      	movs	r3, #0
 800aafe:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc
 800ab02:	e9d7 123e 	ldrd	r1, r2, [r7, #248]	@ 0xf8
 800ab06:	460b      	mov	r3, r1
 800ab08:	4313      	orrs	r3, r2
 800ab0a:	d03a      	beq.n	800ab82 <HAL_RCCEx_PeriphCLKConfig+0x396>
  {
    switch (PeriphClkInit->OspiClockSelection)
 800ab0c:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800ab10:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 800ab12:	2b30      	cmp	r3, #48	@ 0x30
 800ab14:	d01f      	beq.n	800ab56 <HAL_RCCEx_PeriphCLKConfig+0x36a>
 800ab16:	2b30      	cmp	r3, #48	@ 0x30
 800ab18:	d819      	bhi.n	800ab4e <HAL_RCCEx_PeriphCLKConfig+0x362>
 800ab1a:	2b20      	cmp	r3, #32
 800ab1c:	d00c      	beq.n	800ab38 <HAL_RCCEx_PeriphCLKConfig+0x34c>
 800ab1e:	2b20      	cmp	r3, #32
 800ab20:	d815      	bhi.n	800ab4e <HAL_RCCEx_PeriphCLKConfig+0x362>
 800ab22:	2b00      	cmp	r3, #0
 800ab24:	d019      	beq.n	800ab5a <HAL_RCCEx_PeriphCLKConfig+0x36e>
 800ab26:	2b10      	cmp	r3, #16
 800ab28:	d111      	bne.n	800ab4e <HAL_RCCEx_PeriphCLKConfig+0x362>
    {
      case RCC_OSPICLKSOURCE_PLL:      /* PLL is used as clock source for OSPI*/
        /* Enable OSPI Clock output generated form System PLL . */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 800ab2a:	4bae      	ldr	r3, [pc, #696]	@ (800ade4 <HAL_RCCEx_PeriphCLKConfig+0x5f8>)
 800ab2c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800ab2e:	4aad      	ldr	r2, [pc, #692]	@ (800ade4 <HAL_RCCEx_PeriphCLKConfig+0x5f8>)
 800ab30:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 800ab34:	62d3      	str	r3, [r2, #44]	@ 0x2c

        /* OSPI clock source configuration done later after clock selection check */
        break;
 800ab36:	e011      	b.n	800ab5c <HAL_RCCEx_PeriphCLKConfig+0x370>

      case RCC_OSPICLKSOURCE_PLL2: /* PLL2 is used as clock source for OSPI*/

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_R_UPDATE);
 800ab38:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800ab3c:	3308      	adds	r3, #8
 800ab3e:	2102      	movs	r1, #2
 800ab40:	4618      	mov	r0, r3
 800ab42:	f002 f8f9 	bl	800cd38 <RCCEx_PLL2_Config>
 800ab46:	4603      	mov	r3, r0
 800ab48:	f887 311f 	strb.w	r3, [r7, #287]	@ 0x11f

        /* OSPI clock source configuration done later after clock selection check */
        break;
 800ab4c:	e006      	b.n	800ab5c <HAL_RCCEx_PeriphCLKConfig+0x370>
      case RCC_OSPICLKSOURCE_HCLK:
        /* HCLK clock selected as OSPI kernel peripheral clock */
        break;

      default:
        ret = HAL_ERROR;
 800ab4e:	2301      	movs	r3, #1
 800ab50:	f887 311f 	strb.w	r3, [r7, #287]	@ 0x11f
        break;
 800ab54:	e002      	b.n	800ab5c <HAL_RCCEx_PeriphCLKConfig+0x370>
        break;
 800ab56:	bf00      	nop
 800ab58:	e000      	b.n	800ab5c <HAL_RCCEx_PeriphCLKConfig+0x370>
        break;
 800ab5a:	bf00      	nop
    }

    if (ret == HAL_OK)
 800ab5c:	f897 311f 	ldrb.w	r3, [r7, #287]	@ 0x11f
 800ab60:	2b00      	cmp	r3, #0
 800ab62:	d10a      	bne.n	800ab7a <HAL_RCCEx_PeriphCLKConfig+0x38e>
    {
      /* Set the source of OSPI clock*/
      __HAL_RCC_OSPI_CONFIG(PeriphClkInit->OspiClockSelection);
 800ab64:	4b9f      	ldr	r3, [pc, #636]	@ (800ade4 <HAL_RCCEx_PeriphCLKConfig+0x5f8>)
 800ab66:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 800ab68:	f023 0130 	bic.w	r1, r3, #48	@ 0x30
 800ab6c:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800ab70:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 800ab72:	4a9c      	ldr	r2, [pc, #624]	@ (800ade4 <HAL_RCCEx_PeriphCLKConfig+0x5f8>)
 800ab74:	430b      	orrs	r3, r1
 800ab76:	64d3      	str	r3, [r2, #76]	@ 0x4c
 800ab78:	e003      	b.n	800ab82 <HAL_RCCEx_PeriphCLKConfig+0x396>
    }
    else
    {
      /* set overall return value */
      status = ret;
 800ab7a:	f897 311f 	ldrb.w	r3, [r7, #287]	@ 0x11f
 800ab7e:	f887 311e 	strb.w	r3, [r7, #286]	@ 0x11e
    }
  }
#endif  /*OCTOSPI*/

  /*---------------------------- SPI1/2/3 configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI123) == RCC_PERIPHCLK_SPI123)
 800ab82:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800ab86:	e9d3 2300 	ldrd	r2, r3, [r3]
 800ab8a:	f402 5380 	and.w	r3, r2, #4096	@ 0x1000
 800ab8e:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0
 800ab92:	2300      	movs	r3, #0
 800ab94:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
 800ab98:	e9d7 123c 	ldrd	r1, r2, [r7, #240]	@ 0xf0
 800ab9c:	460b      	mov	r3, r1
 800ab9e:	4313      	orrs	r3, r2
 800aba0:	d051      	beq.n	800ac46 <HAL_RCCEx_PeriphCLKConfig+0x45a>
  {
    switch (PeriphClkInit->Spi123ClockSelection)
 800aba2:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800aba6:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 800aba8:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
 800abac:	d035      	beq.n	800ac1a <HAL_RCCEx_PeriphCLKConfig+0x42e>
 800abae:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
 800abb2:	d82e      	bhi.n	800ac12 <HAL_RCCEx_PeriphCLKConfig+0x426>
 800abb4:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
 800abb8:	d031      	beq.n	800ac1e <HAL_RCCEx_PeriphCLKConfig+0x432>
 800abba:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
 800abbe:	d828      	bhi.n	800ac12 <HAL_RCCEx_PeriphCLKConfig+0x426>
 800abc0:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 800abc4:	d01a      	beq.n	800abfc <HAL_RCCEx_PeriphCLKConfig+0x410>
 800abc6:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 800abca:	d822      	bhi.n	800ac12 <HAL_RCCEx_PeriphCLKConfig+0x426>
 800abcc:	2b00      	cmp	r3, #0
 800abce:	d003      	beq.n	800abd8 <HAL_RCCEx_PeriphCLKConfig+0x3ec>
 800abd0:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 800abd4:	d007      	beq.n	800abe6 <HAL_RCCEx_PeriphCLKConfig+0x3fa>
 800abd6:	e01c      	b.n	800ac12 <HAL_RCCEx_PeriphCLKConfig+0x426>
    {
      case RCC_SPI123CLKSOURCE_PLL:      /* PLL is used as clock source for SPI1/2/3 */
        /* Enable SPI Clock output generated form System PLL . */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 800abd8:	4b82      	ldr	r3, [pc, #520]	@ (800ade4 <HAL_RCCEx_PeriphCLKConfig+0x5f8>)
 800abda:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800abdc:	4a81      	ldr	r2, [pc, #516]	@ (800ade4 <HAL_RCCEx_PeriphCLKConfig+0x5f8>)
 800abde:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 800abe2:	62d3      	str	r3, [r2, #44]	@ 0x2c

        /* SPI1/2/3 clock source configuration done later after clock selection check */
        break;
 800abe4:	e01c      	b.n	800ac20 <HAL_RCCEx_PeriphCLKConfig+0x434>

      case RCC_SPI123CLKSOURCE_PLL2: /* PLL2 is used as clock source for SPI1/2/3 */
        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_P_UPDATE);
 800abe6:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800abea:	3308      	adds	r3, #8
 800abec:	2100      	movs	r1, #0
 800abee:	4618      	mov	r0, r3
 800abf0:	f002 f8a2 	bl	800cd38 <RCCEx_PLL2_Config>
 800abf4:	4603      	mov	r3, r0
 800abf6:	f887 311f 	strb.w	r3, [r7, #287]	@ 0x11f

        /* SPI1/2/3 clock source configuration done later after clock selection check */
        break;
 800abfa:	e011      	b.n	800ac20 <HAL_RCCEx_PeriphCLKConfig+0x434>

      case RCC_SPI123CLKSOURCE_PLL3:  /* PLL3 is used as clock source for SPI1/2/3 */
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_P_UPDATE);
 800abfc:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800ac00:	3328      	adds	r3, #40	@ 0x28
 800ac02:	2100      	movs	r1, #0
 800ac04:	4618      	mov	r0, r3
 800ac06:	f002 f949 	bl	800ce9c <RCCEx_PLL3_Config>
 800ac0a:	4603      	mov	r3, r0
 800ac0c:	f887 311f 	strb.w	r3, [r7, #287]	@ 0x11f

        /* SPI1/2/3 clock source configuration done later after clock selection check */
        break;
 800ac10:	e006      	b.n	800ac20 <HAL_RCCEx_PeriphCLKConfig+0x434>
        /* HSI, HSE, or CSI oscillator is used as source of SPI1/2/3 clock */
        /* SPI1/2/3 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 800ac12:	2301      	movs	r3, #1
 800ac14:	f887 311f 	strb.w	r3, [r7, #287]	@ 0x11f
        break;
 800ac18:	e002      	b.n	800ac20 <HAL_RCCEx_PeriphCLKConfig+0x434>
        break;
 800ac1a:	bf00      	nop
 800ac1c:	e000      	b.n	800ac20 <HAL_RCCEx_PeriphCLKConfig+0x434>
        break;
 800ac1e:	bf00      	nop
    }

    if (ret == HAL_OK)
 800ac20:	f897 311f 	ldrb.w	r3, [r7, #287]	@ 0x11f
 800ac24:	2b00      	cmp	r3, #0
 800ac26:	d10a      	bne.n	800ac3e <HAL_RCCEx_PeriphCLKConfig+0x452>
    {
      /* Set the source of SPI1/2/3 clock*/
      __HAL_RCC_SPI123_CONFIG(PeriphClkInit->Spi123ClockSelection);
 800ac28:	4b6e      	ldr	r3, [pc, #440]	@ (800ade4 <HAL_RCCEx_PeriphCLKConfig+0x5f8>)
 800ac2a:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800ac2c:	f423 41e0 	bic.w	r1, r3, #28672	@ 0x7000
 800ac30:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800ac34:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 800ac36:	4a6b      	ldr	r2, [pc, #428]	@ (800ade4 <HAL_RCCEx_PeriphCLKConfig+0x5f8>)
 800ac38:	430b      	orrs	r3, r1
 800ac3a:	6513      	str	r3, [r2, #80]	@ 0x50
 800ac3c:	e003      	b.n	800ac46 <HAL_RCCEx_PeriphCLKConfig+0x45a>
    }
    else
    {
      /* set overall return value */
      status = ret;
 800ac3e:	f897 311f 	ldrb.w	r3, [r7, #287]	@ 0x11f
 800ac42:	f887 311e 	strb.w	r3, [r7, #286]	@ 0x11e
    }
  }

  /*---------------------------- SPI4/5 configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI45) == RCC_PERIPHCLK_SPI45)
 800ac46:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800ac4a:	e9d3 2300 	ldrd	r2, r3, [r3]
 800ac4e:	f402 5300 	and.w	r3, r2, #8192	@ 0x2000
 800ac52:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8
 800ac56:	2300      	movs	r3, #0
 800ac58:	f8c7 30ec 	str.w	r3, [r7, #236]	@ 0xec
 800ac5c:	e9d7 123a 	ldrd	r1, r2, [r7, #232]	@ 0xe8
 800ac60:	460b      	mov	r3, r1
 800ac62:	4313      	orrs	r3, r2
 800ac64:	d053      	beq.n	800ad0e <HAL_RCCEx_PeriphCLKConfig+0x522>
  {
    switch (PeriphClkInit->Spi45ClockSelection)
 800ac66:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800ac6a:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 800ac6c:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
 800ac70:	d033      	beq.n	800acda <HAL_RCCEx_PeriphCLKConfig+0x4ee>
 800ac72:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
 800ac76:	d82c      	bhi.n	800acd2 <HAL_RCCEx_PeriphCLKConfig+0x4e6>
 800ac78:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
 800ac7c:	d02f      	beq.n	800acde <HAL_RCCEx_PeriphCLKConfig+0x4f2>
 800ac7e:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
 800ac82:	d826      	bhi.n	800acd2 <HAL_RCCEx_PeriphCLKConfig+0x4e6>
 800ac84:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
 800ac88:	d02b      	beq.n	800ace2 <HAL_RCCEx_PeriphCLKConfig+0x4f6>
 800ac8a:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
 800ac8e:	d820      	bhi.n	800acd2 <HAL_RCCEx_PeriphCLKConfig+0x4e6>
 800ac90:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 800ac94:	d012      	beq.n	800acbc <HAL_RCCEx_PeriphCLKConfig+0x4d0>
 800ac96:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 800ac9a:	d81a      	bhi.n	800acd2 <HAL_RCCEx_PeriphCLKConfig+0x4e6>
 800ac9c:	2b00      	cmp	r3, #0
 800ac9e:	d022      	beq.n	800ace6 <HAL_RCCEx_PeriphCLKConfig+0x4fa>
 800aca0:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 800aca4:	d115      	bne.n	800acd2 <HAL_RCCEx_PeriphCLKConfig+0x4e6>
        /* SPI4/5 clock source configuration done later after clock selection check */
        break;

      case RCC_SPI45CLKSOURCE_PLL2: /* PLL2 is used as clock source for SPI4/5 */

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_Q_UPDATE);
 800aca6:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800acaa:	3308      	adds	r3, #8
 800acac:	2101      	movs	r1, #1
 800acae:	4618      	mov	r0, r3
 800acb0:	f002 f842 	bl	800cd38 <RCCEx_PLL2_Config>
 800acb4:	4603      	mov	r3, r0
 800acb6:	f887 311f 	strb.w	r3, [r7, #287]	@ 0x11f

        /* SPI4/5 clock source configuration done later after clock selection check */
        break;
 800acba:	e015      	b.n	800ace8 <HAL_RCCEx_PeriphCLKConfig+0x4fc>
      case RCC_SPI45CLKSOURCE_PLL3:  /* PLL3 is used as clock source for SPI4/5 */
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_Q_UPDATE);
 800acbc:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800acc0:	3328      	adds	r3, #40	@ 0x28
 800acc2:	2101      	movs	r1, #1
 800acc4:	4618      	mov	r0, r3
 800acc6:	f002 f8e9 	bl	800ce9c <RCCEx_PLL3_Config>
 800acca:	4603      	mov	r3, r0
 800accc:	f887 311f 	strb.w	r3, [r7, #287]	@ 0x11f
        /* SPI4/5 clock source configuration done later after clock selection check */
        break;
 800acd0:	e00a      	b.n	800ace8 <HAL_RCCEx_PeriphCLKConfig+0x4fc>
        /* HSE,  oscillator is used as source of SPI4/5 clock */
        /* SPI4/5 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 800acd2:	2301      	movs	r3, #1
 800acd4:	f887 311f 	strb.w	r3, [r7, #287]	@ 0x11f
        break;
 800acd8:	e006      	b.n	800ace8 <HAL_RCCEx_PeriphCLKConfig+0x4fc>
        break;
 800acda:	bf00      	nop
 800acdc:	e004      	b.n	800ace8 <HAL_RCCEx_PeriphCLKConfig+0x4fc>
        break;
 800acde:	bf00      	nop
 800ace0:	e002      	b.n	800ace8 <HAL_RCCEx_PeriphCLKConfig+0x4fc>
        break;
 800ace2:	bf00      	nop
 800ace4:	e000      	b.n	800ace8 <HAL_RCCEx_PeriphCLKConfig+0x4fc>
        break;
 800ace6:	bf00      	nop
    }

    if (ret == HAL_OK)
 800ace8:	f897 311f 	ldrb.w	r3, [r7, #287]	@ 0x11f
 800acec:	2b00      	cmp	r3, #0
 800acee:	d10a      	bne.n	800ad06 <HAL_RCCEx_PeriphCLKConfig+0x51a>
    {
      /* Set the source of SPI4/5 clock*/
      __HAL_RCC_SPI45_CONFIG(PeriphClkInit->Spi45ClockSelection);
 800acf0:	4b3c      	ldr	r3, [pc, #240]	@ (800ade4 <HAL_RCCEx_PeriphCLKConfig+0x5f8>)
 800acf2:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800acf4:	f423 21e0 	bic.w	r1, r3, #458752	@ 0x70000
 800acf8:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800acfc:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 800acfe:	4a39      	ldr	r2, [pc, #228]	@ (800ade4 <HAL_RCCEx_PeriphCLKConfig+0x5f8>)
 800ad00:	430b      	orrs	r3, r1
 800ad02:	6513      	str	r3, [r2, #80]	@ 0x50
 800ad04:	e003      	b.n	800ad0e <HAL_RCCEx_PeriphCLKConfig+0x522>
    }
    else
    {
      /* set overall return value */
      status = ret;
 800ad06:	f897 311f 	ldrb.w	r3, [r7, #287]	@ 0x11f
 800ad0a:	f887 311e 	strb.w	r3, [r7, #286]	@ 0x11e
    }
  }

  /*---------------------------- SPI6 configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI6) == RCC_PERIPHCLK_SPI6)
 800ad0e:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800ad12:	e9d3 2300 	ldrd	r2, r3, [r3]
 800ad16:	f402 4380 	and.w	r3, r2, #16384	@ 0x4000
 800ad1a:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
 800ad1e:	2300      	movs	r3, #0
 800ad20:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
 800ad24:	e9d7 1238 	ldrd	r1, r2, [r7, #224]	@ 0xe0
 800ad28:	460b      	mov	r3, r1
 800ad2a:	4313      	orrs	r3, r2
 800ad2c:	d060      	beq.n	800adf0 <HAL_RCCEx_PeriphCLKConfig+0x604>
  {
    switch (PeriphClkInit->Spi6ClockSelection)
 800ad2e:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800ad32:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
 800ad36:	f1b3 4fc0 	cmp.w	r3, #1610612736	@ 0x60000000
 800ad3a:	d039      	beq.n	800adb0 <HAL_RCCEx_PeriphCLKConfig+0x5c4>
 800ad3c:	f1b3 4fc0 	cmp.w	r3, #1610612736	@ 0x60000000
 800ad40:	d832      	bhi.n	800ada8 <HAL_RCCEx_PeriphCLKConfig+0x5bc>
 800ad42:	f1b3 4fa0 	cmp.w	r3, #1342177280	@ 0x50000000
 800ad46:	d035      	beq.n	800adb4 <HAL_RCCEx_PeriphCLKConfig+0x5c8>
 800ad48:	f1b3 4fa0 	cmp.w	r3, #1342177280	@ 0x50000000
 800ad4c:	d82c      	bhi.n	800ada8 <HAL_RCCEx_PeriphCLKConfig+0x5bc>
 800ad4e:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 800ad52:	d031      	beq.n	800adb8 <HAL_RCCEx_PeriphCLKConfig+0x5cc>
 800ad54:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 800ad58:	d826      	bhi.n	800ada8 <HAL_RCCEx_PeriphCLKConfig+0x5bc>
 800ad5a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
 800ad5e:	d02d      	beq.n	800adbc <HAL_RCCEx_PeriphCLKConfig+0x5d0>
 800ad60:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
 800ad64:	d820      	bhi.n	800ada8 <HAL_RCCEx_PeriphCLKConfig+0x5bc>
 800ad66:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 800ad6a:	d012      	beq.n	800ad92 <HAL_RCCEx_PeriphCLKConfig+0x5a6>
 800ad6c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 800ad70:	d81a      	bhi.n	800ada8 <HAL_RCCEx_PeriphCLKConfig+0x5bc>
 800ad72:	2b00      	cmp	r3, #0
 800ad74:	d024      	beq.n	800adc0 <HAL_RCCEx_PeriphCLKConfig+0x5d4>
 800ad76:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
 800ad7a:	d115      	bne.n	800ada8 <HAL_RCCEx_PeriphCLKConfig+0x5bc>
        /* SPI6 clock source configuration done later after clock selection check */
        break;

      case RCC_SPI6CLKSOURCE_PLL2: /* PLL2 is used as clock source for SPI6*/

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_Q_UPDATE);
 800ad7c:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800ad80:	3308      	adds	r3, #8
 800ad82:	2101      	movs	r1, #1
 800ad84:	4618      	mov	r0, r3
 800ad86:	f001 ffd7 	bl	800cd38 <RCCEx_PLL2_Config>
 800ad8a:	4603      	mov	r3, r0
 800ad8c:	f887 311f 	strb.w	r3, [r7, #287]	@ 0x11f

        /* SPI6 clock source configuration done later after clock selection check */
        break;
 800ad90:	e017      	b.n	800adc2 <HAL_RCCEx_PeriphCLKConfig+0x5d6>
      case RCC_SPI6CLKSOURCE_PLL3:  /* PLL3 is used as clock source for SPI6*/
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_Q_UPDATE);
 800ad92:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800ad96:	3328      	adds	r3, #40	@ 0x28
 800ad98:	2101      	movs	r1, #1
 800ad9a:	4618      	mov	r0, r3
 800ad9c:	f002 f87e 	bl	800ce9c <RCCEx_PLL3_Config>
 800ada0:	4603      	mov	r3, r0
 800ada2:	f887 311f 	strb.w	r3, [r7, #287]	@ 0x11f
        /* SPI6 clock source configuration done later after clock selection check */
        break;
 800ada6:	e00c      	b.n	800adc2 <HAL_RCCEx_PeriphCLKConfig+0x5d6>
        /* SPI6 clock source configuration done later after clock selection check */
        break;
#endif

      default:
        ret = HAL_ERROR;
 800ada8:	2301      	movs	r3, #1
 800adaa:	f887 311f 	strb.w	r3, [r7, #287]	@ 0x11f
        break;
 800adae:	e008      	b.n	800adc2 <HAL_RCCEx_PeriphCLKConfig+0x5d6>
        break;
 800adb0:	bf00      	nop
 800adb2:	e006      	b.n	800adc2 <HAL_RCCEx_PeriphCLKConfig+0x5d6>
        break;
 800adb4:	bf00      	nop
 800adb6:	e004      	b.n	800adc2 <HAL_RCCEx_PeriphCLKConfig+0x5d6>
        break;
 800adb8:	bf00      	nop
 800adba:	e002      	b.n	800adc2 <HAL_RCCEx_PeriphCLKConfig+0x5d6>
        break;
 800adbc:	bf00      	nop
 800adbe:	e000      	b.n	800adc2 <HAL_RCCEx_PeriphCLKConfig+0x5d6>
        break;
 800adc0:	bf00      	nop
    }

    if (ret == HAL_OK)
 800adc2:	f897 311f 	ldrb.w	r3, [r7, #287]	@ 0x11f
 800adc6:	2b00      	cmp	r3, #0
 800adc8:	d10e      	bne.n	800ade8 <HAL_RCCEx_PeriphCLKConfig+0x5fc>
    {
      /* Set the source of SPI6 clock*/
      __HAL_RCC_SPI6_CONFIG(PeriphClkInit->Spi6ClockSelection);
 800adca:	4b06      	ldr	r3, [pc, #24]	@ (800ade4 <HAL_RCCEx_PeriphCLKConfig+0x5f8>)
 800adcc:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 800adce:	f023 41e0 	bic.w	r1, r3, #1879048192	@ 0x70000000
 800add2:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800add6:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
 800adda:	4a02      	ldr	r2, [pc, #8]	@ (800ade4 <HAL_RCCEx_PeriphCLKConfig+0x5f8>)
 800addc:	430b      	orrs	r3, r1
 800adde:	6593      	str	r3, [r2, #88]	@ 0x58
 800ade0:	e006      	b.n	800adf0 <HAL_RCCEx_PeriphCLKConfig+0x604>
 800ade2:	bf00      	nop
 800ade4:	58024400 	.word	0x58024400
    }
    else
    {
      /* set overall return value */
      status = ret;
 800ade8:	f897 311f 	ldrb.w	r3, [r7, #287]	@ 0x11f
 800adec:	f887 311e 	strb.w	r3, [r7, #286]	@ 0x11e
  }
#endif /*DSI*/

#if defined(FDCAN1) || defined(FDCAN2)
  /*---------------------------- FDCAN configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_FDCAN) == RCC_PERIPHCLK_FDCAN)
 800adf0:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800adf4:	e9d3 2300 	ldrd	r2, r3, [r3]
 800adf8:	f402 4300 	and.w	r3, r2, #32768	@ 0x8000
 800adfc:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
 800ae00:	2300      	movs	r3, #0
 800ae02:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
 800ae06:	e9d7 1236 	ldrd	r1, r2, [r7, #216]	@ 0xd8
 800ae0a:	460b      	mov	r3, r1
 800ae0c:	4313      	orrs	r3, r2
 800ae0e:	d037      	beq.n	800ae80 <HAL_RCCEx_PeriphCLKConfig+0x694>
  {
    switch (PeriphClkInit->FdcanClockSelection)
 800ae10:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800ae14:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 800ae16:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 800ae1a:	d00e      	beq.n	800ae3a <HAL_RCCEx_PeriphCLKConfig+0x64e>
 800ae1c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 800ae20:	d816      	bhi.n	800ae50 <HAL_RCCEx_PeriphCLKConfig+0x664>
 800ae22:	2b00      	cmp	r3, #0
 800ae24:	d018      	beq.n	800ae58 <HAL_RCCEx_PeriphCLKConfig+0x66c>
 800ae26:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
 800ae2a:	d111      	bne.n	800ae50 <HAL_RCCEx_PeriphCLKConfig+0x664>
    {
      case RCC_FDCANCLKSOURCE_PLL:      /* PLL is used as clock source for FDCAN*/
        /* Enable FDCAN Clock output generated form System PLL . */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 800ae2c:	4bc4      	ldr	r3, [pc, #784]	@ (800b140 <HAL_RCCEx_PeriphCLKConfig+0x954>)
 800ae2e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800ae30:	4ac3      	ldr	r2, [pc, #780]	@ (800b140 <HAL_RCCEx_PeriphCLKConfig+0x954>)
 800ae32:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 800ae36:	62d3      	str	r3, [r2, #44]	@ 0x2c

        /* FDCAN clock source configuration done later after clock selection check */
        break;
 800ae38:	e00f      	b.n	800ae5a <HAL_RCCEx_PeriphCLKConfig+0x66e>

      case RCC_FDCANCLKSOURCE_PLL2: /* PLL2 is used as clock source for FDCAN*/

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_Q_UPDATE);
 800ae3a:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800ae3e:	3308      	adds	r3, #8
 800ae40:	2101      	movs	r1, #1
 800ae42:	4618      	mov	r0, r3
 800ae44:	f001 ff78 	bl	800cd38 <RCCEx_PLL2_Config>
 800ae48:	4603      	mov	r3, r0
 800ae4a:	f887 311f 	strb.w	r3, [r7, #287]	@ 0x11f

        /* FDCAN clock source configuration done later after clock selection check */
        break;
 800ae4e:	e004      	b.n	800ae5a <HAL_RCCEx_PeriphCLKConfig+0x66e>
        /* HSE is used as clock source for FDCAN*/
        /* FDCAN clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 800ae50:	2301      	movs	r3, #1
 800ae52:	f887 311f 	strb.w	r3, [r7, #287]	@ 0x11f
        break;
 800ae56:	e000      	b.n	800ae5a <HAL_RCCEx_PeriphCLKConfig+0x66e>
        break;
 800ae58:	bf00      	nop
    }

    if (ret == HAL_OK)
 800ae5a:	f897 311f 	ldrb.w	r3, [r7, #287]	@ 0x11f
 800ae5e:	2b00      	cmp	r3, #0
 800ae60:	d10a      	bne.n	800ae78 <HAL_RCCEx_PeriphCLKConfig+0x68c>
    {
      /* Set the source of FDCAN clock*/
      __HAL_RCC_FDCAN_CONFIG(PeriphClkInit->FdcanClockSelection);
 800ae62:	4bb7      	ldr	r3, [pc, #732]	@ (800b140 <HAL_RCCEx_PeriphCLKConfig+0x954>)
 800ae64:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800ae66:	f023 5140 	bic.w	r1, r3, #805306368	@ 0x30000000
 800ae6a:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800ae6e:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 800ae70:	4ab3      	ldr	r2, [pc, #716]	@ (800b140 <HAL_RCCEx_PeriphCLKConfig+0x954>)
 800ae72:	430b      	orrs	r3, r1
 800ae74:	6513      	str	r3, [r2, #80]	@ 0x50
 800ae76:	e003      	b.n	800ae80 <HAL_RCCEx_PeriphCLKConfig+0x694>
    }
    else
    {
      /* set overall return value */
      status = ret;
 800ae78:	f897 311f 	ldrb.w	r3, [r7, #287]	@ 0x11f
 800ae7c:	f887 311e 	strb.w	r3, [r7, #286]	@ 0x11e
    }
  }
#endif /*FDCAN1 || FDCAN2*/

  /*---------------------------- FMC configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_FMC) == RCC_PERIPHCLK_FMC)
 800ae80:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800ae84:	e9d3 2300 	ldrd	r2, r3, [r3]
 800ae88:	f002 7380 	and.w	r3, r2, #16777216	@ 0x1000000
 800ae8c:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0
 800ae90:	2300      	movs	r3, #0
 800ae92:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
 800ae96:	e9d7 1234 	ldrd	r1, r2, [r7, #208]	@ 0xd0
 800ae9a:	460b      	mov	r3, r1
 800ae9c:	4313      	orrs	r3, r2
 800ae9e:	d039      	beq.n	800af14 <HAL_RCCEx_PeriphCLKConfig+0x728>
  {
    switch (PeriphClkInit->FmcClockSelection)
 800aea0:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800aea4:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 800aea6:	2b03      	cmp	r3, #3
 800aea8:	d81c      	bhi.n	800aee4 <HAL_RCCEx_PeriphCLKConfig+0x6f8>
 800aeaa:	a201      	add	r2, pc, #4	@ (adr r2, 800aeb0 <HAL_RCCEx_PeriphCLKConfig+0x6c4>)
 800aeac:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800aeb0:	0800aeed 	.word	0x0800aeed
 800aeb4:	0800aec1 	.word	0x0800aec1
 800aeb8:	0800aecf 	.word	0x0800aecf
 800aebc:	0800aeed 	.word	0x0800aeed
    {
      case RCC_FMCCLKSOURCE_PLL:      /* PLL is used as clock source for FMC*/
        /* Enable FMC Clock output generated form System PLL . */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 800aec0:	4b9f      	ldr	r3, [pc, #636]	@ (800b140 <HAL_RCCEx_PeriphCLKConfig+0x954>)
 800aec2:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800aec4:	4a9e      	ldr	r2, [pc, #632]	@ (800b140 <HAL_RCCEx_PeriphCLKConfig+0x954>)
 800aec6:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 800aeca:	62d3      	str	r3, [r2, #44]	@ 0x2c

        /* FMC clock source configuration done later after clock selection check */
        break;
 800aecc:	e00f      	b.n	800aeee <HAL_RCCEx_PeriphCLKConfig+0x702>

      case RCC_FMCCLKSOURCE_PLL2: /* PLL2 is used as clock source for FMC*/

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_R_UPDATE);
 800aece:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800aed2:	3308      	adds	r3, #8
 800aed4:	2102      	movs	r1, #2
 800aed6:	4618      	mov	r0, r3
 800aed8:	f001 ff2e 	bl	800cd38 <RCCEx_PLL2_Config>
 800aedc:	4603      	mov	r3, r0
 800aede:	f887 311f 	strb.w	r3, [r7, #287]	@ 0x11f

        /* FMC clock source configuration done later after clock selection check */
        break;
 800aee2:	e004      	b.n	800aeee <HAL_RCCEx_PeriphCLKConfig+0x702>
      case RCC_FMCCLKSOURCE_HCLK:
        /* D1/CD HCLK  clock selected as FMC kernel peripheral clock */
        break;

      default:
        ret = HAL_ERROR;
 800aee4:	2301      	movs	r3, #1
 800aee6:	f887 311f 	strb.w	r3, [r7, #287]	@ 0x11f
        break;
 800aeea:	e000      	b.n	800aeee <HAL_RCCEx_PeriphCLKConfig+0x702>
        break;
 800aeec:	bf00      	nop
    }

    if (ret == HAL_OK)
 800aeee:	f897 311f 	ldrb.w	r3, [r7, #287]	@ 0x11f
 800aef2:	2b00      	cmp	r3, #0
 800aef4:	d10a      	bne.n	800af0c <HAL_RCCEx_PeriphCLKConfig+0x720>
    {
      /* Set the source of FMC clock*/
      __HAL_RCC_FMC_CONFIG(PeriphClkInit->FmcClockSelection);
 800aef6:	4b92      	ldr	r3, [pc, #584]	@ (800b140 <HAL_RCCEx_PeriphCLKConfig+0x954>)
 800aef8:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 800aefa:	f023 0103 	bic.w	r1, r3, #3
 800aefe:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800af02:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 800af04:	4a8e      	ldr	r2, [pc, #568]	@ (800b140 <HAL_RCCEx_PeriphCLKConfig+0x954>)
 800af06:	430b      	orrs	r3, r1
 800af08:	64d3      	str	r3, [r2, #76]	@ 0x4c
 800af0a:	e003      	b.n	800af14 <HAL_RCCEx_PeriphCLKConfig+0x728>
    }
    else
    {
      /* set overall return value */
      status = ret;
 800af0c:	f897 311f 	ldrb.w	r3, [r7, #287]	@ 0x11f
 800af10:	f887 311e 	strb.w	r3, [r7, #286]	@ 0x11e
    }
  }

  /*---------------------------- RTC configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 800af14:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800af18:	e9d3 2300 	ldrd	r2, r3, [r3]
 800af1c:	f402 0380 	and.w	r3, r2, #4194304	@ 0x400000
 800af20:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
 800af24:	2300      	movs	r3, #0
 800af26:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
 800af2a:	e9d7 1232 	ldrd	r1, r2, [r7, #200]	@ 0xc8
 800af2e:	460b      	mov	r3, r1
 800af30:	4313      	orrs	r3, r2
 800af32:	f000 8099 	beq.w	800b068 <HAL_RCCEx_PeriphCLKConfig+0x87c>
  {
    /* check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));

    /* Enable write access to Backup domain */
    SET_BIT(PWR->CR1, PWR_CR1_DBP);
 800af36:	4b83      	ldr	r3, [pc, #524]	@ (800b144 <HAL_RCCEx_PeriphCLKConfig+0x958>)
 800af38:	681b      	ldr	r3, [r3, #0]
 800af3a:	4a82      	ldr	r2, [pc, #520]	@ (800b144 <HAL_RCCEx_PeriphCLKConfig+0x958>)
 800af3c:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 800af40:	6013      	str	r3, [r2, #0]

    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
 800af42:	f7f7 fd0d 	bl	8002960 <HAL_GetTick>
 800af46:	f8c7 0118 	str.w	r0, [r7, #280]	@ 0x118

    while ((PWR->CR1 & PWR_CR1_DBP) == 0U)
 800af4a:	e00b      	b.n	800af64 <HAL_RCCEx_PeriphCLKConfig+0x778>
    {
      if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 800af4c:	f7f7 fd08 	bl	8002960 <HAL_GetTick>
 800af50:	4602      	mov	r2, r0
 800af52:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 800af56:	1ad3      	subs	r3, r2, r3
 800af58:	2b64      	cmp	r3, #100	@ 0x64
 800af5a:	d903      	bls.n	800af64 <HAL_RCCEx_PeriphCLKConfig+0x778>
      {
        ret = HAL_TIMEOUT;
 800af5c:	2303      	movs	r3, #3
 800af5e:	f887 311f 	strb.w	r3, [r7, #287]	@ 0x11f
        break;
 800af62:	e005      	b.n	800af70 <HAL_RCCEx_PeriphCLKConfig+0x784>
    while ((PWR->CR1 & PWR_CR1_DBP) == 0U)
 800af64:	4b77      	ldr	r3, [pc, #476]	@ (800b144 <HAL_RCCEx_PeriphCLKConfig+0x958>)
 800af66:	681b      	ldr	r3, [r3, #0]
 800af68:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 800af6c:	2b00      	cmp	r3, #0
 800af6e:	d0ed      	beq.n	800af4c <HAL_RCCEx_PeriphCLKConfig+0x760>
      }
    }

    if (ret == HAL_OK)
 800af70:	f897 311f 	ldrb.w	r3, [r7, #287]	@ 0x11f
 800af74:	2b00      	cmp	r3, #0
 800af76:	d173      	bne.n	800b060 <HAL_RCCEx_PeriphCLKConfig+0x874>
    {
      /* Reset the Backup domain only if the RTC Clock source selection is modified */
      if ((RCC->BDCR & RCC_BDCR_RTCSEL) != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL))
 800af78:	4b71      	ldr	r3, [pc, #452]	@ (800b140 <HAL_RCCEx_PeriphCLKConfig+0x954>)
 800af7a:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
 800af7c:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800af80:	f8d3 30b4 	ldr.w	r3, [r3, #180]	@ 0xb4
 800af84:	4053      	eors	r3, r2
 800af86:	f403 7340 	and.w	r3, r3, #768	@ 0x300
 800af8a:	2b00      	cmp	r3, #0
 800af8c:	d015      	beq.n	800afba <HAL_RCCEx_PeriphCLKConfig+0x7ce>
      {
        /* Store the content of BDCR register before the reset of Backup Domain */
        tmpreg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 800af8e:	4b6c      	ldr	r3, [pc, #432]	@ (800b140 <HAL_RCCEx_PeriphCLKConfig+0x954>)
 800af90:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 800af92:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
 800af96:	f8c7 3114 	str.w	r3, [r7, #276]	@ 0x114
        /* RTC Clock selection can be changed only if the Backup Domain is reset */
        __HAL_RCC_BACKUPRESET_FORCE();
 800af9a:	4b69      	ldr	r3, [pc, #420]	@ (800b140 <HAL_RCCEx_PeriphCLKConfig+0x954>)
 800af9c:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 800af9e:	4a68      	ldr	r2, [pc, #416]	@ (800b140 <HAL_RCCEx_PeriphCLKConfig+0x954>)
 800afa0:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 800afa4:	6713      	str	r3, [r2, #112]	@ 0x70
        __HAL_RCC_BACKUPRESET_RELEASE();
 800afa6:	4b66      	ldr	r3, [pc, #408]	@ (800b140 <HAL_RCCEx_PeriphCLKConfig+0x954>)
 800afa8:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 800afaa:	4a65      	ldr	r2, [pc, #404]	@ (800b140 <HAL_RCCEx_PeriphCLKConfig+0x954>)
 800afac:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
 800afb0:	6713      	str	r3, [r2, #112]	@ 0x70
        /* Restore the Content of BDCR register */
        RCC->BDCR = tmpreg;
 800afb2:	4a63      	ldr	r2, [pc, #396]	@ (800b140 <HAL_RCCEx_PeriphCLKConfig+0x954>)
 800afb4:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 800afb8:	6713      	str	r3, [r2, #112]	@ 0x70
      }

      /* If LSE is selected as RTC clock source (and enabled prior to Backup Domain reset), wait for LSE reactivation */
      if (PeriphClkInit->RTCClockSelection == RCC_RTCCLKSOURCE_LSE)
 800afba:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800afbe:	f8d3 30b4 	ldr.w	r3, [r3, #180]	@ 0xb4
 800afc2:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 800afc6:	d118      	bne.n	800affa <HAL_RCCEx_PeriphCLKConfig+0x80e>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800afc8:	f7f7 fcca 	bl	8002960 <HAL_GetTick>
 800afcc:	f8c7 0118 	str.w	r0, [r7, #280]	@ 0x118

        /* Wait till LSE is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
 800afd0:	e00d      	b.n	800afee <HAL_RCCEx_PeriphCLKConfig+0x802>
        {
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800afd2:	f7f7 fcc5 	bl	8002960 <HAL_GetTick>
 800afd6:	4602      	mov	r2, r0
 800afd8:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 800afdc:	1ad2      	subs	r2, r2, r3
 800afde:	f241 3388 	movw	r3, #5000	@ 0x1388
 800afe2:	429a      	cmp	r2, r3
 800afe4:	d903      	bls.n	800afee <HAL_RCCEx_PeriphCLKConfig+0x802>
          {
            ret = HAL_TIMEOUT;
 800afe6:	2303      	movs	r3, #3
 800afe8:	f887 311f 	strb.w	r3, [r7, #287]	@ 0x11f
            break;
 800afec:	e005      	b.n	800affa <HAL_RCCEx_PeriphCLKConfig+0x80e>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
 800afee:	4b54      	ldr	r3, [pc, #336]	@ (800b140 <HAL_RCCEx_PeriphCLKConfig+0x954>)
 800aff0:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 800aff2:	f003 0302 	and.w	r3, r3, #2
 800aff6:	2b00      	cmp	r3, #0
 800aff8:	d0eb      	beq.n	800afd2 <HAL_RCCEx_PeriphCLKConfig+0x7e6>
          }
        }
      }

      if (ret == HAL_OK)
 800affa:	f897 311f 	ldrb.w	r3, [r7, #287]	@ 0x11f
 800affe:	2b00      	cmp	r3, #0
 800b000:	d129      	bne.n	800b056 <HAL_RCCEx_PeriphCLKConfig+0x86a>
      {
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 800b002:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800b006:	f8d3 30b4 	ldr.w	r3, [r3, #180]	@ 0xb4
 800b00a:	f403 7340 	and.w	r3, r3, #768	@ 0x300
 800b00e:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
 800b012:	d10e      	bne.n	800b032 <HAL_RCCEx_PeriphCLKConfig+0x846>
 800b014:	4b4a      	ldr	r3, [pc, #296]	@ (800b140 <HAL_RCCEx_PeriphCLKConfig+0x954>)
 800b016:	691b      	ldr	r3, [r3, #16]
 800b018:	f423 517c 	bic.w	r1, r3, #16128	@ 0x3f00
 800b01c:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800b020:	f8d3 30b4 	ldr.w	r3, [r3, #180]	@ 0xb4
 800b024:	091a      	lsrs	r2, r3, #4
 800b026:	4b48      	ldr	r3, [pc, #288]	@ (800b148 <HAL_RCCEx_PeriphCLKConfig+0x95c>)
 800b028:	4013      	ands	r3, r2
 800b02a:	4a45      	ldr	r2, [pc, #276]	@ (800b140 <HAL_RCCEx_PeriphCLKConfig+0x954>)
 800b02c:	430b      	orrs	r3, r1
 800b02e:	6113      	str	r3, [r2, #16]
 800b030:	e005      	b.n	800b03e <HAL_RCCEx_PeriphCLKConfig+0x852>
 800b032:	4b43      	ldr	r3, [pc, #268]	@ (800b140 <HAL_RCCEx_PeriphCLKConfig+0x954>)
 800b034:	691b      	ldr	r3, [r3, #16]
 800b036:	4a42      	ldr	r2, [pc, #264]	@ (800b140 <HAL_RCCEx_PeriphCLKConfig+0x954>)
 800b038:	f423 537c 	bic.w	r3, r3, #16128	@ 0x3f00
 800b03c:	6113      	str	r3, [r2, #16]
 800b03e:	4b40      	ldr	r3, [pc, #256]	@ (800b140 <HAL_RCCEx_PeriphCLKConfig+0x954>)
 800b040:	6f19      	ldr	r1, [r3, #112]	@ 0x70
 800b042:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800b046:	f8d3 30b4 	ldr.w	r3, [r3, #180]	@ 0xb4
 800b04a:	f3c3 030b 	ubfx	r3, r3, #0, #12
 800b04e:	4a3c      	ldr	r2, [pc, #240]	@ (800b140 <HAL_RCCEx_PeriphCLKConfig+0x954>)
 800b050:	430b      	orrs	r3, r1
 800b052:	6713      	str	r3, [r2, #112]	@ 0x70
 800b054:	e008      	b.n	800b068 <HAL_RCCEx_PeriphCLKConfig+0x87c>
      }
      else
      {
        /* set overall return value */
        status = ret;
 800b056:	f897 311f 	ldrb.w	r3, [r7, #287]	@ 0x11f
 800b05a:	f887 311e 	strb.w	r3, [r7, #286]	@ 0x11e
 800b05e:	e003      	b.n	800b068 <HAL_RCCEx_PeriphCLKConfig+0x87c>
      }
    }
    else
    {
      /* set overall return value */
      status = ret;
 800b060:	f897 311f 	ldrb.w	r3, [r7, #287]	@ 0x11f
 800b064:	f887 311e 	strb.w	r3, [r7, #286]	@ 0x11e
    }
  }


  /*-------------------------- USART1/6 configuration --------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART16) == RCC_PERIPHCLK_USART16)
 800b068:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800b06c:	e9d3 2300 	ldrd	r2, r3, [r3]
 800b070:	f002 0301 	and.w	r3, r2, #1
 800b074:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
 800b078:	2300      	movs	r3, #0
 800b07a:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
 800b07e:	e9d7 1230 	ldrd	r1, r2, [r7, #192]	@ 0xc0
 800b082:	460b      	mov	r3, r1
 800b084:	4313      	orrs	r3, r2
 800b086:	f000 8090 	beq.w	800b1aa <HAL_RCCEx_PeriphCLKConfig+0x9be>
  {
    switch (PeriphClkInit->Usart16ClockSelection)
 800b08a:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800b08e:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 800b092:	2b28      	cmp	r3, #40	@ 0x28
 800b094:	d870      	bhi.n	800b178 <HAL_RCCEx_PeriphCLKConfig+0x98c>
 800b096:	a201      	add	r2, pc, #4	@ (adr r2, 800b09c <HAL_RCCEx_PeriphCLKConfig+0x8b0>)
 800b098:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800b09c:	0800b181 	.word	0x0800b181
 800b0a0:	0800b179 	.word	0x0800b179
 800b0a4:	0800b179 	.word	0x0800b179
 800b0a8:	0800b179 	.word	0x0800b179
 800b0ac:	0800b179 	.word	0x0800b179
 800b0b0:	0800b179 	.word	0x0800b179
 800b0b4:	0800b179 	.word	0x0800b179
 800b0b8:	0800b179 	.word	0x0800b179
 800b0bc:	0800b14d 	.word	0x0800b14d
 800b0c0:	0800b179 	.word	0x0800b179
 800b0c4:	0800b179 	.word	0x0800b179
 800b0c8:	0800b179 	.word	0x0800b179
 800b0cc:	0800b179 	.word	0x0800b179
 800b0d0:	0800b179 	.word	0x0800b179
 800b0d4:	0800b179 	.word	0x0800b179
 800b0d8:	0800b179 	.word	0x0800b179
 800b0dc:	0800b163 	.word	0x0800b163
 800b0e0:	0800b179 	.word	0x0800b179
 800b0e4:	0800b179 	.word	0x0800b179
 800b0e8:	0800b179 	.word	0x0800b179
 800b0ec:	0800b179 	.word	0x0800b179
 800b0f0:	0800b179 	.word	0x0800b179
 800b0f4:	0800b179 	.word	0x0800b179
 800b0f8:	0800b179 	.word	0x0800b179
 800b0fc:	0800b181 	.word	0x0800b181
 800b100:	0800b179 	.word	0x0800b179
 800b104:	0800b179 	.word	0x0800b179
 800b108:	0800b179 	.word	0x0800b179
 800b10c:	0800b179 	.word	0x0800b179
 800b110:	0800b179 	.word	0x0800b179
 800b114:	0800b179 	.word	0x0800b179
 800b118:	0800b179 	.word	0x0800b179
 800b11c:	0800b181 	.word	0x0800b181
 800b120:	0800b179 	.word	0x0800b179
 800b124:	0800b179 	.word	0x0800b179
 800b128:	0800b179 	.word	0x0800b179
 800b12c:	0800b179 	.word	0x0800b179
 800b130:	0800b179 	.word	0x0800b179
 800b134:	0800b179 	.word	0x0800b179
 800b138:	0800b179 	.word	0x0800b179
 800b13c:	0800b181 	.word	0x0800b181
 800b140:	58024400 	.word	0x58024400
 800b144:	58024800 	.word	0x58024800
 800b148:	00ffffcf 	.word	0x00ffffcf
      case RCC_USART16CLKSOURCE_PCLK2: /* CD/D2 PCLK2 as clock source for USART1/6 */
        /* USART1/6 clock source configuration done later after clock selection check */
        break;

      case RCC_USART16CLKSOURCE_PLL2: /* PLL2 is used as clock source for USART1/6 */
        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_Q_UPDATE);
 800b14c:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800b150:	3308      	adds	r3, #8
 800b152:	2101      	movs	r1, #1
 800b154:	4618      	mov	r0, r3
 800b156:	f001 fdef 	bl	800cd38 <RCCEx_PLL2_Config>
 800b15a:	4603      	mov	r3, r0
 800b15c:	f887 311f 	strb.w	r3, [r7, #287]	@ 0x11f
        /* USART1/6 clock source configuration done later after clock selection check */
        break;
 800b160:	e00f      	b.n	800b182 <HAL_RCCEx_PeriphCLKConfig+0x996>

      case RCC_USART16CLKSOURCE_PLL3: /* PLL3 is used as clock source for USART1/6 */
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_Q_UPDATE);
 800b162:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800b166:	3328      	adds	r3, #40	@ 0x28
 800b168:	2101      	movs	r1, #1
 800b16a:	4618      	mov	r0, r3
 800b16c:	f001 fe96 	bl	800ce9c <RCCEx_PLL3_Config>
 800b170:	4603      	mov	r3, r0
 800b172:	f887 311f 	strb.w	r3, [r7, #287]	@ 0x11f
        /* USART1/6 clock source configuration done later after clock selection check */
        break;
 800b176:	e004      	b.n	800b182 <HAL_RCCEx_PeriphCLKConfig+0x996>
        /* LSE,  oscillator is used as source of USART1/6 clock */
        /* USART1/6 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 800b178:	2301      	movs	r3, #1
 800b17a:	f887 311f 	strb.w	r3, [r7, #287]	@ 0x11f
        break;
 800b17e:	e000      	b.n	800b182 <HAL_RCCEx_PeriphCLKConfig+0x996>
        break;
 800b180:	bf00      	nop
    }

    if (ret == HAL_OK)
 800b182:	f897 311f 	ldrb.w	r3, [r7, #287]	@ 0x11f
 800b186:	2b00      	cmp	r3, #0
 800b188:	d10b      	bne.n	800b1a2 <HAL_RCCEx_PeriphCLKConfig+0x9b6>
    {
      /* Set the source of USART1/6 clock */
      __HAL_RCC_USART16_CONFIG(PeriphClkInit->Usart16ClockSelection);
 800b18a:	4bc0      	ldr	r3, [pc, #768]	@ (800b48c <HAL_RCCEx_PeriphCLKConfig+0xca0>)
 800b18c:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 800b18e:	f023 0138 	bic.w	r1, r3, #56	@ 0x38
 800b192:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800b196:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 800b19a:	4abc      	ldr	r2, [pc, #752]	@ (800b48c <HAL_RCCEx_PeriphCLKConfig+0xca0>)
 800b19c:	430b      	orrs	r3, r1
 800b19e:	6553      	str	r3, [r2, #84]	@ 0x54
 800b1a0:	e003      	b.n	800b1aa <HAL_RCCEx_PeriphCLKConfig+0x9be>
    }
    else
    {
      /* set overall return value */
      status = ret;
 800b1a2:	f897 311f 	ldrb.w	r3, [r7, #287]	@ 0x11f
 800b1a6:	f887 311e 	strb.w	r3, [r7, #286]	@ 0x11e
    }
  }

  /*-------------------------- USART2/3/4/5/7/8 Configuration --------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART234578) == RCC_PERIPHCLK_USART234578)
 800b1aa:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800b1ae:	e9d3 2300 	ldrd	r2, r3, [r3]
 800b1b2:	f002 0302 	and.w	r3, r2, #2
 800b1b6:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8
 800b1ba:	2300      	movs	r3, #0
 800b1bc:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
 800b1c0:	e9d7 122e 	ldrd	r1, r2, [r7, #184]	@ 0xb8
 800b1c4:	460b      	mov	r3, r1
 800b1c6:	4313      	orrs	r3, r2
 800b1c8:	d043      	beq.n	800b252 <HAL_RCCEx_PeriphCLKConfig+0xa66>
  {
    switch (PeriphClkInit->Usart234578ClockSelection)
 800b1ca:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800b1ce:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
 800b1d2:	2b05      	cmp	r3, #5
 800b1d4:	d824      	bhi.n	800b220 <HAL_RCCEx_PeriphCLKConfig+0xa34>
 800b1d6:	a201      	add	r2, pc, #4	@ (adr r2, 800b1dc <HAL_RCCEx_PeriphCLKConfig+0x9f0>)
 800b1d8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800b1dc:	0800b229 	.word	0x0800b229
 800b1e0:	0800b1f5 	.word	0x0800b1f5
 800b1e4:	0800b20b 	.word	0x0800b20b
 800b1e8:	0800b229 	.word	0x0800b229
 800b1ec:	0800b229 	.word	0x0800b229
 800b1f0:	0800b229 	.word	0x0800b229
      case RCC_USART234578CLKSOURCE_PCLK1: /* CD/D2 PCLK1 as clock source for USART2/3/4/5/7/8 */
        /* USART2/3/4/5/7/8 clock source configuration done later after clock selection check */
        break;

      case RCC_USART234578CLKSOURCE_PLL2: /* PLL2 is used as clock source for USART2/3/4/5/7/8 */
        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_Q_UPDATE);
 800b1f4:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800b1f8:	3308      	adds	r3, #8
 800b1fa:	2101      	movs	r1, #1
 800b1fc:	4618      	mov	r0, r3
 800b1fe:	f001 fd9b 	bl	800cd38 <RCCEx_PLL2_Config>
 800b202:	4603      	mov	r3, r0
 800b204:	f887 311f 	strb.w	r3, [r7, #287]	@ 0x11f
        /* USART2/3/4/5/7/8 clock source configuration done later after clock selection check */
        break;
 800b208:	e00f      	b.n	800b22a <HAL_RCCEx_PeriphCLKConfig+0xa3e>

      case RCC_USART234578CLKSOURCE_PLL3: /* PLL3 is used as clock source for USART2/3/4/5/7/8 */
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_Q_UPDATE);
 800b20a:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800b20e:	3328      	adds	r3, #40	@ 0x28
 800b210:	2101      	movs	r1, #1
 800b212:	4618      	mov	r0, r3
 800b214:	f001 fe42 	bl	800ce9c <RCCEx_PLL3_Config>
 800b218:	4603      	mov	r3, r0
 800b21a:	f887 311f 	strb.w	r3, [r7, #287]	@ 0x11f
        /* USART2/3/4/5/7/8 clock source configuration done later after clock selection check */
        break;
 800b21e:	e004      	b.n	800b22a <HAL_RCCEx_PeriphCLKConfig+0xa3e>
        /* LSE,  oscillator is used as source of USART2/3/4/5/7/8 clock */
        /* USART2/3/4/5/7/8 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 800b220:	2301      	movs	r3, #1
 800b222:	f887 311f 	strb.w	r3, [r7, #287]	@ 0x11f
        break;
 800b226:	e000      	b.n	800b22a <HAL_RCCEx_PeriphCLKConfig+0xa3e>
        break;
 800b228:	bf00      	nop
    }

    if (ret == HAL_OK)
 800b22a:	f897 311f 	ldrb.w	r3, [r7, #287]	@ 0x11f
 800b22e:	2b00      	cmp	r3, #0
 800b230:	d10b      	bne.n	800b24a <HAL_RCCEx_PeriphCLKConfig+0xa5e>
    {
      /* Set the source of USART2/3/4/5/7/8 clock */
      __HAL_RCC_USART234578_CONFIG(PeriphClkInit->Usart234578ClockSelection);
 800b232:	4b96      	ldr	r3, [pc, #600]	@ (800b48c <HAL_RCCEx_PeriphCLKConfig+0xca0>)
 800b234:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 800b236:	f023 0107 	bic.w	r1, r3, #7
 800b23a:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800b23e:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
 800b242:	4a92      	ldr	r2, [pc, #584]	@ (800b48c <HAL_RCCEx_PeriphCLKConfig+0xca0>)
 800b244:	430b      	orrs	r3, r1
 800b246:	6553      	str	r3, [r2, #84]	@ 0x54
 800b248:	e003      	b.n	800b252 <HAL_RCCEx_PeriphCLKConfig+0xa66>
    }
    else
    {
      /* set overall return value */
      status = ret;
 800b24a:	f897 311f 	ldrb.w	r3, [r7, #287]	@ 0x11f
 800b24e:	f887 311e 	strb.w	r3, [r7, #286]	@ 0x11e
    }
  }

  /*-------------------------- LPUART1 Configuration -------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
 800b252:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800b256:	e9d3 2300 	ldrd	r2, r3, [r3]
 800b25a:	f002 0304 	and.w	r3, r2, #4
 800b25e:	f8c7 30b0 	str.w	r3, [r7, #176]	@ 0xb0
 800b262:	2300      	movs	r3, #0
 800b264:	f8c7 30b4 	str.w	r3, [r7, #180]	@ 0xb4
 800b268:	e9d7 122c 	ldrd	r1, r2, [r7, #176]	@ 0xb0
 800b26c:	460b      	mov	r3, r1
 800b26e:	4313      	orrs	r3, r2
 800b270:	d043      	beq.n	800b2fa <HAL_RCCEx_PeriphCLKConfig+0xb0e>
  {
    switch (PeriphClkInit->Lpuart1ClockSelection)
 800b272:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800b276:	f8d3 309c 	ldr.w	r3, [r3, #156]	@ 0x9c
 800b27a:	2b05      	cmp	r3, #5
 800b27c:	d824      	bhi.n	800b2c8 <HAL_RCCEx_PeriphCLKConfig+0xadc>
 800b27e:	a201      	add	r2, pc, #4	@ (adr r2, 800b284 <HAL_RCCEx_PeriphCLKConfig+0xa98>)
 800b280:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800b284:	0800b2d1 	.word	0x0800b2d1
 800b288:	0800b29d 	.word	0x0800b29d
 800b28c:	0800b2b3 	.word	0x0800b2b3
 800b290:	0800b2d1 	.word	0x0800b2d1
 800b294:	0800b2d1 	.word	0x0800b2d1
 800b298:	0800b2d1 	.word	0x0800b2d1
      case RCC_LPUART1CLKSOURCE_PCLK4: /* SRD/D3 PCLK1 (PCLK4) as clock source for LPUART1 */
        /* LPUART1 clock source configuration done later after clock selection check */
        break;

      case RCC_LPUART1CLKSOURCE_PLL2: /* PLL2 is used as clock source for LPUART1 */
        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_Q_UPDATE);
 800b29c:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800b2a0:	3308      	adds	r3, #8
 800b2a2:	2101      	movs	r1, #1
 800b2a4:	4618      	mov	r0, r3
 800b2a6:	f001 fd47 	bl	800cd38 <RCCEx_PLL2_Config>
 800b2aa:	4603      	mov	r3, r0
 800b2ac:	f887 311f 	strb.w	r3, [r7, #287]	@ 0x11f
        /* LPUART1 clock source configuration done later after clock selection check */
        break;
 800b2b0:	e00f      	b.n	800b2d2 <HAL_RCCEx_PeriphCLKConfig+0xae6>

      case RCC_LPUART1CLKSOURCE_PLL3: /* PLL3 is used as clock source for LPUART1 */
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_Q_UPDATE);
 800b2b2:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800b2b6:	3328      	adds	r3, #40	@ 0x28
 800b2b8:	2101      	movs	r1, #1
 800b2ba:	4618      	mov	r0, r3
 800b2bc:	f001 fdee 	bl	800ce9c <RCCEx_PLL3_Config>
 800b2c0:	4603      	mov	r3, r0
 800b2c2:	f887 311f 	strb.w	r3, [r7, #287]	@ 0x11f
        /* LPUART1 clock source configuration done later after clock selection check */
        break;
 800b2c6:	e004      	b.n	800b2d2 <HAL_RCCEx_PeriphCLKConfig+0xae6>
        /* LSE,  oscillator is used as source of LPUART1 clock */
        /* LPUART1 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 800b2c8:	2301      	movs	r3, #1
 800b2ca:	f887 311f 	strb.w	r3, [r7, #287]	@ 0x11f
        break;
 800b2ce:	e000      	b.n	800b2d2 <HAL_RCCEx_PeriphCLKConfig+0xae6>
        break;
 800b2d0:	bf00      	nop
    }

    if (ret == HAL_OK)
 800b2d2:	f897 311f 	ldrb.w	r3, [r7, #287]	@ 0x11f
 800b2d6:	2b00      	cmp	r3, #0
 800b2d8:	d10b      	bne.n	800b2f2 <HAL_RCCEx_PeriphCLKConfig+0xb06>
    {
      /* Set the source of LPUART1 clock */
      __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
 800b2da:	4b6c      	ldr	r3, [pc, #432]	@ (800b48c <HAL_RCCEx_PeriphCLKConfig+0xca0>)
 800b2dc:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 800b2de:	f023 0107 	bic.w	r1, r3, #7
 800b2e2:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800b2e6:	f8d3 309c 	ldr.w	r3, [r3, #156]	@ 0x9c
 800b2ea:	4a68      	ldr	r2, [pc, #416]	@ (800b48c <HAL_RCCEx_PeriphCLKConfig+0xca0>)
 800b2ec:	430b      	orrs	r3, r1
 800b2ee:	6593      	str	r3, [r2, #88]	@ 0x58
 800b2f0:	e003      	b.n	800b2fa <HAL_RCCEx_PeriphCLKConfig+0xb0e>
    }
    else
    {
      /* set overall return value */
      status = ret;
 800b2f2:	f897 311f 	ldrb.w	r3, [r7, #287]	@ 0x11f
 800b2f6:	f887 311e 	strb.w	r3, [r7, #286]	@ 0x11e
    }
  }

  /*---------------------------- LPTIM1 configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == RCC_PERIPHCLK_LPTIM1)
 800b2fa:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800b2fe:	e9d3 2300 	ldrd	r2, r3, [r3]
 800b302:	f002 0320 	and.w	r3, r2, #32
 800b306:	f8c7 30a8 	str.w	r3, [r7, #168]	@ 0xa8
 800b30a:	2300      	movs	r3, #0
 800b30c:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac
 800b310:	e9d7 122a 	ldrd	r1, r2, [r7, #168]	@ 0xa8
 800b314:	460b      	mov	r3, r1
 800b316:	4313      	orrs	r3, r2
 800b318:	d055      	beq.n	800b3c6 <HAL_RCCEx_PeriphCLKConfig+0xbda>
  {
    switch (PeriphClkInit->Lptim1ClockSelection)
 800b31a:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800b31e:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
 800b322:	f1b3 4fa0 	cmp.w	r3, #1342177280	@ 0x50000000
 800b326:	d033      	beq.n	800b390 <HAL_RCCEx_PeriphCLKConfig+0xba4>
 800b328:	f1b3 4fa0 	cmp.w	r3, #1342177280	@ 0x50000000
 800b32c:	d82c      	bhi.n	800b388 <HAL_RCCEx_PeriphCLKConfig+0xb9c>
 800b32e:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 800b332:	d02f      	beq.n	800b394 <HAL_RCCEx_PeriphCLKConfig+0xba8>
 800b334:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 800b338:	d826      	bhi.n	800b388 <HAL_RCCEx_PeriphCLKConfig+0xb9c>
 800b33a:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
 800b33e:	d02b      	beq.n	800b398 <HAL_RCCEx_PeriphCLKConfig+0xbac>
 800b340:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
 800b344:	d820      	bhi.n	800b388 <HAL_RCCEx_PeriphCLKConfig+0xb9c>
 800b346:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 800b34a:	d012      	beq.n	800b372 <HAL_RCCEx_PeriphCLKConfig+0xb86>
 800b34c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 800b350:	d81a      	bhi.n	800b388 <HAL_RCCEx_PeriphCLKConfig+0xb9c>
 800b352:	2b00      	cmp	r3, #0
 800b354:	d022      	beq.n	800b39c <HAL_RCCEx_PeriphCLKConfig+0xbb0>
 800b356:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
 800b35a:	d115      	bne.n	800b388 <HAL_RCCEx_PeriphCLKConfig+0xb9c>
        /* LPTIM1 clock source configuration done later after clock selection check */
        break;

      case RCC_LPTIM1CLKSOURCE_PLL2: /* PLL2 is used as clock source for LPTIM1*/

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_P_UPDATE);
 800b35c:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800b360:	3308      	adds	r3, #8
 800b362:	2100      	movs	r1, #0
 800b364:	4618      	mov	r0, r3
 800b366:	f001 fce7 	bl	800cd38 <RCCEx_PLL2_Config>
 800b36a:	4603      	mov	r3, r0
 800b36c:	f887 311f 	strb.w	r3, [r7, #287]	@ 0x11f

        /* LPTIM1 clock source configuration done later after clock selection check */
        break;
 800b370:	e015      	b.n	800b39e <HAL_RCCEx_PeriphCLKConfig+0xbb2>

      case RCC_LPTIM1CLKSOURCE_PLL3:  /* PLL3 is used as clock source for LPTIM1*/
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_R_UPDATE);
 800b372:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800b376:	3328      	adds	r3, #40	@ 0x28
 800b378:	2102      	movs	r1, #2
 800b37a:	4618      	mov	r0, r3
 800b37c:	f001 fd8e 	bl	800ce9c <RCCEx_PLL3_Config>
 800b380:	4603      	mov	r3, r0
 800b382:	f887 311f 	strb.w	r3, [r7, #287]	@ 0x11f

        /* LPTIM1 clock source configuration done later after clock selection check */
        break;
 800b386:	e00a      	b.n	800b39e <HAL_RCCEx_PeriphCLKConfig+0xbb2>
        /* HSI, HSE, or CSI oscillator is used as source of LPTIM1 clock */
        /* LPTIM1 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 800b388:	2301      	movs	r3, #1
 800b38a:	f887 311f 	strb.w	r3, [r7, #287]	@ 0x11f
        break;
 800b38e:	e006      	b.n	800b39e <HAL_RCCEx_PeriphCLKConfig+0xbb2>
        break;
 800b390:	bf00      	nop
 800b392:	e004      	b.n	800b39e <HAL_RCCEx_PeriphCLKConfig+0xbb2>
        break;
 800b394:	bf00      	nop
 800b396:	e002      	b.n	800b39e <HAL_RCCEx_PeriphCLKConfig+0xbb2>
        break;
 800b398:	bf00      	nop
 800b39a:	e000      	b.n	800b39e <HAL_RCCEx_PeriphCLKConfig+0xbb2>
        break;
 800b39c:	bf00      	nop
    }

    if (ret == HAL_OK)
 800b39e:	f897 311f 	ldrb.w	r3, [r7, #287]	@ 0x11f
 800b3a2:	2b00      	cmp	r3, #0
 800b3a4:	d10b      	bne.n	800b3be <HAL_RCCEx_PeriphCLKConfig+0xbd2>
    {
      /* Set the source of LPTIM1 clock*/
      __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
 800b3a6:	4b39      	ldr	r3, [pc, #228]	@ (800b48c <HAL_RCCEx_PeriphCLKConfig+0xca0>)
 800b3a8:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 800b3aa:	f023 41e0 	bic.w	r1, r3, #1879048192	@ 0x70000000
 800b3ae:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800b3b2:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
 800b3b6:	4a35      	ldr	r2, [pc, #212]	@ (800b48c <HAL_RCCEx_PeriphCLKConfig+0xca0>)
 800b3b8:	430b      	orrs	r3, r1
 800b3ba:	6553      	str	r3, [r2, #84]	@ 0x54
 800b3bc:	e003      	b.n	800b3c6 <HAL_RCCEx_PeriphCLKConfig+0xbda>
    }
    else
    {
      /* set overall return value */
      status = ret;
 800b3be:	f897 311f 	ldrb.w	r3, [r7, #287]	@ 0x11f
 800b3c2:	f887 311e 	strb.w	r3, [r7, #286]	@ 0x11e
    }
  }

  /*---------------------------- LPTIM2 configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM2) == RCC_PERIPHCLK_LPTIM2)
 800b3c6:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800b3ca:	e9d3 2300 	ldrd	r2, r3, [r3]
 800b3ce:	f002 0340 	and.w	r3, r2, #64	@ 0x40
 800b3d2:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0
 800b3d6:	2300      	movs	r3, #0
 800b3d8:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4
 800b3dc:	e9d7 1228 	ldrd	r1, r2, [r7, #160]	@ 0xa0
 800b3e0:	460b      	mov	r3, r1
 800b3e2:	4313      	orrs	r3, r2
 800b3e4:	d058      	beq.n	800b498 <HAL_RCCEx_PeriphCLKConfig+0xcac>
  {
    switch (PeriphClkInit->Lptim2ClockSelection)
 800b3e6:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800b3ea:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
 800b3ee:	f5b3 5fa0 	cmp.w	r3, #5120	@ 0x1400
 800b3f2:	d033      	beq.n	800b45c <HAL_RCCEx_PeriphCLKConfig+0xc70>
 800b3f4:	f5b3 5fa0 	cmp.w	r3, #5120	@ 0x1400
 800b3f8:	d82c      	bhi.n	800b454 <HAL_RCCEx_PeriphCLKConfig+0xc68>
 800b3fa:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 800b3fe:	d02f      	beq.n	800b460 <HAL_RCCEx_PeriphCLKConfig+0xc74>
 800b400:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 800b404:	d826      	bhi.n	800b454 <HAL_RCCEx_PeriphCLKConfig+0xc68>
 800b406:	f5b3 6f40 	cmp.w	r3, #3072	@ 0xc00
 800b40a:	d02b      	beq.n	800b464 <HAL_RCCEx_PeriphCLKConfig+0xc78>
 800b40c:	f5b3 6f40 	cmp.w	r3, #3072	@ 0xc00
 800b410:	d820      	bhi.n	800b454 <HAL_RCCEx_PeriphCLKConfig+0xc68>
 800b412:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
 800b416:	d012      	beq.n	800b43e <HAL_RCCEx_PeriphCLKConfig+0xc52>
 800b418:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
 800b41c:	d81a      	bhi.n	800b454 <HAL_RCCEx_PeriphCLKConfig+0xc68>
 800b41e:	2b00      	cmp	r3, #0
 800b420:	d022      	beq.n	800b468 <HAL_RCCEx_PeriphCLKConfig+0xc7c>
 800b422:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 800b426:	d115      	bne.n	800b454 <HAL_RCCEx_PeriphCLKConfig+0xc68>
        /* LPTIM2 clock source configuration done later after clock selection check */
        break;

      case RCC_LPTIM2CLKSOURCE_PLL2: /* PLL2 is used as clock source for LPTIM2*/

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_P_UPDATE);
 800b428:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800b42c:	3308      	adds	r3, #8
 800b42e:	2100      	movs	r1, #0
 800b430:	4618      	mov	r0, r3
 800b432:	f001 fc81 	bl	800cd38 <RCCEx_PLL2_Config>
 800b436:	4603      	mov	r3, r0
 800b438:	f887 311f 	strb.w	r3, [r7, #287]	@ 0x11f

        /* LPTIM2 clock source configuration done later after clock selection check */
        break;
 800b43c:	e015      	b.n	800b46a <HAL_RCCEx_PeriphCLKConfig+0xc7e>

      case RCC_LPTIM2CLKSOURCE_PLL3:  /* PLL3 is used as clock source for LPTIM2*/
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_R_UPDATE);
 800b43e:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800b442:	3328      	adds	r3, #40	@ 0x28
 800b444:	2102      	movs	r1, #2
 800b446:	4618      	mov	r0, r3
 800b448:	f001 fd28 	bl	800ce9c <RCCEx_PLL3_Config>
 800b44c:	4603      	mov	r3, r0
 800b44e:	f887 311f 	strb.w	r3, [r7, #287]	@ 0x11f

        /* LPTIM2 clock source configuration done later after clock selection check */
        break;
 800b452:	e00a      	b.n	800b46a <HAL_RCCEx_PeriphCLKConfig+0xc7e>
        /* HSI, HSE, or CSI oscillator is used as source of LPTIM2 clock */
        /* LPTIM2 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 800b454:	2301      	movs	r3, #1
 800b456:	f887 311f 	strb.w	r3, [r7, #287]	@ 0x11f
        break;
 800b45a:	e006      	b.n	800b46a <HAL_RCCEx_PeriphCLKConfig+0xc7e>
        break;
 800b45c:	bf00      	nop
 800b45e:	e004      	b.n	800b46a <HAL_RCCEx_PeriphCLKConfig+0xc7e>
        break;
 800b460:	bf00      	nop
 800b462:	e002      	b.n	800b46a <HAL_RCCEx_PeriphCLKConfig+0xc7e>
        break;
 800b464:	bf00      	nop
 800b466:	e000      	b.n	800b46a <HAL_RCCEx_PeriphCLKConfig+0xc7e>
        break;
 800b468:	bf00      	nop
    }

    if (ret == HAL_OK)
 800b46a:	f897 311f 	ldrb.w	r3, [r7, #287]	@ 0x11f
 800b46e:	2b00      	cmp	r3, #0
 800b470:	d10e      	bne.n	800b490 <HAL_RCCEx_PeriphCLKConfig+0xca4>
    {
      /* Set the source of LPTIM2 clock*/
      __HAL_RCC_LPTIM2_CONFIG(PeriphClkInit->Lptim2ClockSelection);
 800b472:	4b06      	ldr	r3, [pc, #24]	@ (800b48c <HAL_RCCEx_PeriphCLKConfig+0xca0>)
 800b474:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 800b476:	f423 51e0 	bic.w	r1, r3, #7168	@ 0x1c00
 800b47a:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800b47e:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
 800b482:	4a02      	ldr	r2, [pc, #8]	@ (800b48c <HAL_RCCEx_PeriphCLKConfig+0xca0>)
 800b484:	430b      	orrs	r3, r1
 800b486:	6593      	str	r3, [r2, #88]	@ 0x58
 800b488:	e006      	b.n	800b498 <HAL_RCCEx_PeriphCLKConfig+0xcac>
 800b48a:	bf00      	nop
 800b48c:	58024400 	.word	0x58024400
    }
    else
    {
      /* set overall return value */
      status = ret;
 800b490:	f897 311f 	ldrb.w	r3, [r7, #287]	@ 0x11f
 800b494:	f887 311e 	strb.w	r3, [r7, #286]	@ 0x11e
    }
  }

  /*---------------------------- LPTIM345 configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM345) == RCC_PERIPHCLK_LPTIM345)
 800b498:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800b49c:	e9d3 2300 	ldrd	r2, r3, [r3]
 800b4a0:	f002 0380 	and.w	r3, r2, #128	@ 0x80
 800b4a4:	f8c7 3098 	str.w	r3, [r7, #152]	@ 0x98
 800b4a8:	2300      	movs	r3, #0
 800b4aa:	f8c7 309c 	str.w	r3, [r7, #156]	@ 0x9c
 800b4ae:	e9d7 1226 	ldrd	r1, r2, [r7, #152]	@ 0x98
 800b4b2:	460b      	mov	r3, r1
 800b4b4:	4313      	orrs	r3, r2
 800b4b6:	d055      	beq.n	800b564 <HAL_RCCEx_PeriphCLKConfig+0xd78>
  {
    switch (PeriphClkInit->Lptim345ClockSelection)
 800b4b8:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800b4bc:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
 800b4c0:	f5b3 4f20 	cmp.w	r3, #40960	@ 0xa000
 800b4c4:	d033      	beq.n	800b52e <HAL_RCCEx_PeriphCLKConfig+0xd42>
 800b4c6:	f5b3 4f20 	cmp.w	r3, #40960	@ 0xa000
 800b4ca:	d82c      	bhi.n	800b526 <HAL_RCCEx_PeriphCLKConfig+0xd3a>
 800b4cc:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
 800b4d0:	d02f      	beq.n	800b532 <HAL_RCCEx_PeriphCLKConfig+0xd46>
 800b4d2:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
 800b4d6:	d826      	bhi.n	800b526 <HAL_RCCEx_PeriphCLKConfig+0xd3a>
 800b4d8:	f5b3 4fc0 	cmp.w	r3, #24576	@ 0x6000
 800b4dc:	d02b      	beq.n	800b536 <HAL_RCCEx_PeriphCLKConfig+0xd4a>
 800b4de:	f5b3 4fc0 	cmp.w	r3, #24576	@ 0x6000
 800b4e2:	d820      	bhi.n	800b526 <HAL_RCCEx_PeriphCLKConfig+0xd3a>
 800b4e4:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
 800b4e8:	d012      	beq.n	800b510 <HAL_RCCEx_PeriphCLKConfig+0xd24>
 800b4ea:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
 800b4ee:	d81a      	bhi.n	800b526 <HAL_RCCEx_PeriphCLKConfig+0xd3a>
 800b4f0:	2b00      	cmp	r3, #0
 800b4f2:	d022      	beq.n	800b53a <HAL_RCCEx_PeriphCLKConfig+0xd4e>
 800b4f4:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 800b4f8:	d115      	bne.n	800b526 <HAL_RCCEx_PeriphCLKConfig+0xd3a>
      case RCC_LPTIM345CLKSOURCE_PCLK4:      /* SRD/D3 PCLK1 (PCLK4) as clock source for LPTIM3/4/5 */
        /* LPTIM3/4/5 clock source configuration done later after clock selection check */
        break;

      case RCC_LPTIM345CLKSOURCE_PLL2: /* PLL2 is used as clock source for LPTIM3/4/5 */
        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_P_UPDATE);
 800b4fa:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800b4fe:	3308      	adds	r3, #8
 800b500:	2100      	movs	r1, #0
 800b502:	4618      	mov	r0, r3
 800b504:	f001 fc18 	bl	800cd38 <RCCEx_PLL2_Config>
 800b508:	4603      	mov	r3, r0
 800b50a:	f887 311f 	strb.w	r3, [r7, #287]	@ 0x11f

        /* LPTIM3/4/5 clock source configuration done later after clock selection check */
        break;
 800b50e:	e015      	b.n	800b53c <HAL_RCCEx_PeriphCLKConfig+0xd50>

      case RCC_LPTIM345CLKSOURCE_PLL3:  /* PLL3 is used as clock source for LPTIM3/4/5 */
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_R_UPDATE);
 800b510:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800b514:	3328      	adds	r3, #40	@ 0x28
 800b516:	2102      	movs	r1, #2
 800b518:	4618      	mov	r0, r3
 800b51a:	f001 fcbf 	bl	800ce9c <RCCEx_PLL3_Config>
 800b51e:	4603      	mov	r3, r0
 800b520:	f887 311f 	strb.w	r3, [r7, #287]	@ 0x11f

        /* LPTIM3/4/5 clock source configuration done later after clock selection check */
        break;
 800b524:	e00a      	b.n	800b53c <HAL_RCCEx_PeriphCLKConfig+0xd50>
        /* HSI, HSE, or CSI oscillator is used as source of LPTIM3/4/5 clock */
        /* LPTIM3/4/5 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 800b526:	2301      	movs	r3, #1
 800b528:	f887 311f 	strb.w	r3, [r7, #287]	@ 0x11f
        break;
 800b52c:	e006      	b.n	800b53c <HAL_RCCEx_PeriphCLKConfig+0xd50>
        break;
 800b52e:	bf00      	nop
 800b530:	e004      	b.n	800b53c <HAL_RCCEx_PeriphCLKConfig+0xd50>
        break;
 800b532:	bf00      	nop
 800b534:	e002      	b.n	800b53c <HAL_RCCEx_PeriphCLKConfig+0xd50>
        break;
 800b536:	bf00      	nop
 800b538:	e000      	b.n	800b53c <HAL_RCCEx_PeriphCLKConfig+0xd50>
        break;
 800b53a:	bf00      	nop
    }

    if (ret == HAL_OK)
 800b53c:	f897 311f 	ldrb.w	r3, [r7, #287]	@ 0x11f
 800b540:	2b00      	cmp	r3, #0
 800b542:	d10b      	bne.n	800b55c <HAL_RCCEx_PeriphCLKConfig+0xd70>
    {
      /* Set the source of LPTIM3/4/5 clock */
      __HAL_RCC_LPTIM345_CONFIG(PeriphClkInit->Lptim345ClockSelection);
 800b544:	4ba1      	ldr	r3, [pc, #644]	@ (800b7cc <HAL_RCCEx_PeriphCLKConfig+0xfe0>)
 800b546:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 800b548:	f423 4160 	bic.w	r1, r3, #57344	@ 0xe000
 800b54c:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800b550:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
 800b554:	4a9d      	ldr	r2, [pc, #628]	@ (800b7cc <HAL_RCCEx_PeriphCLKConfig+0xfe0>)
 800b556:	430b      	orrs	r3, r1
 800b558:	6593      	str	r3, [r2, #88]	@ 0x58
 800b55a:	e003      	b.n	800b564 <HAL_RCCEx_PeriphCLKConfig+0xd78>
    }
    else
    {
      /* set overall return value */
      status = ret;
 800b55c:	f897 311f 	ldrb.w	r3, [r7, #287]	@ 0x11f
 800b560:	f887 311e 	strb.w	r3, [r7, #286]	@ 0x11e

    __HAL_RCC_I2C1235_CONFIG(PeriphClkInit->I2c1235ClockSelection);

  }
#else
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C123) == RCC_PERIPHCLK_I2C123)
 800b564:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800b568:	e9d3 2300 	ldrd	r2, r3, [r3]
 800b56c:	f002 0308 	and.w	r3, r2, #8
 800b570:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
 800b574:	2300      	movs	r3, #0
 800b576:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94
 800b57a:	e9d7 1224 	ldrd	r1, r2, [r7, #144]	@ 0x90
 800b57e:	460b      	mov	r3, r1
 800b580:	4313      	orrs	r3, r2
 800b582:	d01e      	beq.n	800b5c2 <HAL_RCCEx_PeriphCLKConfig+0xdd6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C123CLKSOURCE(PeriphClkInit->I2c123ClockSelection));

    if ((PeriphClkInit->I2c123ClockSelection) == RCC_I2C123CLKSOURCE_PLL3)
 800b584:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800b588:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800b58c:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 800b590:	d10c      	bne.n	800b5ac <HAL_RCCEx_PeriphCLKConfig+0xdc0>
    {
      if (RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_R_UPDATE) != HAL_OK)
 800b592:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800b596:	3328      	adds	r3, #40	@ 0x28
 800b598:	2102      	movs	r1, #2
 800b59a:	4618      	mov	r0, r3
 800b59c:	f001 fc7e 	bl	800ce9c <RCCEx_PLL3_Config>
 800b5a0:	4603      	mov	r3, r0
 800b5a2:	2b00      	cmp	r3, #0
 800b5a4:	d002      	beq.n	800b5ac <HAL_RCCEx_PeriphCLKConfig+0xdc0>
      {
        status = HAL_ERROR;
 800b5a6:	2301      	movs	r3, #1
 800b5a8:	f887 311e 	strb.w	r3, [r7, #286]	@ 0x11e
      }
    }

    __HAL_RCC_I2C123_CONFIG(PeriphClkInit->I2c123ClockSelection);
 800b5ac:	4b87      	ldr	r3, [pc, #540]	@ (800b7cc <HAL_RCCEx_PeriphCLKConfig+0xfe0>)
 800b5ae:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 800b5b0:	f423 5140 	bic.w	r1, r3, #12288	@ 0x3000
 800b5b4:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800b5b8:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 800b5bc:	4a83      	ldr	r2, [pc, #524]	@ (800b7cc <HAL_RCCEx_PeriphCLKConfig+0xfe0>)
 800b5be:	430b      	orrs	r3, r1
 800b5c0:	6553      	str	r3, [r2, #84]	@ 0x54

  }
#endif /* I2C5 */

  /*------------------------------ I2C4 Configuration ------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
 800b5c2:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800b5c6:	e9d3 2300 	ldrd	r2, r3, [r3]
 800b5ca:	f002 0310 	and.w	r3, r2, #16
 800b5ce:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
 800b5d2:	2300      	movs	r3, #0
 800b5d4:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
 800b5d8:	e9d7 1222 	ldrd	r1, r2, [r7, #136]	@ 0x88
 800b5dc:	460b      	mov	r3, r1
 800b5de:	4313      	orrs	r3, r2
 800b5e0:	d01e      	beq.n	800b620 <HAL_RCCEx_PeriphCLKConfig+0xe34>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C4CLKSOURCE(PeriphClkInit->I2c4ClockSelection));

    if ((PeriphClkInit->I2c4ClockSelection) == RCC_I2C4CLKSOURCE_PLL3)
 800b5e2:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800b5e6:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
 800b5ea:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 800b5ee:	d10c      	bne.n	800b60a <HAL_RCCEx_PeriphCLKConfig+0xe1e>
    {
      if (RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_R_UPDATE) != HAL_OK)
 800b5f0:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800b5f4:	3328      	adds	r3, #40	@ 0x28
 800b5f6:	2102      	movs	r1, #2
 800b5f8:	4618      	mov	r0, r3
 800b5fa:	f001 fc4f 	bl	800ce9c <RCCEx_PLL3_Config>
 800b5fe:	4603      	mov	r3, r0
 800b600:	2b00      	cmp	r3, #0
 800b602:	d002      	beq.n	800b60a <HAL_RCCEx_PeriphCLKConfig+0xe1e>
      {
        status = HAL_ERROR;
 800b604:	2301      	movs	r3, #1
 800b606:	f887 311e 	strb.w	r3, [r7, #286]	@ 0x11e
      }
    }

    __HAL_RCC_I2C4_CONFIG(PeriphClkInit->I2c4ClockSelection);
 800b60a:	4b70      	ldr	r3, [pc, #448]	@ (800b7cc <HAL_RCCEx_PeriphCLKConfig+0xfe0>)
 800b60c:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 800b60e:	f423 7140 	bic.w	r1, r3, #768	@ 0x300
 800b612:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800b616:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
 800b61a:	4a6c      	ldr	r2, [pc, #432]	@ (800b7cc <HAL_RCCEx_PeriphCLKConfig+0xfe0>)
 800b61c:	430b      	orrs	r3, r1
 800b61e:	6593      	str	r3, [r2, #88]	@ 0x58

  }

  /*---------------------------- ADC configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
 800b620:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800b624:	e9d3 2300 	ldrd	r2, r3, [r3]
 800b628:	f402 2300 	and.w	r3, r2, #524288	@ 0x80000
 800b62c:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
 800b630:	2300      	movs	r3, #0
 800b632:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
 800b636:	e9d7 1220 	ldrd	r1, r2, [r7, #128]	@ 0x80
 800b63a:	460b      	mov	r3, r1
 800b63c:	4313      	orrs	r3, r2
 800b63e:	d03e      	beq.n	800b6be <HAL_RCCEx_PeriphCLKConfig+0xed2>
  {
    switch (PeriphClkInit->AdcClockSelection)
 800b640:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800b644:	f8d3 30ac 	ldr.w	r3, [r3, #172]	@ 0xac
 800b648:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 800b64c:	d022      	beq.n	800b694 <HAL_RCCEx_PeriphCLKConfig+0xea8>
 800b64e:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 800b652:	d81b      	bhi.n	800b68c <HAL_RCCEx_PeriphCLKConfig+0xea0>
 800b654:	2b00      	cmp	r3, #0
 800b656:	d003      	beq.n	800b660 <HAL_RCCEx_PeriphCLKConfig+0xe74>
 800b658:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 800b65c:	d00b      	beq.n	800b676 <HAL_RCCEx_PeriphCLKConfig+0xe8a>
 800b65e:	e015      	b.n	800b68c <HAL_RCCEx_PeriphCLKConfig+0xea0>
    {

      case RCC_ADCCLKSOURCE_PLL2: /* PLL2 is used as clock source for ADC*/

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_P_UPDATE);
 800b660:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800b664:	3308      	adds	r3, #8
 800b666:	2100      	movs	r1, #0
 800b668:	4618      	mov	r0, r3
 800b66a:	f001 fb65 	bl	800cd38 <RCCEx_PLL2_Config>
 800b66e:	4603      	mov	r3, r0
 800b670:	f887 311f 	strb.w	r3, [r7, #287]	@ 0x11f

        /* ADC clock source configuration done later after clock selection check */
        break;
 800b674:	e00f      	b.n	800b696 <HAL_RCCEx_PeriphCLKConfig+0xeaa>

      case RCC_ADCCLKSOURCE_PLL3:  /* PLL3 is used as clock source for ADC*/
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_R_UPDATE);
 800b676:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800b67a:	3328      	adds	r3, #40	@ 0x28
 800b67c:	2102      	movs	r1, #2
 800b67e:	4618      	mov	r0, r3
 800b680:	f001 fc0c 	bl	800ce9c <RCCEx_PLL3_Config>
 800b684:	4603      	mov	r3, r0
 800b686:	f887 311f 	strb.w	r3, [r7, #287]	@ 0x11f

        /* ADC clock source configuration done later after clock selection check */
        break;
 800b68a:	e004      	b.n	800b696 <HAL_RCCEx_PeriphCLKConfig+0xeaa>
        /* HSI, HSE, or CSI oscillator is used as source of ADC clock */
        /* ADC clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 800b68c:	2301      	movs	r3, #1
 800b68e:	f887 311f 	strb.w	r3, [r7, #287]	@ 0x11f
        break;
 800b692:	e000      	b.n	800b696 <HAL_RCCEx_PeriphCLKConfig+0xeaa>
        break;
 800b694:	bf00      	nop
    }

    if (ret == HAL_OK)
 800b696:	f897 311f 	ldrb.w	r3, [r7, #287]	@ 0x11f
 800b69a:	2b00      	cmp	r3, #0
 800b69c:	d10b      	bne.n	800b6b6 <HAL_RCCEx_PeriphCLKConfig+0xeca>
    {
      /* Set the source of ADC clock*/
      __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
 800b69e:	4b4b      	ldr	r3, [pc, #300]	@ (800b7cc <HAL_RCCEx_PeriphCLKConfig+0xfe0>)
 800b6a0:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 800b6a2:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
 800b6a6:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800b6aa:	f8d3 30ac 	ldr.w	r3, [r3, #172]	@ 0xac
 800b6ae:	4a47      	ldr	r2, [pc, #284]	@ (800b7cc <HAL_RCCEx_PeriphCLKConfig+0xfe0>)
 800b6b0:	430b      	orrs	r3, r1
 800b6b2:	6593      	str	r3, [r2, #88]	@ 0x58
 800b6b4:	e003      	b.n	800b6be <HAL_RCCEx_PeriphCLKConfig+0xed2>
    }
    else
    {
      /* set overall return value */
      status = ret;
 800b6b6:	f897 311f 	ldrb.w	r3, [r7, #287]	@ 0x11f
 800b6ba:	f887 311e 	strb.w	r3, [r7, #286]	@ 0x11e
    }
  }

  /*------------------------------ USB Configuration -------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == RCC_PERIPHCLK_USB)
 800b6be:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800b6c2:	e9d3 2300 	ldrd	r2, r3, [r3]
 800b6c6:	f402 2380 	and.w	r3, r2, #262144	@ 0x40000
 800b6ca:	67bb      	str	r3, [r7, #120]	@ 0x78
 800b6cc:	2300      	movs	r3, #0
 800b6ce:	67fb      	str	r3, [r7, #124]	@ 0x7c
 800b6d0:	e9d7 121e 	ldrd	r1, r2, [r7, #120]	@ 0x78
 800b6d4:	460b      	mov	r3, r1
 800b6d6:	4313      	orrs	r3, r2
 800b6d8:	d03b      	beq.n	800b752 <HAL_RCCEx_PeriphCLKConfig+0xf66>
  {

    switch (PeriphClkInit->UsbClockSelection)
 800b6da:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800b6de:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 800b6e2:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
 800b6e6:	d01f      	beq.n	800b728 <HAL_RCCEx_PeriphCLKConfig+0xf3c>
 800b6e8:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
 800b6ec:	d818      	bhi.n	800b720 <HAL_RCCEx_PeriphCLKConfig+0xf34>
 800b6ee:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
 800b6f2:	d003      	beq.n	800b6fc <HAL_RCCEx_PeriphCLKConfig+0xf10>
 800b6f4:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
 800b6f8:	d007      	beq.n	800b70a <HAL_RCCEx_PeriphCLKConfig+0xf1e>
 800b6fa:	e011      	b.n	800b720 <HAL_RCCEx_PeriphCLKConfig+0xf34>
    {
      case RCC_USBCLKSOURCE_PLL:      /* PLL is used as clock source for USB*/
        /* Enable USB Clock output generated form System USB . */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 800b6fc:	4b33      	ldr	r3, [pc, #204]	@ (800b7cc <HAL_RCCEx_PeriphCLKConfig+0xfe0>)
 800b6fe:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800b700:	4a32      	ldr	r2, [pc, #200]	@ (800b7cc <HAL_RCCEx_PeriphCLKConfig+0xfe0>)
 800b702:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 800b706:	62d3      	str	r3, [r2, #44]	@ 0x2c

        /* USB clock source configuration done later after clock selection check */
        break;
 800b708:	e00f      	b.n	800b72a <HAL_RCCEx_PeriphCLKConfig+0xf3e>

      case RCC_USBCLKSOURCE_PLL3: /* PLL3 is used as clock source for USB*/

        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_Q_UPDATE);
 800b70a:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800b70e:	3328      	adds	r3, #40	@ 0x28
 800b710:	2101      	movs	r1, #1
 800b712:	4618      	mov	r0, r3
 800b714:	f001 fbc2 	bl	800ce9c <RCCEx_PLL3_Config>
 800b718:	4603      	mov	r3, r0
 800b71a:	f887 311f 	strb.w	r3, [r7, #287]	@ 0x11f

        /* USB clock source configuration done later after clock selection check */
        break;
 800b71e:	e004      	b.n	800b72a <HAL_RCCEx_PeriphCLKConfig+0xf3e>
        /* HSI48 oscillator is used as source of USB clock */
        /* USB clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 800b720:	2301      	movs	r3, #1
 800b722:	f887 311f 	strb.w	r3, [r7, #287]	@ 0x11f
        break;
 800b726:	e000      	b.n	800b72a <HAL_RCCEx_PeriphCLKConfig+0xf3e>
        break;
 800b728:	bf00      	nop
    }

    if (ret == HAL_OK)
 800b72a:	f897 311f 	ldrb.w	r3, [r7, #287]	@ 0x11f
 800b72e:	2b00      	cmp	r3, #0
 800b730:	d10b      	bne.n	800b74a <HAL_RCCEx_PeriphCLKConfig+0xf5e>
    {
      /* Set the source of USB clock*/
      __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
 800b732:	4b26      	ldr	r3, [pc, #152]	@ (800b7cc <HAL_RCCEx_PeriphCLKConfig+0xfe0>)
 800b734:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 800b736:	f423 1140 	bic.w	r1, r3, #3145728	@ 0x300000
 800b73a:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800b73e:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 800b742:	4a22      	ldr	r2, [pc, #136]	@ (800b7cc <HAL_RCCEx_PeriphCLKConfig+0xfe0>)
 800b744:	430b      	orrs	r3, r1
 800b746:	6553      	str	r3, [r2, #84]	@ 0x54
 800b748:	e003      	b.n	800b752 <HAL_RCCEx_PeriphCLKConfig+0xf66>
    }
    else
    {
      /* set overall return value */
      status = ret;
 800b74a:	f897 311f 	ldrb.w	r3, [r7, #287]	@ 0x11f
 800b74e:	f887 311e 	strb.w	r3, [r7, #286]	@ 0x11e
    }

  }

  /*------------------------------------- SDMMC Configuration ------------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC) == RCC_PERIPHCLK_SDMMC)
 800b752:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800b756:	e9d3 2300 	ldrd	r2, r3, [r3]
 800b75a:	f402 3380 	and.w	r3, r2, #65536	@ 0x10000
 800b75e:	673b      	str	r3, [r7, #112]	@ 0x70
 800b760:	2300      	movs	r3, #0
 800b762:	677b      	str	r3, [r7, #116]	@ 0x74
 800b764:	e9d7 121c 	ldrd	r1, r2, [r7, #112]	@ 0x70
 800b768:	460b      	mov	r3, r1
 800b76a:	4313      	orrs	r3, r2
 800b76c:	d034      	beq.n	800b7d8 <HAL_RCCEx_PeriphCLKConfig+0xfec>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SDMMC(PeriphClkInit->SdmmcClockSelection));

    switch (PeriphClkInit->SdmmcClockSelection)
 800b76e:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800b772:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800b774:	2b00      	cmp	r3, #0
 800b776:	d003      	beq.n	800b780 <HAL_RCCEx_PeriphCLKConfig+0xf94>
 800b778:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 800b77c:	d007      	beq.n	800b78e <HAL_RCCEx_PeriphCLKConfig+0xfa2>
 800b77e:	e011      	b.n	800b7a4 <HAL_RCCEx_PeriphCLKConfig+0xfb8>
    {
      case RCC_SDMMCCLKSOURCE_PLL:      /* PLL is used as clock source for SDMMC*/
        /* Enable SDMMC Clock output generated form System PLL . */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 800b780:	4b12      	ldr	r3, [pc, #72]	@ (800b7cc <HAL_RCCEx_PeriphCLKConfig+0xfe0>)
 800b782:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800b784:	4a11      	ldr	r2, [pc, #68]	@ (800b7cc <HAL_RCCEx_PeriphCLKConfig+0xfe0>)
 800b786:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 800b78a:	62d3      	str	r3, [r2, #44]	@ 0x2c

        /* SDMMC clock source configuration done later after clock selection check */
        break;
 800b78c:	e00e      	b.n	800b7ac <HAL_RCCEx_PeriphCLKConfig+0xfc0>

      case RCC_SDMMCCLKSOURCE_PLL2: /* PLL2 is used as clock source for SDMMC*/

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_R_UPDATE);
 800b78e:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800b792:	3308      	adds	r3, #8
 800b794:	2102      	movs	r1, #2
 800b796:	4618      	mov	r0, r3
 800b798:	f001 face 	bl	800cd38 <RCCEx_PLL2_Config>
 800b79c:	4603      	mov	r3, r0
 800b79e:	f887 311f 	strb.w	r3, [r7, #287]	@ 0x11f

        /* SDMMC clock source configuration done later after clock selection check */
        break;
 800b7a2:	e003      	b.n	800b7ac <HAL_RCCEx_PeriphCLKConfig+0xfc0>

      default:
        ret = HAL_ERROR;
 800b7a4:	2301      	movs	r3, #1
 800b7a6:	f887 311f 	strb.w	r3, [r7, #287]	@ 0x11f
        break;
 800b7aa:	bf00      	nop
    }

    if (ret == HAL_OK)
 800b7ac:	f897 311f 	ldrb.w	r3, [r7, #287]	@ 0x11f
 800b7b0:	2b00      	cmp	r3, #0
 800b7b2:	d10d      	bne.n	800b7d0 <HAL_RCCEx_PeriphCLKConfig+0xfe4>
    {
      /* Set the source of SDMMC clock*/
      __HAL_RCC_SDMMC_CONFIG(PeriphClkInit->SdmmcClockSelection);
 800b7b4:	4b05      	ldr	r3, [pc, #20]	@ (800b7cc <HAL_RCCEx_PeriphCLKConfig+0xfe0>)
 800b7b6:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 800b7b8:	f423 3180 	bic.w	r1, r3, #65536	@ 0x10000
 800b7bc:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800b7c0:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800b7c2:	4a02      	ldr	r2, [pc, #8]	@ (800b7cc <HAL_RCCEx_PeriphCLKConfig+0xfe0>)
 800b7c4:	430b      	orrs	r3, r1
 800b7c6:	64d3      	str	r3, [r2, #76]	@ 0x4c
 800b7c8:	e006      	b.n	800b7d8 <HAL_RCCEx_PeriphCLKConfig+0xfec>
 800b7ca:	bf00      	nop
 800b7cc:	58024400 	.word	0x58024400
    }
    else
    {
      /* set overall return value */
      status = ret;
 800b7d0:	f897 311f 	ldrb.w	r3, [r7, #287]	@ 0x11f
 800b7d4:	f887 311e 	strb.w	r3, [r7, #286]	@ 0x11e
    }
  }

#if defined(LTDC)
  /*-------------------------------------- LTDC Configuration -----------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == RCC_PERIPHCLK_LTDC)
 800b7d8:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800b7dc:	e9d3 2300 	ldrd	r2, r3, [r3]
 800b7e0:	f002 5300 	and.w	r3, r2, #536870912	@ 0x20000000
 800b7e4:	66bb      	str	r3, [r7, #104]	@ 0x68
 800b7e6:	2300      	movs	r3, #0
 800b7e8:	66fb      	str	r3, [r7, #108]	@ 0x6c
 800b7ea:	e9d7 121a 	ldrd	r1, r2, [r7, #104]	@ 0x68
 800b7ee:	460b      	mov	r3, r1
 800b7f0:	4313      	orrs	r3, r2
 800b7f2:	d00c      	beq.n	800b80e <HAL_RCCEx_PeriphCLKConfig+0x1022>
  {
    if (RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_R_UPDATE) != HAL_OK)
 800b7f4:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800b7f8:	3328      	adds	r3, #40	@ 0x28
 800b7fa:	2102      	movs	r1, #2
 800b7fc:	4618      	mov	r0, r3
 800b7fe:	f001 fb4d 	bl	800ce9c <RCCEx_PLL3_Config>
 800b802:	4603      	mov	r3, r0
 800b804:	2b00      	cmp	r3, #0
 800b806:	d002      	beq.n	800b80e <HAL_RCCEx_PeriphCLKConfig+0x1022>
    {
      status = HAL_ERROR;
 800b808:	2301      	movs	r3, #1
 800b80a:	f887 311e 	strb.w	r3, [r7, #286]	@ 0x11e
    }
  }
#endif /* LTDC */

  /*------------------------------ RNG Configuration -------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == RCC_PERIPHCLK_RNG)
 800b80e:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800b812:	e9d3 2300 	ldrd	r2, r3, [r3]
 800b816:	f402 3300 	and.w	r3, r2, #131072	@ 0x20000
 800b81a:	663b      	str	r3, [r7, #96]	@ 0x60
 800b81c:	2300      	movs	r3, #0
 800b81e:	667b      	str	r3, [r7, #100]	@ 0x64
 800b820:	e9d7 1218 	ldrd	r1, r2, [r7, #96]	@ 0x60
 800b824:	460b      	mov	r3, r1
 800b826:	4313      	orrs	r3, r2
 800b828:	d038      	beq.n	800b89c <HAL_RCCEx_PeriphCLKConfig+0x10b0>
  {

    switch (PeriphClkInit->RngClockSelection)
 800b82a:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800b82e:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 800b832:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
 800b836:	d018      	beq.n	800b86a <HAL_RCCEx_PeriphCLKConfig+0x107e>
 800b838:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
 800b83c:	d811      	bhi.n	800b862 <HAL_RCCEx_PeriphCLKConfig+0x1076>
 800b83e:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 800b842:	d014      	beq.n	800b86e <HAL_RCCEx_PeriphCLKConfig+0x1082>
 800b844:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 800b848:	d80b      	bhi.n	800b862 <HAL_RCCEx_PeriphCLKConfig+0x1076>
 800b84a:	2b00      	cmp	r3, #0
 800b84c:	d011      	beq.n	800b872 <HAL_RCCEx_PeriphCLKConfig+0x1086>
 800b84e:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 800b852:	d106      	bne.n	800b862 <HAL_RCCEx_PeriphCLKConfig+0x1076>
    {
      case RCC_RNGCLKSOURCE_PLL:     /* PLL is used as clock source for RNG*/
        /* Enable RNG Clock output generated form System RNG . */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 800b854:	4bc3      	ldr	r3, [pc, #780]	@ (800bb64 <HAL_RCCEx_PeriphCLKConfig+0x1378>)
 800b856:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800b858:	4ac2      	ldr	r2, [pc, #776]	@ (800bb64 <HAL_RCCEx_PeriphCLKConfig+0x1378>)
 800b85a:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 800b85e:	62d3      	str	r3, [r2, #44]	@ 0x2c

        /* RNG clock source configuration done later after clock selection check */
        break;
 800b860:	e008      	b.n	800b874 <HAL_RCCEx_PeriphCLKConfig+0x1088>
        /* HSI48 oscillator is used as source of RNG clock */
        /* RNG clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 800b862:	2301      	movs	r3, #1
 800b864:	f887 311f 	strb.w	r3, [r7, #287]	@ 0x11f
        break;
 800b868:	e004      	b.n	800b874 <HAL_RCCEx_PeriphCLKConfig+0x1088>
        break;
 800b86a:	bf00      	nop
 800b86c:	e002      	b.n	800b874 <HAL_RCCEx_PeriphCLKConfig+0x1088>
        break;
 800b86e:	bf00      	nop
 800b870:	e000      	b.n	800b874 <HAL_RCCEx_PeriphCLKConfig+0x1088>
        break;
 800b872:	bf00      	nop
    }

    if (ret == HAL_OK)
 800b874:	f897 311f 	ldrb.w	r3, [r7, #287]	@ 0x11f
 800b878:	2b00      	cmp	r3, #0
 800b87a:	d10b      	bne.n	800b894 <HAL_RCCEx_PeriphCLKConfig+0x10a8>
    {
      /* Set the source of RNG clock*/
      __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
 800b87c:	4bb9      	ldr	r3, [pc, #740]	@ (800bb64 <HAL_RCCEx_PeriphCLKConfig+0x1378>)
 800b87e:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 800b880:	f423 7140 	bic.w	r1, r3, #768	@ 0x300
 800b884:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800b888:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 800b88c:	4ab5      	ldr	r2, [pc, #724]	@ (800bb64 <HAL_RCCEx_PeriphCLKConfig+0x1378>)
 800b88e:	430b      	orrs	r3, r1
 800b890:	6553      	str	r3, [r2, #84]	@ 0x54
 800b892:	e003      	b.n	800b89c <HAL_RCCEx_PeriphCLKConfig+0x10b0>
    }
    else
    {
      /* set overall return value */
      status = ret;
 800b894:	f897 311f 	ldrb.w	r3, [r7, #287]	@ 0x11f
 800b898:	f887 311e 	strb.w	r3, [r7, #286]	@ 0x11e
    }

  }

  /*------------------------------ SWPMI1 Configuration ------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SWPMI1) == RCC_PERIPHCLK_SWPMI1)
 800b89c:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800b8a0:	e9d3 2300 	ldrd	r2, r3, [r3]
 800b8a4:	f402 1380 	and.w	r3, r2, #1048576	@ 0x100000
 800b8a8:	65bb      	str	r3, [r7, #88]	@ 0x58
 800b8aa:	2300      	movs	r3, #0
 800b8ac:	65fb      	str	r3, [r7, #92]	@ 0x5c
 800b8ae:	e9d7 1216 	ldrd	r1, r2, [r7, #88]	@ 0x58
 800b8b2:	460b      	mov	r3, r1
 800b8b4:	4313      	orrs	r3, r2
 800b8b6:	d009      	beq.n	800b8cc <HAL_RCCEx_PeriphCLKConfig+0x10e0>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SWPMI1CLKSOURCE(PeriphClkInit->Swpmi1ClockSelection));

    /* Configure the SWPMI1 interface clock source */
    __HAL_RCC_SWPMI1_CONFIG(PeriphClkInit->Swpmi1ClockSelection);
 800b8b8:	4baa      	ldr	r3, [pc, #680]	@ (800bb64 <HAL_RCCEx_PeriphCLKConfig+0x1378>)
 800b8ba:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800b8bc:	f023 4100 	bic.w	r1, r3, #2147483648	@ 0x80000000
 800b8c0:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800b8c4:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
 800b8c6:	4aa7      	ldr	r2, [pc, #668]	@ (800bb64 <HAL_RCCEx_PeriphCLKConfig+0x1378>)
 800b8c8:	430b      	orrs	r3, r1
 800b8ca:	6513      	str	r3, [r2, #80]	@ 0x50
    /* Configure the HRTIM1 clock source */
    __HAL_RCC_HRTIM1_CONFIG(PeriphClkInit->Hrtim1ClockSelection);
  }
#endif  /*HRTIM1*/
  /*------------------------------ DFSDM1 Configuration ------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DFSDM1) == RCC_PERIPHCLK_DFSDM1)
 800b8cc:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800b8d0:	e9d3 2300 	ldrd	r2, r3, [r3]
 800b8d4:	f402 1300 	and.w	r3, r2, #2097152	@ 0x200000
 800b8d8:	653b      	str	r3, [r7, #80]	@ 0x50
 800b8da:	2300      	movs	r3, #0
 800b8dc:	657b      	str	r3, [r7, #84]	@ 0x54
 800b8de:	e9d7 1214 	ldrd	r1, r2, [r7, #80]	@ 0x50
 800b8e2:	460b      	mov	r3, r1
 800b8e4:	4313      	orrs	r3, r2
 800b8e6:	d009      	beq.n	800b8fc <HAL_RCCEx_PeriphCLKConfig+0x1110>
  {
    /* Check the parameters */
    assert_param(IS_RCC_DFSDM1CLKSOURCE(PeriphClkInit->Dfsdm1ClockSelection));

    /* Configure the DFSDM1 interface clock source */
    __HAL_RCC_DFSDM1_CONFIG(PeriphClkInit->Dfsdm1ClockSelection);
 800b8e8:	4b9e      	ldr	r3, [pc, #632]	@ (800bb64 <HAL_RCCEx_PeriphCLKConfig+0x1378>)
 800b8ea:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800b8ec:	f023 7180 	bic.w	r1, r3, #16777216	@ 0x1000000
 800b8f0:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800b8f4:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 800b8f6:	4a9b      	ldr	r2, [pc, #620]	@ (800bb64 <HAL_RCCEx_PeriphCLKConfig+0x1378>)
 800b8f8:	430b      	orrs	r3, r1
 800b8fa:	6513      	str	r3, [r2, #80]	@ 0x50
  }

#if defined(DFSDM2_BASE)
  /*------------------------------ DFSDM2 Configuration ------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DFSDM2) == RCC_PERIPHCLK_DFSDM2)
 800b8fc:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800b900:	e9d3 2300 	ldrd	r2, r3, [r3]
 800b904:	f402 6300 	and.w	r3, r2, #2048	@ 0x800
 800b908:	64bb      	str	r3, [r7, #72]	@ 0x48
 800b90a:	2300      	movs	r3, #0
 800b90c:	64fb      	str	r3, [r7, #76]	@ 0x4c
 800b90e:	e9d7 1212 	ldrd	r1, r2, [r7, #72]	@ 0x48
 800b912:	460b      	mov	r3, r1
 800b914:	4313      	orrs	r3, r2
 800b916:	d009      	beq.n	800b92c <HAL_RCCEx_PeriphCLKConfig+0x1140>
  {
    /* Check the parameters */
    assert_param(IS_RCC_DFSDM2CLKSOURCE(PeriphClkInit->Dfsdm2ClockSelection));

    /* Configure the DFSDM2 interface clock source */
    __HAL_RCC_DFSDM2_CONFIG(PeriphClkInit->Dfsdm2ClockSelection);
 800b918:	4b92      	ldr	r3, [pc, #584]	@ (800bb64 <HAL_RCCEx_PeriphCLKConfig+0x1378>)
 800b91a:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 800b91c:	f023 6100 	bic.w	r1, r3, #134217728	@ 0x8000000
 800b920:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800b924:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
 800b926:	4a8f      	ldr	r2, [pc, #572]	@ (800bb64 <HAL_RCCEx_PeriphCLKConfig+0x1378>)
 800b928:	430b      	orrs	r3, r1
 800b92a:	6593      	str	r3, [r2, #88]	@ 0x58
  }
#endif  /* DFSDM2 */

  /*------------------------------------ TIM configuration --------------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM) == RCC_PERIPHCLK_TIM)
 800b92c:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800b930:	e9d3 2300 	ldrd	r2, r3, [r3]
 800b934:	f002 4380 	and.w	r3, r2, #1073741824	@ 0x40000000
 800b938:	643b      	str	r3, [r7, #64]	@ 0x40
 800b93a:	2300      	movs	r3, #0
 800b93c:	647b      	str	r3, [r7, #68]	@ 0x44
 800b93e:	e9d7 1210 	ldrd	r1, r2, [r7, #64]	@ 0x40
 800b942:	460b      	mov	r3, r1
 800b944:	4313      	orrs	r3, r2
 800b946:	d00e      	beq.n	800b966 <HAL_RCCEx_PeriphCLKConfig+0x117a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_TIMPRES(PeriphClkInit->TIMPresSelection));

    /* Configure Timer Prescaler */
    __HAL_RCC_TIMCLKPRESCALER(PeriphClkInit->TIMPresSelection);
 800b948:	4b86      	ldr	r3, [pc, #536]	@ (800bb64 <HAL_RCCEx_PeriphCLKConfig+0x1378>)
 800b94a:	691b      	ldr	r3, [r3, #16]
 800b94c:	4a85      	ldr	r2, [pc, #532]	@ (800bb64 <HAL_RCCEx_PeriphCLKConfig+0x1378>)
 800b94e:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
 800b952:	6113      	str	r3, [r2, #16]
 800b954:	4b83      	ldr	r3, [pc, #524]	@ (800bb64 <HAL_RCCEx_PeriphCLKConfig+0x1378>)
 800b956:	6919      	ldr	r1, [r3, #16]
 800b958:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800b95c:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
 800b960:	4a80      	ldr	r2, [pc, #512]	@ (800bb64 <HAL_RCCEx_PeriphCLKConfig+0x1378>)
 800b962:	430b      	orrs	r3, r1
 800b964:	6113      	str	r3, [r2, #16]
  }

  /*------------------------------------ CKPER configuration --------------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CKPER) == RCC_PERIPHCLK_CKPER)
 800b966:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800b96a:	e9d3 2300 	ldrd	r2, r3, [r3]
 800b96e:	f002 4300 	and.w	r3, r2, #2147483648	@ 0x80000000
 800b972:	63bb      	str	r3, [r7, #56]	@ 0x38
 800b974:	2300      	movs	r3, #0
 800b976:	63fb      	str	r3, [r7, #60]	@ 0x3c
 800b978:	e9d7 120e 	ldrd	r1, r2, [r7, #56]	@ 0x38
 800b97c:	460b      	mov	r3, r1
 800b97e:	4313      	orrs	r3, r2
 800b980:	d009      	beq.n	800b996 <HAL_RCCEx_PeriphCLKConfig+0x11aa>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CLKPSOURCE(PeriphClkInit->CkperClockSelection));

    /* Configure the CKPER clock source */
    __HAL_RCC_CLKP_CONFIG(PeriphClkInit->CkperClockSelection);
 800b982:	4b78      	ldr	r3, [pc, #480]	@ (800bb64 <HAL_RCCEx_PeriphCLKConfig+0x1378>)
 800b984:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 800b986:	f023 5140 	bic.w	r1, r3, #805306368	@ 0x30000000
 800b98a:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800b98e:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 800b990:	4a74      	ldr	r2, [pc, #464]	@ (800bb64 <HAL_RCCEx_PeriphCLKConfig+0x1378>)
 800b992:	430b      	orrs	r3, r1
 800b994:	64d3      	str	r3, [r2, #76]	@ 0x4c
  }

  /*------------------------------ CEC Configuration ------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CEC) == RCC_PERIPHCLK_CEC)
 800b996:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800b99a:	e9d3 2300 	ldrd	r2, r3, [r3]
 800b99e:	f402 0300 	and.w	r3, r2, #8388608	@ 0x800000
 800b9a2:	633b      	str	r3, [r7, #48]	@ 0x30
 800b9a4:	2300      	movs	r3, #0
 800b9a6:	637b      	str	r3, [r7, #52]	@ 0x34
 800b9a8:	e9d7 120c 	ldrd	r1, r2, [r7, #48]	@ 0x30
 800b9ac:	460b      	mov	r3, r1
 800b9ae:	4313      	orrs	r3, r2
 800b9b0:	d00a      	beq.n	800b9c8 <HAL_RCCEx_PeriphCLKConfig+0x11dc>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CECCLKSOURCE(PeriphClkInit->CecClockSelection));

    /* Configure the CEC interface clock source */
    __HAL_RCC_CEC_CONFIG(PeriphClkInit->CecClockSelection);
 800b9b2:	4b6c      	ldr	r3, [pc, #432]	@ (800bb64 <HAL_RCCEx_PeriphCLKConfig+0x1378>)
 800b9b4:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 800b9b6:	f423 0140 	bic.w	r1, r3, #12582912	@ 0xc00000
 800b9ba:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800b9be:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 800b9c2:	4a68      	ldr	r2, [pc, #416]	@ (800bb64 <HAL_RCCEx_PeriphCLKConfig+0x1378>)
 800b9c4:	430b      	orrs	r3, r1
 800b9c6:	6553      	str	r3, [r2, #84]	@ 0x54
  }

  /*---------------------------- PLL2 configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_PLL2_DIVP) == RCC_PERIPHCLK_PLL2_DIVP)
 800b9c8:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800b9cc:	e9d3 2300 	ldrd	r2, r3, [r3]
 800b9d0:	2100      	movs	r1, #0
 800b9d2:	62b9      	str	r1, [r7, #40]	@ 0x28
 800b9d4:	f003 0301 	and.w	r3, r3, #1
 800b9d8:	62fb      	str	r3, [r7, #44]	@ 0x2c
 800b9da:	e9d7 120a 	ldrd	r1, r2, [r7, #40]	@ 0x28
 800b9de:	460b      	mov	r3, r1
 800b9e0:	4313      	orrs	r3, r2
 800b9e2:	d011      	beq.n	800ba08 <HAL_RCCEx_PeriphCLKConfig+0x121c>
  {
    ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_P_UPDATE);
 800b9e4:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800b9e8:	3308      	adds	r3, #8
 800b9ea:	2100      	movs	r1, #0
 800b9ec:	4618      	mov	r0, r3
 800b9ee:	f001 f9a3 	bl	800cd38 <RCCEx_PLL2_Config>
 800b9f2:	4603      	mov	r3, r0
 800b9f4:	f887 311f 	strb.w	r3, [r7, #287]	@ 0x11f
    
    if (ret == HAL_OK)
 800b9f8:	f897 311f 	ldrb.w	r3, [r7, #287]	@ 0x11f
 800b9fc:	2b00      	cmp	r3, #0
 800b9fe:	d003      	beq.n	800ba08 <HAL_RCCEx_PeriphCLKConfig+0x121c>
      /*Nothing to do*/
    }
    else
    {
      /* set overall return value */
      status = ret;
 800ba00:	f897 311f 	ldrb.w	r3, [r7, #287]	@ 0x11f
 800ba04:	f887 311e 	strb.w	r3, [r7, #286]	@ 0x11e
    } 
  }
  
  
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_PLL2_DIVQ) == RCC_PERIPHCLK_PLL2_DIVQ)
 800ba08:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800ba0c:	e9d3 2300 	ldrd	r2, r3, [r3]
 800ba10:	2100      	movs	r1, #0
 800ba12:	6239      	str	r1, [r7, #32]
 800ba14:	f003 0302 	and.w	r3, r3, #2
 800ba18:	627b      	str	r3, [r7, #36]	@ 0x24
 800ba1a:	e9d7 1208 	ldrd	r1, r2, [r7, #32]
 800ba1e:	460b      	mov	r3, r1
 800ba20:	4313      	orrs	r3, r2
 800ba22:	d011      	beq.n	800ba48 <HAL_RCCEx_PeriphCLKConfig+0x125c>
  {
    ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_Q_UPDATE);
 800ba24:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800ba28:	3308      	adds	r3, #8
 800ba2a:	2101      	movs	r1, #1
 800ba2c:	4618      	mov	r0, r3
 800ba2e:	f001 f983 	bl	800cd38 <RCCEx_PLL2_Config>
 800ba32:	4603      	mov	r3, r0
 800ba34:	f887 311f 	strb.w	r3, [r7, #287]	@ 0x11f
    
    if (ret == HAL_OK)
 800ba38:	f897 311f 	ldrb.w	r3, [r7, #287]	@ 0x11f
 800ba3c:	2b00      	cmp	r3, #0
 800ba3e:	d003      	beq.n	800ba48 <HAL_RCCEx_PeriphCLKConfig+0x125c>
      /*Nothing to do*/
    }
    else
    {
      /* set overall return value */
      status = ret;
 800ba40:	f897 311f 	ldrb.w	r3, [r7, #287]	@ 0x11f
 800ba44:	f887 311e 	strb.w	r3, [r7, #286]	@ 0x11e
    }
  }
  
  
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_PLL2_DIVR) == RCC_PERIPHCLK_PLL2_DIVR)
 800ba48:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800ba4c:	e9d3 2300 	ldrd	r2, r3, [r3]
 800ba50:	2100      	movs	r1, #0
 800ba52:	61b9      	str	r1, [r7, #24]
 800ba54:	f003 0304 	and.w	r3, r3, #4
 800ba58:	61fb      	str	r3, [r7, #28]
 800ba5a:	e9d7 1206 	ldrd	r1, r2, [r7, #24]
 800ba5e:	460b      	mov	r3, r1
 800ba60:	4313      	orrs	r3, r2
 800ba62:	d011      	beq.n	800ba88 <HAL_RCCEx_PeriphCLKConfig+0x129c>
  {
    ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_R_UPDATE);
 800ba64:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800ba68:	3308      	adds	r3, #8
 800ba6a:	2102      	movs	r1, #2
 800ba6c:	4618      	mov	r0, r3
 800ba6e:	f001 f963 	bl	800cd38 <RCCEx_PLL2_Config>
 800ba72:	4603      	mov	r3, r0
 800ba74:	f887 311f 	strb.w	r3, [r7, #287]	@ 0x11f
    
    if (ret == HAL_OK)
 800ba78:	f897 311f 	ldrb.w	r3, [r7, #287]	@ 0x11f
 800ba7c:	2b00      	cmp	r3, #0
 800ba7e:	d003      	beq.n	800ba88 <HAL_RCCEx_PeriphCLKConfig+0x129c>
      /*Nothing to do*/
    }
    else
    {
      /* set overall return value */
      status = ret;
 800ba80:	f897 311f 	ldrb.w	r3, [r7, #287]	@ 0x11f
 800ba84:	f887 311e 	strb.w	r3, [r7, #286]	@ 0x11e
    }
  }
  

  /*---------------------------- PLL3 configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_PLL3_DIVP) == RCC_PERIPHCLK_PLL3_DIVP)
 800ba88:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800ba8c:	e9d3 2300 	ldrd	r2, r3, [r3]
 800ba90:	2100      	movs	r1, #0
 800ba92:	6139      	str	r1, [r7, #16]
 800ba94:	f003 0308 	and.w	r3, r3, #8
 800ba98:	617b      	str	r3, [r7, #20]
 800ba9a:	e9d7 1204 	ldrd	r1, r2, [r7, #16]
 800ba9e:	460b      	mov	r3, r1
 800baa0:	4313      	orrs	r3, r2
 800baa2:	d011      	beq.n	800bac8 <HAL_RCCEx_PeriphCLKConfig+0x12dc>
  {
    ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_P_UPDATE);
 800baa4:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800baa8:	3328      	adds	r3, #40	@ 0x28
 800baaa:	2100      	movs	r1, #0
 800baac:	4618      	mov	r0, r3
 800baae:	f001 f9f5 	bl	800ce9c <RCCEx_PLL3_Config>
 800bab2:	4603      	mov	r3, r0
 800bab4:	f887 311f 	strb.w	r3, [r7, #287]	@ 0x11f
  
    if (ret == HAL_OK)
 800bab8:	f897 311f 	ldrb.w	r3, [r7, #287]	@ 0x11f
 800babc:	2b00      	cmp	r3, #0
 800babe:	d003      	beq.n	800bac8 <HAL_RCCEx_PeriphCLKConfig+0x12dc>
      /*Nothing to do*/
    }
    else
    {
      /* set overall return value */
      status = ret;
 800bac0:	f897 311f 	ldrb.w	r3, [r7, #287]	@ 0x11f
 800bac4:	f887 311e 	strb.w	r3, [r7, #286]	@ 0x11e
    }
  }
  
  
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_PLL3_DIVQ) == RCC_PERIPHCLK_PLL3_DIVQ)
 800bac8:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800bacc:	e9d3 2300 	ldrd	r2, r3, [r3]
 800bad0:	2100      	movs	r1, #0
 800bad2:	60b9      	str	r1, [r7, #8]
 800bad4:	f003 0310 	and.w	r3, r3, #16
 800bad8:	60fb      	str	r3, [r7, #12]
 800bada:	e9d7 1202 	ldrd	r1, r2, [r7, #8]
 800bade:	460b      	mov	r3, r1
 800bae0:	4313      	orrs	r3, r2
 800bae2:	d011      	beq.n	800bb08 <HAL_RCCEx_PeriphCLKConfig+0x131c>
  {
    ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_Q_UPDATE);
 800bae4:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800bae8:	3328      	adds	r3, #40	@ 0x28
 800baea:	2101      	movs	r1, #1
 800baec:	4618      	mov	r0, r3
 800baee:	f001 f9d5 	bl	800ce9c <RCCEx_PLL3_Config>
 800baf2:	4603      	mov	r3, r0
 800baf4:	f887 311f 	strb.w	r3, [r7, #287]	@ 0x11f
    
    if (ret == HAL_OK)
 800baf8:	f897 311f 	ldrb.w	r3, [r7, #287]	@ 0x11f
 800bafc:	2b00      	cmp	r3, #0
 800bafe:	d003      	beq.n	800bb08 <HAL_RCCEx_PeriphCLKConfig+0x131c>
      /*Nothing to do*/
    }
    else
    {
      /* set overall return value */
      status = ret;
 800bb00:	f897 311f 	ldrb.w	r3, [r7, #287]	@ 0x11f
 800bb04:	f887 311e 	strb.w	r3, [r7, #286]	@ 0x11e
    }
  }
  
  
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_PLL3_DIVR) == RCC_PERIPHCLK_PLL3_DIVR)
 800bb08:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800bb0c:	e9d3 2300 	ldrd	r2, r3, [r3]
 800bb10:	2100      	movs	r1, #0
 800bb12:	6039      	str	r1, [r7, #0]
 800bb14:	f003 0320 	and.w	r3, r3, #32
 800bb18:	607b      	str	r3, [r7, #4]
 800bb1a:	e9d7 1200 	ldrd	r1, r2, [r7]
 800bb1e:	460b      	mov	r3, r1
 800bb20:	4313      	orrs	r3, r2
 800bb22:	d011      	beq.n	800bb48 <HAL_RCCEx_PeriphCLKConfig+0x135c>
  {
    ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_R_UPDATE);
 800bb24:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 800bb28:	3328      	adds	r3, #40	@ 0x28
 800bb2a:	2102      	movs	r1, #2
 800bb2c:	4618      	mov	r0, r3
 800bb2e:	f001 f9b5 	bl	800ce9c <RCCEx_PLL3_Config>
 800bb32:	4603      	mov	r3, r0
 800bb34:	f887 311f 	strb.w	r3, [r7, #287]	@ 0x11f
    
    if (ret == HAL_OK)
 800bb38:	f897 311f 	ldrb.w	r3, [r7, #287]	@ 0x11f
 800bb3c:	2b00      	cmp	r3, #0
 800bb3e:	d003      	beq.n	800bb48 <HAL_RCCEx_PeriphCLKConfig+0x135c>
      /*Nothing to do*/
    }
    else
    {
      /* set overall return value */
      status = ret;
 800bb40:	f897 311f 	ldrb.w	r3, [r7, #287]	@ 0x11f
 800bb44:	f887 311e 	strb.w	r3, [r7, #286]	@ 0x11e
    } 
  }

  if (status == HAL_OK)
 800bb48:	f897 311e 	ldrb.w	r3, [r7, #286]	@ 0x11e
 800bb4c:	2b00      	cmp	r3, #0
 800bb4e:	d101      	bne.n	800bb54 <HAL_RCCEx_PeriphCLKConfig+0x1368>
  {
    return HAL_OK;
 800bb50:	2300      	movs	r3, #0
 800bb52:	e000      	b.n	800bb56 <HAL_RCCEx_PeriphCLKConfig+0x136a>
  }
  return HAL_ERROR;
 800bb54:	2301      	movs	r3, #1
}
 800bb56:	4618      	mov	r0, r3
 800bb58:	f507 7790 	add.w	r7, r7, #288	@ 0x120
 800bb5c:	46bd      	mov	sp, r7
 800bb5e:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
 800bb62:	bf00      	nop
 800bb64:	58024400 	.word	0x58024400

0800bb68 <HAL_RCCEx_GetPeriphCLKFreq>:
  * @retval Frequency in KHz
  *
  *  (*) : Available on some STM32H7 lines only.
  */
uint32_t HAL_RCCEx_GetPeriphCLKFreq(uint64_t PeriphClk)
{
 800bb68:	b580      	push	{r7, lr}
 800bb6a:	b090      	sub	sp, #64	@ 0x40
 800bb6c:	af00      	add	r7, sp, #0
 800bb6e:	e9c7 0100 	strd	r0, r1, [r7]
  /* This variable is used to store the SAI and CKP clock source */
  uint32_t saiclocksource;
  uint32_t ckpclocksource;
  uint32_t srcclk;

  if (PeriphClk == RCC_PERIPHCLK_SAI1)
 800bb72:	e9d7 2300 	ldrd	r2, r3, [r7]
 800bb76:	f5a2 7180 	sub.w	r1, r2, #256	@ 0x100
 800bb7a:	430b      	orrs	r3, r1
 800bb7c:	f040 8094 	bne.w	800bca8 <HAL_RCCEx_GetPeriphCLKFreq+0x140>
  {

    saiclocksource = __HAL_RCC_GET_SAI1_SOURCE();
 800bb80:	4b97      	ldr	r3, [pc, #604]	@ (800bde0 <HAL_RCCEx_GetPeriphCLKFreq+0x278>)
 800bb82:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800bb84:	f003 0307 	and.w	r3, r3, #7
 800bb88:	633b      	str	r3, [r7, #48]	@ 0x30

    switch (saiclocksource)
 800bb8a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800bb8c:	2b04      	cmp	r3, #4
 800bb8e:	f200 8087 	bhi.w	800bca0 <HAL_RCCEx_GetPeriphCLKFreq+0x138>
 800bb92:	a201      	add	r2, pc, #4	@ (adr r2, 800bb98 <HAL_RCCEx_GetPeriphCLKFreq+0x30>)
 800bb94:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800bb98:	0800bbad 	.word	0x0800bbad
 800bb9c:	0800bbd5 	.word	0x0800bbd5
 800bba0:	0800bbfd 	.word	0x0800bbfd
 800bba4:	0800bc99 	.word	0x0800bc99
 800bba8:	0800bc25 	.word	0x0800bc25
    {
      case RCC_SAI1CLKSOURCE_PLL: /* PLL1 is the clock source for SAI1 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL1RDY))
 800bbac:	4b8c      	ldr	r3, [pc, #560]	@ (800bde0 <HAL_RCCEx_GetPeriphCLKFreq+0x278>)
 800bbae:	681b      	ldr	r3, [r3, #0]
 800bbb0:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 800bbb4:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
 800bbb8:	d108      	bne.n	800bbcc <HAL_RCCEx_GetPeriphCLKFreq+0x64>
        {
          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
 800bbba:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 800bbbe:	4618      	mov	r0, r3
 800bbc0:	f000 ff68 	bl	800ca94 <HAL_RCCEx_GetPLL1ClockFreq>
          frequency = pll1_clocks.PLL1_Q_Frequency;
 800bbc4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800bbc6:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 800bbc8:	f000 bc97 	b.w	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
          frequency = 0;
 800bbcc:	2300      	movs	r3, #0
 800bbce:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 800bbd0:	f000 bc93 	b.w	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
      }
      case RCC_SAI1CLKSOURCE_PLL2: /* PLL2 is the clock source for SAI1 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))
 800bbd4:	4b82      	ldr	r3, [pc, #520]	@ (800bde0 <HAL_RCCEx_GetPeriphCLKFreq+0x278>)
 800bbd6:	681b      	ldr	r3, [r3, #0]
 800bbd8:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 800bbdc:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 800bbe0:	d108      	bne.n	800bbf4 <HAL_RCCEx_GetPeriphCLKFreq+0x8c>
        {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 800bbe2:	f107 0318 	add.w	r3, r7, #24
 800bbe6:	4618      	mov	r0, r3
 800bbe8:	f000 fcac 	bl	800c544 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_P_Frequency;
 800bbec:	69bb      	ldr	r3, [r7, #24]
 800bbee:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 800bbf0:	f000 bc83 	b.w	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
          frequency = 0;
 800bbf4:	2300      	movs	r3, #0
 800bbf6:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 800bbf8:	f000 bc7f 	b.w	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
      }

      case RCC_SAI1CLKSOURCE_PLL3: /* PLL3 is the clock source for SAI1 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY))
 800bbfc:	4b78      	ldr	r3, [pc, #480]	@ (800bde0 <HAL_RCCEx_GetPeriphCLKFreq+0x278>)
 800bbfe:	681b      	ldr	r3, [r3, #0]
 800bc00:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
 800bc04:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 800bc08:	d108      	bne.n	800bc1c <HAL_RCCEx_GetPeriphCLKFreq+0xb4>
        {
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 800bc0a:	f107 030c 	add.w	r3, r7, #12
 800bc0e:	4618      	mov	r0, r3
 800bc10:	f000 fdec 	bl	800c7ec <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_P_Frequency;
 800bc14:	68fb      	ldr	r3, [r7, #12]
 800bc16:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 800bc18:	f000 bc6f 	b.w	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
          frequency = 0;
 800bc1c:	2300      	movs	r3, #0
 800bc1e:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 800bc20:	f000 bc6b 	b.w	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
      }

      case RCC_SAI1CLKSOURCE_CLKP: /* CKPER is the clock source for SAI1*/
      {

        ckpclocksource = __HAL_RCC_GET_CLKP_SOURCE();
 800bc24:	4b6e      	ldr	r3, [pc, #440]	@ (800bde0 <HAL_RCCEx_GetPeriphCLKFreq+0x278>)
 800bc26:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 800bc28:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
 800bc2c:	637b      	str	r3, [r7, #52]	@ 0x34

        if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSI))
 800bc2e:	4b6c      	ldr	r3, [pc, #432]	@ (800bde0 <HAL_RCCEx_GetPeriphCLKFreq+0x278>)
 800bc30:	681b      	ldr	r3, [r3, #0]
 800bc32:	f003 0304 	and.w	r3, r3, #4
 800bc36:	2b04      	cmp	r3, #4
 800bc38:	d10c      	bne.n	800bc54 <HAL_RCCEx_GetPeriphCLKFreq+0xec>
 800bc3a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800bc3c:	2b00      	cmp	r3, #0
 800bc3e:	d109      	bne.n	800bc54 <HAL_RCCEx_GetPeriphCLKFreq+0xec>
        {
          /* In Case the CKPER Source is HSI */
          frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
 800bc40:	4b67      	ldr	r3, [pc, #412]	@ (800bde0 <HAL_RCCEx_GetPeriphCLKFreq+0x278>)
 800bc42:	681b      	ldr	r3, [r3, #0]
 800bc44:	08db      	lsrs	r3, r3, #3
 800bc46:	f003 0303 	and.w	r3, r3, #3
 800bc4a:	4a66      	ldr	r2, [pc, #408]	@ (800bde4 <HAL_RCCEx_GetPeriphCLKFreq+0x27c>)
 800bc4c:	fa22 f303 	lsr.w	r3, r2, r3
 800bc50:	63fb      	str	r3, [r7, #60]	@ 0x3c
 800bc52:	e01f      	b.n	800bc94 <HAL_RCCEx_GetPeriphCLKFreq+0x12c>
        }

        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_CSI))
 800bc54:	4b62      	ldr	r3, [pc, #392]	@ (800bde0 <HAL_RCCEx_GetPeriphCLKFreq+0x278>)
 800bc56:	681b      	ldr	r3, [r3, #0]
 800bc58:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 800bc5c:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 800bc60:	d106      	bne.n	800bc70 <HAL_RCCEx_GetPeriphCLKFreq+0x108>
 800bc62:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800bc64:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
 800bc68:	d102      	bne.n	800bc70 <HAL_RCCEx_GetPeriphCLKFreq+0x108>
        {
          /* In Case the CKPER Source is CSI */
          frequency = CSI_VALUE;
 800bc6a:	4b5f      	ldr	r3, [pc, #380]	@ (800bde8 <HAL_RCCEx_GetPeriphCLKFreq+0x280>)
 800bc6c:	63fb      	str	r3, [r7, #60]	@ 0x3c
 800bc6e:	e011      	b.n	800bc94 <HAL_RCCEx_GetPeriphCLKFreq+0x12c>
        }

        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSE))
 800bc70:	4b5b      	ldr	r3, [pc, #364]	@ (800bde0 <HAL_RCCEx_GetPeriphCLKFreq+0x278>)
 800bc72:	681b      	ldr	r3, [r3, #0]
 800bc74:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 800bc78:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 800bc7c:	d106      	bne.n	800bc8c <HAL_RCCEx_GetPeriphCLKFreq+0x124>
 800bc7e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800bc80:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 800bc84:	d102      	bne.n	800bc8c <HAL_RCCEx_GetPeriphCLKFreq+0x124>
        {
          /* In Case the CKPER Source is HSE */
          frequency = HSE_VALUE;
 800bc86:	4b59      	ldr	r3, [pc, #356]	@ (800bdec <HAL_RCCEx_GetPeriphCLKFreq+0x284>)
 800bc88:	63fb      	str	r3, [r7, #60]	@ 0x3c
 800bc8a:	e003      	b.n	800bc94 <HAL_RCCEx_GetPeriphCLKFreq+0x12c>
        }

        else
        {
          /* In Case the CKPER is disabled*/
          frequency = 0;
 800bc8c:	2300      	movs	r3, #0
 800bc8e:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }

        break;
 800bc90:	f000 bc33 	b.w	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
 800bc94:	f000 bc31 	b.w	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
      }

      case (RCC_SAI1CLKSOURCE_PIN): /* External clock is the clock source for SAI1 */
      {
        frequency = EXTERNAL_CLOCK_VALUE;
 800bc98:	4b55      	ldr	r3, [pc, #340]	@ (800bdf0 <HAL_RCCEx_GetPeriphCLKFreq+0x288>)
 800bc9a:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 800bc9c:	f000 bc2d 	b.w	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
      }
      default :
      {
        frequency = 0;
 800bca0:	2300      	movs	r3, #0
 800bca2:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 800bca4:	f000 bc29 	b.w	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
  }
#endif /* SAI3 */

#if  defined(RCC_CDCCIP1R_SAI2ASEL)

  else if (PeriphClk == RCC_PERIPHCLK_SAI2A)
 800bca8:	e9d7 2300 	ldrd	r2, r3, [r7]
 800bcac:	f5a2 7100 	sub.w	r1, r2, #512	@ 0x200
 800bcb0:	430b      	orrs	r3, r1
 800bcb2:	f040 809f 	bne.w	800bdf4 <HAL_RCCEx_GetPeriphCLKFreq+0x28c>
  {
    saiclocksource = __HAL_RCC_GET_SAI2A_SOURCE();
 800bcb6:	4b4a      	ldr	r3, [pc, #296]	@ (800bde0 <HAL_RCCEx_GetPeriphCLKFreq+0x278>)
 800bcb8:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800bcba:	f403 73e0 	and.w	r3, r3, #448	@ 0x1c0
 800bcbe:	633b      	str	r3, [r7, #48]	@ 0x30

    switch (saiclocksource)
 800bcc0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800bcc2:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 800bcc6:	d04d      	beq.n	800bd64 <HAL_RCCEx_GetPeriphCLKFreq+0x1fc>
 800bcc8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800bcca:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 800bcce:	f200 8084 	bhi.w	800bdda <HAL_RCCEx_GetPeriphCLKFreq+0x272>
 800bcd2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800bcd4:	2bc0      	cmp	r3, #192	@ 0xc0
 800bcd6:	d07d      	beq.n	800bdd4 <HAL_RCCEx_GetPeriphCLKFreq+0x26c>
 800bcd8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800bcda:	2bc0      	cmp	r3, #192	@ 0xc0
 800bcdc:	d87d      	bhi.n	800bdda <HAL_RCCEx_GetPeriphCLKFreq+0x272>
 800bcde:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800bce0:	2b80      	cmp	r3, #128	@ 0x80
 800bce2:	d02d      	beq.n	800bd40 <HAL_RCCEx_GetPeriphCLKFreq+0x1d8>
 800bce4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800bce6:	2b80      	cmp	r3, #128	@ 0x80
 800bce8:	d877      	bhi.n	800bdda <HAL_RCCEx_GetPeriphCLKFreq+0x272>
 800bcea:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800bcec:	2b00      	cmp	r3, #0
 800bcee:	d003      	beq.n	800bcf8 <HAL_RCCEx_GetPeriphCLKFreq+0x190>
 800bcf0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800bcf2:	2b40      	cmp	r3, #64	@ 0x40
 800bcf4:	d012      	beq.n	800bd1c <HAL_RCCEx_GetPeriphCLKFreq+0x1b4>
 800bcf6:	e070      	b.n	800bdda <HAL_RCCEx_GetPeriphCLKFreq+0x272>
    {
      case RCC_SAI2ACLKSOURCE_PLL: /* PLL1 is the clock source for SAI2A */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL1RDY))
 800bcf8:	4b39      	ldr	r3, [pc, #228]	@ (800bde0 <HAL_RCCEx_GetPeriphCLKFreq+0x278>)
 800bcfa:	681b      	ldr	r3, [r3, #0]
 800bcfc:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 800bd00:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
 800bd04:	d107      	bne.n	800bd16 <HAL_RCCEx_GetPeriphCLKFreq+0x1ae>
        {
          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
 800bd06:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 800bd0a:	4618      	mov	r0, r3
 800bd0c:	f000 fec2 	bl	800ca94 <HAL_RCCEx_GetPLL1ClockFreq>
          frequency = pll1_clocks.PLL1_Q_Frequency;
 800bd10:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800bd12:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 800bd14:	e3f1      	b.n	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
          frequency = 0;
 800bd16:	2300      	movs	r3, #0
 800bd18:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 800bd1a:	e3ee      	b.n	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
      }
      case RCC_SAI2ACLKSOURCE_PLL2: /* PLLI2 is the clock source for SAI2A */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))
 800bd1c:	4b30      	ldr	r3, [pc, #192]	@ (800bde0 <HAL_RCCEx_GetPeriphCLKFreq+0x278>)
 800bd1e:	681b      	ldr	r3, [r3, #0]
 800bd20:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 800bd24:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 800bd28:	d107      	bne.n	800bd3a <HAL_RCCEx_GetPeriphCLKFreq+0x1d2>
        {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 800bd2a:	f107 0318 	add.w	r3, r7, #24
 800bd2e:	4618      	mov	r0, r3
 800bd30:	f000 fc08 	bl	800c544 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_P_Frequency;
 800bd34:	69bb      	ldr	r3, [r7, #24]
 800bd36:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 800bd38:	e3df      	b.n	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
          frequency = 0;
 800bd3a:	2300      	movs	r3, #0
 800bd3c:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 800bd3e:	e3dc      	b.n	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
      }

      case RCC_SAI2ACLKSOURCE_PLL3: /* PLLI3 is the clock source for SAI2A  */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY))
 800bd40:	4b27      	ldr	r3, [pc, #156]	@ (800bde0 <HAL_RCCEx_GetPeriphCLKFreq+0x278>)
 800bd42:	681b      	ldr	r3, [r3, #0]
 800bd44:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
 800bd48:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 800bd4c:	d107      	bne.n	800bd5e <HAL_RCCEx_GetPeriphCLKFreq+0x1f6>
        {
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 800bd4e:	f107 030c 	add.w	r3, r7, #12
 800bd52:	4618      	mov	r0, r3
 800bd54:	f000 fd4a 	bl	800c7ec <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_P_Frequency;
 800bd58:	68fb      	ldr	r3, [r7, #12]
 800bd5a:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 800bd5c:	e3cd      	b.n	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
          frequency = 0;
 800bd5e:	2300      	movs	r3, #0
 800bd60:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 800bd62:	e3ca      	b.n	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
      }

      case RCC_SAI2ACLKSOURCE_CLKP: /* CKPER is the clock source for SAI2A  */
      {

        ckpclocksource = __HAL_RCC_GET_CLKP_SOURCE();
 800bd64:	4b1e      	ldr	r3, [pc, #120]	@ (800bde0 <HAL_RCCEx_GetPeriphCLKFreq+0x278>)
 800bd66:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 800bd68:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
 800bd6c:	637b      	str	r3, [r7, #52]	@ 0x34

        if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSI))
 800bd6e:	4b1c      	ldr	r3, [pc, #112]	@ (800bde0 <HAL_RCCEx_GetPeriphCLKFreq+0x278>)
 800bd70:	681b      	ldr	r3, [r3, #0]
 800bd72:	f003 0304 	and.w	r3, r3, #4
 800bd76:	2b04      	cmp	r3, #4
 800bd78:	d10c      	bne.n	800bd94 <HAL_RCCEx_GetPeriphCLKFreq+0x22c>
 800bd7a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800bd7c:	2b00      	cmp	r3, #0
 800bd7e:	d109      	bne.n	800bd94 <HAL_RCCEx_GetPeriphCLKFreq+0x22c>
        {
          /* In Case the CKPER Source is HSI */
          frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
 800bd80:	4b17      	ldr	r3, [pc, #92]	@ (800bde0 <HAL_RCCEx_GetPeriphCLKFreq+0x278>)
 800bd82:	681b      	ldr	r3, [r3, #0]
 800bd84:	08db      	lsrs	r3, r3, #3
 800bd86:	f003 0303 	and.w	r3, r3, #3
 800bd8a:	4a16      	ldr	r2, [pc, #88]	@ (800bde4 <HAL_RCCEx_GetPeriphCLKFreq+0x27c>)
 800bd8c:	fa22 f303 	lsr.w	r3, r2, r3
 800bd90:	63fb      	str	r3, [r7, #60]	@ 0x3c
 800bd92:	e01e      	b.n	800bdd2 <HAL_RCCEx_GetPeriphCLKFreq+0x26a>
        }

        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_CSI))
 800bd94:	4b12      	ldr	r3, [pc, #72]	@ (800bde0 <HAL_RCCEx_GetPeriphCLKFreq+0x278>)
 800bd96:	681b      	ldr	r3, [r3, #0]
 800bd98:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 800bd9c:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 800bda0:	d106      	bne.n	800bdb0 <HAL_RCCEx_GetPeriphCLKFreq+0x248>
 800bda2:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800bda4:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
 800bda8:	d102      	bne.n	800bdb0 <HAL_RCCEx_GetPeriphCLKFreq+0x248>
        {
          /* In Case the CKPER Source is CSI */
          frequency = CSI_VALUE;
 800bdaa:	4b0f      	ldr	r3, [pc, #60]	@ (800bde8 <HAL_RCCEx_GetPeriphCLKFreq+0x280>)
 800bdac:	63fb      	str	r3, [r7, #60]	@ 0x3c
 800bdae:	e010      	b.n	800bdd2 <HAL_RCCEx_GetPeriphCLKFreq+0x26a>
        }

        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSE))
 800bdb0:	4b0b      	ldr	r3, [pc, #44]	@ (800bde0 <HAL_RCCEx_GetPeriphCLKFreq+0x278>)
 800bdb2:	681b      	ldr	r3, [r3, #0]
 800bdb4:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 800bdb8:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 800bdbc:	d106      	bne.n	800bdcc <HAL_RCCEx_GetPeriphCLKFreq+0x264>
 800bdbe:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800bdc0:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 800bdc4:	d102      	bne.n	800bdcc <HAL_RCCEx_GetPeriphCLKFreq+0x264>
        {
          /* In Case the CKPER Source is HSE */
          frequency = HSE_VALUE;
 800bdc6:	4b09      	ldr	r3, [pc, #36]	@ (800bdec <HAL_RCCEx_GetPeriphCLKFreq+0x284>)
 800bdc8:	63fb      	str	r3, [r7, #60]	@ 0x3c
 800bdca:	e002      	b.n	800bdd2 <HAL_RCCEx_GetPeriphCLKFreq+0x26a>
        }

        else
        {
          /* In Case the CKPER is disabled*/
          frequency = 0;
 800bdcc:	2300      	movs	r3, #0
 800bdce:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }

        break;
 800bdd0:	e393      	b.n	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
 800bdd2:	e392      	b.n	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
      }

      case (RCC_SAI2ACLKSOURCE_PIN): /* External clock is the clock source for SAI2A */
      {
        frequency = EXTERNAL_CLOCK_VALUE;
 800bdd4:	4b06      	ldr	r3, [pc, #24]	@ (800bdf0 <HAL_RCCEx_GetPeriphCLKFreq+0x288>)
 800bdd6:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 800bdd8:	e38f      	b.n	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
      }

      default :
      {
        frequency = 0;
 800bdda:	2300      	movs	r3, #0
 800bddc:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 800bdde:	e38c      	b.n	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
 800bde0:	58024400 	.word	0x58024400
 800bde4:	03d09000 	.word	0x03d09000
 800bde8:	003d0900 	.word	0x003d0900
 800bdec:	016e3600 	.word	0x016e3600
 800bdf0:	00bb8000 	.word	0x00bb8000

  }
#endif

#if  defined(RCC_CDCCIP1R_SAI2BSEL_0)
  else if (PeriphClk == RCC_PERIPHCLK_SAI2B)
 800bdf4:	e9d7 2300 	ldrd	r2, r3, [r7]
 800bdf8:	f5a2 6180 	sub.w	r1, r2, #1024	@ 0x400
 800bdfc:	430b      	orrs	r3, r1
 800bdfe:	f040 809c 	bne.w	800bf3a <HAL_RCCEx_GetPeriphCLKFreq+0x3d2>
  {

    saiclocksource = __HAL_RCC_GET_SAI2B_SOURCE();
 800be02:	4b9e      	ldr	r3, [pc, #632]	@ (800c07c <HAL_RCCEx_GetPeriphCLKFreq+0x514>)
 800be04:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800be06:	f403 6360 	and.w	r3, r3, #3584	@ 0xe00
 800be0a:	633b      	str	r3, [r7, #48]	@ 0x30

    switch (saiclocksource)
 800be0c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800be0e:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
 800be12:	d054      	beq.n	800bebe <HAL_RCCEx_GetPeriphCLKFreq+0x356>
 800be14:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800be16:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
 800be1a:	f200 808b 	bhi.w	800bf34 <HAL_RCCEx_GetPeriphCLKFreq+0x3cc>
 800be1e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800be20:	f5b3 6fc0 	cmp.w	r3, #1536	@ 0x600
 800be24:	f000 8083 	beq.w	800bf2e <HAL_RCCEx_GetPeriphCLKFreq+0x3c6>
 800be28:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800be2a:	f5b3 6fc0 	cmp.w	r3, #1536	@ 0x600
 800be2e:	f200 8081 	bhi.w	800bf34 <HAL_RCCEx_GetPeriphCLKFreq+0x3cc>
 800be32:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800be34:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 800be38:	d02f      	beq.n	800be9a <HAL_RCCEx_GetPeriphCLKFreq+0x332>
 800be3a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800be3c:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 800be40:	d878      	bhi.n	800bf34 <HAL_RCCEx_GetPeriphCLKFreq+0x3cc>
 800be42:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800be44:	2b00      	cmp	r3, #0
 800be46:	d004      	beq.n	800be52 <HAL_RCCEx_GetPeriphCLKFreq+0x2ea>
 800be48:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800be4a:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 800be4e:	d012      	beq.n	800be76 <HAL_RCCEx_GetPeriphCLKFreq+0x30e>
 800be50:	e070      	b.n	800bf34 <HAL_RCCEx_GetPeriphCLKFreq+0x3cc>
    {
      case RCC_SAI2BCLKSOURCE_PLL: /* PLL1 is the clock source for SAI2B */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL1RDY))
 800be52:	4b8a      	ldr	r3, [pc, #552]	@ (800c07c <HAL_RCCEx_GetPeriphCLKFreq+0x514>)
 800be54:	681b      	ldr	r3, [r3, #0]
 800be56:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 800be5a:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
 800be5e:	d107      	bne.n	800be70 <HAL_RCCEx_GetPeriphCLKFreq+0x308>
        {
          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
 800be60:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 800be64:	4618      	mov	r0, r3
 800be66:	f000 fe15 	bl	800ca94 <HAL_RCCEx_GetPLL1ClockFreq>
          frequency = pll1_clocks.PLL1_Q_Frequency;
 800be6a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800be6c:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 800be6e:	e344      	b.n	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
          frequency = 0;
 800be70:	2300      	movs	r3, #0
 800be72:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 800be74:	e341      	b.n	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
      }
      case RCC_SAI2BCLKSOURCE_PLL2: /* PLLI2 is the clock source for SAI2B */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))
 800be76:	4b81      	ldr	r3, [pc, #516]	@ (800c07c <HAL_RCCEx_GetPeriphCLKFreq+0x514>)
 800be78:	681b      	ldr	r3, [r3, #0]
 800be7a:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 800be7e:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 800be82:	d107      	bne.n	800be94 <HAL_RCCEx_GetPeriphCLKFreq+0x32c>
        {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 800be84:	f107 0318 	add.w	r3, r7, #24
 800be88:	4618      	mov	r0, r3
 800be8a:	f000 fb5b 	bl	800c544 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_P_Frequency;
 800be8e:	69bb      	ldr	r3, [r7, #24]
 800be90:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 800be92:	e332      	b.n	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
          frequency = 0;
 800be94:	2300      	movs	r3, #0
 800be96:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 800be98:	e32f      	b.n	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
      }

      case RCC_SAI2BCLKSOURCE_PLL3: /* PLLI3 is the clock source for SAI2B */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY))
 800be9a:	4b78      	ldr	r3, [pc, #480]	@ (800c07c <HAL_RCCEx_GetPeriphCLKFreq+0x514>)
 800be9c:	681b      	ldr	r3, [r3, #0]
 800be9e:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
 800bea2:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 800bea6:	d107      	bne.n	800beb8 <HAL_RCCEx_GetPeriphCLKFreq+0x350>
        {
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 800bea8:	f107 030c 	add.w	r3, r7, #12
 800beac:	4618      	mov	r0, r3
 800beae:	f000 fc9d 	bl	800c7ec <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_P_Frequency;
 800beb2:	68fb      	ldr	r3, [r7, #12]
 800beb4:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 800beb6:	e320      	b.n	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
          frequency = 0;
 800beb8:	2300      	movs	r3, #0
 800beba:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 800bebc:	e31d      	b.n	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
      }

      case RCC_SAI2BCLKSOURCE_CLKP: /* CKPER is the clock source for SAI2B*/
      {

        ckpclocksource = __HAL_RCC_GET_CLKP_SOURCE();
 800bebe:	4b6f      	ldr	r3, [pc, #444]	@ (800c07c <HAL_RCCEx_GetPeriphCLKFreq+0x514>)
 800bec0:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 800bec2:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
 800bec6:	637b      	str	r3, [r7, #52]	@ 0x34

        if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSI))
 800bec8:	4b6c      	ldr	r3, [pc, #432]	@ (800c07c <HAL_RCCEx_GetPeriphCLKFreq+0x514>)
 800beca:	681b      	ldr	r3, [r3, #0]
 800becc:	f003 0304 	and.w	r3, r3, #4
 800bed0:	2b04      	cmp	r3, #4
 800bed2:	d10c      	bne.n	800beee <HAL_RCCEx_GetPeriphCLKFreq+0x386>
 800bed4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800bed6:	2b00      	cmp	r3, #0
 800bed8:	d109      	bne.n	800beee <HAL_RCCEx_GetPeriphCLKFreq+0x386>
        {
          /* In Case the CKPER Source is HSI */
          frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
 800beda:	4b68      	ldr	r3, [pc, #416]	@ (800c07c <HAL_RCCEx_GetPeriphCLKFreq+0x514>)
 800bedc:	681b      	ldr	r3, [r3, #0]
 800bede:	08db      	lsrs	r3, r3, #3
 800bee0:	f003 0303 	and.w	r3, r3, #3
 800bee4:	4a66      	ldr	r2, [pc, #408]	@ (800c080 <HAL_RCCEx_GetPeriphCLKFreq+0x518>)
 800bee6:	fa22 f303 	lsr.w	r3, r2, r3
 800beea:	63fb      	str	r3, [r7, #60]	@ 0x3c
 800beec:	e01e      	b.n	800bf2c <HAL_RCCEx_GetPeriphCLKFreq+0x3c4>
        }

        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_CSI))
 800beee:	4b63      	ldr	r3, [pc, #396]	@ (800c07c <HAL_RCCEx_GetPeriphCLKFreq+0x514>)
 800bef0:	681b      	ldr	r3, [r3, #0]
 800bef2:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 800bef6:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 800befa:	d106      	bne.n	800bf0a <HAL_RCCEx_GetPeriphCLKFreq+0x3a2>
 800befc:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800befe:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
 800bf02:	d102      	bne.n	800bf0a <HAL_RCCEx_GetPeriphCLKFreq+0x3a2>
        {
          /* In Case the CKPER Source is CSI */
          frequency = CSI_VALUE;
 800bf04:	4b5f      	ldr	r3, [pc, #380]	@ (800c084 <HAL_RCCEx_GetPeriphCLKFreq+0x51c>)
 800bf06:	63fb      	str	r3, [r7, #60]	@ 0x3c
 800bf08:	e010      	b.n	800bf2c <HAL_RCCEx_GetPeriphCLKFreq+0x3c4>
        }

        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSE))
 800bf0a:	4b5c      	ldr	r3, [pc, #368]	@ (800c07c <HAL_RCCEx_GetPeriphCLKFreq+0x514>)
 800bf0c:	681b      	ldr	r3, [r3, #0]
 800bf0e:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 800bf12:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 800bf16:	d106      	bne.n	800bf26 <HAL_RCCEx_GetPeriphCLKFreq+0x3be>
 800bf18:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800bf1a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 800bf1e:	d102      	bne.n	800bf26 <HAL_RCCEx_GetPeriphCLKFreq+0x3be>
        {
          /* In Case the CKPER Source is HSE */
          frequency = HSE_VALUE;
 800bf20:	4b59      	ldr	r3, [pc, #356]	@ (800c088 <HAL_RCCEx_GetPeriphCLKFreq+0x520>)
 800bf22:	63fb      	str	r3, [r7, #60]	@ 0x3c
 800bf24:	e002      	b.n	800bf2c <HAL_RCCEx_GetPeriphCLKFreq+0x3c4>
        }

        else
        {
          /* In Case the CKPER is disabled*/
          frequency = 0;
 800bf26:	2300      	movs	r3, #0
 800bf28:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        break;
 800bf2a:	e2e6      	b.n	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
 800bf2c:	e2e5      	b.n	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
      }

      case (RCC_SAI2BCLKSOURCE_PIN): /* External clock is the clock source for SAI2B */
      {
        frequency = EXTERNAL_CLOCK_VALUE;
 800bf2e:	4b57      	ldr	r3, [pc, #348]	@ (800c08c <HAL_RCCEx_GetPeriphCLKFreq+0x524>)
 800bf30:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 800bf32:	e2e2      	b.n	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
      }

      default :
      {
        frequency = 0;
 800bf34:	2300      	movs	r3, #0
 800bf36:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 800bf38:	e2df      	b.n	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
        break;
      }
    }
  }
#endif /*SAI4*/
  else if (PeriphClk == RCC_PERIPHCLK_SPI123)
 800bf3a:	e9d7 2300 	ldrd	r2, r3, [r7]
 800bf3e:	f5a2 5180 	sub.w	r1, r2, #4096	@ 0x1000
 800bf42:	430b      	orrs	r3, r1
 800bf44:	f040 80a7 	bne.w	800c096 <HAL_RCCEx_GetPeriphCLKFreq+0x52e>
  {
    /* Get SPI1/2/3 clock source */
    srcclk = __HAL_RCC_GET_SPI123_SOURCE();
 800bf48:	4b4c      	ldr	r3, [pc, #304]	@ (800c07c <HAL_RCCEx_GetPeriphCLKFreq+0x514>)
 800bf4a:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800bf4c:	f403 43e0 	and.w	r3, r3, #28672	@ 0x7000
 800bf50:	63bb      	str	r3, [r7, #56]	@ 0x38

    switch (srcclk)
 800bf52:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800bf54:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
 800bf58:	d055      	beq.n	800c006 <HAL_RCCEx_GetPeriphCLKFreq+0x49e>
 800bf5a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800bf5c:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
 800bf60:	f200 8096 	bhi.w	800c090 <HAL_RCCEx_GetPeriphCLKFreq+0x528>
 800bf64:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800bf66:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
 800bf6a:	f000 8084 	beq.w	800c076 <HAL_RCCEx_GetPeriphCLKFreq+0x50e>
 800bf6e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800bf70:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
 800bf74:	f200 808c 	bhi.w	800c090 <HAL_RCCEx_GetPeriphCLKFreq+0x528>
 800bf78:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800bf7a:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 800bf7e:	d030      	beq.n	800bfe2 <HAL_RCCEx_GetPeriphCLKFreq+0x47a>
 800bf80:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800bf82:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 800bf86:	f200 8083 	bhi.w	800c090 <HAL_RCCEx_GetPeriphCLKFreq+0x528>
 800bf8a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800bf8c:	2b00      	cmp	r3, #0
 800bf8e:	d004      	beq.n	800bf9a <HAL_RCCEx_GetPeriphCLKFreq+0x432>
 800bf90:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800bf92:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 800bf96:	d012      	beq.n	800bfbe <HAL_RCCEx_GetPeriphCLKFreq+0x456>
 800bf98:	e07a      	b.n	800c090 <HAL_RCCEx_GetPeriphCLKFreq+0x528>
    {
      case RCC_SPI123CLKSOURCE_PLL: /* PLL1 is the clock source for SPI123 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL1RDY))
 800bf9a:	4b38      	ldr	r3, [pc, #224]	@ (800c07c <HAL_RCCEx_GetPeriphCLKFreq+0x514>)
 800bf9c:	681b      	ldr	r3, [r3, #0]
 800bf9e:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 800bfa2:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
 800bfa6:	d107      	bne.n	800bfb8 <HAL_RCCEx_GetPeriphCLKFreq+0x450>
        {
          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
 800bfa8:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 800bfac:	4618      	mov	r0, r3
 800bfae:	f000 fd71 	bl	800ca94 <HAL_RCCEx_GetPLL1ClockFreq>
          frequency = pll1_clocks.PLL1_Q_Frequency;
 800bfb2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800bfb4:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 800bfb6:	e2a0      	b.n	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
          frequency = 0;
 800bfb8:	2300      	movs	r3, #0
 800bfba:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 800bfbc:	e29d      	b.n	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
      }
      case RCC_SPI123CLKSOURCE_PLL2: /* PLL2 is the clock source for SPI123 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))
 800bfbe:	4b2f      	ldr	r3, [pc, #188]	@ (800c07c <HAL_RCCEx_GetPeriphCLKFreq+0x514>)
 800bfc0:	681b      	ldr	r3, [r3, #0]
 800bfc2:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 800bfc6:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 800bfca:	d107      	bne.n	800bfdc <HAL_RCCEx_GetPeriphCLKFreq+0x474>
        {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 800bfcc:	f107 0318 	add.w	r3, r7, #24
 800bfd0:	4618      	mov	r0, r3
 800bfd2:	f000 fab7 	bl	800c544 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_P_Frequency;
 800bfd6:	69bb      	ldr	r3, [r7, #24]
 800bfd8:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 800bfda:	e28e      	b.n	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
          frequency = 0;
 800bfdc:	2300      	movs	r3, #0
 800bfde:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 800bfe0:	e28b      	b.n	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
      }

      case RCC_SPI123CLKSOURCE_PLL3: /* PLL3 is the clock source for SPI123 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY))
 800bfe2:	4b26      	ldr	r3, [pc, #152]	@ (800c07c <HAL_RCCEx_GetPeriphCLKFreq+0x514>)
 800bfe4:	681b      	ldr	r3, [r3, #0]
 800bfe6:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
 800bfea:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 800bfee:	d107      	bne.n	800c000 <HAL_RCCEx_GetPeriphCLKFreq+0x498>
        {
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 800bff0:	f107 030c 	add.w	r3, r7, #12
 800bff4:	4618      	mov	r0, r3
 800bff6:	f000 fbf9 	bl	800c7ec <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_P_Frequency;
 800bffa:	68fb      	ldr	r3, [r7, #12]
 800bffc:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 800bffe:	e27c      	b.n	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
          frequency = 0;
 800c000:	2300      	movs	r3, #0
 800c002:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 800c004:	e279      	b.n	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
      }

      case RCC_SPI123CLKSOURCE_CLKP: /* CKPER is the clock source for SPI123 */
      {

        ckpclocksource = __HAL_RCC_GET_CLKP_SOURCE();
 800c006:	4b1d      	ldr	r3, [pc, #116]	@ (800c07c <HAL_RCCEx_GetPeriphCLKFreq+0x514>)
 800c008:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 800c00a:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
 800c00e:	637b      	str	r3, [r7, #52]	@ 0x34

        if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSI))
 800c010:	4b1a      	ldr	r3, [pc, #104]	@ (800c07c <HAL_RCCEx_GetPeriphCLKFreq+0x514>)
 800c012:	681b      	ldr	r3, [r3, #0]
 800c014:	f003 0304 	and.w	r3, r3, #4
 800c018:	2b04      	cmp	r3, #4
 800c01a:	d10c      	bne.n	800c036 <HAL_RCCEx_GetPeriphCLKFreq+0x4ce>
 800c01c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800c01e:	2b00      	cmp	r3, #0
 800c020:	d109      	bne.n	800c036 <HAL_RCCEx_GetPeriphCLKFreq+0x4ce>
        {
          /* In Case the CKPER Source is HSI */
          frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
 800c022:	4b16      	ldr	r3, [pc, #88]	@ (800c07c <HAL_RCCEx_GetPeriphCLKFreq+0x514>)
 800c024:	681b      	ldr	r3, [r3, #0]
 800c026:	08db      	lsrs	r3, r3, #3
 800c028:	f003 0303 	and.w	r3, r3, #3
 800c02c:	4a14      	ldr	r2, [pc, #80]	@ (800c080 <HAL_RCCEx_GetPeriphCLKFreq+0x518>)
 800c02e:	fa22 f303 	lsr.w	r3, r2, r3
 800c032:	63fb      	str	r3, [r7, #60]	@ 0x3c
 800c034:	e01e      	b.n	800c074 <HAL_RCCEx_GetPeriphCLKFreq+0x50c>
        }

        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_CSI))
 800c036:	4b11      	ldr	r3, [pc, #68]	@ (800c07c <HAL_RCCEx_GetPeriphCLKFreq+0x514>)
 800c038:	681b      	ldr	r3, [r3, #0]
 800c03a:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 800c03e:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 800c042:	d106      	bne.n	800c052 <HAL_RCCEx_GetPeriphCLKFreq+0x4ea>
 800c044:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800c046:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
 800c04a:	d102      	bne.n	800c052 <HAL_RCCEx_GetPeriphCLKFreq+0x4ea>
        {
          /* In Case the CKPER Source is CSI */
          frequency = CSI_VALUE;
 800c04c:	4b0d      	ldr	r3, [pc, #52]	@ (800c084 <HAL_RCCEx_GetPeriphCLKFreq+0x51c>)
 800c04e:	63fb      	str	r3, [r7, #60]	@ 0x3c
 800c050:	e010      	b.n	800c074 <HAL_RCCEx_GetPeriphCLKFreq+0x50c>
        }

        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSE))
 800c052:	4b0a      	ldr	r3, [pc, #40]	@ (800c07c <HAL_RCCEx_GetPeriphCLKFreq+0x514>)
 800c054:	681b      	ldr	r3, [r3, #0]
 800c056:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 800c05a:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 800c05e:	d106      	bne.n	800c06e <HAL_RCCEx_GetPeriphCLKFreq+0x506>
 800c060:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800c062:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 800c066:	d102      	bne.n	800c06e <HAL_RCCEx_GetPeriphCLKFreq+0x506>
        {
          /* In Case the CKPER Source is HSE */
          frequency = HSE_VALUE;
 800c068:	4b07      	ldr	r3, [pc, #28]	@ (800c088 <HAL_RCCEx_GetPeriphCLKFreq+0x520>)
 800c06a:	63fb      	str	r3, [r7, #60]	@ 0x3c
 800c06c:	e002      	b.n	800c074 <HAL_RCCEx_GetPeriphCLKFreq+0x50c>
        }

        else
        {
          /* In Case the CKPER is disabled*/
          frequency = 0;
 800c06e:	2300      	movs	r3, #0
 800c070:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }

        break;
 800c072:	e242      	b.n	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
 800c074:	e241      	b.n	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
      }

      case (RCC_SPI123CLKSOURCE_PIN): /* External clock is the clock source for I2S */
      {
        frequency = EXTERNAL_CLOCK_VALUE;
 800c076:	4b05      	ldr	r3, [pc, #20]	@ (800c08c <HAL_RCCEx_GetPeriphCLKFreq+0x524>)
 800c078:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 800c07a:	e23e      	b.n	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
 800c07c:	58024400 	.word	0x58024400
 800c080:	03d09000 	.word	0x03d09000
 800c084:	003d0900 	.word	0x003d0900
 800c088:	016e3600 	.word	0x016e3600
 800c08c:	00bb8000 	.word	0x00bb8000
      }
      default :
      {
        frequency = 0;
 800c090:	2300      	movs	r3, #0
 800c092:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 800c094:	e231      	b.n	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
      }
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_SPI45)
 800c096:	e9d7 2300 	ldrd	r2, r3, [r7]
 800c09a:	f5a2 5100 	sub.w	r1, r2, #8192	@ 0x2000
 800c09e:	430b      	orrs	r3, r1
 800c0a0:	f040 8085 	bne.w	800c1ae <HAL_RCCEx_GetPeriphCLKFreq+0x646>
  {
    /* Get SPI45 clock source */
    srcclk = __HAL_RCC_GET_SPI45_SOURCE();
 800c0a4:	4b9c      	ldr	r3, [pc, #624]	@ (800c318 <HAL_RCCEx_GetPeriphCLKFreq+0x7b0>)
 800c0a6:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800c0a8:	f403 23e0 	and.w	r3, r3, #458752	@ 0x70000
 800c0ac:	63bb      	str	r3, [r7, #56]	@ 0x38
    switch (srcclk)
 800c0ae:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800c0b0:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
 800c0b4:	d06b      	beq.n	800c18e <HAL_RCCEx_GetPeriphCLKFreq+0x626>
 800c0b6:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800c0b8:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
 800c0bc:	d874      	bhi.n	800c1a8 <HAL_RCCEx_GetPeriphCLKFreq+0x640>
 800c0be:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800c0c0:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
 800c0c4:	d056      	beq.n	800c174 <HAL_RCCEx_GetPeriphCLKFreq+0x60c>
 800c0c6:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800c0c8:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
 800c0cc:	d86c      	bhi.n	800c1a8 <HAL_RCCEx_GetPeriphCLKFreq+0x640>
 800c0ce:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800c0d0:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
 800c0d4:	d03b      	beq.n	800c14e <HAL_RCCEx_GetPeriphCLKFreq+0x5e6>
 800c0d6:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800c0d8:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
 800c0dc:	d864      	bhi.n	800c1a8 <HAL_RCCEx_GetPeriphCLKFreq+0x640>
 800c0de:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800c0e0:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 800c0e4:	d021      	beq.n	800c12a <HAL_RCCEx_GetPeriphCLKFreq+0x5c2>
 800c0e6:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800c0e8:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 800c0ec:	d85c      	bhi.n	800c1a8 <HAL_RCCEx_GetPeriphCLKFreq+0x640>
 800c0ee:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800c0f0:	2b00      	cmp	r3, #0
 800c0f2:	d004      	beq.n	800c0fe <HAL_RCCEx_GetPeriphCLKFreq+0x596>
 800c0f4:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800c0f6:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 800c0fa:	d004      	beq.n	800c106 <HAL_RCCEx_GetPeriphCLKFreq+0x59e>
 800c0fc:	e054      	b.n	800c1a8 <HAL_RCCEx_GetPeriphCLKFreq+0x640>
    {
      case RCC_SPI45CLKSOURCE_PCLK2: /* CD/D2 PCLK2 is the clock source for SPI4/5 */
      {
        frequency = HAL_RCC_GetPCLK1Freq();
 800c0fe:	f7fe fb5f 	bl	800a7c0 <HAL_RCC_GetPCLK1Freq>
 800c102:	63f8      	str	r0, [r7, #60]	@ 0x3c
        break;
 800c104:	e1f9      	b.n	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
      }
      case RCC_SPI45CLKSOURCE_PLL2: /* PLL2 is the clock source for SPI45 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))
 800c106:	4b84      	ldr	r3, [pc, #528]	@ (800c318 <HAL_RCCEx_GetPeriphCLKFreq+0x7b0>)
 800c108:	681b      	ldr	r3, [r3, #0]
 800c10a:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 800c10e:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 800c112:	d107      	bne.n	800c124 <HAL_RCCEx_GetPeriphCLKFreq+0x5bc>
        {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 800c114:	f107 0318 	add.w	r3, r7, #24
 800c118:	4618      	mov	r0, r3
 800c11a:	f000 fa13 	bl	800c544 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_Q_Frequency;
 800c11e:	69fb      	ldr	r3, [r7, #28]
 800c120:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 800c122:	e1ea      	b.n	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
          frequency = 0;
 800c124:	2300      	movs	r3, #0
 800c126:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 800c128:	e1e7      	b.n	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
      }
      case RCC_SPI45CLKSOURCE_PLL3: /* PLL3 is the clock source for SPI45 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY))
 800c12a:	4b7b      	ldr	r3, [pc, #492]	@ (800c318 <HAL_RCCEx_GetPeriphCLKFreq+0x7b0>)
 800c12c:	681b      	ldr	r3, [r3, #0]
 800c12e:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
 800c132:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 800c136:	d107      	bne.n	800c148 <HAL_RCCEx_GetPeriphCLKFreq+0x5e0>
        {
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 800c138:	f107 030c 	add.w	r3, r7, #12
 800c13c:	4618      	mov	r0, r3
 800c13e:	f000 fb55 	bl	800c7ec <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_Q_Frequency;
 800c142:	693b      	ldr	r3, [r7, #16]
 800c144:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 800c146:	e1d8      	b.n	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
          frequency = 0;
 800c148:	2300      	movs	r3, #0
 800c14a:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 800c14c:	e1d5      	b.n	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
      }
      case RCC_SPI45CLKSOURCE_HSI: /* HSI is the clock source for SPI45 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
 800c14e:	4b72      	ldr	r3, [pc, #456]	@ (800c318 <HAL_RCCEx_GetPeriphCLKFreq+0x7b0>)
 800c150:	681b      	ldr	r3, [r3, #0]
 800c152:	f003 0304 	and.w	r3, r3, #4
 800c156:	2b04      	cmp	r3, #4
 800c158:	d109      	bne.n	800c16e <HAL_RCCEx_GetPeriphCLKFreq+0x606>
        {
          frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
 800c15a:	4b6f      	ldr	r3, [pc, #444]	@ (800c318 <HAL_RCCEx_GetPeriphCLKFreq+0x7b0>)
 800c15c:	681b      	ldr	r3, [r3, #0]
 800c15e:	08db      	lsrs	r3, r3, #3
 800c160:	f003 0303 	and.w	r3, r3, #3
 800c164:	4a6d      	ldr	r2, [pc, #436]	@ (800c31c <HAL_RCCEx_GetPeriphCLKFreq+0x7b4>)
 800c166:	fa22 f303 	lsr.w	r3, r2, r3
 800c16a:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 800c16c:	e1c5      	b.n	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
          frequency = 0;
 800c16e:	2300      	movs	r3, #0
 800c170:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 800c172:	e1c2      	b.n	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
      }
      case RCC_SPI45CLKSOURCE_CSI: /* CSI is the clock source for SPI45 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY))
 800c174:	4b68      	ldr	r3, [pc, #416]	@ (800c318 <HAL_RCCEx_GetPeriphCLKFreq+0x7b0>)
 800c176:	681b      	ldr	r3, [r3, #0]
 800c178:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 800c17c:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 800c180:	d102      	bne.n	800c188 <HAL_RCCEx_GetPeriphCLKFreq+0x620>
        {
          frequency = CSI_VALUE;
 800c182:	4b67      	ldr	r3, [pc, #412]	@ (800c320 <HAL_RCCEx_GetPeriphCLKFreq+0x7b8>)
 800c184:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 800c186:	e1b8      	b.n	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
          frequency = 0;
 800c188:	2300      	movs	r3, #0
 800c18a:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 800c18c:	e1b5      	b.n	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
      }
      case RCC_SPI45CLKSOURCE_HSE: /* HSE is the clock source for SPI45 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY))
 800c18e:	4b62      	ldr	r3, [pc, #392]	@ (800c318 <HAL_RCCEx_GetPeriphCLKFreq+0x7b0>)
 800c190:	681b      	ldr	r3, [r3, #0]
 800c192:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 800c196:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 800c19a:	d102      	bne.n	800c1a2 <HAL_RCCEx_GetPeriphCLKFreq+0x63a>
        {
          frequency = HSE_VALUE;
 800c19c:	4b61      	ldr	r3, [pc, #388]	@ (800c324 <HAL_RCCEx_GetPeriphCLKFreq+0x7bc>)
 800c19e:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 800c1a0:	e1ab      	b.n	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
          frequency = 0;
 800c1a2:	2300      	movs	r3, #0
 800c1a4:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 800c1a6:	e1a8      	b.n	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
      }
      default :
      {
        frequency = 0;
 800c1a8:	2300      	movs	r3, #0
 800c1aa:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 800c1ac:	e1a5      	b.n	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
      }
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_ADC)
 800c1ae:	e9d7 2300 	ldrd	r2, r3, [r7]
 800c1b2:	f5a2 2100 	sub.w	r1, r2, #524288	@ 0x80000
 800c1b6:	430b      	orrs	r3, r1
 800c1b8:	d173      	bne.n	800c2a2 <HAL_RCCEx_GetPeriphCLKFreq+0x73a>
  {
    /* Get ADC clock source */
    srcclk = __HAL_RCC_GET_ADC_SOURCE();
 800c1ba:	4b57      	ldr	r3, [pc, #348]	@ (800c318 <HAL_RCCEx_GetPeriphCLKFreq+0x7b0>)
 800c1bc:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 800c1be:	f403 3340 	and.w	r3, r3, #196608	@ 0x30000
 800c1c2:	63bb      	str	r3, [r7, #56]	@ 0x38

    switch (srcclk)
 800c1c4:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800c1c6:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 800c1ca:	d02f      	beq.n	800c22c <HAL_RCCEx_GetPeriphCLKFreq+0x6c4>
 800c1cc:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800c1ce:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 800c1d2:	d863      	bhi.n	800c29c <HAL_RCCEx_GetPeriphCLKFreq+0x734>
 800c1d4:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800c1d6:	2b00      	cmp	r3, #0
 800c1d8:	d004      	beq.n	800c1e4 <HAL_RCCEx_GetPeriphCLKFreq+0x67c>
 800c1da:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800c1dc:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 800c1e0:	d012      	beq.n	800c208 <HAL_RCCEx_GetPeriphCLKFreq+0x6a0>
 800c1e2:	e05b      	b.n	800c29c <HAL_RCCEx_GetPeriphCLKFreq+0x734>
    {
      case RCC_ADCCLKSOURCE_PLL2:
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))
 800c1e4:	4b4c      	ldr	r3, [pc, #304]	@ (800c318 <HAL_RCCEx_GetPeriphCLKFreq+0x7b0>)
 800c1e6:	681b      	ldr	r3, [r3, #0]
 800c1e8:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 800c1ec:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 800c1f0:	d107      	bne.n	800c202 <HAL_RCCEx_GetPeriphCLKFreq+0x69a>
        {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 800c1f2:	f107 0318 	add.w	r3, r7, #24
 800c1f6:	4618      	mov	r0, r3
 800c1f8:	f000 f9a4 	bl	800c544 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_P_Frequency;
 800c1fc:	69bb      	ldr	r3, [r7, #24]
 800c1fe:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 800c200:	e17b      	b.n	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
          frequency = 0;
 800c202:	2300      	movs	r3, #0
 800c204:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 800c206:	e178      	b.n	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
      }
      case RCC_ADCCLKSOURCE_PLL3:
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY))
 800c208:	4b43      	ldr	r3, [pc, #268]	@ (800c318 <HAL_RCCEx_GetPeriphCLKFreq+0x7b0>)
 800c20a:	681b      	ldr	r3, [r3, #0]
 800c20c:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
 800c210:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 800c214:	d107      	bne.n	800c226 <HAL_RCCEx_GetPeriphCLKFreq+0x6be>
        {
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 800c216:	f107 030c 	add.w	r3, r7, #12
 800c21a:	4618      	mov	r0, r3
 800c21c:	f000 fae6 	bl	800c7ec <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_R_Frequency;
 800c220:	697b      	ldr	r3, [r7, #20]
 800c222:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 800c224:	e169      	b.n	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
          frequency = 0;
 800c226:	2300      	movs	r3, #0
 800c228:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 800c22a:	e166      	b.n	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
      }

      case RCC_ADCCLKSOURCE_CLKP:
      {

        ckpclocksource = __HAL_RCC_GET_CLKP_SOURCE();
 800c22c:	4b3a      	ldr	r3, [pc, #232]	@ (800c318 <HAL_RCCEx_GetPeriphCLKFreq+0x7b0>)
 800c22e:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 800c230:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
 800c234:	637b      	str	r3, [r7, #52]	@ 0x34

        if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSI))
 800c236:	4b38      	ldr	r3, [pc, #224]	@ (800c318 <HAL_RCCEx_GetPeriphCLKFreq+0x7b0>)
 800c238:	681b      	ldr	r3, [r3, #0]
 800c23a:	f003 0304 	and.w	r3, r3, #4
 800c23e:	2b04      	cmp	r3, #4
 800c240:	d10c      	bne.n	800c25c <HAL_RCCEx_GetPeriphCLKFreq+0x6f4>
 800c242:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800c244:	2b00      	cmp	r3, #0
 800c246:	d109      	bne.n	800c25c <HAL_RCCEx_GetPeriphCLKFreq+0x6f4>
        {
          /* In Case the CKPER Source is HSI */
          frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
 800c248:	4b33      	ldr	r3, [pc, #204]	@ (800c318 <HAL_RCCEx_GetPeriphCLKFreq+0x7b0>)
 800c24a:	681b      	ldr	r3, [r3, #0]
 800c24c:	08db      	lsrs	r3, r3, #3
 800c24e:	f003 0303 	and.w	r3, r3, #3
 800c252:	4a32      	ldr	r2, [pc, #200]	@ (800c31c <HAL_RCCEx_GetPeriphCLKFreq+0x7b4>)
 800c254:	fa22 f303 	lsr.w	r3, r2, r3
 800c258:	63fb      	str	r3, [r7, #60]	@ 0x3c
 800c25a:	e01e      	b.n	800c29a <HAL_RCCEx_GetPeriphCLKFreq+0x732>
        }

        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_CSI))
 800c25c:	4b2e      	ldr	r3, [pc, #184]	@ (800c318 <HAL_RCCEx_GetPeriphCLKFreq+0x7b0>)
 800c25e:	681b      	ldr	r3, [r3, #0]
 800c260:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 800c264:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 800c268:	d106      	bne.n	800c278 <HAL_RCCEx_GetPeriphCLKFreq+0x710>
 800c26a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800c26c:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
 800c270:	d102      	bne.n	800c278 <HAL_RCCEx_GetPeriphCLKFreq+0x710>
        {
          /* In Case the CKPER Source is CSI */
          frequency = CSI_VALUE;
 800c272:	4b2b      	ldr	r3, [pc, #172]	@ (800c320 <HAL_RCCEx_GetPeriphCLKFreq+0x7b8>)
 800c274:	63fb      	str	r3, [r7, #60]	@ 0x3c
 800c276:	e010      	b.n	800c29a <HAL_RCCEx_GetPeriphCLKFreq+0x732>
        }

        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSE))
 800c278:	4b27      	ldr	r3, [pc, #156]	@ (800c318 <HAL_RCCEx_GetPeriphCLKFreq+0x7b0>)
 800c27a:	681b      	ldr	r3, [r3, #0]
 800c27c:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 800c280:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 800c284:	d106      	bne.n	800c294 <HAL_RCCEx_GetPeriphCLKFreq+0x72c>
 800c286:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800c288:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 800c28c:	d102      	bne.n	800c294 <HAL_RCCEx_GetPeriphCLKFreq+0x72c>
        {
          /* In Case the CKPER Source is HSE */
          frequency = HSE_VALUE;
 800c28e:	4b25      	ldr	r3, [pc, #148]	@ (800c324 <HAL_RCCEx_GetPeriphCLKFreq+0x7bc>)
 800c290:	63fb      	str	r3, [r7, #60]	@ 0x3c
 800c292:	e002      	b.n	800c29a <HAL_RCCEx_GetPeriphCLKFreq+0x732>
        }

        else
        {
          /* In Case the CKPER is disabled*/
          frequency = 0;
 800c294:	2300      	movs	r3, #0
 800c296:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }

        break;
 800c298:	e12f      	b.n	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
 800c29a:	e12e      	b.n	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
      }

      default :
      {
        frequency = 0;
 800c29c:	2300      	movs	r3, #0
 800c29e:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 800c2a0:	e12b      	b.n	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
      }
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_SDMMC)
 800c2a2:	e9d7 2300 	ldrd	r2, r3, [r7]
 800c2a6:	f5a2 3180 	sub.w	r1, r2, #65536	@ 0x10000
 800c2aa:	430b      	orrs	r3, r1
 800c2ac:	d13c      	bne.n	800c328 <HAL_RCCEx_GetPeriphCLKFreq+0x7c0>
  {
    /* Get SDMMC clock source */
    srcclk = __HAL_RCC_GET_SDMMC_SOURCE();
 800c2ae:	4b1a      	ldr	r3, [pc, #104]	@ (800c318 <HAL_RCCEx_GetPeriphCLKFreq+0x7b0>)
 800c2b0:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 800c2b2:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 800c2b6:	63bb      	str	r3, [r7, #56]	@ 0x38

    switch (srcclk)
 800c2b8:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800c2ba:	2b00      	cmp	r3, #0
 800c2bc:	d004      	beq.n	800c2c8 <HAL_RCCEx_GetPeriphCLKFreq+0x760>
 800c2be:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800c2c0:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 800c2c4:	d012      	beq.n	800c2ec <HAL_RCCEx_GetPeriphCLKFreq+0x784>
 800c2c6:	e023      	b.n	800c310 <HAL_RCCEx_GetPeriphCLKFreq+0x7a8>
    {
      case RCC_SDMMCCLKSOURCE_PLL: /* PLL1 is the clock source for SDMMC */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL1RDY))
 800c2c8:	4b13      	ldr	r3, [pc, #76]	@ (800c318 <HAL_RCCEx_GetPeriphCLKFreq+0x7b0>)
 800c2ca:	681b      	ldr	r3, [r3, #0]
 800c2cc:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 800c2d0:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
 800c2d4:	d107      	bne.n	800c2e6 <HAL_RCCEx_GetPeriphCLKFreq+0x77e>
        {
          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
 800c2d6:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 800c2da:	4618      	mov	r0, r3
 800c2dc:	f000 fbda 	bl	800ca94 <HAL_RCCEx_GetPLL1ClockFreq>
          frequency = pll1_clocks.PLL1_Q_Frequency;
 800c2e0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800c2e2:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 800c2e4:	e109      	b.n	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
          frequency = 0;
 800c2e6:	2300      	movs	r3, #0
 800c2e8:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 800c2ea:	e106      	b.n	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
      }
      case RCC_SDMMCCLKSOURCE_PLL2: /* PLL2 is the clock source for SDMMC */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))
 800c2ec:	4b0a      	ldr	r3, [pc, #40]	@ (800c318 <HAL_RCCEx_GetPeriphCLKFreq+0x7b0>)
 800c2ee:	681b      	ldr	r3, [r3, #0]
 800c2f0:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 800c2f4:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 800c2f8:	d107      	bne.n	800c30a <HAL_RCCEx_GetPeriphCLKFreq+0x7a2>
        {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 800c2fa:	f107 0318 	add.w	r3, r7, #24
 800c2fe:	4618      	mov	r0, r3
 800c300:	f000 f920 	bl	800c544 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_R_Frequency;
 800c304:	6a3b      	ldr	r3, [r7, #32]
 800c306:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 800c308:	e0f7      	b.n	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
          frequency = 0;
 800c30a:	2300      	movs	r3, #0
 800c30c:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 800c30e:	e0f4      	b.n	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
      }

      default :
      {
        frequency = 0;
 800c310:	2300      	movs	r3, #0
 800c312:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 800c314:	e0f1      	b.n	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
 800c316:	bf00      	nop
 800c318:	58024400 	.word	0x58024400
 800c31c:	03d09000 	.word	0x03d09000
 800c320:	003d0900 	.word	0x003d0900
 800c324:	016e3600 	.word	0x016e3600
      }
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_SPI6)
 800c328:	e9d7 2300 	ldrd	r2, r3, [r7]
 800c32c:	f5a2 4180 	sub.w	r1, r2, #16384	@ 0x4000
 800c330:	430b      	orrs	r3, r1
 800c332:	f040 8091 	bne.w	800c458 <HAL_RCCEx_GetPeriphCLKFreq+0x8f0>
  {
    /* Get SPI6 clock source */
    srcclk = __HAL_RCC_GET_SPI6_SOURCE();
 800c336:	4b73      	ldr	r3, [pc, #460]	@ (800c504 <HAL_RCCEx_GetPeriphCLKFreq+0x99c>)
 800c338:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 800c33a:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
 800c33e:	63bb      	str	r3, [r7, #56]	@ 0x38

    switch (srcclk)
 800c340:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800c342:	f1b3 4fc0 	cmp.w	r3, #1610612736	@ 0x60000000
 800c346:	f000 8081 	beq.w	800c44c <HAL_RCCEx_GetPeriphCLKFreq+0x8e4>
 800c34a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800c34c:	f1b3 4fc0 	cmp.w	r3, #1610612736	@ 0x60000000
 800c350:	d87f      	bhi.n	800c452 <HAL_RCCEx_GetPeriphCLKFreq+0x8ea>
 800c352:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800c354:	f1b3 4fa0 	cmp.w	r3, #1342177280	@ 0x50000000
 800c358:	d06b      	beq.n	800c432 <HAL_RCCEx_GetPeriphCLKFreq+0x8ca>
 800c35a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800c35c:	f1b3 4fa0 	cmp.w	r3, #1342177280	@ 0x50000000
 800c360:	d877      	bhi.n	800c452 <HAL_RCCEx_GetPeriphCLKFreq+0x8ea>
 800c362:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800c364:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 800c368:	d056      	beq.n	800c418 <HAL_RCCEx_GetPeriphCLKFreq+0x8b0>
 800c36a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800c36c:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 800c370:	d86f      	bhi.n	800c452 <HAL_RCCEx_GetPeriphCLKFreq+0x8ea>
 800c372:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800c374:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
 800c378:	d03b      	beq.n	800c3f2 <HAL_RCCEx_GetPeriphCLKFreq+0x88a>
 800c37a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800c37c:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
 800c380:	d867      	bhi.n	800c452 <HAL_RCCEx_GetPeriphCLKFreq+0x8ea>
 800c382:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800c384:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 800c388:	d021      	beq.n	800c3ce <HAL_RCCEx_GetPeriphCLKFreq+0x866>
 800c38a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800c38c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 800c390:	d85f      	bhi.n	800c452 <HAL_RCCEx_GetPeriphCLKFreq+0x8ea>
 800c392:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800c394:	2b00      	cmp	r3, #0
 800c396:	d004      	beq.n	800c3a2 <HAL_RCCEx_GetPeriphCLKFreq+0x83a>
 800c398:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800c39a:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
 800c39e:	d004      	beq.n	800c3aa <HAL_RCCEx_GetPeriphCLKFreq+0x842>
 800c3a0:	e057      	b.n	800c452 <HAL_RCCEx_GetPeriphCLKFreq+0x8ea>
    {
      case RCC_SPI6CLKSOURCE_D3PCLK1: /* D3PCLK1 (PCLK4) is the clock source for SPI6 */
      {
        frequency = HAL_RCCEx_GetD3PCLK1Freq();
 800c3a2:	f000 f8b9 	bl	800c518 <HAL_RCCEx_GetD3PCLK1Freq>
 800c3a6:	63f8      	str	r0, [r7, #60]	@ 0x3c
        break;
 800c3a8:	e0a7      	b.n	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
      }
      case RCC_SPI6CLKSOURCE_PLL2: /* PLL2 is the clock source for SPI6 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))
 800c3aa:	4b56      	ldr	r3, [pc, #344]	@ (800c504 <HAL_RCCEx_GetPeriphCLKFreq+0x99c>)
 800c3ac:	681b      	ldr	r3, [r3, #0]
 800c3ae:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 800c3b2:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 800c3b6:	d107      	bne.n	800c3c8 <HAL_RCCEx_GetPeriphCLKFreq+0x860>
        {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 800c3b8:	f107 0318 	add.w	r3, r7, #24
 800c3bc:	4618      	mov	r0, r3
 800c3be:	f000 f8c1 	bl	800c544 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_Q_Frequency;
 800c3c2:	69fb      	ldr	r3, [r7, #28]
 800c3c4:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 800c3c6:	e098      	b.n	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
          frequency = 0;
 800c3c8:	2300      	movs	r3, #0
 800c3ca:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 800c3cc:	e095      	b.n	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
      }
      case RCC_SPI6CLKSOURCE_PLL3: /* PLL3 is the clock source for SPI6 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY))
 800c3ce:	4b4d      	ldr	r3, [pc, #308]	@ (800c504 <HAL_RCCEx_GetPeriphCLKFreq+0x99c>)
 800c3d0:	681b      	ldr	r3, [r3, #0]
 800c3d2:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
 800c3d6:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 800c3da:	d107      	bne.n	800c3ec <HAL_RCCEx_GetPeriphCLKFreq+0x884>
        {
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 800c3dc:	f107 030c 	add.w	r3, r7, #12
 800c3e0:	4618      	mov	r0, r3
 800c3e2:	f000 fa03 	bl	800c7ec <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_Q_Frequency;
 800c3e6:	693b      	ldr	r3, [r7, #16]
 800c3e8:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 800c3ea:	e086      	b.n	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
          frequency = 0;
 800c3ec:	2300      	movs	r3, #0
 800c3ee:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 800c3f0:	e083      	b.n	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
      }
      case RCC_SPI6CLKSOURCE_HSI: /* HSI is the clock source for SPI6 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
 800c3f2:	4b44      	ldr	r3, [pc, #272]	@ (800c504 <HAL_RCCEx_GetPeriphCLKFreq+0x99c>)
 800c3f4:	681b      	ldr	r3, [r3, #0]
 800c3f6:	f003 0304 	and.w	r3, r3, #4
 800c3fa:	2b04      	cmp	r3, #4
 800c3fc:	d109      	bne.n	800c412 <HAL_RCCEx_GetPeriphCLKFreq+0x8aa>
        {
          frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
 800c3fe:	4b41      	ldr	r3, [pc, #260]	@ (800c504 <HAL_RCCEx_GetPeriphCLKFreq+0x99c>)
 800c400:	681b      	ldr	r3, [r3, #0]
 800c402:	08db      	lsrs	r3, r3, #3
 800c404:	f003 0303 	and.w	r3, r3, #3
 800c408:	4a3f      	ldr	r2, [pc, #252]	@ (800c508 <HAL_RCCEx_GetPeriphCLKFreq+0x9a0>)
 800c40a:	fa22 f303 	lsr.w	r3, r2, r3
 800c40e:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 800c410:	e073      	b.n	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
          frequency = 0;
 800c412:	2300      	movs	r3, #0
 800c414:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 800c416:	e070      	b.n	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
      }
      case RCC_SPI6CLKSOURCE_CSI: /* CSI is the clock source for SPI6 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY))
 800c418:	4b3a      	ldr	r3, [pc, #232]	@ (800c504 <HAL_RCCEx_GetPeriphCLKFreq+0x99c>)
 800c41a:	681b      	ldr	r3, [r3, #0]
 800c41c:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 800c420:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 800c424:	d102      	bne.n	800c42c <HAL_RCCEx_GetPeriphCLKFreq+0x8c4>
        {
          frequency = CSI_VALUE;
 800c426:	4b39      	ldr	r3, [pc, #228]	@ (800c50c <HAL_RCCEx_GetPeriphCLKFreq+0x9a4>)
 800c428:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 800c42a:	e066      	b.n	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
          frequency = 0;
 800c42c:	2300      	movs	r3, #0
 800c42e:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 800c430:	e063      	b.n	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
      }
      case RCC_SPI6CLKSOURCE_HSE: /* HSE is the clock source for SPI6 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY))
 800c432:	4b34      	ldr	r3, [pc, #208]	@ (800c504 <HAL_RCCEx_GetPeriphCLKFreq+0x99c>)
 800c434:	681b      	ldr	r3, [r3, #0]
 800c436:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 800c43a:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 800c43e:	d102      	bne.n	800c446 <HAL_RCCEx_GetPeriphCLKFreq+0x8de>
        {
          frequency = HSE_VALUE;
 800c440:	4b33      	ldr	r3, [pc, #204]	@ (800c510 <HAL_RCCEx_GetPeriphCLKFreq+0x9a8>)
 800c442:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 800c444:	e059      	b.n	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
          frequency = 0;
 800c446:	2300      	movs	r3, #0
 800c448:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 800c44a:	e056      	b.n	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
      }
#if defined(RCC_SPI6CLKSOURCE_PIN)
      case RCC_SPI6CLKSOURCE_PIN: /* External clock is the clock source for SPI6 */
      {
        frequency = EXTERNAL_CLOCK_VALUE;
 800c44c:	4b31      	ldr	r3, [pc, #196]	@ (800c514 <HAL_RCCEx_GetPeriphCLKFreq+0x9ac>)
 800c44e:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 800c450:	e053      	b.n	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
      }
#endif /* RCC_SPI6CLKSOURCE_PIN */
      default :
      {
        frequency = 0;
 800c452:	2300      	movs	r3, #0
 800c454:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 800c456:	e050      	b.n	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
      }
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_FDCAN)
 800c458:	e9d7 2300 	ldrd	r2, r3, [r7]
 800c45c:	f5a2 4100 	sub.w	r1, r2, #32768	@ 0x8000
 800c460:	430b      	orrs	r3, r1
 800c462:	d148      	bne.n	800c4f6 <HAL_RCCEx_GetPeriphCLKFreq+0x98e>
  {
    /* Get FDCAN clock source */
    srcclk = __HAL_RCC_GET_FDCAN_SOURCE();
 800c464:	4b27      	ldr	r3, [pc, #156]	@ (800c504 <HAL_RCCEx_GetPeriphCLKFreq+0x99c>)
 800c466:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800c468:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
 800c46c:	63bb      	str	r3, [r7, #56]	@ 0x38

    switch (srcclk)
 800c46e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800c470:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 800c474:	d02a      	beq.n	800c4cc <HAL_RCCEx_GetPeriphCLKFreq+0x964>
 800c476:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800c478:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 800c47c:	d838      	bhi.n	800c4f0 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
 800c47e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800c480:	2b00      	cmp	r3, #0
 800c482:	d004      	beq.n	800c48e <HAL_RCCEx_GetPeriphCLKFreq+0x926>
 800c484:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800c486:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
 800c48a:	d00d      	beq.n	800c4a8 <HAL_RCCEx_GetPeriphCLKFreq+0x940>
 800c48c:	e030      	b.n	800c4f0 <HAL_RCCEx_GetPeriphCLKFreq+0x988>
    {
      case RCC_FDCANCLKSOURCE_HSE: /* HSE is the clock source for FDCAN */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY))
 800c48e:	4b1d      	ldr	r3, [pc, #116]	@ (800c504 <HAL_RCCEx_GetPeriphCLKFreq+0x99c>)
 800c490:	681b      	ldr	r3, [r3, #0]
 800c492:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 800c496:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 800c49a:	d102      	bne.n	800c4a2 <HAL_RCCEx_GetPeriphCLKFreq+0x93a>
        {
          frequency = HSE_VALUE;
 800c49c:	4b1c      	ldr	r3, [pc, #112]	@ (800c510 <HAL_RCCEx_GetPeriphCLKFreq+0x9a8>)
 800c49e:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 800c4a0:	e02b      	b.n	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
          frequency = 0;
 800c4a2:	2300      	movs	r3, #0
 800c4a4:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 800c4a6:	e028      	b.n	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
      }
      case RCC_FDCANCLKSOURCE_PLL: /* PLL is the clock source for FDCAN */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL1RDY))
 800c4a8:	4b16      	ldr	r3, [pc, #88]	@ (800c504 <HAL_RCCEx_GetPeriphCLKFreq+0x99c>)
 800c4aa:	681b      	ldr	r3, [r3, #0]
 800c4ac:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 800c4b0:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
 800c4b4:	d107      	bne.n	800c4c6 <HAL_RCCEx_GetPeriphCLKFreq+0x95e>
        {
          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
 800c4b6:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 800c4ba:	4618      	mov	r0, r3
 800c4bc:	f000 faea 	bl	800ca94 <HAL_RCCEx_GetPLL1ClockFreq>
          frequency = pll1_clocks.PLL1_Q_Frequency;
 800c4c0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800c4c2:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 800c4c4:	e019      	b.n	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
          frequency = 0;
 800c4c6:	2300      	movs	r3, #0
 800c4c8:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 800c4ca:	e016      	b.n	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
      }
      case RCC_FDCANCLKSOURCE_PLL2: /* PLL2 is the clock source for FDCAN */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))
 800c4cc:	4b0d      	ldr	r3, [pc, #52]	@ (800c504 <HAL_RCCEx_GetPeriphCLKFreq+0x99c>)
 800c4ce:	681b      	ldr	r3, [r3, #0]
 800c4d0:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 800c4d4:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 800c4d8:	d107      	bne.n	800c4ea <HAL_RCCEx_GetPeriphCLKFreq+0x982>
        {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 800c4da:	f107 0318 	add.w	r3, r7, #24
 800c4de:	4618      	mov	r0, r3
 800c4e0:	f000 f830 	bl	800c544 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_Q_Frequency;
 800c4e4:	69fb      	ldr	r3, [r7, #28]
 800c4e6:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 800c4e8:	e007      	b.n	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
          frequency = 0;
 800c4ea:	2300      	movs	r3, #0
 800c4ec:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 800c4ee:	e004      	b.n	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
      }
      default :
      {
        frequency = 0;
 800c4f0:	2300      	movs	r3, #0
 800c4f2:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 800c4f4:	e001      	b.n	800c4fa <HAL_RCCEx_GetPeriphCLKFreq+0x992>
      }
    }
  }
  else
  {
    frequency = 0;
 800c4f6:	2300      	movs	r3, #0
 800c4f8:	63fb      	str	r3, [r7, #60]	@ 0x3c
  }

  return frequency;
 800c4fa:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
}
 800c4fc:	4618      	mov	r0, r3
 800c4fe:	3740      	adds	r7, #64	@ 0x40
 800c500:	46bd      	mov	sp, r7
 800c502:	bd80      	pop	{r7, pc}
 800c504:	58024400 	.word	0x58024400
 800c508:	03d09000 	.word	0x03d09000
 800c50c:	003d0900 	.word	0x003d0900
 800c510:	016e3600 	.word	0x016e3600
 800c514:	00bb8000 	.word	0x00bb8000

0800c518 <HAL_RCCEx_GetD3PCLK1Freq>:
  * @note   Each time D3PCLK1 changes, this function must be called to update the
  *         right D3PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval D3PCLK1 frequency
  */
uint32_t HAL_RCCEx_GetD3PCLK1Freq(void)
{
 800c518:	b580      	push	{r7, lr}
 800c51a:	af00      	add	r7, sp, #0
#if defined(RCC_D3CFGR_D3PPRE)
  /* Get HCLK source and Compute D3PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> (D1CorePrescTable[(RCC->D3CFGR & RCC_D3CFGR_D3PPRE) >> RCC_D3CFGR_D3PPRE_Pos] & 0x1FU));
#else
  /* Get HCLK source and Compute D3PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> (D1CorePrescTable[(RCC->SRDCFGR & RCC_SRDCFGR_SRDPPRE) >> RCC_SRDCFGR_SRDPPRE_Pos] & 0x1FU));
 800c51c:	f7fe f920 	bl	800a760 <HAL_RCC_GetHCLKFreq>
 800c520:	4602      	mov	r2, r0
 800c522:	4b06      	ldr	r3, [pc, #24]	@ (800c53c <HAL_RCCEx_GetD3PCLK1Freq+0x24>)
 800c524:	6a1b      	ldr	r3, [r3, #32]
 800c526:	091b      	lsrs	r3, r3, #4
 800c528:	f003 0307 	and.w	r3, r3, #7
 800c52c:	4904      	ldr	r1, [pc, #16]	@ (800c540 <HAL_RCCEx_GetD3PCLK1Freq+0x28>)
 800c52e:	5ccb      	ldrb	r3, [r1, r3]
 800c530:	f003 031f 	and.w	r3, r3, #31
 800c534:	fa22 f303 	lsr.w	r3, r2, r3
#endif
}
 800c538:	4618      	mov	r0, r3
 800c53a:	bd80      	pop	{r7, pc}
 800c53c:	58024400 	.word	0x58024400
 800c540:	080131a4 	.word	0x080131a4

0800c544 <HAL_RCCEx_GetPLL2ClockFreq>:
  *         right PLL2CLK value. Otherwise, any configuration based on this function will be incorrect.
  * @param  PLL2_Clocks structure.
  * @retval None
  */
void HAL_RCCEx_GetPLL2ClockFreq(PLL2_ClocksTypeDef *PLL2_Clocks)
{
 800c544:	b480      	push	{r7}
 800c546:	b089      	sub	sp, #36	@ 0x24
 800c548:	af00      	add	r7, sp, #0
 800c54a:	6078      	str	r0, [r7, #4]
  float_t fracn2, pll2vco;

  /* PLL_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLL2M) * PLL2N
     PLL2xCLK = PLL2_VCO / PLL2x
  */
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 800c54c:	4ba1      	ldr	r3, [pc, #644]	@ (800c7d4 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 800c54e:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800c550:	f003 0303 	and.w	r3, r3, #3
 800c554:	61bb      	str	r3, [r7, #24]
  pll2m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM2) >> 12);
 800c556:	4b9f      	ldr	r3, [pc, #636]	@ (800c7d4 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 800c558:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800c55a:	0b1b      	lsrs	r3, r3, #12
 800c55c:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 800c560:	617b      	str	r3, [r7, #20]
  pll2fracen = (RCC->PLLCFGR & RCC_PLLCFGR_PLL2FRACEN) >> RCC_PLLCFGR_PLL2FRACEN_Pos;
 800c562:	4b9c      	ldr	r3, [pc, #624]	@ (800c7d4 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 800c564:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800c566:	091b      	lsrs	r3, r3, #4
 800c568:	f003 0301 	and.w	r3, r3, #1
 800c56c:	613b      	str	r3, [r7, #16]
  fracn2 = (float_t)(uint32_t)(pll2fracen * ((RCC->PLL2FRACR & RCC_PLL2FRACR_FRACN2) >> 3));
 800c56e:	4b99      	ldr	r3, [pc, #612]	@ (800c7d4 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 800c570:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 800c572:	08db      	lsrs	r3, r3, #3
 800c574:	f3c3 030c 	ubfx	r3, r3, #0, #13
 800c578:	693a      	ldr	r2, [r7, #16]
 800c57a:	fb02 f303 	mul.w	r3, r2, r3
 800c57e:	ee07 3a90 	vmov	s15, r3
 800c582:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800c586:	edc7 7a03 	vstr	s15, [r7, #12]

  if (pll2m != 0U)
 800c58a:	697b      	ldr	r3, [r7, #20]
 800c58c:	2b00      	cmp	r3, #0
 800c58e:	f000 8111 	beq.w	800c7b4 <HAL_RCCEx_GetPLL2ClockFreq+0x270>
  {
    switch (pllsource)
 800c592:	69bb      	ldr	r3, [r7, #24]
 800c594:	2b02      	cmp	r3, #2
 800c596:	f000 8083 	beq.w	800c6a0 <HAL_RCCEx_GetPLL2ClockFreq+0x15c>
 800c59a:	69bb      	ldr	r3, [r7, #24]
 800c59c:	2b02      	cmp	r3, #2
 800c59e:	f200 80a1 	bhi.w	800c6e4 <HAL_RCCEx_GetPLL2ClockFreq+0x1a0>
 800c5a2:	69bb      	ldr	r3, [r7, #24]
 800c5a4:	2b00      	cmp	r3, #0
 800c5a6:	d003      	beq.n	800c5b0 <HAL_RCCEx_GetPLL2ClockFreq+0x6c>
 800c5a8:	69bb      	ldr	r3, [r7, #24]
 800c5aa:	2b01      	cmp	r3, #1
 800c5ac:	d056      	beq.n	800c65c <HAL_RCCEx_GetPLL2ClockFreq+0x118>
 800c5ae:	e099      	b.n	800c6e4 <HAL_RCCEx_GetPLL2ClockFreq+0x1a0>
    {

      case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */

        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 800c5b0:	4b88      	ldr	r3, [pc, #544]	@ (800c7d4 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 800c5b2:	681b      	ldr	r3, [r3, #0]
 800c5b4:	f003 0320 	and.w	r3, r3, #32
 800c5b8:	2b00      	cmp	r3, #0
 800c5ba:	d02d      	beq.n	800c618 <HAL_RCCEx_GetPLL2ClockFreq+0xd4>
        {
          hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
 800c5bc:	4b85      	ldr	r3, [pc, #532]	@ (800c7d4 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 800c5be:	681b      	ldr	r3, [r3, #0]
 800c5c0:	08db      	lsrs	r3, r3, #3
 800c5c2:	f003 0303 	and.w	r3, r3, #3
 800c5c6:	4a84      	ldr	r2, [pc, #528]	@ (800c7d8 <HAL_RCCEx_GetPLL2ClockFreq+0x294>)
 800c5c8:	fa22 f303 	lsr.w	r3, r2, r3
 800c5cc:	60bb      	str	r3, [r7, #8]
          pll2vco = ((float_t)hsivalue / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2 / (float_t)0x2000) + (float_t)1);
 800c5ce:	68bb      	ldr	r3, [r7, #8]
 800c5d0:	ee07 3a90 	vmov	s15, r3
 800c5d4:	eef8 6a67 	vcvt.f32.u32	s13, s15
 800c5d8:	697b      	ldr	r3, [r7, #20]
 800c5da:	ee07 3a90 	vmov	s15, r3
 800c5de:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800c5e2:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 800c5e6:	4b7b      	ldr	r3, [pc, #492]	@ (800c7d4 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 800c5e8:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800c5ea:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800c5ee:	ee07 3a90 	vmov	s15, r3
 800c5f2:	eef8 6a67 	vcvt.f32.u32	s13, s15
 800c5f6:	ed97 6a03 	vldr	s12, [r7, #12]
 800c5fa:	eddf 5a78 	vldr	s11, [pc, #480]	@ 800c7dc <HAL_RCCEx_GetPLL2ClockFreq+0x298>
 800c5fe:	eec6 7a25 	vdiv.f32	s15, s12, s11
 800c602:	ee76 7aa7 	vadd.f32	s15, s13, s15
 800c606:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 800c60a:	ee77 7aa6 	vadd.f32	s15, s15, s13
 800c60e:	ee67 7a27 	vmul.f32	s15, s14, s15
 800c612:	edc7 7a07 	vstr	s15, [r7, #28]
        }
        else
        {
          pll2vco = ((float_t)HSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2 / (float_t)0x2000) + (float_t)1);
        }
        break;
 800c616:	e087      	b.n	800c728 <HAL_RCCEx_GetPLL2ClockFreq+0x1e4>
          pll2vco = ((float_t)HSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2 / (float_t)0x2000) + (float_t)1);
 800c618:	697b      	ldr	r3, [r7, #20]
 800c61a:	ee07 3a90 	vmov	s15, r3
 800c61e:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800c622:	eddf 6a6f 	vldr	s13, [pc, #444]	@ 800c7e0 <HAL_RCCEx_GetPLL2ClockFreq+0x29c>
 800c626:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 800c62a:	4b6a      	ldr	r3, [pc, #424]	@ (800c7d4 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 800c62c:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800c62e:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800c632:	ee07 3a90 	vmov	s15, r3
 800c636:	eef8 6a67 	vcvt.f32.u32	s13, s15
 800c63a:	ed97 6a03 	vldr	s12, [r7, #12]
 800c63e:	eddf 5a67 	vldr	s11, [pc, #412]	@ 800c7dc <HAL_RCCEx_GetPLL2ClockFreq+0x298>
 800c642:	eec6 7a25 	vdiv.f32	s15, s12, s11
 800c646:	ee76 7aa7 	vadd.f32	s15, s13, s15
 800c64a:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 800c64e:	ee77 7aa6 	vadd.f32	s15, s15, s13
 800c652:	ee67 7a27 	vmul.f32	s15, s14, s15
 800c656:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
 800c65a:	e065      	b.n	800c728 <HAL_RCCEx_GetPLL2ClockFreq+0x1e4>

      case RCC_PLLSOURCE_CSI:  /* CSI used as PLL clock source */
        pll2vco = ((float_t)CSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2 / (float_t)0x2000) + (float_t)1);
 800c65c:	697b      	ldr	r3, [r7, #20]
 800c65e:	ee07 3a90 	vmov	s15, r3
 800c662:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800c666:	eddf 6a5f 	vldr	s13, [pc, #380]	@ 800c7e4 <HAL_RCCEx_GetPLL2ClockFreq+0x2a0>
 800c66a:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 800c66e:	4b59      	ldr	r3, [pc, #356]	@ (800c7d4 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 800c670:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800c672:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800c676:	ee07 3a90 	vmov	s15, r3
 800c67a:	eef8 6a67 	vcvt.f32.u32	s13, s15
 800c67e:	ed97 6a03 	vldr	s12, [r7, #12]
 800c682:	eddf 5a56 	vldr	s11, [pc, #344]	@ 800c7dc <HAL_RCCEx_GetPLL2ClockFreq+0x298>
 800c686:	eec6 7a25 	vdiv.f32	s15, s12, s11
 800c68a:	ee76 7aa7 	vadd.f32	s15, s13, s15
 800c68e:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 800c692:	ee77 7aa6 	vadd.f32	s15, s15, s13
 800c696:	ee67 7a27 	vmul.f32	s15, s14, s15
 800c69a:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
 800c69e:	e043      	b.n	800c728 <HAL_RCCEx_GetPLL2ClockFreq+0x1e4>

      case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
        pll2vco = ((float_t)HSE_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2 / (float_t)0x2000) + (float_t)1);
 800c6a0:	697b      	ldr	r3, [r7, #20]
 800c6a2:	ee07 3a90 	vmov	s15, r3
 800c6a6:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800c6aa:	eddf 6a4f 	vldr	s13, [pc, #316]	@ 800c7e8 <HAL_RCCEx_GetPLL2ClockFreq+0x2a4>
 800c6ae:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 800c6b2:	4b48      	ldr	r3, [pc, #288]	@ (800c7d4 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 800c6b4:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800c6b6:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800c6ba:	ee07 3a90 	vmov	s15, r3
 800c6be:	eef8 6a67 	vcvt.f32.u32	s13, s15
 800c6c2:	ed97 6a03 	vldr	s12, [r7, #12]
 800c6c6:	eddf 5a45 	vldr	s11, [pc, #276]	@ 800c7dc <HAL_RCCEx_GetPLL2ClockFreq+0x298>
 800c6ca:	eec6 7a25 	vdiv.f32	s15, s12, s11
 800c6ce:	ee76 7aa7 	vadd.f32	s15, s13, s15
 800c6d2:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 800c6d6:	ee77 7aa6 	vadd.f32	s15, s15, s13
 800c6da:	ee67 7a27 	vmul.f32	s15, s14, s15
 800c6de:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
 800c6e2:	e021      	b.n	800c728 <HAL_RCCEx_GetPLL2ClockFreq+0x1e4>

      default:
        pll2vco = ((float_t)CSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2 / (float_t)0x2000) + (float_t)1);
 800c6e4:	697b      	ldr	r3, [r7, #20]
 800c6e6:	ee07 3a90 	vmov	s15, r3
 800c6ea:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800c6ee:	eddf 6a3d 	vldr	s13, [pc, #244]	@ 800c7e4 <HAL_RCCEx_GetPLL2ClockFreq+0x2a0>
 800c6f2:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 800c6f6:	4b37      	ldr	r3, [pc, #220]	@ (800c7d4 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 800c6f8:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800c6fa:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800c6fe:	ee07 3a90 	vmov	s15, r3
 800c702:	eef8 6a67 	vcvt.f32.u32	s13, s15
 800c706:	ed97 6a03 	vldr	s12, [r7, #12]
 800c70a:	eddf 5a34 	vldr	s11, [pc, #208]	@ 800c7dc <HAL_RCCEx_GetPLL2ClockFreq+0x298>
 800c70e:	eec6 7a25 	vdiv.f32	s15, s12, s11
 800c712:	ee76 7aa7 	vadd.f32	s15, s13, s15
 800c716:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 800c71a:	ee77 7aa6 	vadd.f32	s15, s15, s13
 800c71e:	ee67 7a27 	vmul.f32	s15, s14, s15
 800c722:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
 800c726:	bf00      	nop
    }
    PLL2_Clocks->PLL2_P_Frequency = (uint32_t)(float_t)(pll2vco / ((float_t)(uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_P2) >> 9)  + (float_t)1)) ;
 800c728:	4b2a      	ldr	r3, [pc, #168]	@ (800c7d4 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 800c72a:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800c72c:	0a5b      	lsrs	r3, r3, #9
 800c72e:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 800c732:	ee07 3a90 	vmov	s15, r3
 800c736:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800c73a:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 800c73e:	ee37 7a87 	vadd.f32	s14, s15, s14
 800c742:	edd7 6a07 	vldr	s13, [r7, #28]
 800c746:	eec6 7a87 	vdiv.f32	s15, s13, s14
 800c74a:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 800c74e:	ee17 2a90 	vmov	r2, s15
 800c752:	687b      	ldr	r3, [r7, #4]
 800c754:	601a      	str	r2, [r3, #0]
    PLL2_Clocks->PLL2_Q_Frequency = (uint32_t)(float_t)(pll2vco / ((float_t)(uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_Q2) >> 16) + (float_t)1)) ;
 800c756:	4b1f      	ldr	r3, [pc, #124]	@ (800c7d4 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 800c758:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800c75a:	0c1b      	lsrs	r3, r3, #16
 800c75c:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 800c760:	ee07 3a90 	vmov	s15, r3
 800c764:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800c768:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 800c76c:	ee37 7a87 	vadd.f32	s14, s15, s14
 800c770:	edd7 6a07 	vldr	s13, [r7, #28]
 800c774:	eec6 7a87 	vdiv.f32	s15, s13, s14
 800c778:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 800c77c:	ee17 2a90 	vmov	r2, s15
 800c780:	687b      	ldr	r3, [r7, #4]
 800c782:	605a      	str	r2, [r3, #4]
    PLL2_Clocks->PLL2_R_Frequency = (uint32_t)(float_t)(pll2vco / ((float_t)(uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_R2) >> 24) + (float_t)1)) ;
 800c784:	4b13      	ldr	r3, [pc, #76]	@ (800c7d4 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 800c786:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800c788:	0e1b      	lsrs	r3, r3, #24
 800c78a:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 800c78e:	ee07 3a90 	vmov	s15, r3
 800c792:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800c796:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 800c79a:	ee37 7a87 	vadd.f32	s14, s15, s14
 800c79e:	edd7 6a07 	vldr	s13, [r7, #28]
 800c7a2:	eec6 7a87 	vdiv.f32	s15, s13, s14
 800c7a6:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 800c7aa:	ee17 2a90 	vmov	r2, s15
 800c7ae:	687b      	ldr	r3, [r7, #4]
 800c7b0:	609a      	str	r2, [r3, #8]
  {
    PLL2_Clocks->PLL2_P_Frequency = 0U;
    PLL2_Clocks->PLL2_Q_Frequency = 0U;
    PLL2_Clocks->PLL2_R_Frequency = 0U;
  }
}
 800c7b2:	e008      	b.n	800c7c6 <HAL_RCCEx_GetPLL2ClockFreq+0x282>
    PLL2_Clocks->PLL2_P_Frequency = 0U;
 800c7b4:	687b      	ldr	r3, [r7, #4]
 800c7b6:	2200      	movs	r2, #0
 800c7b8:	601a      	str	r2, [r3, #0]
    PLL2_Clocks->PLL2_Q_Frequency = 0U;
 800c7ba:	687b      	ldr	r3, [r7, #4]
 800c7bc:	2200      	movs	r2, #0
 800c7be:	605a      	str	r2, [r3, #4]
    PLL2_Clocks->PLL2_R_Frequency = 0U;
 800c7c0:	687b      	ldr	r3, [r7, #4]
 800c7c2:	2200      	movs	r2, #0
 800c7c4:	609a      	str	r2, [r3, #8]
}
 800c7c6:	bf00      	nop
 800c7c8:	3724      	adds	r7, #36	@ 0x24
 800c7ca:	46bd      	mov	sp, r7
 800c7cc:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c7d0:	4770      	bx	lr
 800c7d2:	bf00      	nop
 800c7d4:	58024400 	.word	0x58024400
 800c7d8:	03d09000 	.word	0x03d09000
 800c7dc:	46000000 	.word	0x46000000
 800c7e0:	4c742400 	.word	0x4c742400
 800c7e4:	4a742400 	.word	0x4a742400
 800c7e8:	4bb71b00 	.word	0x4bb71b00

0800c7ec <HAL_RCCEx_GetPLL3ClockFreq>:
  *         right PLL3CLK value. Otherwise, any configuration based on this function will be incorrect.
  * @param  PLL3_Clocks structure.
  * @retval None
  */
void HAL_RCCEx_GetPLL3ClockFreq(PLL3_ClocksTypeDef *PLL3_Clocks)
{
 800c7ec:	b480      	push	{r7}
 800c7ee:	b089      	sub	sp, #36	@ 0x24
 800c7f0:	af00      	add	r7, sp, #0
 800c7f2:	6078      	str	r0, [r7, #4]
  float_t fracn3, pll3vco;

  /* PLL3_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLL3M) * PLL3N
     PLL3xCLK = PLL3_VCO / PLLxR
  */
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 800c7f4:	4ba1      	ldr	r3, [pc, #644]	@ (800ca7c <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 800c7f6:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800c7f8:	f003 0303 	and.w	r3, r3, #3
 800c7fc:	61bb      	str	r3, [r7, #24]
  pll3m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM3) >> 20)  ;
 800c7fe:	4b9f      	ldr	r3, [pc, #636]	@ (800ca7c <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 800c800:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800c802:	0d1b      	lsrs	r3, r3, #20
 800c804:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 800c808:	617b      	str	r3, [r7, #20]
  pll3fracen = (RCC->PLLCFGR & RCC_PLLCFGR_PLL3FRACEN) >> RCC_PLLCFGR_PLL3FRACEN_Pos;
 800c80a:	4b9c      	ldr	r3, [pc, #624]	@ (800ca7c <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 800c80c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800c80e:	0a1b      	lsrs	r3, r3, #8
 800c810:	f003 0301 	and.w	r3, r3, #1
 800c814:	613b      	str	r3, [r7, #16]
  fracn3 = (float_t)(uint32_t)(pll3fracen * ((RCC->PLL3FRACR & RCC_PLL3FRACR_FRACN3) >> 3));
 800c816:	4b99      	ldr	r3, [pc, #612]	@ (800ca7c <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 800c818:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800c81a:	08db      	lsrs	r3, r3, #3
 800c81c:	f3c3 030c 	ubfx	r3, r3, #0, #13
 800c820:	693a      	ldr	r2, [r7, #16]
 800c822:	fb02 f303 	mul.w	r3, r2, r3
 800c826:	ee07 3a90 	vmov	s15, r3
 800c82a:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800c82e:	edc7 7a03 	vstr	s15, [r7, #12]

  if (pll3m != 0U)
 800c832:	697b      	ldr	r3, [r7, #20]
 800c834:	2b00      	cmp	r3, #0
 800c836:	f000 8111 	beq.w	800ca5c <HAL_RCCEx_GetPLL3ClockFreq+0x270>
  {
    switch (pllsource)
 800c83a:	69bb      	ldr	r3, [r7, #24]
 800c83c:	2b02      	cmp	r3, #2
 800c83e:	f000 8083 	beq.w	800c948 <HAL_RCCEx_GetPLL3ClockFreq+0x15c>
 800c842:	69bb      	ldr	r3, [r7, #24]
 800c844:	2b02      	cmp	r3, #2
 800c846:	f200 80a1 	bhi.w	800c98c <HAL_RCCEx_GetPLL3ClockFreq+0x1a0>
 800c84a:	69bb      	ldr	r3, [r7, #24]
 800c84c:	2b00      	cmp	r3, #0
 800c84e:	d003      	beq.n	800c858 <HAL_RCCEx_GetPLL3ClockFreq+0x6c>
 800c850:	69bb      	ldr	r3, [r7, #24]
 800c852:	2b01      	cmp	r3, #1
 800c854:	d056      	beq.n	800c904 <HAL_RCCEx_GetPLL3ClockFreq+0x118>
 800c856:	e099      	b.n	800c98c <HAL_RCCEx_GetPLL3ClockFreq+0x1a0>
    {
      case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */

        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 800c858:	4b88      	ldr	r3, [pc, #544]	@ (800ca7c <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 800c85a:	681b      	ldr	r3, [r3, #0]
 800c85c:	f003 0320 	and.w	r3, r3, #32
 800c860:	2b00      	cmp	r3, #0
 800c862:	d02d      	beq.n	800c8c0 <HAL_RCCEx_GetPLL3ClockFreq+0xd4>
        {
          hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
 800c864:	4b85      	ldr	r3, [pc, #532]	@ (800ca7c <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 800c866:	681b      	ldr	r3, [r3, #0]
 800c868:	08db      	lsrs	r3, r3, #3
 800c86a:	f003 0303 	and.w	r3, r3, #3
 800c86e:	4a84      	ldr	r2, [pc, #528]	@ (800ca80 <HAL_RCCEx_GetPLL3ClockFreq+0x294>)
 800c870:	fa22 f303 	lsr.w	r3, r2, r3
 800c874:	60bb      	str	r3, [r7, #8]
          pll3vco = ((float_t)hsivalue / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3 / (float_t)0x2000) + (float_t)1);
 800c876:	68bb      	ldr	r3, [r7, #8]
 800c878:	ee07 3a90 	vmov	s15, r3
 800c87c:	eef8 6a67 	vcvt.f32.u32	s13, s15
 800c880:	697b      	ldr	r3, [r7, #20]
 800c882:	ee07 3a90 	vmov	s15, r3
 800c886:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800c88a:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 800c88e:	4b7b      	ldr	r3, [pc, #492]	@ (800ca7c <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 800c890:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800c892:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800c896:	ee07 3a90 	vmov	s15, r3
 800c89a:	eef8 6a67 	vcvt.f32.u32	s13, s15
 800c89e:	ed97 6a03 	vldr	s12, [r7, #12]
 800c8a2:	eddf 5a78 	vldr	s11, [pc, #480]	@ 800ca84 <HAL_RCCEx_GetPLL3ClockFreq+0x298>
 800c8a6:	eec6 7a25 	vdiv.f32	s15, s12, s11
 800c8aa:	ee76 7aa7 	vadd.f32	s15, s13, s15
 800c8ae:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 800c8b2:	ee77 7aa6 	vadd.f32	s15, s15, s13
 800c8b6:	ee67 7a27 	vmul.f32	s15, s14, s15
 800c8ba:	edc7 7a07 	vstr	s15, [r7, #28]
        }
        else
        {
          pll3vco = ((float_t)HSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3 / (float_t)0x2000) + (float_t)1);
        }
        break;
 800c8be:	e087      	b.n	800c9d0 <HAL_RCCEx_GetPLL3ClockFreq+0x1e4>
          pll3vco = ((float_t)HSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3 / (float_t)0x2000) + (float_t)1);
 800c8c0:	697b      	ldr	r3, [r7, #20]
 800c8c2:	ee07 3a90 	vmov	s15, r3
 800c8c6:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800c8ca:	eddf 6a6f 	vldr	s13, [pc, #444]	@ 800ca88 <HAL_RCCEx_GetPLL3ClockFreq+0x29c>
 800c8ce:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 800c8d2:	4b6a      	ldr	r3, [pc, #424]	@ (800ca7c <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 800c8d4:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800c8d6:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800c8da:	ee07 3a90 	vmov	s15, r3
 800c8de:	eef8 6a67 	vcvt.f32.u32	s13, s15
 800c8e2:	ed97 6a03 	vldr	s12, [r7, #12]
 800c8e6:	eddf 5a67 	vldr	s11, [pc, #412]	@ 800ca84 <HAL_RCCEx_GetPLL3ClockFreq+0x298>
 800c8ea:	eec6 7a25 	vdiv.f32	s15, s12, s11
 800c8ee:	ee76 7aa7 	vadd.f32	s15, s13, s15
 800c8f2:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 800c8f6:	ee77 7aa6 	vadd.f32	s15, s15, s13
 800c8fa:	ee67 7a27 	vmul.f32	s15, s14, s15
 800c8fe:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
 800c902:	e065      	b.n	800c9d0 <HAL_RCCEx_GetPLL3ClockFreq+0x1e4>
      case RCC_PLLSOURCE_CSI:  /* CSI used as PLL clock source */
        pll3vco = ((float_t)CSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3 / (float_t)0x2000) + (float_t)1);
 800c904:	697b      	ldr	r3, [r7, #20]
 800c906:	ee07 3a90 	vmov	s15, r3
 800c90a:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800c90e:	eddf 6a5f 	vldr	s13, [pc, #380]	@ 800ca8c <HAL_RCCEx_GetPLL3ClockFreq+0x2a0>
 800c912:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 800c916:	4b59      	ldr	r3, [pc, #356]	@ (800ca7c <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 800c918:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800c91a:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800c91e:	ee07 3a90 	vmov	s15, r3
 800c922:	eef8 6a67 	vcvt.f32.u32	s13, s15
 800c926:	ed97 6a03 	vldr	s12, [r7, #12]
 800c92a:	eddf 5a56 	vldr	s11, [pc, #344]	@ 800ca84 <HAL_RCCEx_GetPLL3ClockFreq+0x298>
 800c92e:	eec6 7a25 	vdiv.f32	s15, s12, s11
 800c932:	ee76 7aa7 	vadd.f32	s15, s13, s15
 800c936:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 800c93a:	ee77 7aa6 	vadd.f32	s15, s15, s13
 800c93e:	ee67 7a27 	vmul.f32	s15, s14, s15
 800c942:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
 800c946:	e043      	b.n	800c9d0 <HAL_RCCEx_GetPLL3ClockFreq+0x1e4>

      case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
        pll3vco = ((float_t)HSE_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3 / (float_t)0x2000) + (float_t)1);
 800c948:	697b      	ldr	r3, [r7, #20]
 800c94a:	ee07 3a90 	vmov	s15, r3
 800c94e:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800c952:	eddf 6a4f 	vldr	s13, [pc, #316]	@ 800ca90 <HAL_RCCEx_GetPLL3ClockFreq+0x2a4>
 800c956:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 800c95a:	4b48      	ldr	r3, [pc, #288]	@ (800ca7c <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 800c95c:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800c95e:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800c962:	ee07 3a90 	vmov	s15, r3
 800c966:	eef8 6a67 	vcvt.f32.u32	s13, s15
 800c96a:	ed97 6a03 	vldr	s12, [r7, #12]
 800c96e:	eddf 5a45 	vldr	s11, [pc, #276]	@ 800ca84 <HAL_RCCEx_GetPLL3ClockFreq+0x298>
 800c972:	eec6 7a25 	vdiv.f32	s15, s12, s11
 800c976:	ee76 7aa7 	vadd.f32	s15, s13, s15
 800c97a:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 800c97e:	ee77 7aa6 	vadd.f32	s15, s15, s13
 800c982:	ee67 7a27 	vmul.f32	s15, s14, s15
 800c986:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
 800c98a:	e021      	b.n	800c9d0 <HAL_RCCEx_GetPLL3ClockFreq+0x1e4>

      default:
        pll3vco = ((float_t)CSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3 / (float_t)0x2000) + (float_t)1);
 800c98c:	697b      	ldr	r3, [r7, #20]
 800c98e:	ee07 3a90 	vmov	s15, r3
 800c992:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800c996:	eddf 6a3d 	vldr	s13, [pc, #244]	@ 800ca8c <HAL_RCCEx_GetPLL3ClockFreq+0x2a0>
 800c99a:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 800c99e:	4b37      	ldr	r3, [pc, #220]	@ (800ca7c <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 800c9a0:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800c9a2:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800c9a6:	ee07 3a90 	vmov	s15, r3
 800c9aa:	eef8 6a67 	vcvt.f32.u32	s13, s15
 800c9ae:	ed97 6a03 	vldr	s12, [r7, #12]
 800c9b2:	eddf 5a34 	vldr	s11, [pc, #208]	@ 800ca84 <HAL_RCCEx_GetPLL3ClockFreq+0x298>
 800c9b6:	eec6 7a25 	vdiv.f32	s15, s12, s11
 800c9ba:	ee76 7aa7 	vadd.f32	s15, s13, s15
 800c9be:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 800c9c2:	ee77 7aa6 	vadd.f32	s15, s15, s13
 800c9c6:	ee67 7a27 	vmul.f32	s15, s14, s15
 800c9ca:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
 800c9ce:	bf00      	nop
    }
    PLL3_Clocks->PLL3_P_Frequency = (uint32_t)(float_t)(pll3vco / ((float_t)(uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_P3) >> 9)  + (float_t)1)) ;
 800c9d0:	4b2a      	ldr	r3, [pc, #168]	@ (800ca7c <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 800c9d2:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800c9d4:	0a5b      	lsrs	r3, r3, #9
 800c9d6:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 800c9da:	ee07 3a90 	vmov	s15, r3
 800c9de:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800c9e2:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 800c9e6:	ee37 7a87 	vadd.f32	s14, s15, s14
 800c9ea:	edd7 6a07 	vldr	s13, [r7, #28]
 800c9ee:	eec6 7a87 	vdiv.f32	s15, s13, s14
 800c9f2:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 800c9f6:	ee17 2a90 	vmov	r2, s15
 800c9fa:	687b      	ldr	r3, [r7, #4]
 800c9fc:	601a      	str	r2, [r3, #0]
    PLL3_Clocks->PLL3_Q_Frequency = (uint32_t)(float_t)(pll3vco / ((float_t)(uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_Q3) >> 16) + (float_t)1)) ;
 800c9fe:	4b1f      	ldr	r3, [pc, #124]	@ (800ca7c <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 800ca00:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800ca02:	0c1b      	lsrs	r3, r3, #16
 800ca04:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 800ca08:	ee07 3a90 	vmov	s15, r3
 800ca0c:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800ca10:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 800ca14:	ee37 7a87 	vadd.f32	s14, s15, s14
 800ca18:	edd7 6a07 	vldr	s13, [r7, #28]
 800ca1c:	eec6 7a87 	vdiv.f32	s15, s13, s14
 800ca20:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 800ca24:	ee17 2a90 	vmov	r2, s15
 800ca28:	687b      	ldr	r3, [r7, #4]
 800ca2a:	605a      	str	r2, [r3, #4]
    PLL3_Clocks->PLL3_R_Frequency = (uint32_t)(float_t)(pll3vco / ((float_t)(uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_R3) >> 24) + (float_t)1)) ;
 800ca2c:	4b13      	ldr	r3, [pc, #76]	@ (800ca7c <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 800ca2e:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800ca30:	0e1b      	lsrs	r3, r3, #24
 800ca32:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 800ca36:	ee07 3a90 	vmov	s15, r3
 800ca3a:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800ca3e:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 800ca42:	ee37 7a87 	vadd.f32	s14, s15, s14
 800ca46:	edd7 6a07 	vldr	s13, [r7, #28]
 800ca4a:	eec6 7a87 	vdiv.f32	s15, s13, s14
 800ca4e:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 800ca52:	ee17 2a90 	vmov	r2, s15
 800ca56:	687b      	ldr	r3, [r7, #4]
 800ca58:	609a      	str	r2, [r3, #8]
    PLL3_Clocks->PLL3_P_Frequency = 0U;
    PLL3_Clocks->PLL3_Q_Frequency = 0U;
    PLL3_Clocks->PLL3_R_Frequency = 0U;
  }

}
 800ca5a:	e008      	b.n	800ca6e <HAL_RCCEx_GetPLL3ClockFreq+0x282>
    PLL3_Clocks->PLL3_P_Frequency = 0U;
 800ca5c:	687b      	ldr	r3, [r7, #4]
 800ca5e:	2200      	movs	r2, #0
 800ca60:	601a      	str	r2, [r3, #0]
    PLL3_Clocks->PLL3_Q_Frequency = 0U;
 800ca62:	687b      	ldr	r3, [r7, #4]
 800ca64:	2200      	movs	r2, #0
 800ca66:	605a      	str	r2, [r3, #4]
    PLL3_Clocks->PLL3_R_Frequency = 0U;
 800ca68:	687b      	ldr	r3, [r7, #4]
 800ca6a:	2200      	movs	r2, #0
 800ca6c:	609a      	str	r2, [r3, #8]
}
 800ca6e:	bf00      	nop
 800ca70:	3724      	adds	r7, #36	@ 0x24
 800ca72:	46bd      	mov	sp, r7
 800ca74:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ca78:	4770      	bx	lr
 800ca7a:	bf00      	nop
 800ca7c:	58024400 	.word	0x58024400
 800ca80:	03d09000 	.word	0x03d09000
 800ca84:	46000000 	.word	0x46000000
 800ca88:	4c742400 	.word	0x4c742400
 800ca8c:	4a742400 	.word	0x4a742400
 800ca90:	4bb71b00 	.word	0x4bb71b00

0800ca94 <HAL_RCCEx_GetPLL1ClockFreq>:
  *         right PLL1CLK value. Otherwise, any configuration based on this function will be incorrect.
  * @param  PLL1_Clocks structure.
  * @retval None
  */
void HAL_RCCEx_GetPLL1ClockFreq(PLL1_ClocksTypeDef *PLL1_Clocks)
{
 800ca94:	b480      	push	{r7}
 800ca96:	b089      	sub	sp, #36	@ 0x24
 800ca98:	af00      	add	r7, sp, #0
 800ca9a:	6078      	str	r0, [r7, #4]
  uint32_t pllsource, pll1m, pll1fracen, hsivalue;
  float_t fracn1, pll1vco;

  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 800ca9c:	4ba0      	ldr	r3, [pc, #640]	@ (800cd20 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
 800ca9e:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800caa0:	f003 0303 	and.w	r3, r3, #3
 800caa4:	61bb      	str	r3, [r7, #24]
  pll1m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1) >> 4);
 800caa6:	4b9e      	ldr	r3, [pc, #632]	@ (800cd20 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
 800caa8:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800caaa:	091b      	lsrs	r3, r3, #4
 800caac:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 800cab0:	617b      	str	r3, [r7, #20]
  pll1fracen = RCC->PLLCFGR & RCC_PLLCFGR_PLL1FRACEN;
 800cab2:	4b9b      	ldr	r3, [pc, #620]	@ (800cd20 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
 800cab4:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800cab6:	f003 0301 	and.w	r3, r3, #1
 800caba:	613b      	str	r3, [r7, #16]
  fracn1 = (float_t)(uint32_t)(pll1fracen * ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1) >> 3));
 800cabc:	4b98      	ldr	r3, [pc, #608]	@ (800cd20 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
 800cabe:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 800cac0:	08db      	lsrs	r3, r3, #3
 800cac2:	f3c3 030c 	ubfx	r3, r3, #0, #13
 800cac6:	693a      	ldr	r2, [r7, #16]
 800cac8:	fb02 f303 	mul.w	r3, r2, r3
 800cacc:	ee07 3a90 	vmov	s15, r3
 800cad0:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800cad4:	edc7 7a03 	vstr	s15, [r7, #12]

  if (pll1m != 0U)
 800cad8:	697b      	ldr	r3, [r7, #20]
 800cada:	2b00      	cmp	r3, #0
 800cadc:	f000 8111 	beq.w	800cd02 <HAL_RCCEx_GetPLL1ClockFreq+0x26e>
  {
    switch (pllsource)
 800cae0:	69bb      	ldr	r3, [r7, #24]
 800cae2:	2b02      	cmp	r3, #2
 800cae4:	f000 8083 	beq.w	800cbee <HAL_RCCEx_GetPLL1ClockFreq+0x15a>
 800cae8:	69bb      	ldr	r3, [r7, #24]
 800caea:	2b02      	cmp	r3, #2
 800caec:	f200 80a1 	bhi.w	800cc32 <HAL_RCCEx_GetPLL1ClockFreq+0x19e>
 800caf0:	69bb      	ldr	r3, [r7, #24]
 800caf2:	2b00      	cmp	r3, #0
 800caf4:	d003      	beq.n	800cafe <HAL_RCCEx_GetPLL1ClockFreq+0x6a>
 800caf6:	69bb      	ldr	r3, [r7, #24]
 800caf8:	2b01      	cmp	r3, #1
 800cafa:	d056      	beq.n	800cbaa <HAL_RCCEx_GetPLL1ClockFreq+0x116>
 800cafc:	e099      	b.n	800cc32 <HAL_RCCEx_GetPLL1ClockFreq+0x19e>
    {

      case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */

        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 800cafe:	4b88      	ldr	r3, [pc, #544]	@ (800cd20 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
 800cb00:	681b      	ldr	r3, [r3, #0]
 800cb02:	f003 0320 	and.w	r3, r3, #32
 800cb06:	2b00      	cmp	r3, #0
 800cb08:	d02d      	beq.n	800cb66 <HAL_RCCEx_GetPLL1ClockFreq+0xd2>
        {
          hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
 800cb0a:	4b85      	ldr	r3, [pc, #532]	@ (800cd20 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
 800cb0c:	681b      	ldr	r3, [r3, #0]
 800cb0e:	08db      	lsrs	r3, r3, #3
 800cb10:	f003 0303 	and.w	r3, r3, #3
 800cb14:	4a83      	ldr	r2, [pc, #524]	@ (800cd24 <HAL_RCCEx_GetPLL1ClockFreq+0x290>)
 800cb16:	fa22 f303 	lsr.w	r3, r2, r3
 800cb1a:	60bb      	str	r3, [r7, #8]
          pll1vco = ((float_t)hsivalue / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
 800cb1c:	68bb      	ldr	r3, [r7, #8]
 800cb1e:	ee07 3a90 	vmov	s15, r3
 800cb22:	eef8 6a67 	vcvt.f32.u32	s13, s15
 800cb26:	697b      	ldr	r3, [r7, #20]
 800cb28:	ee07 3a90 	vmov	s15, r3
 800cb2c:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800cb30:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 800cb34:	4b7a      	ldr	r3, [pc, #488]	@ (800cd20 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
 800cb36:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800cb38:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800cb3c:	ee07 3a90 	vmov	s15, r3
 800cb40:	eef8 6a67 	vcvt.f32.u32	s13, s15
 800cb44:	ed97 6a03 	vldr	s12, [r7, #12]
 800cb48:	eddf 5a77 	vldr	s11, [pc, #476]	@ 800cd28 <HAL_RCCEx_GetPLL1ClockFreq+0x294>
 800cb4c:	eec6 7a25 	vdiv.f32	s15, s12, s11
 800cb50:	ee76 7aa7 	vadd.f32	s15, s13, s15
 800cb54:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 800cb58:	ee77 7aa6 	vadd.f32	s15, s15, s13
 800cb5c:	ee67 7a27 	vmul.f32	s15, s14, s15
 800cb60:	edc7 7a07 	vstr	s15, [r7, #28]
        }
        else
        {
          pll1vco = ((float_t)HSI_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
        }
        break;
 800cb64:	e087      	b.n	800cc76 <HAL_RCCEx_GetPLL1ClockFreq+0x1e2>
          pll1vco = ((float_t)HSI_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
 800cb66:	697b      	ldr	r3, [r7, #20]
 800cb68:	ee07 3a90 	vmov	s15, r3
 800cb6c:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800cb70:	eddf 6a6e 	vldr	s13, [pc, #440]	@ 800cd2c <HAL_RCCEx_GetPLL1ClockFreq+0x298>
 800cb74:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 800cb78:	4b69      	ldr	r3, [pc, #420]	@ (800cd20 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
 800cb7a:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800cb7c:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800cb80:	ee07 3a90 	vmov	s15, r3
 800cb84:	eef8 6a67 	vcvt.f32.u32	s13, s15
 800cb88:	ed97 6a03 	vldr	s12, [r7, #12]
 800cb8c:	eddf 5a66 	vldr	s11, [pc, #408]	@ 800cd28 <HAL_RCCEx_GetPLL1ClockFreq+0x294>
 800cb90:	eec6 7a25 	vdiv.f32	s15, s12, s11
 800cb94:	ee76 7aa7 	vadd.f32	s15, s13, s15
 800cb98:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 800cb9c:	ee77 7aa6 	vadd.f32	s15, s15, s13
 800cba0:	ee67 7a27 	vmul.f32	s15, s14, s15
 800cba4:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
 800cba8:	e065      	b.n	800cc76 <HAL_RCCEx_GetPLL1ClockFreq+0x1e2>
      case RCC_PLLSOURCE_CSI:  /* CSI used as PLL clock source */
        pll1vco = ((float_t)CSI_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
 800cbaa:	697b      	ldr	r3, [r7, #20]
 800cbac:	ee07 3a90 	vmov	s15, r3
 800cbb0:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800cbb4:	eddf 6a5e 	vldr	s13, [pc, #376]	@ 800cd30 <HAL_RCCEx_GetPLL1ClockFreq+0x29c>
 800cbb8:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 800cbbc:	4b58      	ldr	r3, [pc, #352]	@ (800cd20 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
 800cbbe:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800cbc0:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800cbc4:	ee07 3a90 	vmov	s15, r3
 800cbc8:	eef8 6a67 	vcvt.f32.u32	s13, s15
 800cbcc:	ed97 6a03 	vldr	s12, [r7, #12]
 800cbd0:	eddf 5a55 	vldr	s11, [pc, #340]	@ 800cd28 <HAL_RCCEx_GetPLL1ClockFreq+0x294>
 800cbd4:	eec6 7a25 	vdiv.f32	s15, s12, s11
 800cbd8:	ee76 7aa7 	vadd.f32	s15, s13, s15
 800cbdc:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 800cbe0:	ee77 7aa6 	vadd.f32	s15, s15, s13
 800cbe4:	ee67 7a27 	vmul.f32	s15, s14, s15
 800cbe8:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
 800cbec:	e043      	b.n	800cc76 <HAL_RCCEx_GetPLL1ClockFreq+0x1e2>

      case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
        pll1vco = ((float_t)HSE_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
 800cbee:	697b      	ldr	r3, [r7, #20]
 800cbf0:	ee07 3a90 	vmov	s15, r3
 800cbf4:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800cbf8:	eddf 6a4e 	vldr	s13, [pc, #312]	@ 800cd34 <HAL_RCCEx_GetPLL1ClockFreq+0x2a0>
 800cbfc:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 800cc00:	4b47      	ldr	r3, [pc, #284]	@ (800cd20 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
 800cc02:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800cc04:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800cc08:	ee07 3a90 	vmov	s15, r3
 800cc0c:	eef8 6a67 	vcvt.f32.u32	s13, s15
 800cc10:	ed97 6a03 	vldr	s12, [r7, #12]
 800cc14:	eddf 5a44 	vldr	s11, [pc, #272]	@ 800cd28 <HAL_RCCEx_GetPLL1ClockFreq+0x294>
 800cc18:	eec6 7a25 	vdiv.f32	s15, s12, s11
 800cc1c:	ee76 7aa7 	vadd.f32	s15, s13, s15
 800cc20:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 800cc24:	ee77 7aa6 	vadd.f32	s15, s15, s13
 800cc28:	ee67 7a27 	vmul.f32	s15, s14, s15
 800cc2c:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
 800cc30:	e021      	b.n	800cc76 <HAL_RCCEx_GetPLL1ClockFreq+0x1e2>

      default:
        pll1vco = ((float_t)HSI_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
 800cc32:	697b      	ldr	r3, [r7, #20]
 800cc34:	ee07 3a90 	vmov	s15, r3
 800cc38:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800cc3c:	eddf 6a3b 	vldr	s13, [pc, #236]	@ 800cd2c <HAL_RCCEx_GetPLL1ClockFreq+0x298>
 800cc40:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 800cc44:	4b36      	ldr	r3, [pc, #216]	@ (800cd20 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
 800cc46:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800cc48:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800cc4c:	ee07 3a90 	vmov	s15, r3
 800cc50:	eef8 6a67 	vcvt.f32.u32	s13, s15
 800cc54:	ed97 6a03 	vldr	s12, [r7, #12]
 800cc58:	eddf 5a33 	vldr	s11, [pc, #204]	@ 800cd28 <HAL_RCCEx_GetPLL1ClockFreq+0x294>
 800cc5c:	eec6 7a25 	vdiv.f32	s15, s12, s11
 800cc60:	ee76 7aa7 	vadd.f32	s15, s13, s15
 800cc64:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 800cc68:	ee77 7aa6 	vadd.f32	s15, s15, s13
 800cc6c:	ee67 7a27 	vmul.f32	s15, s14, s15
 800cc70:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
 800cc74:	bf00      	nop
    }

    PLL1_Clocks->PLL1_P_Frequency = (uint32_t)(float_t)(pll1vco / ((float_t)(uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >> 9)  + (float_t)1)) ;
 800cc76:	4b2a      	ldr	r3, [pc, #168]	@ (800cd20 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
 800cc78:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800cc7a:	0a5b      	lsrs	r3, r3, #9
 800cc7c:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 800cc80:	ee07 3a90 	vmov	s15, r3
 800cc84:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800cc88:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 800cc8c:	ee37 7a87 	vadd.f32	s14, s15, s14
 800cc90:	edd7 6a07 	vldr	s13, [r7, #28]
 800cc94:	eec6 7a87 	vdiv.f32	s15, s13, s14
 800cc98:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 800cc9c:	ee17 2a90 	vmov	r2, s15
 800cca0:	687b      	ldr	r3, [r7, #4]
 800cca2:	601a      	str	r2, [r3, #0]
    PLL1_Clocks->PLL1_Q_Frequency = (uint32_t)(float_t)(pll1vco / ((float_t)(uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_Q1) >> 16) + (float_t)1)) ;
 800cca4:	4b1e      	ldr	r3, [pc, #120]	@ (800cd20 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
 800cca6:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800cca8:	0c1b      	lsrs	r3, r3, #16
 800ccaa:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 800ccae:	ee07 3a90 	vmov	s15, r3
 800ccb2:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800ccb6:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 800ccba:	ee37 7a87 	vadd.f32	s14, s15, s14
 800ccbe:	edd7 6a07 	vldr	s13, [r7, #28]
 800ccc2:	eec6 7a87 	vdiv.f32	s15, s13, s14
 800ccc6:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 800ccca:	ee17 2a90 	vmov	r2, s15
 800ccce:	687b      	ldr	r3, [r7, #4]
 800ccd0:	605a      	str	r2, [r3, #4]
    PLL1_Clocks->PLL1_R_Frequency = (uint32_t)(float_t)(pll1vco / ((float_t)(uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_R1) >> 24) + (float_t)1)) ;
 800ccd2:	4b13      	ldr	r3, [pc, #76]	@ (800cd20 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
 800ccd4:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800ccd6:	0e1b      	lsrs	r3, r3, #24
 800ccd8:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 800ccdc:	ee07 3a90 	vmov	s15, r3
 800cce0:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800cce4:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 800cce8:	ee37 7a87 	vadd.f32	s14, s15, s14
 800ccec:	edd7 6a07 	vldr	s13, [r7, #28]
 800ccf0:	eec6 7a87 	vdiv.f32	s15, s13, s14
 800ccf4:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 800ccf8:	ee17 2a90 	vmov	r2, s15
 800ccfc:	687b      	ldr	r3, [r7, #4]
 800ccfe:	609a      	str	r2, [r3, #8]
    PLL1_Clocks->PLL1_P_Frequency = 0U;
    PLL1_Clocks->PLL1_Q_Frequency = 0U;
    PLL1_Clocks->PLL1_R_Frequency = 0U;
  }

}
 800cd00:	e008      	b.n	800cd14 <HAL_RCCEx_GetPLL1ClockFreq+0x280>
    PLL1_Clocks->PLL1_P_Frequency = 0U;
 800cd02:	687b      	ldr	r3, [r7, #4]
 800cd04:	2200      	movs	r2, #0
 800cd06:	601a      	str	r2, [r3, #0]
    PLL1_Clocks->PLL1_Q_Frequency = 0U;
 800cd08:	687b      	ldr	r3, [r7, #4]
 800cd0a:	2200      	movs	r2, #0
 800cd0c:	605a      	str	r2, [r3, #4]
    PLL1_Clocks->PLL1_R_Frequency = 0U;
 800cd0e:	687b      	ldr	r3, [r7, #4]
 800cd10:	2200      	movs	r2, #0
 800cd12:	609a      	str	r2, [r3, #8]
}
 800cd14:	bf00      	nop
 800cd16:	3724      	adds	r7, #36	@ 0x24
 800cd18:	46bd      	mov	sp, r7
 800cd1a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cd1e:	4770      	bx	lr
 800cd20:	58024400 	.word	0x58024400
 800cd24:	03d09000 	.word	0x03d09000
 800cd28:	46000000 	.word	0x46000000
 800cd2c:	4c742400 	.word	0x4c742400
 800cd30:	4a742400 	.word	0x4a742400
 800cd34:	4bb71b00 	.word	0x4bb71b00

0800cd38 <RCCEx_PLL2_Config>:
  * @note   PLL2 is temporary disabled to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLL2_Config(RCC_PLL2InitTypeDef *pll2, uint32_t Divider)
{
 800cd38:	b580      	push	{r7, lr}
 800cd3a:	b084      	sub	sp, #16
 800cd3c:	af00      	add	r7, sp, #0
 800cd3e:	6078      	str	r0, [r7, #4]
 800cd40:	6039      	str	r1, [r7, #0]

  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;
 800cd42:	2300      	movs	r3, #0
 800cd44:	73fb      	strb	r3, [r7, #15]
  assert_param(IS_RCC_PLL2RGE_VALUE(pll2->PLL2RGE));
  assert_param(IS_RCC_PLL2VCO_VALUE(pll2->PLL2VCOSEL));
  assert_param(IS_RCC_PLLFRACN_VALUE(pll2->PLL2FRACN));

  /* Check that PLL2 OSC clock source is already set */
  if (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_NONE)
 800cd46:	4b53      	ldr	r3, [pc, #332]	@ (800ce94 <RCCEx_PLL2_Config+0x15c>)
 800cd48:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800cd4a:	f003 0303 	and.w	r3, r3, #3
 800cd4e:	2b03      	cmp	r3, #3
 800cd50:	d101      	bne.n	800cd56 <RCCEx_PLL2_Config+0x1e>
  {
    return HAL_ERROR;
 800cd52:	2301      	movs	r3, #1
 800cd54:	e099      	b.n	800ce8a <RCCEx_PLL2_Config+0x152>


  else
  {
    /* Disable  PLL2. */
    __HAL_RCC_PLL2_DISABLE();
 800cd56:	4b4f      	ldr	r3, [pc, #316]	@ (800ce94 <RCCEx_PLL2_Config+0x15c>)
 800cd58:	681b      	ldr	r3, [r3, #0]
 800cd5a:	4a4e      	ldr	r2, [pc, #312]	@ (800ce94 <RCCEx_PLL2_Config+0x15c>)
 800cd5c:	f023 6380 	bic.w	r3, r3, #67108864	@ 0x4000000
 800cd60:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 800cd62:	f7f5 fdfd 	bl	8002960 <HAL_GetTick>
 800cd66:	60b8      	str	r0, [r7, #8]

    /* Wait till PLL is disabled */
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) != 0U)
 800cd68:	e008      	b.n	800cd7c <RCCEx_PLL2_Config+0x44>
    {
      if ((HAL_GetTick() - tickstart) > PLL2_TIMEOUT_VALUE)
 800cd6a:	f7f5 fdf9 	bl	8002960 <HAL_GetTick>
 800cd6e:	4602      	mov	r2, r0
 800cd70:	68bb      	ldr	r3, [r7, #8]
 800cd72:	1ad3      	subs	r3, r2, r3
 800cd74:	2b02      	cmp	r3, #2
 800cd76:	d901      	bls.n	800cd7c <RCCEx_PLL2_Config+0x44>
      {
        return HAL_TIMEOUT;
 800cd78:	2303      	movs	r3, #3
 800cd7a:	e086      	b.n	800ce8a <RCCEx_PLL2_Config+0x152>
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) != 0U)
 800cd7c:	4b45      	ldr	r3, [pc, #276]	@ (800ce94 <RCCEx_PLL2_Config+0x15c>)
 800cd7e:	681b      	ldr	r3, [r3, #0]
 800cd80:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 800cd84:	2b00      	cmp	r3, #0
 800cd86:	d1f0      	bne.n	800cd6a <RCCEx_PLL2_Config+0x32>
      }
    }

    /* Configure PLL2 multiplication and division factors. */
    __HAL_RCC_PLL2_CONFIG(pll2->PLL2M,
 800cd88:	4b42      	ldr	r3, [pc, #264]	@ (800ce94 <RCCEx_PLL2_Config+0x15c>)
 800cd8a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800cd8c:	f423 327c 	bic.w	r2, r3, #258048	@ 0x3f000
 800cd90:	687b      	ldr	r3, [r7, #4]
 800cd92:	681b      	ldr	r3, [r3, #0]
 800cd94:	031b      	lsls	r3, r3, #12
 800cd96:	493f      	ldr	r1, [pc, #252]	@ (800ce94 <RCCEx_PLL2_Config+0x15c>)
 800cd98:	4313      	orrs	r3, r2
 800cd9a:	628b      	str	r3, [r1, #40]	@ 0x28
 800cd9c:	687b      	ldr	r3, [r7, #4]
 800cd9e:	685b      	ldr	r3, [r3, #4]
 800cda0:	3b01      	subs	r3, #1
 800cda2:	f3c3 0208 	ubfx	r2, r3, #0, #9
 800cda6:	687b      	ldr	r3, [r7, #4]
 800cda8:	689b      	ldr	r3, [r3, #8]
 800cdaa:	3b01      	subs	r3, #1
 800cdac:	025b      	lsls	r3, r3, #9
 800cdae:	b29b      	uxth	r3, r3
 800cdb0:	431a      	orrs	r2, r3
 800cdb2:	687b      	ldr	r3, [r7, #4]
 800cdb4:	68db      	ldr	r3, [r3, #12]
 800cdb6:	3b01      	subs	r3, #1
 800cdb8:	041b      	lsls	r3, r3, #16
 800cdba:	f403 03fe 	and.w	r3, r3, #8323072	@ 0x7f0000
 800cdbe:	431a      	orrs	r2, r3
 800cdc0:	687b      	ldr	r3, [r7, #4]
 800cdc2:	691b      	ldr	r3, [r3, #16]
 800cdc4:	3b01      	subs	r3, #1
 800cdc6:	061b      	lsls	r3, r3, #24
 800cdc8:	f003 43fe 	and.w	r3, r3, #2130706432	@ 0x7f000000
 800cdcc:	4931      	ldr	r1, [pc, #196]	@ (800ce94 <RCCEx_PLL2_Config+0x15c>)
 800cdce:	4313      	orrs	r3, r2
 800cdd0:	638b      	str	r3, [r1, #56]	@ 0x38
                          pll2->PLL2P,
                          pll2->PLL2Q,
                          pll2->PLL2R);

    /* Select PLL2 input reference frequency range: VCI */
    __HAL_RCC_PLL2_VCIRANGE(pll2->PLL2RGE) ;
 800cdd2:	4b30      	ldr	r3, [pc, #192]	@ (800ce94 <RCCEx_PLL2_Config+0x15c>)
 800cdd4:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800cdd6:	f023 02c0 	bic.w	r2, r3, #192	@ 0xc0
 800cdda:	687b      	ldr	r3, [r7, #4]
 800cddc:	695b      	ldr	r3, [r3, #20]
 800cdde:	492d      	ldr	r1, [pc, #180]	@ (800ce94 <RCCEx_PLL2_Config+0x15c>)
 800cde0:	4313      	orrs	r3, r2
 800cde2:	62cb      	str	r3, [r1, #44]	@ 0x2c

    /* Select PLL2 output frequency range : VCO */
    __HAL_RCC_PLL2_VCORANGE(pll2->PLL2VCOSEL) ;
 800cde4:	4b2b      	ldr	r3, [pc, #172]	@ (800ce94 <RCCEx_PLL2_Config+0x15c>)
 800cde6:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800cde8:	f023 0220 	bic.w	r2, r3, #32
 800cdec:	687b      	ldr	r3, [r7, #4]
 800cdee:	699b      	ldr	r3, [r3, #24]
 800cdf0:	4928      	ldr	r1, [pc, #160]	@ (800ce94 <RCCEx_PLL2_Config+0x15c>)
 800cdf2:	4313      	orrs	r3, r2
 800cdf4:	62cb      	str	r3, [r1, #44]	@ 0x2c

    /* Disable PLL2FRACN . */
    __HAL_RCC_PLL2FRACN_DISABLE();
 800cdf6:	4b27      	ldr	r3, [pc, #156]	@ (800ce94 <RCCEx_PLL2_Config+0x15c>)
 800cdf8:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800cdfa:	4a26      	ldr	r2, [pc, #152]	@ (800ce94 <RCCEx_PLL2_Config+0x15c>)
 800cdfc:	f023 0310 	bic.w	r3, r3, #16
 800ce00:	62d3      	str	r3, [r2, #44]	@ 0x2c

    /* Configures PLL2 clock Fractional Part Of The Multiplication Factor */
    __HAL_RCC_PLL2FRACN_CONFIG(pll2->PLL2FRACN);
 800ce02:	4b24      	ldr	r3, [pc, #144]	@ (800ce94 <RCCEx_PLL2_Config+0x15c>)
 800ce04:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 800ce06:	4b24      	ldr	r3, [pc, #144]	@ (800ce98 <RCCEx_PLL2_Config+0x160>)
 800ce08:	4013      	ands	r3, r2
 800ce0a:	687a      	ldr	r2, [r7, #4]
 800ce0c:	69d2      	ldr	r2, [r2, #28]
 800ce0e:	00d2      	lsls	r2, r2, #3
 800ce10:	4920      	ldr	r1, [pc, #128]	@ (800ce94 <RCCEx_PLL2_Config+0x15c>)
 800ce12:	4313      	orrs	r3, r2
 800ce14:	63cb      	str	r3, [r1, #60]	@ 0x3c

    /* Enable PLL2FRACN . */
    __HAL_RCC_PLL2FRACN_ENABLE();
 800ce16:	4b1f      	ldr	r3, [pc, #124]	@ (800ce94 <RCCEx_PLL2_Config+0x15c>)
 800ce18:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800ce1a:	4a1e      	ldr	r2, [pc, #120]	@ (800ce94 <RCCEx_PLL2_Config+0x15c>)
 800ce1c:	f043 0310 	orr.w	r3, r3, #16
 800ce20:	62d3      	str	r3, [r2, #44]	@ 0x2c

    /* Enable the PLL2 clock output */
    if (Divider == DIVIDER_P_UPDATE)
 800ce22:	683b      	ldr	r3, [r7, #0]
 800ce24:	2b00      	cmp	r3, #0
 800ce26:	d106      	bne.n	800ce36 <RCCEx_PLL2_Config+0xfe>
    {
      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVP);
 800ce28:	4b1a      	ldr	r3, [pc, #104]	@ (800ce94 <RCCEx_PLL2_Config+0x15c>)
 800ce2a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800ce2c:	4a19      	ldr	r2, [pc, #100]	@ (800ce94 <RCCEx_PLL2_Config+0x15c>)
 800ce2e:	f443 2300 	orr.w	r3, r3, #524288	@ 0x80000
 800ce32:	62d3      	str	r3, [r2, #44]	@ 0x2c
 800ce34:	e00f      	b.n	800ce56 <RCCEx_PLL2_Config+0x11e>
    }
    else if (Divider == DIVIDER_Q_UPDATE)
 800ce36:	683b      	ldr	r3, [r7, #0]
 800ce38:	2b01      	cmp	r3, #1
 800ce3a:	d106      	bne.n	800ce4a <RCCEx_PLL2_Config+0x112>
    {
      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVQ);
 800ce3c:	4b15      	ldr	r3, [pc, #84]	@ (800ce94 <RCCEx_PLL2_Config+0x15c>)
 800ce3e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800ce40:	4a14      	ldr	r2, [pc, #80]	@ (800ce94 <RCCEx_PLL2_Config+0x15c>)
 800ce42:	f443 1380 	orr.w	r3, r3, #1048576	@ 0x100000
 800ce46:	62d3      	str	r3, [r2, #44]	@ 0x2c
 800ce48:	e005      	b.n	800ce56 <RCCEx_PLL2_Config+0x11e>
    }
    else
    {
      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVR);
 800ce4a:	4b12      	ldr	r3, [pc, #72]	@ (800ce94 <RCCEx_PLL2_Config+0x15c>)
 800ce4c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800ce4e:	4a11      	ldr	r2, [pc, #68]	@ (800ce94 <RCCEx_PLL2_Config+0x15c>)
 800ce50:	f443 1300 	orr.w	r3, r3, #2097152	@ 0x200000
 800ce54:	62d3      	str	r3, [r2, #44]	@ 0x2c
    }

    /* Enable  PLL2. */
    __HAL_RCC_PLL2_ENABLE();
 800ce56:	4b0f      	ldr	r3, [pc, #60]	@ (800ce94 <RCCEx_PLL2_Config+0x15c>)
 800ce58:	681b      	ldr	r3, [r3, #0]
 800ce5a:	4a0e      	ldr	r2, [pc, #56]	@ (800ce94 <RCCEx_PLL2_Config+0x15c>)
 800ce5c:	f043 6380 	orr.w	r3, r3, #67108864	@ 0x4000000
 800ce60:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 800ce62:	f7f5 fd7d 	bl	8002960 <HAL_GetTick>
 800ce66:	60b8      	str	r0, [r7, #8]

    /* Wait till PLL2 is ready */
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) == 0U)
 800ce68:	e008      	b.n	800ce7c <RCCEx_PLL2_Config+0x144>
    {
      if ((HAL_GetTick() - tickstart) > PLL2_TIMEOUT_VALUE)
 800ce6a:	f7f5 fd79 	bl	8002960 <HAL_GetTick>
 800ce6e:	4602      	mov	r2, r0
 800ce70:	68bb      	ldr	r3, [r7, #8]
 800ce72:	1ad3      	subs	r3, r2, r3
 800ce74:	2b02      	cmp	r3, #2
 800ce76:	d901      	bls.n	800ce7c <RCCEx_PLL2_Config+0x144>
      {
        return HAL_TIMEOUT;
 800ce78:	2303      	movs	r3, #3
 800ce7a:	e006      	b.n	800ce8a <RCCEx_PLL2_Config+0x152>
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) == 0U)
 800ce7c:	4b05      	ldr	r3, [pc, #20]	@ (800ce94 <RCCEx_PLL2_Config+0x15c>)
 800ce7e:	681b      	ldr	r3, [r3, #0]
 800ce80:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 800ce84:	2b00      	cmp	r3, #0
 800ce86:	d0f0      	beq.n	800ce6a <RCCEx_PLL2_Config+0x132>
    }

  }


  return status;
 800ce88:	7bfb      	ldrb	r3, [r7, #15]
}
 800ce8a:	4618      	mov	r0, r3
 800ce8c:	3710      	adds	r7, #16
 800ce8e:	46bd      	mov	sp, r7
 800ce90:	bd80      	pop	{r7, pc}
 800ce92:	bf00      	nop
 800ce94:	58024400 	.word	0x58024400
 800ce98:	ffff0007 	.word	0xffff0007

0800ce9c <RCCEx_PLL3_Config>:
  * @note   PLL3 is temporary disabled to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLL3_Config(RCC_PLL3InitTypeDef *pll3, uint32_t Divider)
{
 800ce9c:	b580      	push	{r7, lr}
 800ce9e:	b084      	sub	sp, #16
 800cea0:	af00      	add	r7, sp, #0
 800cea2:	6078      	str	r0, [r7, #4]
 800cea4:	6039      	str	r1, [r7, #0]
  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;
 800cea6:	2300      	movs	r3, #0
 800cea8:	73fb      	strb	r3, [r7, #15]
  assert_param(IS_RCC_PLL3RGE_VALUE(pll3->PLL3RGE));
  assert_param(IS_RCC_PLL3VCO_VALUE(pll3->PLL3VCOSEL));
  assert_param(IS_RCC_PLLFRACN_VALUE(pll3->PLL3FRACN));

  /* Check that PLL3 OSC clock source is already set */
  if (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_NONE)
 800ceaa:	4b53      	ldr	r3, [pc, #332]	@ (800cff8 <RCCEx_PLL3_Config+0x15c>)
 800ceac:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800ceae:	f003 0303 	and.w	r3, r3, #3
 800ceb2:	2b03      	cmp	r3, #3
 800ceb4:	d101      	bne.n	800ceba <RCCEx_PLL3_Config+0x1e>
  {
    return HAL_ERROR;
 800ceb6:	2301      	movs	r3, #1
 800ceb8:	e099      	b.n	800cfee <RCCEx_PLL3_Config+0x152>


  else
  {
    /* Disable  PLL3. */
    __HAL_RCC_PLL3_DISABLE();
 800ceba:	4b4f      	ldr	r3, [pc, #316]	@ (800cff8 <RCCEx_PLL3_Config+0x15c>)
 800cebc:	681b      	ldr	r3, [r3, #0]
 800cebe:	4a4e      	ldr	r2, [pc, #312]	@ (800cff8 <RCCEx_PLL3_Config+0x15c>)
 800cec0:	f023 5380 	bic.w	r3, r3, #268435456	@ 0x10000000
 800cec4:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 800cec6:	f7f5 fd4b 	bl	8002960 <HAL_GetTick>
 800ceca:	60b8      	str	r0, [r7, #8]
    /* Wait till PLL3 is ready */
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) != 0U)
 800cecc:	e008      	b.n	800cee0 <RCCEx_PLL3_Config+0x44>
    {
      if ((HAL_GetTick() - tickstart) > PLL3_TIMEOUT_VALUE)
 800cece:	f7f5 fd47 	bl	8002960 <HAL_GetTick>
 800ced2:	4602      	mov	r2, r0
 800ced4:	68bb      	ldr	r3, [r7, #8]
 800ced6:	1ad3      	subs	r3, r2, r3
 800ced8:	2b02      	cmp	r3, #2
 800ceda:	d901      	bls.n	800cee0 <RCCEx_PLL3_Config+0x44>
      {
        return HAL_TIMEOUT;
 800cedc:	2303      	movs	r3, #3
 800cede:	e086      	b.n	800cfee <RCCEx_PLL3_Config+0x152>
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) != 0U)
 800cee0:	4b45      	ldr	r3, [pc, #276]	@ (800cff8 <RCCEx_PLL3_Config+0x15c>)
 800cee2:	681b      	ldr	r3, [r3, #0]
 800cee4:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
 800cee8:	2b00      	cmp	r3, #0
 800ceea:	d1f0      	bne.n	800cece <RCCEx_PLL3_Config+0x32>
      }
    }

    /* Configure the PLL3  multiplication and division factors. */
    __HAL_RCC_PLL3_CONFIG(pll3->PLL3M,
 800ceec:	4b42      	ldr	r3, [pc, #264]	@ (800cff8 <RCCEx_PLL3_Config+0x15c>)
 800ceee:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800cef0:	f023 727c 	bic.w	r2, r3, #66060288	@ 0x3f00000
 800cef4:	687b      	ldr	r3, [r7, #4]
 800cef6:	681b      	ldr	r3, [r3, #0]
 800cef8:	051b      	lsls	r3, r3, #20
 800cefa:	493f      	ldr	r1, [pc, #252]	@ (800cff8 <RCCEx_PLL3_Config+0x15c>)
 800cefc:	4313      	orrs	r3, r2
 800cefe:	628b      	str	r3, [r1, #40]	@ 0x28
 800cf00:	687b      	ldr	r3, [r7, #4]
 800cf02:	685b      	ldr	r3, [r3, #4]
 800cf04:	3b01      	subs	r3, #1
 800cf06:	f3c3 0208 	ubfx	r2, r3, #0, #9
 800cf0a:	687b      	ldr	r3, [r7, #4]
 800cf0c:	689b      	ldr	r3, [r3, #8]
 800cf0e:	3b01      	subs	r3, #1
 800cf10:	025b      	lsls	r3, r3, #9
 800cf12:	b29b      	uxth	r3, r3
 800cf14:	431a      	orrs	r2, r3
 800cf16:	687b      	ldr	r3, [r7, #4]
 800cf18:	68db      	ldr	r3, [r3, #12]
 800cf1a:	3b01      	subs	r3, #1
 800cf1c:	041b      	lsls	r3, r3, #16
 800cf1e:	f403 03fe 	and.w	r3, r3, #8323072	@ 0x7f0000
 800cf22:	431a      	orrs	r2, r3
 800cf24:	687b      	ldr	r3, [r7, #4]
 800cf26:	691b      	ldr	r3, [r3, #16]
 800cf28:	3b01      	subs	r3, #1
 800cf2a:	061b      	lsls	r3, r3, #24
 800cf2c:	f003 43fe 	and.w	r3, r3, #2130706432	@ 0x7f000000
 800cf30:	4931      	ldr	r1, [pc, #196]	@ (800cff8 <RCCEx_PLL3_Config+0x15c>)
 800cf32:	4313      	orrs	r3, r2
 800cf34:	640b      	str	r3, [r1, #64]	@ 0x40
                          pll3->PLL3P,
                          pll3->PLL3Q,
                          pll3->PLL3R);

    /* Select PLL3 input reference frequency range: VCI */
    __HAL_RCC_PLL3_VCIRANGE(pll3->PLL3RGE) ;
 800cf36:	4b30      	ldr	r3, [pc, #192]	@ (800cff8 <RCCEx_PLL3_Config+0x15c>)
 800cf38:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800cf3a:	f423 6240 	bic.w	r2, r3, #3072	@ 0xc00
 800cf3e:	687b      	ldr	r3, [r7, #4]
 800cf40:	695b      	ldr	r3, [r3, #20]
 800cf42:	492d      	ldr	r1, [pc, #180]	@ (800cff8 <RCCEx_PLL3_Config+0x15c>)
 800cf44:	4313      	orrs	r3, r2
 800cf46:	62cb      	str	r3, [r1, #44]	@ 0x2c

    /* Select PLL3 output frequency range : VCO */
    __HAL_RCC_PLL3_VCORANGE(pll3->PLL3VCOSEL) ;
 800cf48:	4b2b      	ldr	r3, [pc, #172]	@ (800cff8 <RCCEx_PLL3_Config+0x15c>)
 800cf4a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800cf4c:	f423 7200 	bic.w	r2, r3, #512	@ 0x200
 800cf50:	687b      	ldr	r3, [r7, #4]
 800cf52:	699b      	ldr	r3, [r3, #24]
 800cf54:	4928      	ldr	r1, [pc, #160]	@ (800cff8 <RCCEx_PLL3_Config+0x15c>)
 800cf56:	4313      	orrs	r3, r2
 800cf58:	62cb      	str	r3, [r1, #44]	@ 0x2c

    /* Disable PLL3FRACN . */
    __HAL_RCC_PLL3FRACN_DISABLE();
 800cf5a:	4b27      	ldr	r3, [pc, #156]	@ (800cff8 <RCCEx_PLL3_Config+0x15c>)
 800cf5c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800cf5e:	4a26      	ldr	r2, [pc, #152]	@ (800cff8 <RCCEx_PLL3_Config+0x15c>)
 800cf60:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
 800cf64:	62d3      	str	r3, [r2, #44]	@ 0x2c

    /* Configures PLL3 clock Fractional Part Of The Multiplication Factor */
    __HAL_RCC_PLL3FRACN_CONFIG(pll3->PLL3FRACN);
 800cf66:	4b24      	ldr	r3, [pc, #144]	@ (800cff8 <RCCEx_PLL3_Config+0x15c>)
 800cf68:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
 800cf6a:	4b24      	ldr	r3, [pc, #144]	@ (800cffc <RCCEx_PLL3_Config+0x160>)
 800cf6c:	4013      	ands	r3, r2
 800cf6e:	687a      	ldr	r2, [r7, #4]
 800cf70:	69d2      	ldr	r2, [r2, #28]
 800cf72:	00d2      	lsls	r2, r2, #3
 800cf74:	4920      	ldr	r1, [pc, #128]	@ (800cff8 <RCCEx_PLL3_Config+0x15c>)
 800cf76:	4313      	orrs	r3, r2
 800cf78:	644b      	str	r3, [r1, #68]	@ 0x44

    /* Enable PLL3FRACN . */
    __HAL_RCC_PLL3FRACN_ENABLE();
 800cf7a:	4b1f      	ldr	r3, [pc, #124]	@ (800cff8 <RCCEx_PLL3_Config+0x15c>)
 800cf7c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800cf7e:	4a1e      	ldr	r2, [pc, #120]	@ (800cff8 <RCCEx_PLL3_Config+0x15c>)
 800cf80:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 800cf84:	62d3      	str	r3, [r2, #44]	@ 0x2c

    /* Enable the PLL3 clock output */
    if (Divider == DIVIDER_P_UPDATE)
 800cf86:	683b      	ldr	r3, [r7, #0]
 800cf88:	2b00      	cmp	r3, #0
 800cf8a:	d106      	bne.n	800cf9a <RCCEx_PLL3_Config+0xfe>
    {
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVP);
 800cf8c:	4b1a      	ldr	r3, [pc, #104]	@ (800cff8 <RCCEx_PLL3_Config+0x15c>)
 800cf8e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800cf90:	4a19      	ldr	r2, [pc, #100]	@ (800cff8 <RCCEx_PLL3_Config+0x15c>)
 800cf92:	f443 0380 	orr.w	r3, r3, #4194304	@ 0x400000
 800cf96:	62d3      	str	r3, [r2, #44]	@ 0x2c
 800cf98:	e00f      	b.n	800cfba <RCCEx_PLL3_Config+0x11e>
    }
    else if (Divider == DIVIDER_Q_UPDATE)
 800cf9a:	683b      	ldr	r3, [r7, #0]
 800cf9c:	2b01      	cmp	r3, #1
 800cf9e:	d106      	bne.n	800cfae <RCCEx_PLL3_Config+0x112>
    {
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVQ);
 800cfa0:	4b15      	ldr	r3, [pc, #84]	@ (800cff8 <RCCEx_PLL3_Config+0x15c>)
 800cfa2:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800cfa4:	4a14      	ldr	r2, [pc, #80]	@ (800cff8 <RCCEx_PLL3_Config+0x15c>)
 800cfa6:	f443 0300 	orr.w	r3, r3, #8388608	@ 0x800000
 800cfaa:	62d3      	str	r3, [r2, #44]	@ 0x2c
 800cfac:	e005      	b.n	800cfba <RCCEx_PLL3_Config+0x11e>
    }
    else
    {
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVR);
 800cfae:	4b12      	ldr	r3, [pc, #72]	@ (800cff8 <RCCEx_PLL3_Config+0x15c>)
 800cfb0:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800cfb2:	4a11      	ldr	r2, [pc, #68]	@ (800cff8 <RCCEx_PLL3_Config+0x15c>)
 800cfb4:	f043 7380 	orr.w	r3, r3, #16777216	@ 0x1000000
 800cfb8:	62d3      	str	r3, [r2, #44]	@ 0x2c
    }

    /* Enable  PLL3. */
    __HAL_RCC_PLL3_ENABLE();
 800cfba:	4b0f      	ldr	r3, [pc, #60]	@ (800cff8 <RCCEx_PLL3_Config+0x15c>)
 800cfbc:	681b      	ldr	r3, [r3, #0]
 800cfbe:	4a0e      	ldr	r2, [pc, #56]	@ (800cff8 <RCCEx_PLL3_Config+0x15c>)
 800cfc0:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 800cfc4:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 800cfc6:	f7f5 fccb 	bl	8002960 <HAL_GetTick>
 800cfca:	60b8      	str	r0, [r7, #8]

    /* Wait till PLL3 is ready */
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) == 0U)
 800cfcc:	e008      	b.n	800cfe0 <RCCEx_PLL3_Config+0x144>
    {
      if ((HAL_GetTick() - tickstart) > PLL3_TIMEOUT_VALUE)
 800cfce:	f7f5 fcc7 	bl	8002960 <HAL_GetTick>
 800cfd2:	4602      	mov	r2, r0
 800cfd4:	68bb      	ldr	r3, [r7, #8]
 800cfd6:	1ad3      	subs	r3, r2, r3
 800cfd8:	2b02      	cmp	r3, #2
 800cfda:	d901      	bls.n	800cfe0 <RCCEx_PLL3_Config+0x144>
      {
        return HAL_TIMEOUT;
 800cfdc:	2303      	movs	r3, #3
 800cfde:	e006      	b.n	800cfee <RCCEx_PLL3_Config+0x152>
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) == 0U)
 800cfe0:	4b05      	ldr	r3, [pc, #20]	@ (800cff8 <RCCEx_PLL3_Config+0x15c>)
 800cfe2:	681b      	ldr	r3, [r3, #0]
 800cfe4:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
 800cfe8:	2b00      	cmp	r3, #0
 800cfea:	d0f0      	beq.n	800cfce <RCCEx_PLL3_Config+0x132>
    }

  }


  return status;
 800cfec:	7bfb      	ldrb	r3, [r7, #15]
}
 800cfee:	4618      	mov	r0, r3
 800cff0:	3710      	adds	r7, #16
 800cff2:	46bd      	mov	sp, r7
 800cff4:	bd80      	pop	{r7, pc}
 800cff6:	bf00      	nop
 800cff8:	58024400 	.word	0x58024400
 800cffc:	ffff0007 	.word	0xffff0007

0800d000 <HAL_SAI_InitProtocol>:
  *                   the configuration information for SAI module.
  * @param  nbslot Number of slot.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SAI_InitProtocol(SAI_HandleTypeDef *hsai, uint32_t protocol, uint32_t datasize, uint32_t nbslot)
{
 800d000:	b580      	push	{r7, lr}
 800d002:	b086      	sub	sp, #24
 800d004:	af00      	add	r7, sp, #0
 800d006:	60f8      	str	r0, [r7, #12]
 800d008:	60b9      	str	r1, [r7, #8]
 800d00a:	607a      	str	r2, [r7, #4]
 800d00c:	603b      	str	r3, [r7, #0]

  /* Check the parameters */
  assert_param(IS_SAI_SUPPORTED_PROTOCOL(protocol));
  assert_param(IS_SAI_PROTOCOL_DATASIZE(datasize));

  switch (protocol)
 800d00e:	68bb      	ldr	r3, [r7, #8]
 800d010:	2b02      	cmp	r3, #2
 800d012:	d904      	bls.n	800d01e <HAL_SAI_InitProtocol+0x1e>
 800d014:	68bb      	ldr	r3, [r7, #8]
 800d016:	3b03      	subs	r3, #3
 800d018:	2b01      	cmp	r3, #1
 800d01a:	d812      	bhi.n	800d042 <HAL_SAI_InitProtocol+0x42>
 800d01c:	e008      	b.n	800d030 <HAL_SAI_InitProtocol+0x30>
  {
    case SAI_I2S_STANDARD :
    case SAI_I2S_MSBJUSTIFIED :
    case SAI_I2S_LSBJUSTIFIED :
      status = SAI_InitI2S(hsai, protocol, datasize, nbslot);
 800d01e:	683b      	ldr	r3, [r7, #0]
 800d020:	687a      	ldr	r2, [r7, #4]
 800d022:	68b9      	ldr	r1, [r7, #8]
 800d024:	68f8      	ldr	r0, [r7, #12]
 800d026:	f000 fb8d 	bl	800d744 <SAI_InitI2S>
 800d02a:	4603      	mov	r3, r0
 800d02c:	75fb      	strb	r3, [r7, #23]
      break;
 800d02e:	e00b      	b.n	800d048 <HAL_SAI_InitProtocol+0x48>
    case SAI_PCM_LONG :
    case SAI_PCM_SHORT :
      status = SAI_InitPCM(hsai, protocol, datasize, nbslot);
 800d030:	683b      	ldr	r3, [r7, #0]
 800d032:	687a      	ldr	r2, [r7, #4]
 800d034:	68b9      	ldr	r1, [r7, #8]
 800d036:	68f8      	ldr	r0, [r7, #12]
 800d038:	f000 fc36 	bl	800d8a8 <SAI_InitPCM>
 800d03c:	4603      	mov	r3, r0
 800d03e:	75fb      	strb	r3, [r7, #23]
      break;
 800d040:	e002      	b.n	800d048 <HAL_SAI_InitProtocol+0x48>
    default :
      status = HAL_ERROR;
 800d042:	2301      	movs	r3, #1
 800d044:	75fb      	strb	r3, [r7, #23]
      break;
 800d046:	bf00      	nop
  }

  if (status == HAL_OK)
 800d048:	7dfb      	ldrb	r3, [r7, #23]
 800d04a:	2b00      	cmp	r3, #0
 800d04c:	d104      	bne.n	800d058 <HAL_SAI_InitProtocol+0x58>
  {
    status = HAL_SAI_Init(hsai);
 800d04e:	68f8      	ldr	r0, [r7, #12]
 800d050:	f000 f808 	bl	800d064 <HAL_SAI_Init>
 800d054:	4603      	mov	r3, r0
 800d056:	75fb      	strb	r3, [r7, #23]
  }

  return status;
 800d058:	7dfb      	ldrb	r3, [r7, #23]
}
 800d05a:	4618      	mov	r0, r3
 800d05c:	3718      	adds	r7, #24
 800d05e:	46bd      	mov	sp, r7
 800d060:	bd80      	pop	{r7, pc}
	...

0800d064 <HAL_SAI_Init>:
  * @param  hsai pointer to a SAI_HandleTypeDef structure that contains
  *              the configuration information for SAI module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SAI_Init(SAI_HandleTypeDef *hsai)
{
 800d064:	b580      	push	{r7, lr}
 800d066:	b08a      	sub	sp, #40	@ 0x28
 800d068:	af00      	add	r7, sp, #0
 800d06a:	6078      	str	r0, [r7, #4]
  uint32_t ckstr_bits;
  uint32_t syncen_bits;
  SAI_TypeDef *SaiBaseAddress;

  /* Check the SAI handle allocation */
  if (hsai == NULL)
 800d06c:	687b      	ldr	r3, [r7, #4]
 800d06e:	2b00      	cmp	r3, #0
 800d070:	d101      	bne.n	800d076 <HAL_SAI_Init+0x12>
  {
    return HAL_ERROR;
 800d072:	2301      	movs	r3, #1
 800d074:	e1f2      	b.n	800d45c <HAL_SAI_Init+0x3f8>
  assert_param(IS_SAI_BLOCK_SLOT_NUMBER(hsai->SlotInit.SlotNumber));
  assert_param(IS_SAI_SLOT_ACTIVE(hsai->SlotInit.SlotActive));

  /* Check the SAI PDM parameters */
  assert_param(IS_FUNCTIONAL_STATE(hsai->Init.PdmInit.Activation));
  if (hsai->Init.PdmInit.Activation == ENABLE)
 800d076:	687b      	ldr	r3, [r7, #4]
 800d078:	f893 3038 	ldrb.w	r3, [r3, #56]	@ 0x38
 800d07c:	2b01      	cmp	r3, #1
 800d07e:	d10e      	bne.n	800d09e <HAL_SAI_Init+0x3a>
         (hsai->Init.Protocol != SAI_FREE_PROTOCOL))
    {
      return HAL_ERROR;
    }
#else
    if ((hsai->Instance != SAI1_Block_A) ||
 800d080:	687b      	ldr	r3, [r7, #4]
 800d082:	681b      	ldr	r3, [r3, #0]
 800d084:	4a94      	ldr	r2, [pc, #592]	@ (800d2d8 <HAL_SAI_Init+0x274>)
 800d086:	4293      	cmp	r3, r2
 800d088:	d107      	bne.n	800d09a <HAL_SAI_Init+0x36>
        (hsai->Init.AudioMode != SAI_MODEMASTER_RX) ||
 800d08a:	687b      	ldr	r3, [r7, #4]
 800d08c:	685b      	ldr	r3, [r3, #4]
    if ((hsai->Instance != SAI1_Block_A) ||
 800d08e:	2b01      	cmp	r3, #1
 800d090:	d103      	bne.n	800d09a <HAL_SAI_Init+0x36>
        (hsai->Init.Protocol != SAI_FREE_PROTOCOL))
 800d092:	687b      	ldr	r3, [r7, #4]
 800d094:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
        (hsai->Init.AudioMode != SAI_MODEMASTER_RX) ||
 800d096:	2b00      	cmp	r3, #0
 800d098:	d001      	beq.n	800d09e <HAL_SAI_Init+0x3a>
    {
      return HAL_ERROR;
 800d09a:	2301      	movs	r3, #1
 800d09c:	e1de      	b.n	800d45c <HAL_SAI_Init+0x3f8>
    }
#endif /* SAI4 */
  }

  /* Get the SAI base address according to the SAI handle */
  if ((hsai->Instance == SAI1_Block_A) || (hsai->Instance == SAI1_Block_B))
 800d09e:	687b      	ldr	r3, [r7, #4]
 800d0a0:	681b      	ldr	r3, [r3, #0]
 800d0a2:	4a8d      	ldr	r2, [pc, #564]	@ (800d2d8 <HAL_SAI_Init+0x274>)
 800d0a4:	4293      	cmp	r3, r2
 800d0a6:	d004      	beq.n	800d0b2 <HAL_SAI_Init+0x4e>
 800d0a8:	687b      	ldr	r3, [r7, #4]
 800d0aa:	681b      	ldr	r3, [r3, #0]
 800d0ac:	4a8b      	ldr	r2, [pc, #556]	@ (800d2dc <HAL_SAI_Init+0x278>)
 800d0ae:	4293      	cmp	r3, r2
 800d0b0:	d102      	bne.n	800d0b8 <HAL_SAI_Init+0x54>
  {
    SaiBaseAddress = SAI1;
 800d0b2:	4b8b      	ldr	r3, [pc, #556]	@ (800d2e0 <HAL_SAI_Init+0x27c>)
 800d0b4:	61bb      	str	r3, [r7, #24]
 800d0b6:	e00e      	b.n	800d0d6 <HAL_SAI_Init+0x72>
  }
#if defined(SAI2)
  else if ((hsai->Instance == SAI2_Block_A) || (hsai->Instance == SAI2_Block_B))
 800d0b8:	687b      	ldr	r3, [r7, #4]
 800d0ba:	681b      	ldr	r3, [r3, #0]
 800d0bc:	4a89      	ldr	r2, [pc, #548]	@ (800d2e4 <HAL_SAI_Init+0x280>)
 800d0be:	4293      	cmp	r3, r2
 800d0c0:	d004      	beq.n	800d0cc <HAL_SAI_Init+0x68>
 800d0c2:	687b      	ldr	r3, [r7, #4]
 800d0c4:	681b      	ldr	r3, [r3, #0]
 800d0c6:	4a88      	ldr	r2, [pc, #544]	@ (800d2e8 <HAL_SAI_Init+0x284>)
 800d0c8:	4293      	cmp	r3, r2
 800d0ca:	d102      	bne.n	800d0d2 <HAL_SAI_Init+0x6e>
  {
    SaiBaseAddress = SAI2;
 800d0cc:	4b87      	ldr	r3, [pc, #540]	@ (800d2ec <HAL_SAI_Init+0x288>)
 800d0ce:	61bb      	str	r3, [r7, #24]
 800d0d0:	e001      	b.n	800d0d6 <HAL_SAI_Init+0x72>
    SaiBaseAddress = SAI4;
  }
#endif /* SAI4 */
  else
  {
    return HAL_ERROR;
 800d0d2:	2301      	movs	r3, #1
 800d0d4:	e1c2      	b.n	800d45c <HAL_SAI_Init+0x3f8>
  }

  if (hsai->State == HAL_SAI_STATE_RESET)
 800d0d6:	687b      	ldr	r3, [r7, #4]
 800d0d8:	f893 3091 	ldrb.w	r3, [r3, #145]	@ 0x91
 800d0dc:	b2db      	uxtb	r3, r3
 800d0de:	2b00      	cmp	r3, #0
 800d0e0:	d106      	bne.n	800d0f0 <HAL_SAI_Init+0x8c>
  {
    /* Allocate lock resource and initialize it */
    hsai->Lock = HAL_UNLOCKED;
 800d0e2:	687b      	ldr	r3, [r7, #4]
 800d0e4:	2200      	movs	r2, #0
 800d0e6:	f883 2090 	strb.w	r2, [r3, #144]	@ 0x90
      hsai->MspInitCallback = HAL_SAI_MspInit;
    }
    hsai->MspInitCallback(hsai);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
    HAL_SAI_MspInit(hsai);
 800d0ea:	6878      	ldr	r0, [r7, #4]
 800d0ec:	f7f5 f9a6 	bl	800243c <HAL_SAI_MspInit>
#endif
  }

  /* Disable the selected SAI peripheral */
  if(SAI_Disable(hsai) != HAL_OK)
 800d0f0:	6878      	ldr	r0, [r7, #4]
 800d0f2:	f000 fc93 	bl	800da1c <SAI_Disable>
 800d0f6:	4603      	mov	r3, r0
 800d0f8:	2b00      	cmp	r3, #0
 800d0fa:	d001      	beq.n	800d100 <HAL_SAI_Init+0x9c>
  {
    return HAL_ERROR;
 800d0fc:	2301      	movs	r3, #1
 800d0fe:	e1ad      	b.n	800d45c <HAL_SAI_Init+0x3f8>
  }

  hsai->State = HAL_SAI_STATE_BUSY;
 800d100:	687b      	ldr	r3, [r7, #4]
 800d102:	2202      	movs	r2, #2
 800d104:	f883 2091 	strb.w	r2, [r3, #145]	@ 0x91

  /* SAI Block Synchro Configuration -----------------------------------------*/
  /* This setting must be done with both audio block (A & B) disabled         */
  switch (hsai->Init.SynchroExt)
 800d108:	687b      	ldr	r3, [r7, #4]
 800d10a:	68db      	ldr	r3, [r3, #12]
 800d10c:	2b02      	cmp	r3, #2
 800d10e:	d00c      	beq.n	800d12a <HAL_SAI_Init+0xc6>
 800d110:	2b02      	cmp	r3, #2
 800d112:	d80d      	bhi.n	800d130 <HAL_SAI_Init+0xcc>
 800d114:	2b00      	cmp	r3, #0
 800d116:	d002      	beq.n	800d11e <HAL_SAI_Init+0xba>
 800d118:	2b01      	cmp	r3, #1
 800d11a:	d003      	beq.n	800d124 <HAL_SAI_Init+0xc0>
 800d11c:	e008      	b.n	800d130 <HAL_SAI_Init+0xcc>
  {
    case SAI_SYNCEXT_DISABLE :
      tmpregisterGCR = 0;
 800d11e:	2300      	movs	r3, #0
 800d120:	627b      	str	r3, [r7, #36]	@ 0x24
      break;
 800d122:	e008      	b.n	800d136 <HAL_SAI_Init+0xd2>
    case SAI_SYNCEXT_OUTBLOCKA_ENABLE :
      tmpregisterGCR = SAI_GCR_SYNCOUT_0;
 800d124:	2310      	movs	r3, #16
 800d126:	627b      	str	r3, [r7, #36]	@ 0x24
      break;
 800d128:	e005      	b.n	800d136 <HAL_SAI_Init+0xd2>
    case SAI_SYNCEXT_OUTBLOCKB_ENABLE :
      tmpregisterGCR = SAI_GCR_SYNCOUT_1;
 800d12a:	2320      	movs	r3, #32
 800d12c:	627b      	str	r3, [r7, #36]	@ 0x24
      break;
 800d12e:	e002      	b.n	800d136 <HAL_SAI_Init+0xd2>
    default:
      tmpregisterGCR = 0;
 800d130:	2300      	movs	r3, #0
 800d132:	627b      	str	r3, [r7, #36]	@ 0x24
      break;
 800d134:	bf00      	nop
  }

  switch (hsai->Init.Synchro)
 800d136:	687b      	ldr	r3, [r7, #4]
 800d138:	689b      	ldr	r3, [r3, #8]
 800d13a:	2b03      	cmp	r3, #3
 800d13c:	d81d      	bhi.n	800d17a <HAL_SAI_Init+0x116>
 800d13e:	a201      	add	r2, pc, #4	@ (adr r2, 800d144 <HAL_SAI_Init+0xe0>)
 800d140:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800d144:	0800d155 	.word	0x0800d155
 800d148:	0800d15b 	.word	0x0800d15b
 800d14c:	0800d163 	.word	0x0800d163
 800d150:	0800d16b 	.word	0x0800d16b
  {
    case SAI_ASYNCHRONOUS :
      syncen_bits = 0;
 800d154:	2300      	movs	r3, #0
 800d156:	61fb      	str	r3, [r7, #28]
      break;
 800d158:	e012      	b.n	800d180 <HAL_SAI_Init+0x11c>
    case SAI_SYNCHRONOUS :
      syncen_bits = SAI_xCR1_SYNCEN_0;
 800d15a:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 800d15e:	61fb      	str	r3, [r7, #28]
      break;
 800d160:	e00e      	b.n	800d180 <HAL_SAI_Init+0x11c>
    case SAI_SYNCHRONOUS_EXT_SAI1 :
      syncen_bits = SAI_xCR1_SYNCEN_1;
 800d162:	f44f 6300 	mov.w	r3, #2048	@ 0x800
 800d166:	61fb      	str	r3, [r7, #28]
      break;
 800d168:	e00a      	b.n	800d180 <HAL_SAI_Init+0x11c>
#if defined(SAI2)
    case SAI_SYNCHRONOUS_EXT_SAI2 :
      syncen_bits = SAI_xCR1_SYNCEN_1;
 800d16a:	f44f 6300 	mov.w	r3, #2048	@ 0x800
 800d16e:	61fb      	str	r3, [r7, #28]
      tmpregisterGCR |= SAI_GCR_SYNCIN_0;
 800d170:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800d172:	f043 0301 	orr.w	r3, r3, #1
 800d176:	627b      	str	r3, [r7, #36]	@ 0x24
      break;
 800d178:	e002      	b.n	800d180 <HAL_SAI_Init+0x11c>
      syncen_bits = SAI_xCR1_SYNCEN_1;
      tmpregisterGCR |= (SAI_GCR_SYNCIN_1 | SAI_GCR_SYNCIN_0);
      break;
#endif /* SAI4 */
    default:
      syncen_bits = 0;
 800d17a:	2300      	movs	r3, #0
 800d17c:	61fb      	str	r3, [r7, #28]
      break;
 800d17e:	bf00      	nop
  }

  /* Set the SAI Block Synchro Configuration */
  SaiBaseAddress->GCR = tmpregisterGCR;
 800d180:	69bb      	ldr	r3, [r7, #24]
 800d182:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800d184:	601a      	str	r2, [r3, #0]

  if (hsai->Init.AudioFrequency != SAI_AUDIO_FREQUENCY_MCKDIV)
 800d186:	687b      	ldr	r3, [r7, #4]
 800d188:	6a1b      	ldr	r3, [r3, #32]
 800d18a:	2b00      	cmp	r3, #0
 800d18c:	f000 808a 	beq.w	800d2a4 <HAL_SAI_Init+0x240>
  {
    uint32_t freq = 0;
 800d190:	2300      	movs	r3, #0
 800d192:	617b      	str	r3, [r7, #20]
    uint32_t tmpval;

    /* In this case, the MCKDIV value is calculated to get AudioFrequency */
    if ((hsai->Instance == SAI1_Block_A) || (hsai->Instance == SAI1_Block_B))
 800d194:	687b      	ldr	r3, [r7, #4]
 800d196:	681b      	ldr	r3, [r3, #0]
 800d198:	4a4f      	ldr	r2, [pc, #316]	@ (800d2d8 <HAL_SAI_Init+0x274>)
 800d19a:	4293      	cmp	r3, r2
 800d19c:	d004      	beq.n	800d1a8 <HAL_SAI_Init+0x144>
 800d19e:	687b      	ldr	r3, [r7, #4]
 800d1a0:	681b      	ldr	r3, [r3, #0]
 800d1a2:	4a4e      	ldr	r2, [pc, #312]	@ (800d2dc <HAL_SAI_Init+0x278>)
 800d1a4:	4293      	cmp	r3, r2
 800d1a6:	d106      	bne.n	800d1b6 <HAL_SAI_Init+0x152>
    {
      freq = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_SAI1);
 800d1a8:	f44f 7080 	mov.w	r0, #256	@ 0x100
 800d1ac:	f04f 0100 	mov.w	r1, #0
 800d1b0:	f7fe fcda 	bl	800bb68 <HAL_RCCEx_GetPeriphCLKFreq>
 800d1b4:	6178      	str	r0, [r7, #20]
    if ((hsai->Instance == SAI2_Block_A) || (hsai->Instance == SAI2_Block_B))
    {
      freq = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_SAI2);
    }
#else
    if (hsai->Instance == SAI2_Block_A)
 800d1b6:	687b      	ldr	r3, [r7, #4]
 800d1b8:	681b      	ldr	r3, [r3, #0]
 800d1ba:	4a4a      	ldr	r2, [pc, #296]	@ (800d2e4 <HAL_SAI_Init+0x280>)
 800d1bc:	4293      	cmp	r3, r2
 800d1be:	d106      	bne.n	800d1ce <HAL_SAI_Init+0x16a>
    {
      freq = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_SAI2A);
 800d1c0:	f44f 7000 	mov.w	r0, #512	@ 0x200
 800d1c4:	f04f 0100 	mov.w	r1, #0
 800d1c8:	f7fe fcce 	bl	800bb68 <HAL_RCCEx_GetPeriphCLKFreq>
 800d1cc:	6178      	str	r0, [r7, #20]
    }
    if (hsai->Instance == SAI2_Block_B)
 800d1ce:	687b      	ldr	r3, [r7, #4]
 800d1d0:	681b      	ldr	r3, [r3, #0]
 800d1d2:	4a45      	ldr	r2, [pc, #276]	@ (800d2e8 <HAL_SAI_Init+0x284>)
 800d1d4:	4293      	cmp	r3, r2
 800d1d6:	d106      	bne.n	800d1e6 <HAL_SAI_Init+0x182>
    {
      freq = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_SAI2B);
 800d1d8:	f44f 6080 	mov.w	r0, #1024	@ 0x400
 800d1dc:	f04f 0100 	mov.w	r1, #0
 800d1e0:	f7fe fcc2 	bl	800bb68 <HAL_RCCEx_GetPeriphCLKFreq>
 800d1e4:	6178      	str	r0, [r7, #20]
    /* Configure Master Clock Divider using the following formula :
       - If NODIV = 1 :
         MCKDIV[5:0] = SAI_CK_x / (FS * (FRL + 1))
       - If NODIV = 0 :
         MCKDIV[5:0] = SAI_CK_x / (FS * (OSR + 1) * 256) */
    if (hsai->Init.NoDivider == SAI_MASTERDIVIDER_DISABLE)
 800d1e6:	687b      	ldr	r3, [r7, #4]
 800d1e8:	699b      	ldr	r3, [r3, #24]
 800d1ea:	f5b3 2f00 	cmp.w	r3, #524288	@ 0x80000
 800d1ee:	d120      	bne.n	800d232 <HAL_SAI_Init+0x1ce>
    {
      /* NODIV = 1 */
      uint32_t tmpframelength;

      if (hsai->Init.Protocol == SAI_SPDIF_PROTOCOL)
 800d1f0:	687b      	ldr	r3, [r7, #4]
 800d1f2:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800d1f4:	2b04      	cmp	r3, #4
 800d1f6:	d102      	bne.n	800d1fe <HAL_SAI_Init+0x19a>
      {
        /* For SPDIF protocol, frame length is set by hardware to 64 */
        tmpframelength = SAI_SPDIF_FRAME_LENGTH;
 800d1f8:	2340      	movs	r3, #64	@ 0x40
 800d1fa:	60fb      	str	r3, [r7, #12]
 800d1fc:	e00a      	b.n	800d214 <HAL_SAI_Init+0x1b0>
      }
      else if (hsai->Init.Protocol == SAI_AC97_PROTOCOL)
 800d1fe:	687b      	ldr	r3, [r7, #4]
 800d200:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800d202:	2b08      	cmp	r3, #8
 800d204:	d103      	bne.n	800d20e <HAL_SAI_Init+0x1aa>
      {
        /* For AC97 protocol, frame length is set by hardware to 256 */
        tmpframelength = SAI_AC97_FRAME_LENGTH;
 800d206:	f44f 7380 	mov.w	r3, #256	@ 0x100
 800d20a:	60fb      	str	r3, [r7, #12]
 800d20c:	e002      	b.n	800d214 <HAL_SAI_Init+0x1b0>
      }
      else
      {
        /* For free protocol, frame length is set by user */
        tmpframelength = hsai->FrameInit.FrameLength;
 800d20e:	687b      	ldr	r3, [r7, #4]
 800d210:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 800d212:	60fb      	str	r3, [r7, #12]
      }

      /* (freq x 10) to keep Significant digits */
      tmpval = (freq * 10U) / (hsai->Init.AudioFrequency * tmpframelength);
 800d214:	697a      	ldr	r2, [r7, #20]
 800d216:	4613      	mov	r3, r2
 800d218:	009b      	lsls	r3, r3, #2
 800d21a:	4413      	add	r3, r2
 800d21c:	005b      	lsls	r3, r3, #1
 800d21e:	4619      	mov	r1, r3
 800d220:	687b      	ldr	r3, [r7, #4]
 800d222:	6a1b      	ldr	r3, [r3, #32]
 800d224:	68fa      	ldr	r2, [r7, #12]
 800d226:	fb02 f303 	mul.w	r3, r2, r3
 800d22a:	fbb1 f3f3 	udiv	r3, r1, r3
 800d22e:	613b      	str	r3, [r7, #16]
 800d230:	e017      	b.n	800d262 <HAL_SAI_Init+0x1fe>
    }
    else
    {
      /* NODIV = 0 */
      uint32_t tmposr;
      tmposr = (hsai->Init.MckOverSampling == SAI_MCK_OVERSAMPLING_ENABLE) ? 2U : 1U;
 800d232:	687b      	ldr	r3, [r7, #4]
 800d234:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800d236:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
 800d23a:	d101      	bne.n	800d240 <HAL_SAI_Init+0x1dc>
 800d23c:	2302      	movs	r3, #2
 800d23e:	e000      	b.n	800d242 <HAL_SAI_Init+0x1de>
 800d240:	2301      	movs	r3, #1
 800d242:	60bb      	str	r3, [r7, #8]
      /* (freq x 10) to keep Significant digits */
      tmpval = (freq * 10U) / (hsai->Init.AudioFrequency * tmposr * 256U);
 800d244:	697a      	ldr	r2, [r7, #20]
 800d246:	4613      	mov	r3, r2
 800d248:	009b      	lsls	r3, r3, #2
 800d24a:	4413      	add	r3, r2
 800d24c:	005b      	lsls	r3, r3, #1
 800d24e:	4619      	mov	r1, r3
 800d250:	687b      	ldr	r3, [r7, #4]
 800d252:	6a1b      	ldr	r3, [r3, #32]
 800d254:	68ba      	ldr	r2, [r7, #8]
 800d256:	fb02 f303 	mul.w	r3, r2, r3
 800d25a:	021b      	lsls	r3, r3, #8
 800d25c:	fbb1 f3f3 	udiv	r3, r1, r3
 800d260:	613b      	str	r3, [r7, #16]
    }
    hsai->Init.Mckdiv = tmpval / 10U;
 800d262:	693b      	ldr	r3, [r7, #16]
 800d264:	4a22      	ldr	r2, [pc, #136]	@ (800d2f0 <HAL_SAI_Init+0x28c>)
 800d266:	fba2 2303 	umull	r2, r3, r2, r3
 800d26a:	08da      	lsrs	r2, r3, #3
 800d26c:	687b      	ldr	r3, [r7, #4]
 800d26e:	625a      	str	r2, [r3, #36]	@ 0x24

    /* Round result to the nearest integer */
    if ((tmpval % 10U) > 8U)
 800d270:	6939      	ldr	r1, [r7, #16]
 800d272:	4b1f      	ldr	r3, [pc, #124]	@ (800d2f0 <HAL_SAI_Init+0x28c>)
 800d274:	fba3 2301 	umull	r2, r3, r3, r1
 800d278:	08da      	lsrs	r2, r3, #3
 800d27a:	4613      	mov	r3, r2
 800d27c:	009b      	lsls	r3, r3, #2
 800d27e:	4413      	add	r3, r2
 800d280:	005b      	lsls	r3, r3, #1
 800d282:	1aca      	subs	r2, r1, r3
 800d284:	2a08      	cmp	r2, #8
 800d286:	d904      	bls.n	800d292 <HAL_SAI_Init+0x22e>
    {
      hsai->Init.Mckdiv += 1U;
 800d288:	687b      	ldr	r3, [r7, #4]
 800d28a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800d28c:	1c5a      	adds	r2, r3, #1
 800d28e:	687b      	ldr	r3, [r7, #4]
 800d290:	625a      	str	r2, [r3, #36]	@ 0x24
    }

    /* For SPDIF protocol, SAI shall provide a bit clock twice faster the symbol-rate */
    if (hsai->Init.Protocol == SAI_SPDIF_PROTOCOL)
 800d292:	687b      	ldr	r3, [r7, #4]
 800d294:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800d296:	2b04      	cmp	r3, #4
 800d298:	d104      	bne.n	800d2a4 <HAL_SAI_Init+0x240>
    {
      hsai->Init.Mckdiv = hsai->Init.Mckdiv >> 1;
 800d29a:	687b      	ldr	r3, [r7, #4]
 800d29c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800d29e:	085a      	lsrs	r2, r3, #1
 800d2a0:	687b      	ldr	r3, [r7, #4]
 800d2a2:	625a      	str	r2, [r3, #36]	@ 0x24

  /* Check the SAI Block master clock divider parameter */
  assert_param(IS_SAI_BLOCK_MASTER_DIVIDER(hsai->Init.Mckdiv));

  /* Compute CKSTR bits of SAI CR1 according ClockStrobing and AudioMode */
  if ((hsai->Init.AudioMode == SAI_MODEMASTER_TX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
 800d2a4:	687b      	ldr	r3, [r7, #4]
 800d2a6:	685b      	ldr	r3, [r3, #4]
 800d2a8:	2b00      	cmp	r3, #0
 800d2aa:	d003      	beq.n	800d2b4 <HAL_SAI_Init+0x250>
 800d2ac:	687b      	ldr	r3, [r7, #4]
 800d2ae:	685b      	ldr	r3, [r3, #4]
 800d2b0:	2b02      	cmp	r3, #2
 800d2b2:	d109      	bne.n	800d2c8 <HAL_SAI_Init+0x264>
  {
    /* Transmit */
    ckstr_bits = (hsai->Init.ClockStrobing == SAI_CLOCKSTROBING_RISINGEDGE) ? 0U : SAI_xCR1_CKSTR;
 800d2b4:	687b      	ldr	r3, [r7, #4]
 800d2b6:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800d2b8:	2b01      	cmp	r3, #1
 800d2ba:	d101      	bne.n	800d2c0 <HAL_SAI_Init+0x25c>
 800d2bc:	2300      	movs	r3, #0
 800d2be:	e001      	b.n	800d2c4 <HAL_SAI_Init+0x260>
 800d2c0:	f44f 7300 	mov.w	r3, #512	@ 0x200
 800d2c4:	623b      	str	r3, [r7, #32]
 800d2c6:	e017      	b.n	800d2f8 <HAL_SAI_Init+0x294>
  }
  else
  {
    /* Receive */
    ckstr_bits = (hsai->Init.ClockStrobing == SAI_CLOCKSTROBING_RISINGEDGE) ? SAI_xCR1_CKSTR : 0U;
 800d2c8:	687b      	ldr	r3, [r7, #4]
 800d2ca:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800d2cc:	2b01      	cmp	r3, #1
 800d2ce:	d111      	bne.n	800d2f4 <HAL_SAI_Init+0x290>
 800d2d0:	f44f 7300 	mov.w	r3, #512	@ 0x200
 800d2d4:	e00f      	b.n	800d2f6 <HAL_SAI_Init+0x292>
 800d2d6:	bf00      	nop
 800d2d8:	40015804 	.word	0x40015804
 800d2dc:	40015824 	.word	0x40015824
 800d2e0:	40015800 	.word	0x40015800
 800d2e4:	40015c04 	.word	0x40015c04
 800d2e8:	40015c24 	.word	0x40015c24
 800d2ec:	40015c00 	.word	0x40015c00
 800d2f0:	cccccccd 	.word	0xcccccccd
 800d2f4:	2300      	movs	r3, #0
 800d2f6:	623b      	str	r3, [r7, #32]
                            hsai->Init.MonoStereoMode | hsai->Init.OutputDrive |   \
                            hsai->Init.NoDivider | (hsai->Init.Mckdiv << 20) |     \
                            hsai->Init.MckOverSampling);
  }
#else /* SAI_VER_V2_1*/
  hsai->Instance->CR1 &= ~(SAI_xCR1_MODE | SAI_xCR1_PRTCFG |  SAI_xCR1_DS |      \
 800d2f8:	687b      	ldr	r3, [r7, #4]
 800d2fa:	681b      	ldr	r3, [r3, #0]
 800d2fc:	6819      	ldr	r1, [r3, #0]
 800d2fe:	687b      	ldr	r3, [r7, #4]
 800d300:	681a      	ldr	r2, [r3, #0]
 800d302:	4b58      	ldr	r3, [pc, #352]	@ (800d464 <HAL_SAI_Init+0x400>)
 800d304:	400b      	ands	r3, r1
 800d306:	6013      	str	r3, [r2, #0]
                           SAI_xCR1_LSBFIRST | SAI_xCR1_CKSTR | SAI_xCR1_SYNCEN | \
                           SAI_xCR1_MONO | SAI_xCR1_OUTDRIV  | SAI_xCR1_DMAEN |  \
                           SAI_xCR1_NODIV | SAI_xCR1_MCKDIV | SAI_xCR1_OSR |     \
                           SAI_xCR1_MCKEN);

  hsai->Instance->CR1 |= (hsai->Init.AudioMode | hsai->Init.Protocol |           \
 800d308:	687b      	ldr	r3, [r7, #4]
 800d30a:	681b      	ldr	r3, [r3, #0]
 800d30c:	6819      	ldr	r1, [r3, #0]
 800d30e:	687b      	ldr	r3, [r7, #4]
 800d310:	685a      	ldr	r2, [r3, #4]
 800d312:	687b      	ldr	r3, [r7, #4]
 800d314:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800d316:	431a      	orrs	r2, r3
                          hsai->Init.DataSize | hsai->Init.FirstBit  |           \
 800d318:	687b      	ldr	r3, [r7, #4]
 800d31a:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
  hsai->Instance->CR1 |= (hsai->Init.AudioMode | hsai->Init.Protocol |           \
 800d31c:	431a      	orrs	r2, r3
                          hsai->Init.DataSize | hsai->Init.FirstBit  |           \
 800d31e:	687b      	ldr	r3, [r7, #4]
 800d320:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 800d322:	431a      	orrs	r2, r3
 800d324:	6a3b      	ldr	r3, [r7, #32]
 800d326:	431a      	orrs	r2, r3
                          ckstr_bits | syncen_bits |                             \
 800d328:	69fb      	ldr	r3, [r7, #28]
 800d32a:	431a      	orrs	r2, r3
                          hsai->Init.MonoStereoMode | hsai->Init.OutputDrive |   \
 800d32c:	687b      	ldr	r3, [r7, #4]
 800d32e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
                          ckstr_bits | syncen_bits |                             \
 800d330:	431a      	orrs	r2, r3
                          hsai->Init.MonoStereoMode | hsai->Init.OutputDrive |   \
 800d332:	687b      	ldr	r3, [r7, #4]
 800d334:	695b      	ldr	r3, [r3, #20]
 800d336:	431a      	orrs	r2, r3
                          hsai->Init.NoDivider | (hsai->Init.Mckdiv << 20) |     \
 800d338:	687b      	ldr	r3, [r7, #4]
 800d33a:	699b      	ldr	r3, [r3, #24]
                          hsai->Init.MonoStereoMode | hsai->Init.OutputDrive |   \
 800d33c:	431a      	orrs	r2, r3
                          hsai->Init.NoDivider | (hsai->Init.Mckdiv << 20) |     \
 800d33e:	687b      	ldr	r3, [r7, #4]
 800d340:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800d342:	051b      	lsls	r3, r3, #20
 800d344:	431a      	orrs	r2, r3
                          hsai->Init.MckOverSampling | hsai->Init.MckOutput);
 800d346:	687b      	ldr	r3, [r7, #4]
 800d348:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
                          hsai->Init.NoDivider | (hsai->Init.Mckdiv << 20) |     \
 800d34a:	431a      	orrs	r2, r3
                          hsai->Init.MckOverSampling | hsai->Init.MckOutput);
 800d34c:	687b      	ldr	r3, [r7, #4]
 800d34e:	691b      	ldr	r3, [r3, #16]
 800d350:	431a      	orrs	r2, r3
  hsai->Instance->CR1 |= (hsai->Init.AudioMode | hsai->Init.Protocol |           \
 800d352:	687b      	ldr	r3, [r7, #4]
 800d354:	681b      	ldr	r3, [r3, #0]
 800d356:	430a      	orrs	r2, r1
 800d358:	601a      	str	r2, [r3, #0]
#endif /* SAI_VER_V2_X */

  /* SAI CR2 Configuration */
  hsai->Instance->CR2 &= ~(SAI_xCR2_FTH | SAI_xCR2_FFLUSH | SAI_xCR2_COMP | SAI_xCR2_CPL);
 800d35a:	687b      	ldr	r3, [r7, #4]
 800d35c:	681b      	ldr	r3, [r3, #0]
 800d35e:	6859      	ldr	r1, [r3, #4]
 800d360:	687b      	ldr	r3, [r7, #4]
 800d362:	681a      	ldr	r2, [r3, #0]
 800d364:	4b40      	ldr	r3, [pc, #256]	@ (800d468 <HAL_SAI_Init+0x404>)
 800d366:	400b      	ands	r3, r1
 800d368:	6053      	str	r3, [r2, #4]
  hsai->Instance->CR2 |= (hsai->Init.FIFOThreshold | hsai->Init.CompandingMode | hsai->Init.TriState);
 800d36a:	687b      	ldr	r3, [r7, #4]
 800d36c:	681b      	ldr	r3, [r3, #0]
 800d36e:	6859      	ldr	r1, [r3, #4]
 800d370:	687b      	ldr	r3, [r7, #4]
 800d372:	69da      	ldr	r2, [r3, #28]
 800d374:	687b      	ldr	r3, [r7, #4]
 800d376:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800d378:	431a      	orrs	r2, r3
 800d37a:	687b      	ldr	r3, [r7, #4]
 800d37c:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 800d37e:	431a      	orrs	r2, r3
 800d380:	687b      	ldr	r3, [r7, #4]
 800d382:	681b      	ldr	r3, [r3, #0]
 800d384:	430a      	orrs	r2, r1
 800d386:	605a      	str	r2, [r3, #4]

  /* SAI Frame Configuration -----------------------------------------*/
  hsai->Instance->FRCR &= (~(SAI_xFRCR_FRL | SAI_xFRCR_FSALL | SAI_xFRCR_FSDEF | \
 800d388:	687b      	ldr	r3, [r7, #4]
 800d38a:	681b      	ldr	r3, [r3, #0]
 800d38c:	6899      	ldr	r1, [r3, #8]
 800d38e:	687b      	ldr	r3, [r7, #4]
 800d390:	681a      	ldr	r2, [r3, #0]
 800d392:	4b36      	ldr	r3, [pc, #216]	@ (800d46c <HAL_SAI_Init+0x408>)
 800d394:	400b      	ands	r3, r1
 800d396:	6093      	str	r3, [r2, #8]
                             SAI_xFRCR_FSPOL | SAI_xFRCR_FSOFF));
  hsai->Instance->FRCR |= ((hsai->FrameInit.FrameLength - 1U) |
 800d398:	687b      	ldr	r3, [r7, #4]
 800d39a:	681b      	ldr	r3, [r3, #0]
 800d39c:	6899      	ldr	r1, [r3, #8]
 800d39e:	687b      	ldr	r3, [r7, #4]
 800d3a0:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 800d3a2:	1e5a      	subs	r2, r3, #1
                           hsai->FrameInit.FSOffset |
 800d3a4:	687b      	ldr	r3, [r7, #4]
 800d3a6:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
  hsai->Instance->FRCR |= ((hsai->FrameInit.FrameLength - 1U) |
 800d3a8:	431a      	orrs	r2, r3
                           hsai->FrameInit.FSDefinition |
 800d3aa:	687b      	ldr	r3, [r7, #4]
 800d3ac:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
                           hsai->FrameInit.FSOffset |
 800d3ae:	431a      	orrs	r2, r3
                           hsai->FrameInit.FSPolarity   |
 800d3b0:	687b      	ldr	r3, [r7, #4]
 800d3b2:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
                           hsai->FrameInit.FSDefinition |
 800d3b4:	431a      	orrs	r2, r3
                           ((hsai->FrameInit.ActiveFrameLength - 1U) << 8));
 800d3b6:	687b      	ldr	r3, [r7, #4]
 800d3b8:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 800d3ba:	3b01      	subs	r3, #1
 800d3bc:	021b      	lsls	r3, r3, #8
                           hsai->FrameInit.FSPolarity   |
 800d3be:	431a      	orrs	r2, r3
  hsai->Instance->FRCR |= ((hsai->FrameInit.FrameLength - 1U) |
 800d3c0:	687b      	ldr	r3, [r7, #4]
 800d3c2:	681b      	ldr	r3, [r3, #0]
 800d3c4:	430a      	orrs	r2, r1
 800d3c6:	609a      	str	r2, [r3, #8]

  /* SAI Block_x SLOT Configuration ------------------------------------------*/
  /* This register has no meaning in AC 97 and SPDIF audio protocol */
  hsai->Instance->SLOTR &= (~(SAI_xSLOTR_FBOFF | SAI_xSLOTR_SLOTSZ |  \
 800d3c8:	687b      	ldr	r3, [r7, #4]
 800d3ca:	681b      	ldr	r3, [r3, #0]
 800d3cc:	68d9      	ldr	r1, [r3, #12]
 800d3ce:	687b      	ldr	r3, [r7, #4]
 800d3d0:	681a      	ldr	r2, [r3, #0]
 800d3d2:	f24f 0320 	movw	r3, #61472	@ 0xf020
 800d3d6:	400b      	ands	r3, r1
 800d3d8:	60d3      	str	r3, [r2, #12]
                              SAI_xSLOTR_NBSLOT | SAI_xSLOTR_SLOTEN));

  hsai->Instance->SLOTR |= hsai->SlotInit.FirstBitOffset | hsai->SlotInit.SlotSize | \
 800d3da:	687b      	ldr	r3, [r7, #4]
 800d3dc:	681b      	ldr	r3, [r3, #0]
 800d3de:	68d9      	ldr	r1, [r3, #12]
 800d3e0:	687b      	ldr	r3, [r7, #4]
 800d3e2:	6e9a      	ldr	r2, [r3, #104]	@ 0x68
 800d3e4:	687b      	ldr	r3, [r7, #4]
 800d3e6:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 800d3e8:	431a      	orrs	r2, r3
                           (hsai->SlotInit.SlotActive << 16) | ((hsai->SlotInit.SlotNumber - 1U) <<  8);
 800d3ea:	687b      	ldr	r3, [r7, #4]
 800d3ec:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
 800d3ee:	041b      	lsls	r3, r3, #16
  hsai->Instance->SLOTR |= hsai->SlotInit.FirstBitOffset | hsai->SlotInit.SlotSize | \
 800d3f0:	431a      	orrs	r2, r3
                           (hsai->SlotInit.SlotActive << 16) | ((hsai->SlotInit.SlotNumber - 1U) <<  8);
 800d3f2:	687b      	ldr	r3, [r7, #4]
 800d3f4:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 800d3f6:	3b01      	subs	r3, #1
 800d3f8:	021b      	lsls	r3, r3, #8
 800d3fa:	431a      	orrs	r2, r3
  hsai->Instance->SLOTR |= hsai->SlotInit.FirstBitOffset | hsai->SlotInit.SlotSize | \
 800d3fc:	687b      	ldr	r3, [r7, #4]
 800d3fe:	681b      	ldr	r3, [r3, #0]
 800d400:	430a      	orrs	r2, r1
 800d402:	60da      	str	r2, [r3, #12]

  /* SAI PDM Configuration ---------------------------------------------------*/
#if defined(SAI4)
  if ((hsai->Instance == SAI1_Block_A) || (hsai->Instance == SAI4_Block_A))
#else
  if (hsai->Instance == SAI1_Block_A)
 800d404:	687b      	ldr	r3, [r7, #4]
 800d406:	681b      	ldr	r3, [r3, #0]
 800d408:	4a19      	ldr	r2, [pc, #100]	@ (800d470 <HAL_SAI_Init+0x40c>)
 800d40a:	4293      	cmp	r3, r2
 800d40c:	d119      	bne.n	800d442 <HAL_SAI_Init+0x3de>
#endif /* SAI4 */
  {
    /* Disable PDM interface */
    SaiBaseAddress->PDMCR &= ~(SAI_PDMCR_PDMEN);
 800d40e:	69bb      	ldr	r3, [r7, #24]
 800d410:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800d412:	f023 0201 	bic.w	r2, r3, #1
 800d416:	69bb      	ldr	r3, [r7, #24]
 800d418:	645a      	str	r2, [r3, #68]	@ 0x44
    if (hsai->Init.PdmInit.Activation == ENABLE)
 800d41a:	687b      	ldr	r3, [r7, #4]
 800d41c:	f893 3038 	ldrb.w	r3, [r3, #56]	@ 0x38
 800d420:	2b01      	cmp	r3, #1
 800d422:	d10e      	bne.n	800d442 <HAL_SAI_Init+0x3de>
    {
      /* Configure and enable PDM interface */
      SaiBaseAddress->PDMCR = (hsai->Init.PdmInit.ClockEnable |
 800d424:	687b      	ldr	r3, [r7, #4]
 800d426:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
                               ((hsai->Init.PdmInit.MicPairsNbr - 1U) << SAI_PDMCR_MICNBR_Pos));
 800d428:	687b      	ldr	r3, [r7, #4]
 800d42a:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 800d42c:	3b01      	subs	r3, #1
 800d42e:	011b      	lsls	r3, r3, #4
      SaiBaseAddress->PDMCR = (hsai->Init.PdmInit.ClockEnable |
 800d430:	431a      	orrs	r2, r3
 800d432:	69bb      	ldr	r3, [r7, #24]
 800d434:	645a      	str	r2, [r3, #68]	@ 0x44
      SaiBaseAddress->PDMCR |= SAI_PDMCR_PDMEN;
 800d436:	69bb      	ldr	r3, [r7, #24]
 800d438:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800d43a:	f043 0201 	orr.w	r2, r3, #1
 800d43e:	69bb      	ldr	r3, [r7, #24]
 800d440:	645a      	str	r2, [r3, #68]	@ 0x44
    }
  }

  /* Initialize the error code */
  hsai->ErrorCode = HAL_SAI_ERROR_NONE;
 800d442:	687b      	ldr	r3, [r7, #4]
 800d444:	2200      	movs	r2, #0
 800d446:	f8c3 2094 	str.w	r2, [r3, #148]	@ 0x94

  /* Initialize the SAI state */
  hsai->State = HAL_SAI_STATE_READY;
 800d44a:	687b      	ldr	r3, [r7, #4]
 800d44c:	2201      	movs	r2, #1
 800d44e:	f883 2091 	strb.w	r2, [r3, #145]	@ 0x91

  /* Release Lock */
  __HAL_UNLOCK(hsai);
 800d452:	687b      	ldr	r3, [r7, #4]
 800d454:	2200      	movs	r2, #0
 800d456:	f883 2090 	strb.w	r2, [r3, #144]	@ 0x90

  return HAL_OK;
 800d45a:	2300      	movs	r3, #0
}
 800d45c:	4618      	mov	r0, r3
 800d45e:	3728      	adds	r7, #40	@ 0x28
 800d460:	46bd      	mov	sp, r7
 800d462:	bd80      	pop	{r7, pc}
 800d464:	f005c010 	.word	0xf005c010
 800d468:	ffff1ff0 	.word	0xffff1ff0
 800d46c:	fff88000 	.word	0xfff88000
 800d470:	40015804 	.word	0x40015804

0800d474 <HAL_SAI_Transmit_DMA>:
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SAI_Transmit_DMA(SAI_HandleTypeDef *hsai, uint8_t *pData, uint16_t Size)
{
 800d474:	b580      	push	{r7, lr}
 800d476:	b086      	sub	sp, #24
 800d478:	af00      	add	r7, sp, #0
 800d47a:	60f8      	str	r0, [r7, #12]
 800d47c:	60b9      	str	r1, [r7, #8]
 800d47e:	4613      	mov	r3, r2
 800d480:	80fb      	strh	r3, [r7, #6]
  uint32_t tickstart = HAL_GetTick();
 800d482:	f7f5 fa6d 	bl	8002960 <HAL_GetTick>
 800d486:	6178      	str	r0, [r7, #20]

  if ((pData == NULL) || (Size == 0U))
 800d488:	68bb      	ldr	r3, [r7, #8]
 800d48a:	2b00      	cmp	r3, #0
 800d48c:	d002      	beq.n	800d494 <HAL_SAI_Transmit_DMA+0x20>
 800d48e:	88fb      	ldrh	r3, [r7, #6]
 800d490:	2b00      	cmp	r3, #0
 800d492:	d101      	bne.n	800d498 <HAL_SAI_Transmit_DMA+0x24>
  {
    return  HAL_ERROR;
 800d494:	2301      	movs	r3, #1
 800d496:	e098      	b.n	800d5ca <HAL_SAI_Transmit_DMA+0x156>
  }

  if (hsai->State == HAL_SAI_STATE_READY)
 800d498:	68fb      	ldr	r3, [r7, #12]
 800d49a:	f893 3091 	ldrb.w	r3, [r3, #145]	@ 0x91
 800d49e:	b2db      	uxtb	r3, r3
 800d4a0:	2b01      	cmp	r3, #1
 800d4a2:	f040 8091 	bne.w	800d5c8 <HAL_SAI_Transmit_DMA+0x154>
  {
    /* Process Locked */
    __HAL_LOCK(hsai);
 800d4a6:	68fb      	ldr	r3, [r7, #12]
 800d4a8:	f893 3090 	ldrb.w	r3, [r3, #144]	@ 0x90
 800d4ac:	2b01      	cmp	r3, #1
 800d4ae:	d101      	bne.n	800d4b4 <HAL_SAI_Transmit_DMA+0x40>
 800d4b0:	2302      	movs	r3, #2
 800d4b2:	e08a      	b.n	800d5ca <HAL_SAI_Transmit_DMA+0x156>
 800d4b4:	68fb      	ldr	r3, [r7, #12]
 800d4b6:	2201      	movs	r2, #1
 800d4b8:	f883 2090 	strb.w	r2, [r3, #144]	@ 0x90

    hsai->pBuffPtr = pData;
 800d4bc:	68fb      	ldr	r3, [r7, #12]
 800d4be:	68ba      	ldr	r2, [r7, #8]
 800d4c0:	679a      	str	r2, [r3, #120]	@ 0x78
    hsai->XferSize = Size;
 800d4c2:	68fb      	ldr	r3, [r7, #12]
 800d4c4:	88fa      	ldrh	r2, [r7, #6]
 800d4c6:	f8a3 207c 	strh.w	r2, [r3, #124]	@ 0x7c
    hsai->XferCount = Size;
 800d4ca:	68fb      	ldr	r3, [r7, #12]
 800d4cc:	88fa      	ldrh	r2, [r7, #6]
 800d4ce:	f8a3 207e 	strh.w	r2, [r3, #126]	@ 0x7e
    hsai->ErrorCode = HAL_SAI_ERROR_NONE;
 800d4d2:	68fb      	ldr	r3, [r7, #12]
 800d4d4:	2200      	movs	r2, #0
 800d4d6:	f8c3 2094 	str.w	r2, [r3, #148]	@ 0x94
    hsai->State = HAL_SAI_STATE_BUSY_TX;
 800d4da:	68fb      	ldr	r3, [r7, #12]
 800d4dc:	2212      	movs	r2, #18
 800d4de:	f883 2091 	strb.w	r2, [r3, #145]	@ 0x91

    /* Set the SAI Tx DMA Half transfer complete callback */
    hsai->hdmatx->XferHalfCpltCallback = SAI_DMATxHalfCplt;
 800d4e2:	68fb      	ldr	r3, [r7, #12]
 800d4e4:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
 800d4e8:	4a3a      	ldr	r2, [pc, #232]	@ (800d5d4 <HAL_SAI_Transmit_DMA+0x160>)
 800d4ea:	641a      	str	r2, [r3, #64]	@ 0x40

    /* Set the SAI TxDMA transfer complete callback */
    hsai->hdmatx->XferCpltCallback = SAI_DMATxCplt;
 800d4ec:	68fb      	ldr	r3, [r7, #12]
 800d4ee:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
 800d4f2:	4a39      	ldr	r2, [pc, #228]	@ (800d5d8 <HAL_SAI_Transmit_DMA+0x164>)
 800d4f4:	63da      	str	r2, [r3, #60]	@ 0x3c

    /* Set the DMA error callback */
    hsai->hdmatx->XferErrorCallback = SAI_DMAError;
 800d4f6:	68fb      	ldr	r3, [r7, #12]
 800d4f8:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
 800d4fc:	4a37      	ldr	r2, [pc, #220]	@ (800d5dc <HAL_SAI_Transmit_DMA+0x168>)
 800d4fe:	64da      	str	r2, [r3, #76]	@ 0x4c

    /* Set the DMA Tx abort callback */
    hsai->hdmatx->XferAbortCallback = NULL;
 800d500:	68fb      	ldr	r3, [r7, #12]
 800d502:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
 800d506:	2200      	movs	r2, #0
 800d508:	651a      	str	r2, [r3, #80]	@ 0x50

    /* Enable the Tx DMA Stream */
    if (HAL_DMA_Start_IT(hsai->hdmatx, (uint32_t)hsai->pBuffPtr, (uint32_t)&hsai->Instance->DR, hsai->XferSize) != HAL_OK)
 800d50a:	68fb      	ldr	r3, [r7, #12]
 800d50c:	f8d3 0080 	ldr.w	r0, [r3, #128]	@ 0x80
 800d510:	68fb      	ldr	r3, [r7, #12]
 800d512:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 800d514:	4619      	mov	r1, r3
 800d516:	68fb      	ldr	r3, [r7, #12]
 800d518:	681b      	ldr	r3, [r3, #0]
 800d51a:	331c      	adds	r3, #28
 800d51c:	461a      	mov	r2, r3
 800d51e:	68fb      	ldr	r3, [r7, #12]
 800d520:	f8b3 307c 	ldrh.w	r3, [r3, #124]	@ 0x7c
 800d524:	f7f7 fa14 	bl	8004950 <HAL_DMA_Start_IT>
 800d528:	4603      	mov	r3, r0
 800d52a:	2b00      	cmp	r3, #0
 800d52c:	d005      	beq.n	800d53a <HAL_SAI_Transmit_DMA+0xc6>
    {
      __HAL_UNLOCK(hsai);
 800d52e:	68fb      	ldr	r3, [r7, #12]
 800d530:	2200      	movs	r2, #0
 800d532:	f883 2090 	strb.w	r2, [r3, #144]	@ 0x90
      return  HAL_ERROR;
 800d536:	2301      	movs	r3, #1
 800d538:	e047      	b.n	800d5ca <HAL_SAI_Transmit_DMA+0x156>
    }

    /* Enable the interrupts for error handling */
    __HAL_SAI_ENABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_DMA));
 800d53a:	2100      	movs	r1, #0
 800d53c:	68f8      	ldr	r0, [r7, #12]
 800d53e:	f000 fa35 	bl	800d9ac <SAI_InterruptFlag>
 800d542:	4601      	mov	r1, r0
 800d544:	68fb      	ldr	r3, [r7, #12]
 800d546:	681b      	ldr	r3, [r3, #0]
 800d548:	691a      	ldr	r2, [r3, #16]
 800d54a:	68fb      	ldr	r3, [r7, #12]
 800d54c:	681b      	ldr	r3, [r3, #0]
 800d54e:	430a      	orrs	r2, r1
 800d550:	611a      	str	r2, [r3, #16]

    /* Enable SAI Tx DMA Request */
    hsai->Instance->CR1 |= SAI_xCR1_DMAEN;
 800d552:	68fb      	ldr	r3, [r7, #12]
 800d554:	681b      	ldr	r3, [r3, #0]
 800d556:	681a      	ldr	r2, [r3, #0]
 800d558:	68fb      	ldr	r3, [r7, #12]
 800d55a:	681b      	ldr	r3, [r3, #0]
 800d55c:	f442 3200 	orr.w	r2, r2, #131072	@ 0x20000
 800d560:	601a      	str	r2, [r3, #0]

    /* Wait until FIFO is not empty */
    while ((hsai->Instance->SR & SAI_xSR_FLVL) == SAI_FIFOSTATUS_EMPTY)
 800d562:	e015      	b.n	800d590 <HAL_SAI_Transmit_DMA+0x11c>
    {
      /* Check for the Timeout */
      if ((HAL_GetTick() - tickstart) > SAI_LONG_TIMEOUT)
 800d564:	f7f5 f9fc 	bl	8002960 <HAL_GetTick>
 800d568:	4602      	mov	r2, r0
 800d56a:	697b      	ldr	r3, [r7, #20]
 800d56c:	1ad3      	subs	r3, r2, r3
 800d56e:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
 800d572:	d90d      	bls.n	800d590 <HAL_SAI_Transmit_DMA+0x11c>
      {
        /* Update error code */
        hsai->ErrorCode |= HAL_SAI_ERROR_TIMEOUT;
 800d574:	68fb      	ldr	r3, [r7, #12]
 800d576:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 800d57a:	f043 0240 	orr.w	r2, r3, #64	@ 0x40
 800d57e:	68fb      	ldr	r3, [r7, #12]
 800d580:	f8c3 2094 	str.w	r2, [r3, #148]	@ 0x94

        /* Process Unlocked */
        __HAL_UNLOCK(hsai);
 800d584:	68fb      	ldr	r3, [r7, #12]
 800d586:	2200      	movs	r2, #0
 800d588:	f883 2090 	strb.w	r2, [r3, #144]	@ 0x90

        return HAL_TIMEOUT;
 800d58c:	2303      	movs	r3, #3
 800d58e:	e01c      	b.n	800d5ca <HAL_SAI_Transmit_DMA+0x156>
    while ((hsai->Instance->SR & SAI_xSR_FLVL) == SAI_FIFOSTATUS_EMPTY)
 800d590:	68fb      	ldr	r3, [r7, #12]
 800d592:	681b      	ldr	r3, [r3, #0]
 800d594:	695b      	ldr	r3, [r3, #20]
 800d596:	f403 23e0 	and.w	r3, r3, #458752	@ 0x70000
 800d59a:	2b00      	cmp	r3, #0
 800d59c:	d0e2      	beq.n	800d564 <HAL_SAI_Transmit_DMA+0xf0>
      }
    }

    /* Check if the SAI is already enabled */
    if ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) == 0U)
 800d59e:	68fb      	ldr	r3, [r7, #12]
 800d5a0:	681b      	ldr	r3, [r3, #0]
 800d5a2:	681b      	ldr	r3, [r3, #0]
 800d5a4:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 800d5a8:	2b00      	cmp	r3, #0
 800d5aa:	d107      	bne.n	800d5bc <HAL_SAI_Transmit_DMA+0x148>
    {
      /* Enable SAI peripheral */
      __HAL_SAI_ENABLE(hsai);
 800d5ac:	68fb      	ldr	r3, [r7, #12]
 800d5ae:	681b      	ldr	r3, [r3, #0]
 800d5b0:	681a      	ldr	r2, [r3, #0]
 800d5b2:	68fb      	ldr	r3, [r7, #12]
 800d5b4:	681b      	ldr	r3, [r3, #0]
 800d5b6:	f442 3280 	orr.w	r2, r2, #65536	@ 0x10000
 800d5ba:	601a      	str	r2, [r3, #0]
    }

    /* Process Unlocked */
    __HAL_UNLOCK(hsai);
 800d5bc:	68fb      	ldr	r3, [r7, #12]
 800d5be:	2200      	movs	r2, #0
 800d5c0:	f883 2090 	strb.w	r2, [r3, #144]	@ 0x90

    return HAL_OK;
 800d5c4:	2300      	movs	r3, #0
 800d5c6:	e000      	b.n	800d5ca <HAL_SAI_Transmit_DMA+0x156>
  }
  else
  {
    return HAL_BUSY;
 800d5c8:	2302      	movs	r3, #2
  }
}
 800d5ca:	4618      	mov	r0, r3
 800d5cc:	3718      	adds	r7, #24
 800d5ce:	46bd      	mov	sp, r7
 800d5d0:	bd80      	pop	{r7, pc}
 800d5d2:	bf00      	nop
 800d5d4:	0800daf1 	.word	0x0800daf1
 800d5d8:	0800da91 	.word	0x0800da91
 800d5dc:	0800db89 	.word	0x0800db89

0800d5e0 <HAL_SAI_Receive_DMA>:
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be received
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SAI_Receive_DMA(SAI_HandleTypeDef *hsai, uint8_t *pData, uint16_t Size)
{
 800d5e0:	b580      	push	{r7, lr}
 800d5e2:	b084      	sub	sp, #16
 800d5e4:	af00      	add	r7, sp, #0
 800d5e6:	60f8      	str	r0, [r7, #12]
 800d5e8:	60b9      	str	r1, [r7, #8]
 800d5ea:	4613      	mov	r3, r2
 800d5ec:	80fb      	strh	r3, [r7, #6]

  if ((pData == NULL) || (Size == 0U))
 800d5ee:	68bb      	ldr	r3, [r7, #8]
 800d5f0:	2b00      	cmp	r3, #0
 800d5f2:	d002      	beq.n	800d5fa <HAL_SAI_Receive_DMA+0x1a>
 800d5f4:	88fb      	ldrh	r3, [r7, #6]
 800d5f6:	2b00      	cmp	r3, #0
 800d5f8:	d101      	bne.n	800d5fe <HAL_SAI_Receive_DMA+0x1e>
  {
    return  HAL_ERROR;
 800d5fa:	2301      	movs	r3, #1
 800d5fc:	e079      	b.n	800d6f2 <HAL_SAI_Receive_DMA+0x112>
  }

  if (hsai->State == HAL_SAI_STATE_READY)
 800d5fe:	68fb      	ldr	r3, [r7, #12]
 800d600:	f893 3091 	ldrb.w	r3, [r3, #145]	@ 0x91
 800d604:	b2db      	uxtb	r3, r3
 800d606:	2b01      	cmp	r3, #1
 800d608:	d172      	bne.n	800d6f0 <HAL_SAI_Receive_DMA+0x110>
  {
    /* Process Locked */
    __HAL_LOCK(hsai);
 800d60a:	68fb      	ldr	r3, [r7, #12]
 800d60c:	f893 3090 	ldrb.w	r3, [r3, #144]	@ 0x90
 800d610:	2b01      	cmp	r3, #1
 800d612:	d101      	bne.n	800d618 <HAL_SAI_Receive_DMA+0x38>
 800d614:	2302      	movs	r3, #2
 800d616:	e06c      	b.n	800d6f2 <HAL_SAI_Receive_DMA+0x112>
 800d618:	68fb      	ldr	r3, [r7, #12]
 800d61a:	2201      	movs	r2, #1
 800d61c:	f883 2090 	strb.w	r2, [r3, #144]	@ 0x90

    hsai->pBuffPtr = pData;
 800d620:	68fb      	ldr	r3, [r7, #12]
 800d622:	68ba      	ldr	r2, [r7, #8]
 800d624:	679a      	str	r2, [r3, #120]	@ 0x78
    hsai->XferSize = Size;
 800d626:	68fb      	ldr	r3, [r7, #12]
 800d628:	88fa      	ldrh	r2, [r7, #6]
 800d62a:	f8a3 207c 	strh.w	r2, [r3, #124]	@ 0x7c
    hsai->XferCount = Size;
 800d62e:	68fb      	ldr	r3, [r7, #12]
 800d630:	88fa      	ldrh	r2, [r7, #6]
 800d632:	f8a3 207e 	strh.w	r2, [r3, #126]	@ 0x7e
    hsai->ErrorCode = HAL_SAI_ERROR_NONE;
 800d636:	68fb      	ldr	r3, [r7, #12]
 800d638:	2200      	movs	r2, #0
 800d63a:	f8c3 2094 	str.w	r2, [r3, #148]	@ 0x94
    hsai->State = HAL_SAI_STATE_BUSY_RX;
 800d63e:	68fb      	ldr	r3, [r7, #12]
 800d640:	2222      	movs	r2, #34	@ 0x22
 800d642:	f883 2091 	strb.w	r2, [r3, #145]	@ 0x91

    /* Set the SAI Rx DMA Half transfer complete callback */
    hsai->hdmarx->XferHalfCpltCallback = SAI_DMARxHalfCplt;
 800d646:	68fb      	ldr	r3, [r7, #12]
 800d648:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 800d64c:	4a2b      	ldr	r2, [pc, #172]	@ (800d6fc <HAL_SAI_Receive_DMA+0x11c>)
 800d64e:	641a      	str	r2, [r3, #64]	@ 0x40

    /* Set the SAI Rx DMA transfer complete callback */
    hsai->hdmarx->XferCpltCallback = SAI_DMARxCplt;
 800d650:	68fb      	ldr	r3, [r7, #12]
 800d652:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 800d656:	4a2a      	ldr	r2, [pc, #168]	@ (800d700 <HAL_SAI_Receive_DMA+0x120>)
 800d658:	63da      	str	r2, [r3, #60]	@ 0x3c

    /* Set the DMA error callback */
    hsai->hdmarx->XferErrorCallback = SAI_DMAError;
 800d65a:	68fb      	ldr	r3, [r7, #12]
 800d65c:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 800d660:	4a28      	ldr	r2, [pc, #160]	@ (800d704 <HAL_SAI_Receive_DMA+0x124>)
 800d662:	64da      	str	r2, [r3, #76]	@ 0x4c

    /* Set the DMA Rx abort callback */
    hsai->hdmarx->XferAbortCallback = NULL;
 800d664:	68fb      	ldr	r3, [r7, #12]
 800d666:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 800d66a:	2200      	movs	r2, #0
 800d66c:	651a      	str	r2, [r3, #80]	@ 0x50

    /* Enable the Rx DMA Stream */
    if (HAL_DMA_Start_IT(hsai->hdmarx, (uint32_t)&hsai->Instance->DR, (uint32_t)hsai->pBuffPtr, hsai->XferSize) != HAL_OK)
 800d66e:	68fb      	ldr	r3, [r7, #12]
 800d670:	f8d3 0084 	ldr.w	r0, [r3, #132]	@ 0x84
 800d674:	68fb      	ldr	r3, [r7, #12]
 800d676:	681b      	ldr	r3, [r3, #0]
 800d678:	331c      	adds	r3, #28
 800d67a:	4619      	mov	r1, r3
 800d67c:	68fb      	ldr	r3, [r7, #12]
 800d67e:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 800d680:	461a      	mov	r2, r3
 800d682:	68fb      	ldr	r3, [r7, #12]
 800d684:	f8b3 307c 	ldrh.w	r3, [r3, #124]	@ 0x7c
 800d688:	f7f7 f962 	bl	8004950 <HAL_DMA_Start_IT>
 800d68c:	4603      	mov	r3, r0
 800d68e:	2b00      	cmp	r3, #0
 800d690:	d005      	beq.n	800d69e <HAL_SAI_Receive_DMA+0xbe>
    {
      __HAL_UNLOCK(hsai);
 800d692:	68fb      	ldr	r3, [r7, #12]
 800d694:	2200      	movs	r2, #0
 800d696:	f883 2090 	strb.w	r2, [r3, #144]	@ 0x90
      return  HAL_ERROR;
 800d69a:	2301      	movs	r3, #1
 800d69c:	e029      	b.n	800d6f2 <HAL_SAI_Receive_DMA+0x112>
    }

    /* Enable the interrupts for error handling */
    __HAL_SAI_ENABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_DMA));
 800d69e:	2100      	movs	r1, #0
 800d6a0:	68f8      	ldr	r0, [r7, #12]
 800d6a2:	f000 f983 	bl	800d9ac <SAI_InterruptFlag>
 800d6a6:	4601      	mov	r1, r0
 800d6a8:	68fb      	ldr	r3, [r7, #12]
 800d6aa:	681b      	ldr	r3, [r3, #0]
 800d6ac:	691a      	ldr	r2, [r3, #16]
 800d6ae:	68fb      	ldr	r3, [r7, #12]
 800d6b0:	681b      	ldr	r3, [r3, #0]
 800d6b2:	430a      	orrs	r2, r1
 800d6b4:	611a      	str	r2, [r3, #16]

    /* Enable SAI Rx DMA Request */
    hsai->Instance->CR1 |= SAI_xCR1_DMAEN;
 800d6b6:	68fb      	ldr	r3, [r7, #12]
 800d6b8:	681b      	ldr	r3, [r3, #0]
 800d6ba:	681a      	ldr	r2, [r3, #0]
 800d6bc:	68fb      	ldr	r3, [r7, #12]
 800d6be:	681b      	ldr	r3, [r3, #0]
 800d6c0:	f442 3200 	orr.w	r2, r2, #131072	@ 0x20000
 800d6c4:	601a      	str	r2, [r3, #0]

    /* Check if the SAI is already enabled */
    if ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) == 0U)
 800d6c6:	68fb      	ldr	r3, [r7, #12]
 800d6c8:	681b      	ldr	r3, [r3, #0]
 800d6ca:	681b      	ldr	r3, [r3, #0]
 800d6cc:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 800d6d0:	2b00      	cmp	r3, #0
 800d6d2:	d107      	bne.n	800d6e4 <HAL_SAI_Receive_DMA+0x104>
    {
      /* Enable SAI peripheral */
      __HAL_SAI_ENABLE(hsai);
 800d6d4:	68fb      	ldr	r3, [r7, #12]
 800d6d6:	681b      	ldr	r3, [r3, #0]
 800d6d8:	681a      	ldr	r2, [r3, #0]
 800d6da:	68fb      	ldr	r3, [r7, #12]
 800d6dc:	681b      	ldr	r3, [r3, #0]
 800d6de:	f442 3280 	orr.w	r2, r2, #65536	@ 0x10000
 800d6e2:	601a      	str	r2, [r3, #0]
    }

    /* Process Unlocked */
    __HAL_UNLOCK(hsai);
 800d6e4:	68fb      	ldr	r3, [r7, #12]
 800d6e6:	2200      	movs	r2, #0
 800d6e8:	f883 2090 	strb.w	r2, [r3, #144]	@ 0x90

    return HAL_OK;
 800d6ec:	2300      	movs	r3, #0
 800d6ee:	e000      	b.n	800d6f2 <HAL_SAI_Receive_DMA+0x112>
  }
  else
  {
    return HAL_BUSY;
 800d6f0:	2302      	movs	r3, #2
  }
}
 800d6f2:	4618      	mov	r0, r3
 800d6f4:	3710      	adds	r7, #16
 800d6f6:	46bd      	mov	sp, r7
 800d6f8:	bd80      	pop	{r7, pc}
 800d6fa:	bf00      	nop
 800d6fc:	0800db6d 	.word	0x0800db6d
 800d700:	0800db0d 	.word	0x0800db0d
 800d704:	0800db89 	.word	0x0800db89

0800d708 <HAL_SAI_TxCpltCallback>:
  * @param  hsai pointer to a SAI_HandleTypeDef structure that contains
  *              the configuration information for SAI module.
  * @retval None
  */
__weak void HAL_SAI_TxCpltCallback(SAI_HandleTypeDef *hsai)
{
 800d708:	b480      	push	{r7}
 800d70a:	b083      	sub	sp, #12
 800d70c:	af00      	add	r7, sp, #0
 800d70e:	6078      	str	r0, [r7, #4]
  UNUSED(hsai);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_SAI_TxCpltCallback could be implemented in the user file
   */
}
 800d710:	bf00      	nop
 800d712:	370c      	adds	r7, #12
 800d714:	46bd      	mov	sp, r7
 800d716:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d71a:	4770      	bx	lr

0800d71c <HAL_SAI_TxHalfCpltCallback>:
  * @param  hsai pointer to a SAI_HandleTypeDef structure that contains
  *              the configuration information for SAI module.
  * @retval None
  */
__weak void HAL_SAI_TxHalfCpltCallback(SAI_HandleTypeDef *hsai)
{
 800d71c:	b480      	push	{r7}
 800d71e:	b083      	sub	sp, #12
 800d720:	af00      	add	r7, sp, #0
 800d722:	6078      	str	r0, [r7, #4]
  UNUSED(hsai);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_SAI_TxHalfCpltCallback could be implemented in the user file
   */
}
 800d724:	bf00      	nop
 800d726:	370c      	adds	r7, #12
 800d728:	46bd      	mov	sp, r7
 800d72a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d72e:	4770      	bx	lr

0800d730 <HAL_SAI_ErrorCallback>:
  * @param  hsai pointer to a SAI_HandleTypeDef structure that contains
  *              the configuration information for SAI module.
  * @retval None
  */
__weak void HAL_SAI_ErrorCallback(SAI_HandleTypeDef *hsai)
{
 800d730:	b480      	push	{r7}
 800d732:	b083      	sub	sp, #12
 800d734:	af00      	add	r7, sp, #0
 800d736:	6078      	str	r0, [r7, #4]
  UNUSED(hsai);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_SAI_ErrorCallback could be implemented in the user file
   */
}
 800d738:	bf00      	nop
 800d73a:	370c      	adds	r7, #12
 800d73c:	46bd      	mov	sp, r7
 800d73e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d742:	4770      	bx	lr

0800d744 <SAI_InitI2S>:
  * @param  nbslot number of slot minimum value is 2 and max is 16.
  *         the value must be a multiple of 2.
  * @retval HAL status
  */
static HAL_StatusTypeDef SAI_InitI2S(SAI_HandleTypeDef *hsai, uint32_t protocol, uint32_t datasize, uint32_t nbslot)
{
 800d744:	b480      	push	{r7}
 800d746:	b087      	sub	sp, #28
 800d748:	af00      	add	r7, sp, #0
 800d74a:	60f8      	str	r0, [r7, #12]
 800d74c:	60b9      	str	r1, [r7, #8]
 800d74e:	607a      	str	r2, [r7, #4]
 800d750:	603b      	str	r3, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
 800d752:	2300      	movs	r3, #0
 800d754:	75fb      	strb	r3, [r7, #23]

  hsai->Init.Protocol            = SAI_FREE_PROTOCOL;
 800d756:	68fb      	ldr	r3, [r7, #12]
 800d758:	2200      	movs	r2, #0
 800d75a:	645a      	str	r2, [r3, #68]	@ 0x44
  hsai->Init.FirstBit            = SAI_FIRSTBIT_MSB;
 800d75c:	68fb      	ldr	r3, [r7, #12]
 800d75e:	2200      	movs	r2, #0
 800d760:	64da      	str	r2, [r3, #76]	@ 0x4c
  /* Compute ClockStrobing according AudioMode */
  if ((hsai->Init.AudioMode == SAI_MODEMASTER_TX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
 800d762:	68fb      	ldr	r3, [r7, #12]
 800d764:	685b      	ldr	r3, [r3, #4]
 800d766:	2b00      	cmp	r3, #0
 800d768:	d003      	beq.n	800d772 <SAI_InitI2S+0x2e>
 800d76a:	68fb      	ldr	r3, [r7, #12]
 800d76c:	685b      	ldr	r3, [r3, #4]
 800d76e:	2b02      	cmp	r3, #2
 800d770:	d103      	bne.n	800d77a <SAI_InitI2S+0x36>
  {
    /* Transmit */
    hsai->Init.ClockStrobing     = SAI_CLOCKSTROBING_FALLINGEDGE;
 800d772:	68fb      	ldr	r3, [r7, #12]
 800d774:	2200      	movs	r2, #0
 800d776:	651a      	str	r2, [r3, #80]	@ 0x50
 800d778:	e002      	b.n	800d780 <SAI_InitI2S+0x3c>
  }
  else
  {
    /* Receive */
    hsai->Init.ClockStrobing     = SAI_CLOCKSTROBING_RISINGEDGE;
 800d77a:	68fb      	ldr	r3, [r7, #12]
 800d77c:	2201      	movs	r2, #1
 800d77e:	651a      	str	r2, [r3, #80]	@ 0x50
  }
  hsai->FrameInit.FSDefinition   = SAI_FS_CHANNEL_IDENTIFICATION;
 800d780:	68fb      	ldr	r3, [r7, #12]
 800d782:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
 800d786:	65da      	str	r2, [r3, #92]	@ 0x5c
  hsai->SlotInit.SlotActive      = SAI_SLOTACTIVE_ALL;
 800d788:	68fb      	ldr	r3, [r7, #12]
 800d78a:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 800d78e:	675a      	str	r2, [r3, #116]	@ 0x74
  hsai->SlotInit.FirstBitOffset  = 0;
 800d790:	68fb      	ldr	r3, [r7, #12]
 800d792:	2200      	movs	r2, #0
 800d794:	669a      	str	r2, [r3, #104]	@ 0x68
  hsai->SlotInit.SlotNumber      = nbslot;
 800d796:	68fb      	ldr	r3, [r7, #12]
 800d798:	683a      	ldr	r2, [r7, #0]
 800d79a:	671a      	str	r2, [r3, #112]	@ 0x70

  /* in IS2 the number of slot must be even */
  if ((nbslot & 0x1U) != 0U)
 800d79c:	683b      	ldr	r3, [r7, #0]
 800d79e:	f003 0301 	and.w	r3, r3, #1
 800d7a2:	2b00      	cmp	r3, #0
 800d7a4:	d001      	beq.n	800d7aa <SAI_InitI2S+0x66>
  {
    return HAL_ERROR;
 800d7a6:	2301      	movs	r3, #1
 800d7a8:	e077      	b.n	800d89a <SAI_InitI2S+0x156>
  }

  if (protocol == SAI_I2S_STANDARD)
 800d7aa:	68bb      	ldr	r3, [r7, #8]
 800d7ac:	2b00      	cmp	r3, #0
 800d7ae:	d107      	bne.n	800d7c0 <SAI_InitI2S+0x7c>
  {
      hsai->FrameInit.FSPolarity = SAI_FS_ACTIVE_LOW;
 800d7b0:	68fb      	ldr	r3, [r7, #12]
 800d7b2:	2200      	movs	r2, #0
 800d7b4:	661a      	str	r2, [r3, #96]	@ 0x60
      hsai->FrameInit.FSOffset   = SAI_FS_BEFOREFIRSTBIT;
 800d7b6:	68fb      	ldr	r3, [r7, #12]
 800d7b8:	f44f 2280 	mov.w	r2, #262144	@ 0x40000
 800d7bc:	665a      	str	r2, [r3, #100]	@ 0x64
 800d7be:	e006      	b.n	800d7ce <SAI_InitI2S+0x8a>
  }
  else
  {
     /* SAI_I2S_MSBJUSTIFIED or SAI_I2S_LSBJUSTIFIED */
      hsai->FrameInit.FSPolarity = SAI_FS_ACTIVE_HIGH;
 800d7c0:	68fb      	ldr	r3, [r7, #12]
 800d7c2:	f44f 3200 	mov.w	r2, #131072	@ 0x20000
 800d7c6:	661a      	str	r2, [r3, #96]	@ 0x60
      hsai->FrameInit.FSOffset   = SAI_FS_FIRSTBIT;
 800d7c8:	68fb      	ldr	r3, [r7, #12]
 800d7ca:	2200      	movs	r2, #0
 800d7cc:	665a      	str	r2, [r3, #100]	@ 0x64
  }

  /* Frame definition */
  switch (datasize)
 800d7ce:	687b      	ldr	r3, [r7, #4]
 800d7d0:	2b03      	cmp	r3, #3
 800d7d2:	d84f      	bhi.n	800d874 <SAI_InitI2S+0x130>
 800d7d4:	a201      	add	r2, pc, #4	@ (adr r2, 800d7dc <SAI_InitI2S+0x98>)
 800d7d6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800d7da:	bf00      	nop
 800d7dc:	0800d7ed 	.word	0x0800d7ed
 800d7e0:	0800d80f 	.word	0x0800d80f
 800d7e4:	0800d831 	.word	0x0800d831
 800d7e8:	0800d853 	.word	0x0800d853
  {
    case SAI_PROTOCOL_DATASIZE_16BIT:
      hsai->Init.DataSize = SAI_DATASIZE_16;
 800d7ec:	68fb      	ldr	r3, [r7, #12]
 800d7ee:	2280      	movs	r2, #128	@ 0x80
 800d7f0:	649a      	str	r2, [r3, #72]	@ 0x48
      hsai->FrameInit.FrameLength = 32U * (nbslot / 2U);
 800d7f2:	683b      	ldr	r3, [r7, #0]
 800d7f4:	085b      	lsrs	r3, r3, #1
 800d7f6:	015a      	lsls	r2, r3, #5
 800d7f8:	68fb      	ldr	r3, [r7, #12]
 800d7fa:	655a      	str	r2, [r3, #84]	@ 0x54
      hsai->FrameInit.ActiveFrameLength = 16U * (nbslot / 2U);
 800d7fc:	683b      	ldr	r3, [r7, #0]
 800d7fe:	085b      	lsrs	r3, r3, #1
 800d800:	011a      	lsls	r2, r3, #4
 800d802:	68fb      	ldr	r3, [r7, #12]
 800d804:	659a      	str	r2, [r3, #88]	@ 0x58
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_16B;
 800d806:	68fb      	ldr	r3, [r7, #12]
 800d808:	2240      	movs	r2, #64	@ 0x40
 800d80a:	66da      	str	r2, [r3, #108]	@ 0x6c
      break;
 800d80c:	e035      	b.n	800d87a <SAI_InitI2S+0x136>
    case SAI_PROTOCOL_DATASIZE_16BITEXTENDED :
      hsai->Init.DataSize = SAI_DATASIZE_16;
 800d80e:	68fb      	ldr	r3, [r7, #12]
 800d810:	2280      	movs	r2, #128	@ 0x80
 800d812:	649a      	str	r2, [r3, #72]	@ 0x48
      hsai->FrameInit.FrameLength = 64U * (nbslot / 2U);
 800d814:	683b      	ldr	r3, [r7, #0]
 800d816:	085b      	lsrs	r3, r3, #1
 800d818:	019a      	lsls	r2, r3, #6
 800d81a:	68fb      	ldr	r3, [r7, #12]
 800d81c:	655a      	str	r2, [r3, #84]	@ 0x54
      hsai->FrameInit.ActiveFrameLength = 32U * (nbslot / 2U);
 800d81e:	683b      	ldr	r3, [r7, #0]
 800d820:	085b      	lsrs	r3, r3, #1
 800d822:	015a      	lsls	r2, r3, #5
 800d824:	68fb      	ldr	r3, [r7, #12]
 800d826:	659a      	str	r2, [r3, #88]	@ 0x58
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_32B;
 800d828:	68fb      	ldr	r3, [r7, #12]
 800d82a:	2280      	movs	r2, #128	@ 0x80
 800d82c:	66da      	str	r2, [r3, #108]	@ 0x6c
      break;
 800d82e:	e024      	b.n	800d87a <SAI_InitI2S+0x136>
    case SAI_PROTOCOL_DATASIZE_24BIT:
      hsai->Init.DataSize = SAI_DATASIZE_24;
 800d830:	68fb      	ldr	r3, [r7, #12]
 800d832:	22c0      	movs	r2, #192	@ 0xc0
 800d834:	649a      	str	r2, [r3, #72]	@ 0x48
      hsai->FrameInit.FrameLength = 64U * (nbslot / 2U);
 800d836:	683b      	ldr	r3, [r7, #0]
 800d838:	085b      	lsrs	r3, r3, #1
 800d83a:	019a      	lsls	r2, r3, #6
 800d83c:	68fb      	ldr	r3, [r7, #12]
 800d83e:	655a      	str	r2, [r3, #84]	@ 0x54
      hsai->FrameInit.ActiveFrameLength = 32U * (nbslot / 2U);
 800d840:	683b      	ldr	r3, [r7, #0]
 800d842:	085b      	lsrs	r3, r3, #1
 800d844:	015a      	lsls	r2, r3, #5
 800d846:	68fb      	ldr	r3, [r7, #12]
 800d848:	659a      	str	r2, [r3, #88]	@ 0x58
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_32B;
 800d84a:	68fb      	ldr	r3, [r7, #12]
 800d84c:	2280      	movs	r2, #128	@ 0x80
 800d84e:	66da      	str	r2, [r3, #108]	@ 0x6c
      break;
 800d850:	e013      	b.n	800d87a <SAI_InitI2S+0x136>
    case SAI_PROTOCOL_DATASIZE_32BIT:
      hsai->Init.DataSize = SAI_DATASIZE_32;
 800d852:	68fb      	ldr	r3, [r7, #12]
 800d854:	22e0      	movs	r2, #224	@ 0xe0
 800d856:	649a      	str	r2, [r3, #72]	@ 0x48
      hsai->FrameInit.FrameLength = 64U * (nbslot / 2U);
 800d858:	683b      	ldr	r3, [r7, #0]
 800d85a:	085b      	lsrs	r3, r3, #1
 800d85c:	019a      	lsls	r2, r3, #6
 800d85e:	68fb      	ldr	r3, [r7, #12]
 800d860:	655a      	str	r2, [r3, #84]	@ 0x54
      hsai->FrameInit.ActiveFrameLength = 32U * (nbslot / 2U);
 800d862:	683b      	ldr	r3, [r7, #0]
 800d864:	085b      	lsrs	r3, r3, #1
 800d866:	015a      	lsls	r2, r3, #5
 800d868:	68fb      	ldr	r3, [r7, #12]
 800d86a:	659a      	str	r2, [r3, #88]	@ 0x58
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_32B;
 800d86c:	68fb      	ldr	r3, [r7, #12]
 800d86e:	2280      	movs	r2, #128	@ 0x80
 800d870:	66da      	str	r2, [r3, #108]	@ 0x6c
      break;
 800d872:	e002      	b.n	800d87a <SAI_InitI2S+0x136>
    default :
      status = HAL_ERROR;
 800d874:	2301      	movs	r3, #1
 800d876:	75fb      	strb	r3, [r7, #23]
      break;
 800d878:	bf00      	nop
  }
  if (protocol == SAI_I2S_LSBJUSTIFIED)
 800d87a:	68bb      	ldr	r3, [r7, #8]
 800d87c:	2b02      	cmp	r3, #2
 800d87e:	d10b      	bne.n	800d898 <SAI_InitI2S+0x154>
  {
    if (datasize == SAI_PROTOCOL_DATASIZE_16BITEXTENDED)
 800d880:	687b      	ldr	r3, [r7, #4]
 800d882:	2b01      	cmp	r3, #1
 800d884:	d102      	bne.n	800d88c <SAI_InitI2S+0x148>
    {
      hsai->SlotInit.FirstBitOffset = 16;
 800d886:	68fb      	ldr	r3, [r7, #12]
 800d888:	2210      	movs	r2, #16
 800d88a:	669a      	str	r2, [r3, #104]	@ 0x68
    }
    if (datasize == SAI_PROTOCOL_DATASIZE_24BIT)
 800d88c:	687b      	ldr	r3, [r7, #4]
 800d88e:	2b02      	cmp	r3, #2
 800d890:	d102      	bne.n	800d898 <SAI_InitI2S+0x154>
    {
      hsai->SlotInit.FirstBitOffset = 8;
 800d892:	68fb      	ldr	r3, [r7, #12]
 800d894:	2208      	movs	r2, #8
 800d896:	669a      	str	r2, [r3, #104]	@ 0x68
    }
  }
  return status;
 800d898:	7dfb      	ldrb	r3, [r7, #23]
}
 800d89a:	4618      	mov	r0, r3
 800d89c:	371c      	adds	r7, #28
 800d89e:	46bd      	mov	sp, r7
 800d8a0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d8a4:	4770      	bx	lr
 800d8a6:	bf00      	nop

0800d8a8 <SAI_InitPCM>:
  * @param  datasize one of the supported datasize @ref SAI_Protocol_DataSize
  * @param  nbslot number of slot minimum value is 1 and the max is 16.
  * @retval HAL status
  */
static HAL_StatusTypeDef SAI_InitPCM(SAI_HandleTypeDef *hsai, uint32_t protocol, uint32_t datasize, uint32_t nbslot)
{
 800d8a8:	b480      	push	{r7}
 800d8aa:	b087      	sub	sp, #28
 800d8ac:	af00      	add	r7, sp, #0
 800d8ae:	60f8      	str	r0, [r7, #12]
 800d8b0:	60b9      	str	r1, [r7, #8]
 800d8b2:	607a      	str	r2, [r7, #4]
 800d8b4:	603b      	str	r3, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
 800d8b6:	2300      	movs	r3, #0
 800d8b8:	75fb      	strb	r3, [r7, #23]

  hsai->Init.Protocol            = SAI_FREE_PROTOCOL;
 800d8ba:	68fb      	ldr	r3, [r7, #12]
 800d8bc:	2200      	movs	r2, #0
 800d8be:	645a      	str	r2, [r3, #68]	@ 0x44
  hsai->Init.FirstBit            = SAI_FIRSTBIT_MSB;
 800d8c0:	68fb      	ldr	r3, [r7, #12]
 800d8c2:	2200      	movs	r2, #0
 800d8c4:	64da      	str	r2, [r3, #76]	@ 0x4c
  /* Compute ClockStrobing according AudioMode */
  if ((hsai->Init.AudioMode == SAI_MODEMASTER_TX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
 800d8c6:	68fb      	ldr	r3, [r7, #12]
 800d8c8:	685b      	ldr	r3, [r3, #4]
 800d8ca:	2b00      	cmp	r3, #0
 800d8cc:	d003      	beq.n	800d8d6 <SAI_InitPCM+0x2e>
 800d8ce:	68fb      	ldr	r3, [r7, #12]
 800d8d0:	685b      	ldr	r3, [r3, #4]
 800d8d2:	2b02      	cmp	r3, #2
 800d8d4:	d103      	bne.n	800d8de <SAI_InitPCM+0x36>
  {
    /* Transmit */
    hsai->Init.ClockStrobing     = SAI_CLOCKSTROBING_RISINGEDGE;
 800d8d6:	68fb      	ldr	r3, [r7, #12]
 800d8d8:	2201      	movs	r2, #1
 800d8da:	651a      	str	r2, [r3, #80]	@ 0x50
 800d8dc:	e002      	b.n	800d8e4 <SAI_InitPCM+0x3c>
  }
  else
  {
    /* Receive */
    hsai->Init.ClockStrobing     = SAI_CLOCKSTROBING_FALLINGEDGE;
 800d8de:	68fb      	ldr	r3, [r7, #12]
 800d8e0:	2200      	movs	r2, #0
 800d8e2:	651a      	str	r2, [r3, #80]	@ 0x50
  }
  hsai->FrameInit.FSDefinition   = SAI_FS_STARTFRAME;
 800d8e4:	68fb      	ldr	r3, [r7, #12]
 800d8e6:	2200      	movs	r2, #0
 800d8e8:	65da      	str	r2, [r3, #92]	@ 0x5c
  hsai->FrameInit.FSPolarity     = SAI_FS_ACTIVE_HIGH;
 800d8ea:	68fb      	ldr	r3, [r7, #12]
 800d8ec:	f44f 3200 	mov.w	r2, #131072	@ 0x20000
 800d8f0:	661a      	str	r2, [r3, #96]	@ 0x60
  hsai->FrameInit.FSOffset       = SAI_FS_BEFOREFIRSTBIT;
 800d8f2:	68fb      	ldr	r3, [r7, #12]
 800d8f4:	f44f 2280 	mov.w	r2, #262144	@ 0x40000
 800d8f8:	665a      	str	r2, [r3, #100]	@ 0x64
  hsai->SlotInit.FirstBitOffset  = 0;
 800d8fa:	68fb      	ldr	r3, [r7, #12]
 800d8fc:	2200      	movs	r2, #0
 800d8fe:	669a      	str	r2, [r3, #104]	@ 0x68
  hsai->SlotInit.SlotNumber      = nbslot;
 800d900:	68fb      	ldr	r3, [r7, #12]
 800d902:	683a      	ldr	r2, [r7, #0]
 800d904:	671a      	str	r2, [r3, #112]	@ 0x70
  hsai->SlotInit.SlotActive      = SAI_SLOTACTIVE_ALL;
 800d906:	68fb      	ldr	r3, [r7, #12]
 800d908:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 800d90c:	675a      	str	r2, [r3, #116]	@ 0x74

  if (protocol == SAI_PCM_SHORT)
 800d90e:	68bb      	ldr	r3, [r7, #8]
 800d910:	2b04      	cmp	r3, #4
 800d912:	d103      	bne.n	800d91c <SAI_InitPCM+0x74>
  {
      hsai->FrameInit.ActiveFrameLength = 1;
 800d914:	68fb      	ldr	r3, [r7, #12]
 800d916:	2201      	movs	r2, #1
 800d918:	659a      	str	r2, [r3, #88]	@ 0x58
 800d91a:	e002      	b.n	800d922 <SAI_InitPCM+0x7a>
  }
  else
  {
    /* SAI_PCM_LONG */
      hsai->FrameInit.ActiveFrameLength = 13;
 800d91c:	68fb      	ldr	r3, [r7, #12]
 800d91e:	220d      	movs	r2, #13
 800d920:	659a      	str	r2, [r3, #88]	@ 0x58
  }

  switch (datasize)
 800d922:	687b      	ldr	r3, [r7, #4]
 800d924:	2b03      	cmp	r3, #3
 800d926:	d837      	bhi.n	800d998 <SAI_InitPCM+0xf0>
 800d928:	a201      	add	r2, pc, #4	@ (adr r2, 800d930 <SAI_InitPCM+0x88>)
 800d92a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800d92e:	bf00      	nop
 800d930:	0800d941 	.word	0x0800d941
 800d934:	0800d957 	.word	0x0800d957
 800d938:	0800d96d 	.word	0x0800d96d
 800d93c:	0800d983 	.word	0x0800d983
  {
    case SAI_PROTOCOL_DATASIZE_16BIT:
      hsai->Init.DataSize = SAI_DATASIZE_16;
 800d940:	68fb      	ldr	r3, [r7, #12]
 800d942:	2280      	movs	r2, #128	@ 0x80
 800d944:	649a      	str	r2, [r3, #72]	@ 0x48
      hsai->FrameInit.FrameLength = 16U * nbslot;
 800d946:	683b      	ldr	r3, [r7, #0]
 800d948:	011a      	lsls	r2, r3, #4
 800d94a:	68fb      	ldr	r3, [r7, #12]
 800d94c:	655a      	str	r2, [r3, #84]	@ 0x54
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_16B;
 800d94e:	68fb      	ldr	r3, [r7, #12]
 800d950:	2240      	movs	r2, #64	@ 0x40
 800d952:	66da      	str	r2, [r3, #108]	@ 0x6c
      break;
 800d954:	e023      	b.n	800d99e <SAI_InitPCM+0xf6>
    case SAI_PROTOCOL_DATASIZE_16BITEXTENDED :
      hsai->Init.DataSize = SAI_DATASIZE_16;
 800d956:	68fb      	ldr	r3, [r7, #12]
 800d958:	2280      	movs	r2, #128	@ 0x80
 800d95a:	649a      	str	r2, [r3, #72]	@ 0x48
      hsai->FrameInit.FrameLength = 32U * nbslot;
 800d95c:	683b      	ldr	r3, [r7, #0]
 800d95e:	015a      	lsls	r2, r3, #5
 800d960:	68fb      	ldr	r3, [r7, #12]
 800d962:	655a      	str	r2, [r3, #84]	@ 0x54
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_32B;
 800d964:	68fb      	ldr	r3, [r7, #12]
 800d966:	2280      	movs	r2, #128	@ 0x80
 800d968:	66da      	str	r2, [r3, #108]	@ 0x6c
      break;
 800d96a:	e018      	b.n	800d99e <SAI_InitPCM+0xf6>
    case SAI_PROTOCOL_DATASIZE_24BIT :
      hsai->Init.DataSize = SAI_DATASIZE_24;
 800d96c:	68fb      	ldr	r3, [r7, #12]
 800d96e:	22c0      	movs	r2, #192	@ 0xc0
 800d970:	649a      	str	r2, [r3, #72]	@ 0x48
      hsai->FrameInit.FrameLength = 32U * nbslot;
 800d972:	683b      	ldr	r3, [r7, #0]
 800d974:	015a      	lsls	r2, r3, #5
 800d976:	68fb      	ldr	r3, [r7, #12]
 800d978:	655a      	str	r2, [r3, #84]	@ 0x54
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_32B;
 800d97a:	68fb      	ldr	r3, [r7, #12]
 800d97c:	2280      	movs	r2, #128	@ 0x80
 800d97e:	66da      	str	r2, [r3, #108]	@ 0x6c
      break;
 800d980:	e00d      	b.n	800d99e <SAI_InitPCM+0xf6>
    case SAI_PROTOCOL_DATASIZE_32BIT:
      hsai->Init.DataSize = SAI_DATASIZE_32;
 800d982:	68fb      	ldr	r3, [r7, #12]
 800d984:	22e0      	movs	r2, #224	@ 0xe0
 800d986:	649a      	str	r2, [r3, #72]	@ 0x48
      hsai->FrameInit.FrameLength = 32U * nbslot;
 800d988:	683b      	ldr	r3, [r7, #0]
 800d98a:	015a      	lsls	r2, r3, #5
 800d98c:	68fb      	ldr	r3, [r7, #12]
 800d98e:	655a      	str	r2, [r3, #84]	@ 0x54
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_32B;
 800d990:	68fb      	ldr	r3, [r7, #12]
 800d992:	2280      	movs	r2, #128	@ 0x80
 800d994:	66da      	str	r2, [r3, #108]	@ 0x6c
      break;
 800d996:	e002      	b.n	800d99e <SAI_InitPCM+0xf6>
    default :
      status = HAL_ERROR;
 800d998:	2301      	movs	r3, #1
 800d99a:	75fb      	strb	r3, [r7, #23]
      break;
 800d99c:	bf00      	nop
  }

  return status;
 800d99e:	7dfb      	ldrb	r3, [r7, #23]
}
 800d9a0:	4618      	mov	r0, r3
 800d9a2:	371c      	adds	r7, #28
 800d9a4:	46bd      	mov	sp, r7
 800d9a6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d9aa:	4770      	bx	lr

0800d9ac <SAI_InterruptFlag>:
  *              the configuration information for SAI module.
  * @param  mode SAI_MODE_DMA or SAI_MODE_IT
  * @retval the list of the IT flag to enable
  */
static uint32_t SAI_InterruptFlag(const SAI_HandleTypeDef *hsai, SAI_ModeTypedef mode)
{
 800d9ac:	b480      	push	{r7}
 800d9ae:	b085      	sub	sp, #20
 800d9b0:	af00      	add	r7, sp, #0
 800d9b2:	6078      	str	r0, [r7, #4]
 800d9b4:	460b      	mov	r3, r1
 800d9b6:	70fb      	strb	r3, [r7, #3]
  uint32_t tmpIT = SAI_IT_OVRUDR;
 800d9b8:	2301      	movs	r3, #1
 800d9ba:	60fb      	str	r3, [r7, #12]

  if (mode == SAI_MODE_IT)
 800d9bc:	78fb      	ldrb	r3, [r7, #3]
 800d9be:	2b01      	cmp	r3, #1
 800d9c0:	d103      	bne.n	800d9ca <SAI_InterruptFlag+0x1e>
  {
    tmpIT |= SAI_IT_FREQ;
 800d9c2:	68fb      	ldr	r3, [r7, #12]
 800d9c4:	f043 0308 	orr.w	r3, r3, #8
 800d9c8:	60fb      	str	r3, [r7, #12]
  }

  if ((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
 800d9ca:	687b      	ldr	r3, [r7, #4]
 800d9cc:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800d9ce:	2b08      	cmp	r3, #8
 800d9d0:	d10b      	bne.n	800d9ea <SAI_InterruptFlag+0x3e>
      ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODEMASTER_RX)))
 800d9d2:	687b      	ldr	r3, [r7, #4]
 800d9d4:	685b      	ldr	r3, [r3, #4]
  if ((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
 800d9d6:	2b03      	cmp	r3, #3
 800d9d8:	d003      	beq.n	800d9e2 <SAI_InterruptFlag+0x36>
      ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODEMASTER_RX)))
 800d9da:	687b      	ldr	r3, [r7, #4]
 800d9dc:	685b      	ldr	r3, [r3, #4]
 800d9de:	2b01      	cmp	r3, #1
 800d9e0:	d103      	bne.n	800d9ea <SAI_InterruptFlag+0x3e>
  {
    tmpIT |= SAI_IT_CNRDY;
 800d9e2:	68fb      	ldr	r3, [r7, #12]
 800d9e4:	f043 0310 	orr.w	r3, r3, #16
 800d9e8:	60fb      	str	r3, [r7, #12]
  }

  if ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
 800d9ea:	687b      	ldr	r3, [r7, #4]
 800d9ec:	685b      	ldr	r3, [r3, #4]
 800d9ee:	2b03      	cmp	r3, #3
 800d9f0:	d003      	beq.n	800d9fa <SAI_InterruptFlag+0x4e>
 800d9f2:	687b      	ldr	r3, [r7, #4]
 800d9f4:	685b      	ldr	r3, [r3, #4]
 800d9f6:	2b02      	cmp	r3, #2
 800d9f8:	d104      	bne.n	800da04 <SAI_InterruptFlag+0x58>
  {
    tmpIT |= SAI_IT_AFSDET | SAI_IT_LFSDET;
 800d9fa:	68fb      	ldr	r3, [r7, #12]
 800d9fc:	f043 0360 	orr.w	r3, r3, #96	@ 0x60
 800da00:	60fb      	str	r3, [r7, #12]
 800da02:	e003      	b.n	800da0c <SAI_InterruptFlag+0x60>
  }
  else
  {
    /* hsai has been configured in master mode */
    tmpIT |= SAI_IT_WCKCFG;
 800da04:	68fb      	ldr	r3, [r7, #12]
 800da06:	f043 0304 	orr.w	r3, r3, #4
 800da0a:	60fb      	str	r3, [r7, #12]
  }
  return tmpIT;
 800da0c:	68fb      	ldr	r3, [r7, #12]
}
 800da0e:	4618      	mov	r0, r3
 800da10:	3714      	adds	r7, #20
 800da12:	46bd      	mov	sp, r7
 800da14:	f85d 7b04 	ldr.w	r7, [sp], #4
 800da18:	4770      	bx	lr
	...

0800da1c <SAI_Disable>:
  * @param  hsai pointer to a SAI_HandleTypeDef structure that contains
  *              the configuration information for SAI module.
  * @retval None
  */
static HAL_StatusTypeDef SAI_Disable(SAI_HandleTypeDef *hsai)
{
 800da1c:	b480      	push	{r7}
 800da1e:	b085      	sub	sp, #20
 800da20:	af00      	add	r7, sp, #0
 800da22:	6078      	str	r0, [r7, #4]
  uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7U / 1000U);
 800da24:	4b18      	ldr	r3, [pc, #96]	@ (800da88 <SAI_Disable+0x6c>)
 800da26:	681b      	ldr	r3, [r3, #0]
 800da28:	4a18      	ldr	r2, [pc, #96]	@ (800da8c <SAI_Disable+0x70>)
 800da2a:	fba2 2303 	umull	r2, r3, r2, r3
 800da2e:	0b1b      	lsrs	r3, r3, #12
 800da30:	009b      	lsls	r3, r3, #2
 800da32:	60fb      	str	r3, [r7, #12]
  HAL_StatusTypeDef status = HAL_OK;
 800da34:	2300      	movs	r3, #0
 800da36:	72fb      	strb	r3, [r7, #11]

  /* Disable the SAI instance */
  __HAL_SAI_DISABLE(hsai);
 800da38:	687b      	ldr	r3, [r7, #4]
 800da3a:	681b      	ldr	r3, [r3, #0]
 800da3c:	681a      	ldr	r2, [r3, #0]
 800da3e:	687b      	ldr	r3, [r7, #4]
 800da40:	681b      	ldr	r3, [r3, #0]
 800da42:	f422 3280 	bic.w	r2, r2, #65536	@ 0x10000
 800da46:	601a      	str	r2, [r3, #0]

  do
  {
    /* Check for the Timeout */
    if (count == 0U)
 800da48:	68fb      	ldr	r3, [r7, #12]
 800da4a:	2b00      	cmp	r3, #0
 800da4c:	d10a      	bne.n	800da64 <SAI_Disable+0x48>
    {
      /* Update error code */
      hsai->ErrorCode |= HAL_SAI_ERROR_TIMEOUT;
 800da4e:	687b      	ldr	r3, [r7, #4]
 800da50:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 800da54:	f043 0240 	orr.w	r2, r3, #64	@ 0x40
 800da58:	687b      	ldr	r3, [r7, #4]
 800da5a:	f8c3 2094 	str.w	r2, [r3, #148]	@ 0x94
      status = HAL_TIMEOUT;
 800da5e:	2303      	movs	r3, #3
 800da60:	72fb      	strb	r3, [r7, #11]
      break;
 800da62:	e009      	b.n	800da78 <SAI_Disable+0x5c>
    }
    count--;
 800da64:	68fb      	ldr	r3, [r7, #12]
 800da66:	3b01      	subs	r3, #1
 800da68:	60fb      	str	r3, [r7, #12]
  }
  while ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) != 0U);
 800da6a:	687b      	ldr	r3, [r7, #4]
 800da6c:	681b      	ldr	r3, [r3, #0]
 800da6e:	681b      	ldr	r3, [r3, #0]
 800da70:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 800da74:	2b00      	cmp	r3, #0
 800da76:	d1e7      	bne.n	800da48 <SAI_Disable+0x2c>

  return status;
 800da78:	7afb      	ldrb	r3, [r7, #11]
}
 800da7a:	4618      	mov	r0, r3
 800da7c:	3714      	adds	r7, #20
 800da7e:	46bd      	mov	sp, r7
 800da80:	f85d 7b04 	ldr.w	r7, [sp], #4
 800da84:	4770      	bx	lr
 800da86:	bf00      	nop
 800da88:	2400011c 	.word	0x2400011c
 800da8c:	95cbec1b 	.word	0x95cbec1b

0800da90 <SAI_DMATxCplt>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *              the configuration information for the specified DMA module.
  * @retval None
  */
static void SAI_DMATxCplt(DMA_HandleTypeDef *hdma)
{
 800da90:	b580      	push	{r7, lr}
 800da92:	b084      	sub	sp, #16
 800da94:	af00      	add	r7, sp, #0
 800da96:	6078      	str	r0, [r7, #4]
  SAI_HandleTypeDef *hsai = (SAI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 800da98:	687b      	ldr	r3, [r7, #4]
 800da9a:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800da9c:	60fb      	str	r3, [r7, #12]

  if (hdma->Init.Mode != DMA_CIRCULAR)
 800da9e:	687b      	ldr	r3, [r7, #4]
 800daa0:	69db      	ldr	r3, [r3, #28]
 800daa2:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 800daa6:	d01c      	beq.n	800dae2 <SAI_DMATxCplt+0x52>
  {
    hsai->XferCount = 0;
 800daa8:	68fb      	ldr	r3, [r7, #12]
 800daaa:	2200      	movs	r2, #0
 800daac:	f8a3 207e 	strh.w	r2, [r3, #126]	@ 0x7e

    /* Disable SAI Tx DMA Request */
    hsai->Instance->CR1 &= (uint32_t)(~SAI_xCR1_DMAEN);
 800dab0:	68fb      	ldr	r3, [r7, #12]
 800dab2:	681b      	ldr	r3, [r3, #0]
 800dab4:	681a      	ldr	r2, [r3, #0]
 800dab6:	68fb      	ldr	r3, [r7, #12]
 800dab8:	681b      	ldr	r3, [r3, #0]
 800daba:	f422 3200 	bic.w	r2, r2, #131072	@ 0x20000
 800dabe:	601a      	str	r2, [r3, #0]

    /* Stop the interrupts error handling */
    __HAL_SAI_DISABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_DMA));
 800dac0:	2100      	movs	r1, #0
 800dac2:	68f8      	ldr	r0, [r7, #12]
 800dac4:	f7ff ff72 	bl	800d9ac <SAI_InterruptFlag>
 800dac8:	4603      	mov	r3, r0
 800daca:	43d9      	mvns	r1, r3
 800dacc:	68fb      	ldr	r3, [r7, #12]
 800dace:	681b      	ldr	r3, [r3, #0]
 800dad0:	691a      	ldr	r2, [r3, #16]
 800dad2:	68fb      	ldr	r3, [r7, #12]
 800dad4:	681b      	ldr	r3, [r3, #0]
 800dad6:	400a      	ands	r2, r1
 800dad8:	611a      	str	r2, [r3, #16]

    hsai->State = HAL_SAI_STATE_READY;
 800dada:	68fb      	ldr	r3, [r7, #12]
 800dadc:	2201      	movs	r2, #1
 800dade:	f883 2091 	strb.w	r2, [r3, #145]	@ 0x91
  }
#if (USE_HAL_SAI_REGISTER_CALLBACKS == 1)
  hsai->TxCpltCallback(hsai);
#else
  HAL_SAI_TxCpltCallback(hsai);
 800dae2:	68f8      	ldr	r0, [r7, #12]
 800dae4:	f7ff fe10 	bl	800d708 <HAL_SAI_TxCpltCallback>
#endif
}
 800dae8:	bf00      	nop
 800daea:	3710      	adds	r7, #16
 800daec:	46bd      	mov	sp, r7
 800daee:	bd80      	pop	{r7, pc}

0800daf0 <SAI_DMATxHalfCplt>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *              the configuration information for the specified DMA module.
  * @retval None
  */
static void SAI_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
{
 800daf0:	b580      	push	{r7, lr}
 800daf2:	b084      	sub	sp, #16
 800daf4:	af00      	add	r7, sp, #0
 800daf6:	6078      	str	r0, [r7, #4]
  SAI_HandleTypeDef *hsai = (SAI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 800daf8:	687b      	ldr	r3, [r7, #4]
 800dafa:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800dafc:	60fb      	str	r3, [r7, #12]

#if (USE_HAL_SAI_REGISTER_CALLBACKS == 1)
  hsai->TxHalfCpltCallback(hsai);
#else
  HAL_SAI_TxHalfCpltCallback(hsai);
 800dafe:	68f8      	ldr	r0, [r7, #12]
 800db00:	f7ff fe0c 	bl	800d71c <HAL_SAI_TxHalfCpltCallback>
#endif
}
 800db04:	bf00      	nop
 800db06:	3710      	adds	r7, #16
 800db08:	46bd      	mov	sp, r7
 800db0a:	bd80      	pop	{r7, pc}

0800db0c <SAI_DMARxCplt>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *              the configuration information for the specified DMA module.
  * @retval None
  */
static void SAI_DMARxCplt(DMA_HandleTypeDef *hdma)
{
 800db0c:	b580      	push	{r7, lr}
 800db0e:	b084      	sub	sp, #16
 800db10:	af00      	add	r7, sp, #0
 800db12:	6078      	str	r0, [r7, #4]
  SAI_HandleTypeDef *hsai = (SAI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 800db14:	687b      	ldr	r3, [r7, #4]
 800db16:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800db18:	60fb      	str	r3, [r7, #12]

  if (hdma->Init.Mode != DMA_CIRCULAR)
 800db1a:	687b      	ldr	r3, [r7, #4]
 800db1c:	69db      	ldr	r3, [r3, #28]
 800db1e:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 800db22:	d01c      	beq.n	800db5e <SAI_DMARxCplt+0x52>
  {
    /* Disable Rx DMA Request */
    hsai->Instance->CR1 &= (uint32_t)(~SAI_xCR1_DMAEN);
 800db24:	68fb      	ldr	r3, [r7, #12]
 800db26:	681b      	ldr	r3, [r3, #0]
 800db28:	681a      	ldr	r2, [r3, #0]
 800db2a:	68fb      	ldr	r3, [r7, #12]
 800db2c:	681b      	ldr	r3, [r3, #0]
 800db2e:	f422 3200 	bic.w	r2, r2, #131072	@ 0x20000
 800db32:	601a      	str	r2, [r3, #0]
    hsai->XferCount = 0;
 800db34:	68fb      	ldr	r3, [r7, #12]
 800db36:	2200      	movs	r2, #0
 800db38:	f8a3 207e 	strh.w	r2, [r3, #126]	@ 0x7e

    /* Stop the interrupts error handling */
    __HAL_SAI_DISABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_DMA));
 800db3c:	2100      	movs	r1, #0
 800db3e:	68f8      	ldr	r0, [r7, #12]
 800db40:	f7ff ff34 	bl	800d9ac <SAI_InterruptFlag>
 800db44:	4603      	mov	r3, r0
 800db46:	43d9      	mvns	r1, r3
 800db48:	68fb      	ldr	r3, [r7, #12]
 800db4a:	681b      	ldr	r3, [r3, #0]
 800db4c:	691a      	ldr	r2, [r3, #16]
 800db4e:	68fb      	ldr	r3, [r7, #12]
 800db50:	681b      	ldr	r3, [r3, #0]
 800db52:	400a      	ands	r2, r1
 800db54:	611a      	str	r2, [r3, #16]

    hsai->State = HAL_SAI_STATE_READY;
 800db56:	68fb      	ldr	r3, [r7, #12]
 800db58:	2201      	movs	r2, #1
 800db5a:	f883 2091 	strb.w	r2, [r3, #145]	@ 0x91
  }
#if (USE_HAL_SAI_REGISTER_CALLBACKS == 1)
  hsai->RxCpltCallback(hsai);
#else
  HAL_SAI_RxCpltCallback(hsai);
 800db5e:	68f8      	ldr	r0, [r7, #12]
 800db60:	f7f3 f87e 	bl	8000c60 <HAL_SAI_RxCpltCallback>
#endif
}
 800db64:	bf00      	nop
 800db66:	3710      	adds	r7, #16
 800db68:	46bd      	mov	sp, r7
 800db6a:	bd80      	pop	{r7, pc}

0800db6c <SAI_DMARxHalfCplt>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *              the configuration information for the specified DMA module.
  * @retval None
  */
static void SAI_DMARxHalfCplt(DMA_HandleTypeDef *hdma)
{
 800db6c:	b580      	push	{r7, lr}
 800db6e:	b084      	sub	sp, #16
 800db70:	af00      	add	r7, sp, #0
 800db72:	6078      	str	r0, [r7, #4]
  SAI_HandleTypeDef *hsai = (SAI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 800db74:	687b      	ldr	r3, [r7, #4]
 800db76:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800db78:	60fb      	str	r3, [r7, #12]

#if (USE_HAL_SAI_REGISTER_CALLBACKS == 1)
  hsai->RxHalfCpltCallback(hsai);
#else
  HAL_SAI_RxHalfCpltCallback(hsai);
 800db7a:	68f8      	ldr	r0, [r7, #12]
 800db7c:	f7f3 f858 	bl	8000c30 <HAL_SAI_RxHalfCpltCallback>
#endif
}
 800db80:	bf00      	nop
 800db82:	3710      	adds	r7, #16
 800db84:	46bd      	mov	sp, r7
 800db86:	bd80      	pop	{r7, pc}

0800db88 <SAI_DMAError>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *              the configuration information for the specified DMA module.
  * @retval None
  */
static void SAI_DMAError(DMA_HandleTypeDef *hdma)
{
 800db88:	b580      	push	{r7, lr}
 800db8a:	b084      	sub	sp, #16
 800db8c:	af00      	add	r7, sp, #0
 800db8e:	6078      	str	r0, [r7, #4]
  SAI_HandleTypeDef *hsai = (SAI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 800db90:	687b      	ldr	r3, [r7, #4]
 800db92:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800db94:	60fb      	str	r3, [r7, #12]

  /* Ignore DMA FIFO error */
  if (HAL_DMA_GetError(hdma) != HAL_DMA_ERROR_FE)
 800db96:	6878      	ldr	r0, [r7, #4]
 800db98:	f7f8 f8a6 	bl	8005ce8 <HAL_DMA_GetError>
 800db9c:	4603      	mov	r3, r0
 800db9e:	2b02      	cmp	r3, #2
 800dba0:	d01d      	beq.n	800dbde <SAI_DMAError+0x56>
  {
    /* Set SAI error code */
    hsai->ErrorCode |= HAL_SAI_ERROR_DMA;
 800dba2:	68fb      	ldr	r3, [r7, #12]
 800dba4:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 800dba8:	f043 0280 	orr.w	r2, r3, #128	@ 0x80
 800dbac:	68fb      	ldr	r3, [r7, #12]
 800dbae:	f8c3 2094 	str.w	r2, [r3, #148]	@ 0x94

    /* Disable the SAI DMA request */
    hsai->Instance->CR1 &= ~SAI_xCR1_DMAEN;
 800dbb2:	68fb      	ldr	r3, [r7, #12]
 800dbb4:	681b      	ldr	r3, [r3, #0]
 800dbb6:	681a      	ldr	r2, [r3, #0]
 800dbb8:	68fb      	ldr	r3, [r7, #12]
 800dbba:	681b      	ldr	r3, [r3, #0]
 800dbbc:	f422 3200 	bic.w	r2, r2, #131072	@ 0x20000
 800dbc0:	601a      	str	r2, [r3, #0]

    /* Disable SAI peripheral */
    /* No need to check return value because state will be updated and HAL_SAI_ErrorCallback will be called later */
    (void) SAI_Disable(hsai);
 800dbc2:	68f8      	ldr	r0, [r7, #12]
 800dbc4:	f7ff ff2a 	bl	800da1c <SAI_Disable>

    /* Set the SAI state ready to be able to start again the process */
    hsai->State = HAL_SAI_STATE_READY;
 800dbc8:	68fb      	ldr	r3, [r7, #12]
 800dbca:	2201      	movs	r2, #1
 800dbcc:	f883 2091 	strb.w	r2, [r3, #145]	@ 0x91

    /* Initialize XferCount */
    hsai->XferCount = 0U;
 800dbd0:	68fb      	ldr	r3, [r7, #12]
 800dbd2:	2200      	movs	r2, #0
 800dbd4:	f8a3 207e 	strh.w	r2, [r3, #126]	@ 0x7e

    /* SAI error Callback */
#if (USE_HAL_SAI_REGISTER_CALLBACKS == 1)
    hsai->ErrorCallback(hsai);
#else
    HAL_SAI_ErrorCallback(hsai);
 800dbd8:	68f8      	ldr	r0, [r7, #12]
 800dbda:	f7ff fda9 	bl	800d730 <HAL_SAI_ErrorCallback>
#endif
  }
}
 800dbde:	bf00      	nop
 800dbe0:	3710      	adds	r7, #16
 800dbe2:	46bd      	mov	sp, r7
 800dbe4:	bd80      	pop	{r7, pc}

0800dbe6 <HAL_TIM_Base_Init>:
  *         Ex: call @ref HAL_TIM_Base_DeInit() before HAL_TIM_Base_Init()
  * @param  htim TIM Base handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
{
 800dbe6:	b580      	push	{r7, lr}
 800dbe8:	b082      	sub	sp, #8
 800dbea:	af00      	add	r7, sp, #0
 800dbec:	6078      	str	r0, [r7, #4]
  /* Check the TIM handle allocation */
  if (htim == NULL)
 800dbee:	687b      	ldr	r3, [r7, #4]
 800dbf0:	2b00      	cmp	r3, #0
 800dbf2:	d101      	bne.n	800dbf8 <HAL_TIM_Base_Init+0x12>
  {
    return HAL_ERROR;
 800dbf4:	2301      	movs	r3, #1
 800dbf6:	e049      	b.n	800dc8c <HAL_TIM_Base_Init+0xa6>
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
  assert_param(IS_TIM_PERIOD(htim, htim->Init.Period));
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));

  if (htim->State == HAL_TIM_STATE_RESET)
 800dbf8:	687b      	ldr	r3, [r7, #4]
 800dbfa:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
 800dbfe:	b2db      	uxtb	r3, r3
 800dc00:	2b00      	cmp	r3, #0
 800dc02:	d106      	bne.n	800dc12 <HAL_TIM_Base_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    htim->Lock = HAL_UNLOCKED;
 800dc04:	687b      	ldr	r3, [r7, #4]
 800dc06:	2200      	movs	r2, #0
 800dc08:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c
    }
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    htim->Base_MspInitCallback(htim);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    HAL_TIM_Base_MspInit(htim);
 800dc0c:	6878      	ldr	r0, [r7, #4]
 800dc0e:	f7f4 fb59 	bl	80022c4 <HAL_TIM_Base_MspInit>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
  }

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;
 800dc12:	687b      	ldr	r3, [r7, #4]
 800dc14:	2202      	movs	r2, #2
 800dc16:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d

  /* Set the Time Base configuration */
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 800dc1a:	687b      	ldr	r3, [r7, #4]
 800dc1c:	681a      	ldr	r2, [r3, #0]
 800dc1e:	687b      	ldr	r3, [r7, #4]
 800dc20:	3304      	adds	r3, #4
 800dc22:	4619      	mov	r1, r3
 800dc24:	4610      	mov	r0, r2
 800dc26:	f000 fd5b 	bl	800e6e0 <TIM_Base_SetConfig>

  /* Initialize the DMA burst operation state */
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 800dc2a:	687b      	ldr	r3, [r7, #4]
 800dc2c:	2201      	movs	r2, #1
 800dc2e:	f883 2048 	strb.w	r2, [r3, #72]	@ 0x48

  /* Initialize the TIM channels state */
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 800dc32:	687b      	ldr	r3, [r7, #4]
 800dc34:	2201      	movs	r2, #1
 800dc36:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e
 800dc3a:	687b      	ldr	r3, [r7, #4]
 800dc3c:	2201      	movs	r2, #1
 800dc3e:	f883 203f 	strb.w	r2, [r3, #63]	@ 0x3f
 800dc42:	687b      	ldr	r3, [r7, #4]
 800dc44:	2201      	movs	r2, #1
 800dc46:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
 800dc4a:	687b      	ldr	r3, [r7, #4]
 800dc4c:	2201      	movs	r2, #1
 800dc4e:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
 800dc52:	687b      	ldr	r3, [r7, #4]
 800dc54:	2201      	movs	r2, #1
 800dc56:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42
 800dc5a:	687b      	ldr	r3, [r7, #4]
 800dc5c:	2201      	movs	r2, #1
 800dc5e:	f883 2043 	strb.w	r2, [r3, #67]	@ 0x43
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 800dc62:	687b      	ldr	r3, [r7, #4]
 800dc64:	2201      	movs	r2, #1
 800dc66:	f883 2044 	strb.w	r2, [r3, #68]	@ 0x44
 800dc6a:	687b      	ldr	r3, [r7, #4]
 800dc6c:	2201      	movs	r2, #1
 800dc6e:	f883 2045 	strb.w	r2, [r3, #69]	@ 0x45
 800dc72:	687b      	ldr	r3, [r7, #4]
 800dc74:	2201      	movs	r2, #1
 800dc76:	f883 2046 	strb.w	r2, [r3, #70]	@ 0x46
 800dc7a:	687b      	ldr	r3, [r7, #4]
 800dc7c:	2201      	movs	r2, #1
 800dc7e:	f883 2047 	strb.w	r2, [r3, #71]	@ 0x47

  /* Initialize the TIM state*/
  htim->State = HAL_TIM_STATE_READY;
 800dc82:	687b      	ldr	r3, [r7, #4]
 800dc84:	2201      	movs	r2, #1
 800dc86:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d

  return HAL_OK;
 800dc8a:	2300      	movs	r3, #0
}
 800dc8c:	4618      	mov	r0, r3
 800dc8e:	3708      	adds	r7, #8
 800dc90:	46bd      	mov	sp, r7
 800dc92:	bd80      	pop	{r7, pc}

0800dc94 <HAL_TIM_Base_Start>:
  * @brief  Starts the TIM Base generation.
  * @param  htim TIM Base handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_Start(TIM_HandleTypeDef *htim)
{
 800dc94:	b480      	push	{r7}
 800dc96:	b085      	sub	sp, #20
 800dc98:	af00      	add	r7, sp, #0
 800dc9a:	6078      	str	r0, [r7, #4]

  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));

  /* Check the TIM state */
  if (htim->State != HAL_TIM_STATE_READY)
 800dc9c:	687b      	ldr	r3, [r7, #4]
 800dc9e:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
 800dca2:	b2db      	uxtb	r3, r3
 800dca4:	2b01      	cmp	r3, #1
 800dca6:	d001      	beq.n	800dcac <HAL_TIM_Base_Start+0x18>
  {
    return HAL_ERROR;
 800dca8:	2301      	movs	r3, #1
 800dcaa:	e04c      	b.n	800dd46 <HAL_TIM_Base_Start+0xb2>
  }

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;
 800dcac:	687b      	ldr	r3, [r7, #4]
 800dcae:	2202      	movs	r2, #2
 800dcb0:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d

  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 800dcb4:	687b      	ldr	r3, [r7, #4]
 800dcb6:	681b      	ldr	r3, [r3, #0]
 800dcb8:	4a26      	ldr	r2, [pc, #152]	@ (800dd54 <HAL_TIM_Base_Start+0xc0>)
 800dcba:	4293      	cmp	r3, r2
 800dcbc:	d022      	beq.n	800dd04 <HAL_TIM_Base_Start+0x70>
 800dcbe:	687b      	ldr	r3, [r7, #4]
 800dcc0:	681b      	ldr	r3, [r3, #0]
 800dcc2:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 800dcc6:	d01d      	beq.n	800dd04 <HAL_TIM_Base_Start+0x70>
 800dcc8:	687b      	ldr	r3, [r7, #4]
 800dcca:	681b      	ldr	r3, [r3, #0]
 800dccc:	4a22      	ldr	r2, [pc, #136]	@ (800dd58 <HAL_TIM_Base_Start+0xc4>)
 800dcce:	4293      	cmp	r3, r2
 800dcd0:	d018      	beq.n	800dd04 <HAL_TIM_Base_Start+0x70>
 800dcd2:	687b      	ldr	r3, [r7, #4]
 800dcd4:	681b      	ldr	r3, [r3, #0]
 800dcd6:	4a21      	ldr	r2, [pc, #132]	@ (800dd5c <HAL_TIM_Base_Start+0xc8>)
 800dcd8:	4293      	cmp	r3, r2
 800dcda:	d013      	beq.n	800dd04 <HAL_TIM_Base_Start+0x70>
 800dcdc:	687b      	ldr	r3, [r7, #4]
 800dcde:	681b      	ldr	r3, [r3, #0]
 800dce0:	4a1f      	ldr	r2, [pc, #124]	@ (800dd60 <HAL_TIM_Base_Start+0xcc>)
 800dce2:	4293      	cmp	r3, r2
 800dce4:	d00e      	beq.n	800dd04 <HAL_TIM_Base_Start+0x70>
 800dce6:	687b      	ldr	r3, [r7, #4]
 800dce8:	681b      	ldr	r3, [r3, #0]
 800dcea:	4a1e      	ldr	r2, [pc, #120]	@ (800dd64 <HAL_TIM_Base_Start+0xd0>)
 800dcec:	4293      	cmp	r3, r2
 800dcee:	d009      	beq.n	800dd04 <HAL_TIM_Base_Start+0x70>
 800dcf0:	687b      	ldr	r3, [r7, #4]
 800dcf2:	681b      	ldr	r3, [r3, #0]
 800dcf4:	4a1c      	ldr	r2, [pc, #112]	@ (800dd68 <HAL_TIM_Base_Start+0xd4>)
 800dcf6:	4293      	cmp	r3, r2
 800dcf8:	d004      	beq.n	800dd04 <HAL_TIM_Base_Start+0x70>
 800dcfa:	687b      	ldr	r3, [r7, #4]
 800dcfc:	681b      	ldr	r3, [r3, #0]
 800dcfe:	4a1b      	ldr	r2, [pc, #108]	@ (800dd6c <HAL_TIM_Base_Start+0xd8>)
 800dd00:	4293      	cmp	r3, r2
 800dd02:	d115      	bne.n	800dd30 <HAL_TIM_Base_Start+0x9c>
  {
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 800dd04:	687b      	ldr	r3, [r7, #4]
 800dd06:	681b      	ldr	r3, [r3, #0]
 800dd08:	689a      	ldr	r2, [r3, #8]
 800dd0a:	4b19      	ldr	r3, [pc, #100]	@ (800dd70 <HAL_TIM_Base_Start+0xdc>)
 800dd0c:	4013      	ands	r3, r2
 800dd0e:	60fb      	str	r3, [r7, #12]
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 800dd10:	68fb      	ldr	r3, [r7, #12]
 800dd12:	2b06      	cmp	r3, #6
 800dd14:	d015      	beq.n	800dd42 <HAL_TIM_Base_Start+0xae>
 800dd16:	68fb      	ldr	r3, [r7, #12]
 800dd18:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 800dd1c:	d011      	beq.n	800dd42 <HAL_TIM_Base_Start+0xae>
    {
      __HAL_TIM_ENABLE(htim);
 800dd1e:	687b      	ldr	r3, [r7, #4]
 800dd20:	681b      	ldr	r3, [r3, #0]
 800dd22:	681a      	ldr	r2, [r3, #0]
 800dd24:	687b      	ldr	r3, [r7, #4]
 800dd26:	681b      	ldr	r3, [r3, #0]
 800dd28:	f042 0201 	orr.w	r2, r2, #1
 800dd2c:	601a      	str	r2, [r3, #0]
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 800dd2e:	e008      	b.n	800dd42 <HAL_TIM_Base_Start+0xae>
    }
  }
  else
  {
    __HAL_TIM_ENABLE(htim);
 800dd30:	687b      	ldr	r3, [r7, #4]
 800dd32:	681b      	ldr	r3, [r3, #0]
 800dd34:	681a      	ldr	r2, [r3, #0]
 800dd36:	687b      	ldr	r3, [r7, #4]
 800dd38:	681b      	ldr	r3, [r3, #0]
 800dd3a:	f042 0201 	orr.w	r2, r2, #1
 800dd3e:	601a      	str	r2, [r3, #0]
 800dd40:	e000      	b.n	800dd44 <HAL_TIM_Base_Start+0xb0>
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 800dd42:	bf00      	nop
  }

  /* Return function status */
  return HAL_OK;
 800dd44:	2300      	movs	r3, #0
}
 800dd46:	4618      	mov	r0, r3
 800dd48:	3714      	adds	r7, #20
 800dd4a:	46bd      	mov	sp, r7
 800dd4c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800dd50:	4770      	bx	lr
 800dd52:	bf00      	nop
 800dd54:	40010000 	.word	0x40010000
 800dd58:	40000400 	.word	0x40000400
 800dd5c:	40000800 	.word	0x40000800
 800dd60:	40000c00 	.word	0x40000c00
 800dd64:	40010400 	.word	0x40010400
 800dd68:	40001800 	.word	0x40001800
 800dd6c:	40014000 	.word	0x40014000
 800dd70:	00010007 	.word	0x00010007

0800dd74 <HAL_TIM_PWM_Init>:
  *         Ex: call @ref HAL_TIM_PWM_DeInit() before HAL_TIM_PWM_Init()
  * @param  htim TIM PWM handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_PWM_Init(TIM_HandleTypeDef *htim)
{
 800dd74:	b580      	push	{r7, lr}
 800dd76:	b082      	sub	sp, #8
 800dd78:	af00      	add	r7, sp, #0
 800dd7a:	6078      	str	r0, [r7, #4]
  /* Check the TIM handle allocation */
  if (htim == NULL)
 800dd7c:	687b      	ldr	r3, [r7, #4]
 800dd7e:	2b00      	cmp	r3, #0
 800dd80:	d101      	bne.n	800dd86 <HAL_TIM_PWM_Init+0x12>
  {
    return HAL_ERROR;
 800dd82:	2301      	movs	r3, #1
 800dd84:	e049      	b.n	800de1a <HAL_TIM_PWM_Init+0xa6>
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
  assert_param(IS_TIM_PERIOD(htim, htim->Init.Period));
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));

  if (htim->State == HAL_TIM_STATE_RESET)
 800dd86:	687b      	ldr	r3, [r7, #4]
 800dd88:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
 800dd8c:	b2db      	uxtb	r3, r3
 800dd8e:	2b00      	cmp	r3, #0
 800dd90:	d106      	bne.n	800dda0 <HAL_TIM_PWM_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    htim->Lock = HAL_UNLOCKED;
 800dd92:	687b      	ldr	r3, [r7, #4]
 800dd94:	2200      	movs	r2, #0
 800dd96:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c
    }
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    htim->PWM_MspInitCallback(htim);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
    HAL_TIM_PWM_MspInit(htim);
 800dd9a:	6878      	ldr	r0, [r7, #4]
 800dd9c:	f000 f841 	bl	800de22 <HAL_TIM_PWM_MspInit>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
  }

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;
 800dda0:	687b      	ldr	r3, [r7, #4]
 800dda2:	2202      	movs	r2, #2
 800dda4:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d

  /* Init the base time for the PWM */
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 800dda8:	687b      	ldr	r3, [r7, #4]
 800ddaa:	681a      	ldr	r2, [r3, #0]
 800ddac:	687b      	ldr	r3, [r7, #4]
 800ddae:	3304      	adds	r3, #4
 800ddb0:	4619      	mov	r1, r3
 800ddb2:	4610      	mov	r0, r2
 800ddb4:	f000 fc94 	bl	800e6e0 <TIM_Base_SetConfig>

  /* Initialize the DMA burst operation state */
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 800ddb8:	687b      	ldr	r3, [r7, #4]
 800ddba:	2201      	movs	r2, #1
 800ddbc:	f883 2048 	strb.w	r2, [r3, #72]	@ 0x48

  /* Initialize the TIM channels state */
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 800ddc0:	687b      	ldr	r3, [r7, #4]
 800ddc2:	2201      	movs	r2, #1
 800ddc4:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e
 800ddc8:	687b      	ldr	r3, [r7, #4]
 800ddca:	2201      	movs	r2, #1
 800ddcc:	f883 203f 	strb.w	r2, [r3, #63]	@ 0x3f
 800ddd0:	687b      	ldr	r3, [r7, #4]
 800ddd2:	2201      	movs	r2, #1
 800ddd4:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
 800ddd8:	687b      	ldr	r3, [r7, #4]
 800ddda:	2201      	movs	r2, #1
 800dddc:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
 800dde0:	687b      	ldr	r3, [r7, #4]
 800dde2:	2201      	movs	r2, #1
 800dde4:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42
 800dde8:	687b      	ldr	r3, [r7, #4]
 800ddea:	2201      	movs	r2, #1
 800ddec:	f883 2043 	strb.w	r2, [r3, #67]	@ 0x43
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 800ddf0:	687b      	ldr	r3, [r7, #4]
 800ddf2:	2201      	movs	r2, #1
 800ddf4:	f883 2044 	strb.w	r2, [r3, #68]	@ 0x44
 800ddf8:	687b      	ldr	r3, [r7, #4]
 800ddfa:	2201      	movs	r2, #1
 800ddfc:	f883 2045 	strb.w	r2, [r3, #69]	@ 0x45
 800de00:	687b      	ldr	r3, [r7, #4]
 800de02:	2201      	movs	r2, #1
 800de04:	f883 2046 	strb.w	r2, [r3, #70]	@ 0x46
 800de08:	687b      	ldr	r3, [r7, #4]
 800de0a:	2201      	movs	r2, #1
 800de0c:	f883 2047 	strb.w	r2, [r3, #71]	@ 0x47

  /* Initialize the TIM state*/
  htim->State = HAL_TIM_STATE_READY;
 800de10:	687b      	ldr	r3, [r7, #4]
 800de12:	2201      	movs	r2, #1
 800de14:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d

  return HAL_OK;
 800de18:	2300      	movs	r3, #0
}
 800de1a:	4618      	mov	r0, r3
 800de1c:	3708      	adds	r7, #8
 800de1e:	46bd      	mov	sp, r7
 800de20:	bd80      	pop	{r7, pc}

0800de22 <HAL_TIM_PWM_MspInit>:
  * @brief  Initializes the TIM PWM MSP.
  * @param  htim TIM PWM handle
  * @retval None
  */
__weak void HAL_TIM_PWM_MspInit(TIM_HandleTypeDef *htim)
{
 800de22:	b480      	push	{r7}
 800de24:	b083      	sub	sp, #12
 800de26:	af00      	add	r7, sp, #0
 800de28:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_PWM_MspInit could be implemented in the user file
   */
}
 800de2a:	bf00      	nop
 800de2c:	370c      	adds	r7, #12
 800de2e:	46bd      	mov	sp, r7
 800de30:	f85d 7b04 	ldr.w	r7, [sp], #4
 800de34:	4770      	bx	lr
	...

0800de38 <HAL_TIM_PWM_Start>:
  *            @arg TIM_CHANNEL_5: TIM Channel 5 selected
  *            @arg TIM_CHANNEL_6: TIM Channel 6 selected
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_PWM_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
{
 800de38:	b580      	push	{r7, lr}
 800de3a:	b084      	sub	sp, #16
 800de3c:	af00      	add	r7, sp, #0
 800de3e:	6078      	str	r0, [r7, #4]
 800de40:	6039      	str	r1, [r7, #0]

  /* Check the parameters */
  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));

  /* Check the TIM channel state */
  if (TIM_CHANNEL_STATE_GET(htim, Channel) != HAL_TIM_CHANNEL_STATE_READY)
 800de42:	683b      	ldr	r3, [r7, #0]
 800de44:	2b00      	cmp	r3, #0
 800de46:	d109      	bne.n	800de5c <HAL_TIM_PWM_Start+0x24>
 800de48:	687b      	ldr	r3, [r7, #4]
 800de4a:	f893 303e 	ldrb.w	r3, [r3, #62]	@ 0x3e
 800de4e:	b2db      	uxtb	r3, r3
 800de50:	2b01      	cmp	r3, #1
 800de52:	bf14      	ite	ne
 800de54:	2301      	movne	r3, #1
 800de56:	2300      	moveq	r3, #0
 800de58:	b2db      	uxtb	r3, r3
 800de5a:	e03c      	b.n	800ded6 <HAL_TIM_PWM_Start+0x9e>
 800de5c:	683b      	ldr	r3, [r7, #0]
 800de5e:	2b04      	cmp	r3, #4
 800de60:	d109      	bne.n	800de76 <HAL_TIM_PWM_Start+0x3e>
 800de62:	687b      	ldr	r3, [r7, #4]
 800de64:	f893 303f 	ldrb.w	r3, [r3, #63]	@ 0x3f
 800de68:	b2db      	uxtb	r3, r3
 800de6a:	2b01      	cmp	r3, #1
 800de6c:	bf14      	ite	ne
 800de6e:	2301      	movne	r3, #1
 800de70:	2300      	moveq	r3, #0
 800de72:	b2db      	uxtb	r3, r3
 800de74:	e02f      	b.n	800ded6 <HAL_TIM_PWM_Start+0x9e>
 800de76:	683b      	ldr	r3, [r7, #0]
 800de78:	2b08      	cmp	r3, #8
 800de7a:	d109      	bne.n	800de90 <HAL_TIM_PWM_Start+0x58>
 800de7c:	687b      	ldr	r3, [r7, #4]
 800de7e:	f893 3040 	ldrb.w	r3, [r3, #64]	@ 0x40
 800de82:	b2db      	uxtb	r3, r3
 800de84:	2b01      	cmp	r3, #1
 800de86:	bf14      	ite	ne
 800de88:	2301      	movne	r3, #1
 800de8a:	2300      	moveq	r3, #0
 800de8c:	b2db      	uxtb	r3, r3
 800de8e:	e022      	b.n	800ded6 <HAL_TIM_PWM_Start+0x9e>
 800de90:	683b      	ldr	r3, [r7, #0]
 800de92:	2b0c      	cmp	r3, #12
 800de94:	d109      	bne.n	800deaa <HAL_TIM_PWM_Start+0x72>
 800de96:	687b      	ldr	r3, [r7, #4]
 800de98:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
 800de9c:	b2db      	uxtb	r3, r3
 800de9e:	2b01      	cmp	r3, #1
 800dea0:	bf14      	ite	ne
 800dea2:	2301      	movne	r3, #1
 800dea4:	2300      	moveq	r3, #0
 800dea6:	b2db      	uxtb	r3, r3
 800dea8:	e015      	b.n	800ded6 <HAL_TIM_PWM_Start+0x9e>
 800deaa:	683b      	ldr	r3, [r7, #0]
 800deac:	2b10      	cmp	r3, #16
 800deae:	d109      	bne.n	800dec4 <HAL_TIM_PWM_Start+0x8c>
 800deb0:	687b      	ldr	r3, [r7, #4]
 800deb2:	f893 3042 	ldrb.w	r3, [r3, #66]	@ 0x42
 800deb6:	b2db      	uxtb	r3, r3
 800deb8:	2b01      	cmp	r3, #1
 800deba:	bf14      	ite	ne
 800debc:	2301      	movne	r3, #1
 800debe:	2300      	moveq	r3, #0
 800dec0:	b2db      	uxtb	r3, r3
 800dec2:	e008      	b.n	800ded6 <HAL_TIM_PWM_Start+0x9e>
 800dec4:	687b      	ldr	r3, [r7, #4]
 800dec6:	f893 3043 	ldrb.w	r3, [r3, #67]	@ 0x43
 800deca:	b2db      	uxtb	r3, r3
 800decc:	2b01      	cmp	r3, #1
 800dece:	bf14      	ite	ne
 800ded0:	2301      	movne	r3, #1
 800ded2:	2300      	moveq	r3, #0
 800ded4:	b2db      	uxtb	r3, r3
 800ded6:	2b00      	cmp	r3, #0
 800ded8:	d001      	beq.n	800dede <HAL_TIM_PWM_Start+0xa6>
  {
    return HAL_ERROR;
 800deda:	2301      	movs	r3, #1
 800dedc:	e0a1      	b.n	800e022 <HAL_TIM_PWM_Start+0x1ea>
  }

  /* Set the TIM channel state */
  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
 800dede:	683b      	ldr	r3, [r7, #0]
 800dee0:	2b00      	cmp	r3, #0
 800dee2:	d104      	bne.n	800deee <HAL_TIM_PWM_Start+0xb6>
 800dee4:	687b      	ldr	r3, [r7, #4]
 800dee6:	2202      	movs	r2, #2
 800dee8:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e
 800deec:	e023      	b.n	800df36 <HAL_TIM_PWM_Start+0xfe>
 800deee:	683b      	ldr	r3, [r7, #0]
 800def0:	2b04      	cmp	r3, #4
 800def2:	d104      	bne.n	800defe <HAL_TIM_PWM_Start+0xc6>
 800def4:	687b      	ldr	r3, [r7, #4]
 800def6:	2202      	movs	r2, #2
 800def8:	f883 203f 	strb.w	r2, [r3, #63]	@ 0x3f
 800defc:	e01b      	b.n	800df36 <HAL_TIM_PWM_Start+0xfe>
 800defe:	683b      	ldr	r3, [r7, #0]
 800df00:	2b08      	cmp	r3, #8
 800df02:	d104      	bne.n	800df0e <HAL_TIM_PWM_Start+0xd6>
 800df04:	687b      	ldr	r3, [r7, #4]
 800df06:	2202      	movs	r2, #2
 800df08:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
 800df0c:	e013      	b.n	800df36 <HAL_TIM_PWM_Start+0xfe>
 800df0e:	683b      	ldr	r3, [r7, #0]
 800df10:	2b0c      	cmp	r3, #12
 800df12:	d104      	bne.n	800df1e <HAL_TIM_PWM_Start+0xe6>
 800df14:	687b      	ldr	r3, [r7, #4]
 800df16:	2202      	movs	r2, #2
 800df18:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
 800df1c:	e00b      	b.n	800df36 <HAL_TIM_PWM_Start+0xfe>
 800df1e:	683b      	ldr	r3, [r7, #0]
 800df20:	2b10      	cmp	r3, #16
 800df22:	d104      	bne.n	800df2e <HAL_TIM_PWM_Start+0xf6>
 800df24:	687b      	ldr	r3, [r7, #4]
 800df26:	2202      	movs	r2, #2
 800df28:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42
 800df2c:	e003      	b.n	800df36 <HAL_TIM_PWM_Start+0xfe>
 800df2e:	687b      	ldr	r3, [r7, #4]
 800df30:	2202      	movs	r2, #2
 800df32:	f883 2043 	strb.w	r2, [r3, #67]	@ 0x43

  /* Enable the Capture compare channel */
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
 800df36:	687b      	ldr	r3, [r7, #4]
 800df38:	681b      	ldr	r3, [r3, #0]
 800df3a:	2201      	movs	r2, #1
 800df3c:	6839      	ldr	r1, [r7, #0]
 800df3e:	4618      	mov	r0, r3
 800df40:	f000 ffe8 	bl	800ef14 <TIM_CCxChannelCmd>

  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
 800df44:	687b      	ldr	r3, [r7, #4]
 800df46:	681b      	ldr	r3, [r3, #0]
 800df48:	4a38      	ldr	r2, [pc, #224]	@ (800e02c <HAL_TIM_PWM_Start+0x1f4>)
 800df4a:	4293      	cmp	r3, r2
 800df4c:	d013      	beq.n	800df76 <HAL_TIM_PWM_Start+0x13e>
 800df4e:	687b      	ldr	r3, [r7, #4]
 800df50:	681b      	ldr	r3, [r3, #0]
 800df52:	4a37      	ldr	r2, [pc, #220]	@ (800e030 <HAL_TIM_PWM_Start+0x1f8>)
 800df54:	4293      	cmp	r3, r2
 800df56:	d00e      	beq.n	800df76 <HAL_TIM_PWM_Start+0x13e>
 800df58:	687b      	ldr	r3, [r7, #4]
 800df5a:	681b      	ldr	r3, [r3, #0]
 800df5c:	4a35      	ldr	r2, [pc, #212]	@ (800e034 <HAL_TIM_PWM_Start+0x1fc>)
 800df5e:	4293      	cmp	r3, r2
 800df60:	d009      	beq.n	800df76 <HAL_TIM_PWM_Start+0x13e>
 800df62:	687b      	ldr	r3, [r7, #4]
 800df64:	681b      	ldr	r3, [r3, #0]
 800df66:	4a34      	ldr	r2, [pc, #208]	@ (800e038 <HAL_TIM_PWM_Start+0x200>)
 800df68:	4293      	cmp	r3, r2
 800df6a:	d004      	beq.n	800df76 <HAL_TIM_PWM_Start+0x13e>
 800df6c:	687b      	ldr	r3, [r7, #4]
 800df6e:	681b      	ldr	r3, [r3, #0]
 800df70:	4a32      	ldr	r2, [pc, #200]	@ (800e03c <HAL_TIM_PWM_Start+0x204>)
 800df72:	4293      	cmp	r3, r2
 800df74:	d101      	bne.n	800df7a <HAL_TIM_PWM_Start+0x142>
 800df76:	2301      	movs	r3, #1
 800df78:	e000      	b.n	800df7c <HAL_TIM_PWM_Start+0x144>
 800df7a:	2300      	movs	r3, #0
 800df7c:	2b00      	cmp	r3, #0
 800df7e:	d007      	beq.n	800df90 <HAL_TIM_PWM_Start+0x158>
  {
    /* Enable the main output */
    __HAL_TIM_MOE_ENABLE(htim);
 800df80:	687b      	ldr	r3, [r7, #4]
 800df82:	681b      	ldr	r3, [r3, #0]
 800df84:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
 800df86:	687b      	ldr	r3, [r7, #4]
 800df88:	681b      	ldr	r3, [r3, #0]
 800df8a:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
 800df8e:	645a      	str	r2, [r3, #68]	@ 0x44
  }

  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 800df90:	687b      	ldr	r3, [r7, #4]
 800df92:	681b      	ldr	r3, [r3, #0]
 800df94:	4a25      	ldr	r2, [pc, #148]	@ (800e02c <HAL_TIM_PWM_Start+0x1f4>)
 800df96:	4293      	cmp	r3, r2
 800df98:	d022      	beq.n	800dfe0 <HAL_TIM_PWM_Start+0x1a8>
 800df9a:	687b      	ldr	r3, [r7, #4]
 800df9c:	681b      	ldr	r3, [r3, #0]
 800df9e:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 800dfa2:	d01d      	beq.n	800dfe0 <HAL_TIM_PWM_Start+0x1a8>
 800dfa4:	687b      	ldr	r3, [r7, #4]
 800dfa6:	681b      	ldr	r3, [r3, #0]
 800dfa8:	4a25      	ldr	r2, [pc, #148]	@ (800e040 <HAL_TIM_PWM_Start+0x208>)
 800dfaa:	4293      	cmp	r3, r2
 800dfac:	d018      	beq.n	800dfe0 <HAL_TIM_PWM_Start+0x1a8>
 800dfae:	687b      	ldr	r3, [r7, #4]
 800dfb0:	681b      	ldr	r3, [r3, #0]
 800dfb2:	4a24      	ldr	r2, [pc, #144]	@ (800e044 <HAL_TIM_PWM_Start+0x20c>)
 800dfb4:	4293      	cmp	r3, r2
 800dfb6:	d013      	beq.n	800dfe0 <HAL_TIM_PWM_Start+0x1a8>
 800dfb8:	687b      	ldr	r3, [r7, #4]
 800dfba:	681b      	ldr	r3, [r3, #0]
 800dfbc:	4a22      	ldr	r2, [pc, #136]	@ (800e048 <HAL_TIM_PWM_Start+0x210>)
 800dfbe:	4293      	cmp	r3, r2
 800dfc0:	d00e      	beq.n	800dfe0 <HAL_TIM_PWM_Start+0x1a8>
 800dfc2:	687b      	ldr	r3, [r7, #4]
 800dfc4:	681b      	ldr	r3, [r3, #0]
 800dfc6:	4a1a      	ldr	r2, [pc, #104]	@ (800e030 <HAL_TIM_PWM_Start+0x1f8>)
 800dfc8:	4293      	cmp	r3, r2
 800dfca:	d009      	beq.n	800dfe0 <HAL_TIM_PWM_Start+0x1a8>
 800dfcc:	687b      	ldr	r3, [r7, #4]
 800dfce:	681b      	ldr	r3, [r3, #0]
 800dfd0:	4a1e      	ldr	r2, [pc, #120]	@ (800e04c <HAL_TIM_PWM_Start+0x214>)
 800dfd2:	4293      	cmp	r3, r2
 800dfd4:	d004      	beq.n	800dfe0 <HAL_TIM_PWM_Start+0x1a8>
 800dfd6:	687b      	ldr	r3, [r7, #4]
 800dfd8:	681b      	ldr	r3, [r3, #0]
 800dfda:	4a16      	ldr	r2, [pc, #88]	@ (800e034 <HAL_TIM_PWM_Start+0x1fc>)
 800dfdc:	4293      	cmp	r3, r2
 800dfde:	d115      	bne.n	800e00c <HAL_TIM_PWM_Start+0x1d4>
  {
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 800dfe0:	687b      	ldr	r3, [r7, #4]
 800dfe2:	681b      	ldr	r3, [r3, #0]
 800dfe4:	689a      	ldr	r2, [r3, #8]
 800dfe6:	4b1a      	ldr	r3, [pc, #104]	@ (800e050 <HAL_TIM_PWM_Start+0x218>)
 800dfe8:	4013      	ands	r3, r2
 800dfea:	60fb      	str	r3, [r7, #12]
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 800dfec:	68fb      	ldr	r3, [r7, #12]
 800dfee:	2b06      	cmp	r3, #6
 800dff0:	d015      	beq.n	800e01e <HAL_TIM_PWM_Start+0x1e6>
 800dff2:	68fb      	ldr	r3, [r7, #12]
 800dff4:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 800dff8:	d011      	beq.n	800e01e <HAL_TIM_PWM_Start+0x1e6>
    {
      __HAL_TIM_ENABLE(htim);
 800dffa:	687b      	ldr	r3, [r7, #4]
 800dffc:	681b      	ldr	r3, [r3, #0]
 800dffe:	681a      	ldr	r2, [r3, #0]
 800e000:	687b      	ldr	r3, [r7, #4]
 800e002:	681b      	ldr	r3, [r3, #0]
 800e004:	f042 0201 	orr.w	r2, r2, #1
 800e008:	601a      	str	r2, [r3, #0]
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 800e00a:	e008      	b.n	800e01e <HAL_TIM_PWM_Start+0x1e6>
    }
  }
  else
  {
    __HAL_TIM_ENABLE(htim);
 800e00c:	687b      	ldr	r3, [r7, #4]
 800e00e:	681b      	ldr	r3, [r3, #0]
 800e010:	681a      	ldr	r2, [r3, #0]
 800e012:	687b      	ldr	r3, [r7, #4]
 800e014:	681b      	ldr	r3, [r3, #0]
 800e016:	f042 0201 	orr.w	r2, r2, #1
 800e01a:	601a      	str	r2, [r3, #0]
 800e01c:	e000      	b.n	800e020 <HAL_TIM_PWM_Start+0x1e8>
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 800e01e:	bf00      	nop
  }

  /* Return function status */
  return HAL_OK;
 800e020:	2300      	movs	r3, #0
}
 800e022:	4618      	mov	r0, r3
 800e024:	3710      	adds	r7, #16
 800e026:	46bd      	mov	sp, r7
 800e028:	bd80      	pop	{r7, pc}
 800e02a:	bf00      	nop
 800e02c:	40010000 	.word	0x40010000
 800e030:	40010400 	.word	0x40010400
 800e034:	40014000 	.word	0x40014000
 800e038:	40014400 	.word	0x40014400
 800e03c:	40014800 	.word	0x40014800
 800e040:	40000400 	.word	0x40000400
 800e044:	40000800 	.word	0x40000800
 800e048:	40000c00 	.word	0x40000c00
 800e04c:	40001800 	.word	0x40001800
 800e050:	00010007 	.word	0x00010007

0800e054 <HAL_TIM_IRQHandler>:
  * @brief  This function handles TIM interrupts requests.
  * @param  htim TIM  handle
  * @retval None
  */
void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
{
 800e054:	b580      	push	{r7, lr}
 800e056:	b084      	sub	sp, #16
 800e058:	af00      	add	r7, sp, #0
 800e05a:	6078      	str	r0, [r7, #4]
  uint32_t itsource = htim->Instance->DIER;
 800e05c:	687b      	ldr	r3, [r7, #4]
 800e05e:	681b      	ldr	r3, [r3, #0]
 800e060:	68db      	ldr	r3, [r3, #12]
 800e062:	60fb      	str	r3, [r7, #12]
  uint32_t itflag   = htim->Instance->SR;
 800e064:	687b      	ldr	r3, [r7, #4]
 800e066:	681b      	ldr	r3, [r3, #0]
 800e068:	691b      	ldr	r3, [r3, #16]
 800e06a:	60bb      	str	r3, [r7, #8]

  /* Capture compare 1 event */
  if ((itflag & (TIM_FLAG_CC1)) == (TIM_FLAG_CC1))
 800e06c:	68bb      	ldr	r3, [r7, #8]
 800e06e:	f003 0302 	and.w	r3, r3, #2
 800e072:	2b00      	cmp	r3, #0
 800e074:	d020      	beq.n	800e0b8 <HAL_TIM_IRQHandler+0x64>
  {
    if ((itsource & (TIM_IT_CC1)) == (TIM_IT_CC1))
 800e076:	68fb      	ldr	r3, [r7, #12]
 800e078:	f003 0302 	and.w	r3, r3, #2
 800e07c:	2b00      	cmp	r3, #0
 800e07e:	d01b      	beq.n	800e0b8 <HAL_TIM_IRQHandler+0x64>
    {
      {
        __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC1);
 800e080:	687b      	ldr	r3, [r7, #4]
 800e082:	681b      	ldr	r3, [r3, #0]
 800e084:	f06f 0202 	mvn.w	r2, #2
 800e088:	611a      	str	r2, [r3, #16]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 800e08a:	687b      	ldr	r3, [r7, #4]
 800e08c:	2201      	movs	r2, #1
 800e08e:	771a      	strb	r2, [r3, #28]

        /* Input capture event */
        if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
 800e090:	687b      	ldr	r3, [r7, #4]
 800e092:	681b      	ldr	r3, [r3, #0]
 800e094:	699b      	ldr	r3, [r3, #24]
 800e096:	f003 0303 	and.w	r3, r3, #3
 800e09a:	2b00      	cmp	r3, #0
 800e09c:	d003      	beq.n	800e0a6 <HAL_TIM_IRQHandler+0x52>
        {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
          htim->IC_CaptureCallback(htim);
#else
          HAL_TIM_IC_CaptureCallback(htim);
 800e09e:	6878      	ldr	r0, [r7, #4]
 800e0a0:	f000 fb00 	bl	800e6a4 <HAL_TIM_IC_CaptureCallback>
 800e0a4:	e005      	b.n	800e0b2 <HAL_TIM_IRQHandler+0x5e>
        {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
          htim->OC_DelayElapsedCallback(htim);
          htim->PWM_PulseFinishedCallback(htim);
#else
          HAL_TIM_OC_DelayElapsedCallback(htim);
 800e0a6:	6878      	ldr	r0, [r7, #4]
 800e0a8:	f000 faf2 	bl	800e690 <HAL_TIM_OC_DelayElapsedCallback>
          HAL_TIM_PWM_PulseFinishedCallback(htim);
 800e0ac:	6878      	ldr	r0, [r7, #4]
 800e0ae:	f000 fb03 	bl	800e6b8 <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
        }
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 800e0b2:	687b      	ldr	r3, [r7, #4]
 800e0b4:	2200      	movs	r2, #0
 800e0b6:	771a      	strb	r2, [r3, #28]
      }
    }
  }
  /* Capture compare 2 event */
  if ((itflag & (TIM_FLAG_CC2)) == (TIM_FLAG_CC2))
 800e0b8:	68bb      	ldr	r3, [r7, #8]
 800e0ba:	f003 0304 	and.w	r3, r3, #4
 800e0be:	2b00      	cmp	r3, #0
 800e0c0:	d020      	beq.n	800e104 <HAL_TIM_IRQHandler+0xb0>
  {
    if ((itsource & (TIM_IT_CC2)) == (TIM_IT_CC2))
 800e0c2:	68fb      	ldr	r3, [r7, #12]
 800e0c4:	f003 0304 	and.w	r3, r3, #4
 800e0c8:	2b00      	cmp	r3, #0
 800e0ca:	d01b      	beq.n	800e104 <HAL_TIM_IRQHandler+0xb0>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC2);
 800e0cc:	687b      	ldr	r3, [r7, #4]
 800e0ce:	681b      	ldr	r3, [r3, #0]
 800e0d0:	f06f 0204 	mvn.w	r2, #4
 800e0d4:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 800e0d6:	687b      	ldr	r3, [r7, #4]
 800e0d8:	2202      	movs	r2, #2
 800e0da:	771a      	strb	r2, [r3, #28]
      /* Input capture event */
      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 800e0dc:	687b      	ldr	r3, [r7, #4]
 800e0de:	681b      	ldr	r3, [r3, #0]
 800e0e0:	699b      	ldr	r3, [r3, #24]
 800e0e2:	f403 7340 	and.w	r3, r3, #768	@ 0x300
 800e0e6:	2b00      	cmp	r3, #0
 800e0e8:	d003      	beq.n	800e0f2 <HAL_TIM_IRQHandler+0x9e>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
 800e0ea:	6878      	ldr	r0, [r7, #4]
 800e0ec:	f000 fada 	bl	800e6a4 <HAL_TIM_IC_CaptureCallback>
 800e0f0:	e005      	b.n	800e0fe <HAL_TIM_IRQHandler+0xaa>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->OC_DelayElapsedCallback(htim);
        htim->PWM_PulseFinishedCallback(htim);
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
 800e0f2:	6878      	ldr	r0, [r7, #4]
 800e0f4:	f000 facc 	bl	800e690 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 800e0f8:	6878      	ldr	r0, [r7, #4]
 800e0fa:	f000 fadd 	bl	800e6b8 <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 800e0fe:	687b      	ldr	r3, [r7, #4]
 800e100:	2200      	movs	r2, #0
 800e102:	771a      	strb	r2, [r3, #28]
    }
  }
  /* Capture compare 3 event */
  if ((itflag & (TIM_FLAG_CC3)) == (TIM_FLAG_CC3))
 800e104:	68bb      	ldr	r3, [r7, #8]
 800e106:	f003 0308 	and.w	r3, r3, #8
 800e10a:	2b00      	cmp	r3, #0
 800e10c:	d020      	beq.n	800e150 <HAL_TIM_IRQHandler+0xfc>
  {
    if ((itsource & (TIM_IT_CC3)) == (TIM_IT_CC3))
 800e10e:	68fb      	ldr	r3, [r7, #12]
 800e110:	f003 0308 	and.w	r3, r3, #8
 800e114:	2b00      	cmp	r3, #0
 800e116:	d01b      	beq.n	800e150 <HAL_TIM_IRQHandler+0xfc>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC3);
 800e118:	687b      	ldr	r3, [r7, #4]
 800e11a:	681b      	ldr	r3, [r3, #0]
 800e11c:	f06f 0208 	mvn.w	r2, #8
 800e120:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 800e122:	687b      	ldr	r3, [r7, #4]
 800e124:	2204      	movs	r2, #4
 800e126:	771a      	strb	r2, [r3, #28]
      /* Input capture event */
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 800e128:	687b      	ldr	r3, [r7, #4]
 800e12a:	681b      	ldr	r3, [r3, #0]
 800e12c:	69db      	ldr	r3, [r3, #28]
 800e12e:	f003 0303 	and.w	r3, r3, #3
 800e132:	2b00      	cmp	r3, #0
 800e134:	d003      	beq.n	800e13e <HAL_TIM_IRQHandler+0xea>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
 800e136:	6878      	ldr	r0, [r7, #4]
 800e138:	f000 fab4 	bl	800e6a4 <HAL_TIM_IC_CaptureCallback>
 800e13c:	e005      	b.n	800e14a <HAL_TIM_IRQHandler+0xf6>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->OC_DelayElapsedCallback(htim);
        htim->PWM_PulseFinishedCallback(htim);
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
 800e13e:	6878      	ldr	r0, [r7, #4]
 800e140:	f000 faa6 	bl	800e690 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 800e144:	6878      	ldr	r0, [r7, #4]
 800e146:	f000 fab7 	bl	800e6b8 <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 800e14a:	687b      	ldr	r3, [r7, #4]
 800e14c:	2200      	movs	r2, #0
 800e14e:	771a      	strb	r2, [r3, #28]
    }
  }
  /* Capture compare 4 event */
  if ((itflag & (TIM_FLAG_CC4)) == (TIM_FLAG_CC4))
 800e150:	68bb      	ldr	r3, [r7, #8]
 800e152:	f003 0310 	and.w	r3, r3, #16
 800e156:	2b00      	cmp	r3, #0
 800e158:	d020      	beq.n	800e19c <HAL_TIM_IRQHandler+0x148>
  {
    if ((itsource & (TIM_IT_CC4)) == (TIM_IT_CC4))
 800e15a:	68fb      	ldr	r3, [r7, #12]
 800e15c:	f003 0310 	and.w	r3, r3, #16
 800e160:	2b00      	cmp	r3, #0
 800e162:	d01b      	beq.n	800e19c <HAL_TIM_IRQHandler+0x148>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC4);
 800e164:	687b      	ldr	r3, [r7, #4]
 800e166:	681b      	ldr	r3, [r3, #0]
 800e168:	f06f 0210 	mvn.w	r2, #16
 800e16c:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 800e16e:	687b      	ldr	r3, [r7, #4]
 800e170:	2208      	movs	r2, #8
 800e172:	771a      	strb	r2, [r3, #28]
      /* Input capture event */
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 800e174:	687b      	ldr	r3, [r7, #4]
 800e176:	681b      	ldr	r3, [r3, #0]
 800e178:	69db      	ldr	r3, [r3, #28]
 800e17a:	f403 7340 	and.w	r3, r3, #768	@ 0x300
 800e17e:	2b00      	cmp	r3, #0
 800e180:	d003      	beq.n	800e18a <HAL_TIM_IRQHandler+0x136>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
 800e182:	6878      	ldr	r0, [r7, #4]
 800e184:	f000 fa8e 	bl	800e6a4 <HAL_TIM_IC_CaptureCallback>
 800e188:	e005      	b.n	800e196 <HAL_TIM_IRQHandler+0x142>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->OC_DelayElapsedCallback(htim);
        htim->PWM_PulseFinishedCallback(htim);
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
 800e18a:	6878      	ldr	r0, [r7, #4]
 800e18c:	f000 fa80 	bl	800e690 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 800e190:	6878      	ldr	r0, [r7, #4]
 800e192:	f000 fa91 	bl	800e6b8 <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 800e196:	687b      	ldr	r3, [r7, #4]
 800e198:	2200      	movs	r2, #0
 800e19a:	771a      	strb	r2, [r3, #28]
    }
  }
  /* TIM Update event */
  if ((itflag & (TIM_FLAG_UPDATE)) == (TIM_FLAG_UPDATE))
 800e19c:	68bb      	ldr	r3, [r7, #8]
 800e19e:	f003 0301 	and.w	r3, r3, #1
 800e1a2:	2b00      	cmp	r3, #0
 800e1a4:	d00c      	beq.n	800e1c0 <HAL_TIM_IRQHandler+0x16c>
  {
    if ((itsource & (TIM_IT_UPDATE)) == (TIM_IT_UPDATE))
 800e1a6:	68fb      	ldr	r3, [r7, #12]
 800e1a8:	f003 0301 	and.w	r3, r3, #1
 800e1ac:	2b00      	cmp	r3, #0
 800e1ae:	d007      	beq.n	800e1c0 <HAL_TIM_IRQHandler+0x16c>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_UPDATE);
 800e1b0:	687b      	ldr	r3, [r7, #4]
 800e1b2:	681b      	ldr	r3, [r3, #0]
 800e1b4:	f06f 0201 	mvn.w	r2, #1
 800e1b8:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->PeriodElapsedCallback(htim);
#else
      HAL_TIM_PeriodElapsedCallback(htim);
 800e1ba:	6878      	ldr	r0, [r7, #4]
 800e1bc:	f000 fa5e 	bl	800e67c <HAL_TIM_PeriodElapsedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Break input event */
  if (((itflag & (TIM_FLAG_BREAK)) == (TIM_FLAG_BREAK)) || \
 800e1c0:	68bb      	ldr	r3, [r7, #8]
 800e1c2:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 800e1c6:	2b00      	cmp	r3, #0
 800e1c8:	d104      	bne.n	800e1d4 <HAL_TIM_IRQHandler+0x180>
      ((itflag & (TIM_FLAG_SYSTEM_BREAK)) == (TIM_FLAG_SYSTEM_BREAK)))
 800e1ca:	68bb      	ldr	r3, [r7, #8]
 800e1cc:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
  if (((itflag & (TIM_FLAG_BREAK)) == (TIM_FLAG_BREAK)) || \
 800e1d0:	2b00      	cmp	r3, #0
 800e1d2:	d00c      	beq.n	800e1ee <HAL_TIM_IRQHandler+0x19a>
  {
    if ((itsource & (TIM_IT_BREAK)) == (TIM_IT_BREAK))
 800e1d4:	68fb      	ldr	r3, [r7, #12]
 800e1d6:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 800e1da:	2b00      	cmp	r3, #0
 800e1dc:	d007      	beq.n	800e1ee <HAL_TIM_IRQHandler+0x19a>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_BREAK | TIM_FLAG_SYSTEM_BREAK);
 800e1de:	687b      	ldr	r3, [r7, #4]
 800e1e0:	681b      	ldr	r3, [r3, #0]
 800e1e2:	f46f 5202 	mvn.w	r2, #8320	@ 0x2080
 800e1e6:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->BreakCallback(htim);
#else
      HAL_TIMEx_BreakCallback(htim);
 800e1e8:	6878      	ldr	r0, [r7, #4]
 800e1ea:	f000 ffdd 	bl	800f1a8 <HAL_TIMEx_BreakCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Break2 input event */
  if ((itflag & (TIM_FLAG_BREAK2)) == (TIM_FLAG_BREAK2))
 800e1ee:	68bb      	ldr	r3, [r7, #8]
 800e1f0:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 800e1f4:	2b00      	cmp	r3, #0
 800e1f6:	d00c      	beq.n	800e212 <HAL_TIM_IRQHandler+0x1be>
  {
    if ((itsource & (TIM_IT_BREAK)) == (TIM_IT_BREAK))
 800e1f8:	68fb      	ldr	r3, [r7, #12]
 800e1fa:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 800e1fe:	2b00      	cmp	r3, #0
 800e200:	d007      	beq.n	800e212 <HAL_TIM_IRQHandler+0x1be>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_BREAK2);
 800e202:	687b      	ldr	r3, [r7, #4]
 800e204:	681b      	ldr	r3, [r3, #0]
 800e206:	f46f 7280 	mvn.w	r2, #256	@ 0x100
 800e20a:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->Break2Callback(htim);
#else
      HAL_TIMEx_Break2Callback(htim);
 800e20c:	6878      	ldr	r0, [r7, #4]
 800e20e:	f000 ffd5 	bl	800f1bc <HAL_TIMEx_Break2Callback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Trigger detection event */
  if ((itflag & (TIM_FLAG_TRIGGER)) == (TIM_FLAG_TRIGGER))
 800e212:	68bb      	ldr	r3, [r7, #8]
 800e214:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 800e218:	2b00      	cmp	r3, #0
 800e21a:	d00c      	beq.n	800e236 <HAL_TIM_IRQHandler+0x1e2>
  {
    if ((itsource & (TIM_IT_TRIGGER)) == (TIM_IT_TRIGGER))
 800e21c:	68fb      	ldr	r3, [r7, #12]
 800e21e:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 800e222:	2b00      	cmp	r3, #0
 800e224:	d007      	beq.n	800e236 <HAL_TIM_IRQHandler+0x1e2>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_TRIGGER);
 800e226:	687b      	ldr	r3, [r7, #4]
 800e228:	681b      	ldr	r3, [r3, #0]
 800e22a:	f06f 0240 	mvn.w	r2, #64	@ 0x40
 800e22e:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->TriggerCallback(htim);
#else
      HAL_TIM_TriggerCallback(htim);
 800e230:	6878      	ldr	r0, [r7, #4]
 800e232:	f000 fa4b 	bl	800e6cc <HAL_TIM_TriggerCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM commutation event */
  if ((itflag & (TIM_FLAG_COM)) == (TIM_FLAG_COM))
 800e236:	68bb      	ldr	r3, [r7, #8]
 800e238:	f003 0320 	and.w	r3, r3, #32
 800e23c:	2b00      	cmp	r3, #0
 800e23e:	d00c      	beq.n	800e25a <HAL_TIM_IRQHandler+0x206>
  {
    if ((itsource & (TIM_IT_COM)) == (TIM_IT_COM))
 800e240:	68fb      	ldr	r3, [r7, #12]
 800e242:	f003 0320 	and.w	r3, r3, #32
 800e246:	2b00      	cmp	r3, #0
 800e248:	d007      	beq.n	800e25a <HAL_TIM_IRQHandler+0x206>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_COM);
 800e24a:	687b      	ldr	r3, [r7, #4]
 800e24c:	681b      	ldr	r3, [r3, #0]
 800e24e:	f06f 0220 	mvn.w	r2, #32
 800e252:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->CommutationCallback(htim);
#else
      HAL_TIMEx_CommutCallback(htim);
 800e254:	6878      	ldr	r0, [r7, #4]
 800e256:	f000 ff9d 	bl	800f194 <HAL_TIMEx_CommutCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
}
 800e25a:	bf00      	nop
 800e25c:	3710      	adds	r7, #16
 800e25e:	46bd      	mov	sp, r7
 800e260:	bd80      	pop	{r7, pc}
	...

0800e264 <HAL_TIM_PWM_ConfigChannel>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_PWM_ConfigChannel(TIM_HandleTypeDef *htim,
                                            const TIM_OC_InitTypeDef *sConfig,
                                            uint32_t Channel)
{
 800e264:	b580      	push	{r7, lr}
 800e266:	b086      	sub	sp, #24
 800e268:	af00      	add	r7, sp, #0
 800e26a:	60f8      	str	r0, [r7, #12]
 800e26c:	60b9      	str	r1, [r7, #8]
 800e26e:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
 800e270:	2300      	movs	r3, #0
 800e272:	75fb      	strb	r3, [r7, #23]
  assert_param(IS_TIM_PWM_MODE(sConfig->OCMode));
  assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
  assert_param(IS_TIM_FAST_STATE(sConfig->OCFastMode));

  /* Process Locked */
  __HAL_LOCK(htim);
 800e274:	68fb      	ldr	r3, [r7, #12]
 800e276:	f893 303c 	ldrb.w	r3, [r3, #60]	@ 0x3c
 800e27a:	2b01      	cmp	r3, #1
 800e27c:	d101      	bne.n	800e282 <HAL_TIM_PWM_ConfigChannel+0x1e>
 800e27e:	2302      	movs	r3, #2
 800e280:	e0ff      	b.n	800e482 <HAL_TIM_PWM_ConfigChannel+0x21e>
 800e282:	68fb      	ldr	r3, [r7, #12]
 800e284:	2201      	movs	r2, #1
 800e286:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c

  switch (Channel)
 800e28a:	687b      	ldr	r3, [r7, #4]
 800e28c:	2b14      	cmp	r3, #20
 800e28e:	f200 80f0 	bhi.w	800e472 <HAL_TIM_PWM_ConfigChannel+0x20e>
 800e292:	a201      	add	r2, pc, #4	@ (adr r2, 800e298 <HAL_TIM_PWM_ConfigChannel+0x34>)
 800e294:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800e298:	0800e2ed 	.word	0x0800e2ed
 800e29c:	0800e473 	.word	0x0800e473
 800e2a0:	0800e473 	.word	0x0800e473
 800e2a4:	0800e473 	.word	0x0800e473
 800e2a8:	0800e32d 	.word	0x0800e32d
 800e2ac:	0800e473 	.word	0x0800e473
 800e2b0:	0800e473 	.word	0x0800e473
 800e2b4:	0800e473 	.word	0x0800e473
 800e2b8:	0800e36f 	.word	0x0800e36f
 800e2bc:	0800e473 	.word	0x0800e473
 800e2c0:	0800e473 	.word	0x0800e473
 800e2c4:	0800e473 	.word	0x0800e473
 800e2c8:	0800e3af 	.word	0x0800e3af
 800e2cc:	0800e473 	.word	0x0800e473
 800e2d0:	0800e473 	.word	0x0800e473
 800e2d4:	0800e473 	.word	0x0800e473
 800e2d8:	0800e3f1 	.word	0x0800e3f1
 800e2dc:	0800e473 	.word	0x0800e473
 800e2e0:	0800e473 	.word	0x0800e473
 800e2e4:	0800e473 	.word	0x0800e473
 800e2e8:	0800e431 	.word	0x0800e431
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));

      /* Configure the Channel 1 in PWM mode */
      TIM_OC1_SetConfig(htim->Instance, sConfig);
 800e2ec:	68fb      	ldr	r3, [r7, #12]
 800e2ee:	681b      	ldr	r3, [r3, #0]
 800e2f0:	68b9      	ldr	r1, [r7, #8]
 800e2f2:	4618      	mov	r0, r3
 800e2f4:	f000 fa9a 	bl	800e82c <TIM_OC1_SetConfig>

      /* Set the Preload enable bit for channel1 */
      htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
 800e2f8:	68fb      	ldr	r3, [r7, #12]
 800e2fa:	681b      	ldr	r3, [r3, #0]
 800e2fc:	699a      	ldr	r2, [r3, #24]
 800e2fe:	68fb      	ldr	r3, [r7, #12]
 800e300:	681b      	ldr	r3, [r3, #0]
 800e302:	f042 0208 	orr.w	r2, r2, #8
 800e306:	619a      	str	r2, [r3, #24]

      /* Configure the Output Fast mode */
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
 800e308:	68fb      	ldr	r3, [r7, #12]
 800e30a:	681b      	ldr	r3, [r3, #0]
 800e30c:	699a      	ldr	r2, [r3, #24]
 800e30e:	68fb      	ldr	r3, [r7, #12]
 800e310:	681b      	ldr	r3, [r3, #0]
 800e312:	f022 0204 	bic.w	r2, r2, #4
 800e316:	619a      	str	r2, [r3, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode;
 800e318:	68fb      	ldr	r3, [r7, #12]
 800e31a:	681b      	ldr	r3, [r3, #0]
 800e31c:	6999      	ldr	r1, [r3, #24]
 800e31e:	68bb      	ldr	r3, [r7, #8]
 800e320:	691a      	ldr	r2, [r3, #16]
 800e322:	68fb      	ldr	r3, [r7, #12]
 800e324:	681b      	ldr	r3, [r3, #0]
 800e326:	430a      	orrs	r2, r1
 800e328:	619a      	str	r2, [r3, #24]
      break;
 800e32a:	e0a5      	b.n	800e478 <HAL_TIM_PWM_ConfigChannel+0x214>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));

      /* Configure the Channel 2 in PWM mode */
      TIM_OC2_SetConfig(htim->Instance, sConfig);
 800e32c:	68fb      	ldr	r3, [r7, #12]
 800e32e:	681b      	ldr	r3, [r3, #0]
 800e330:	68b9      	ldr	r1, [r7, #8]
 800e332:	4618      	mov	r0, r3
 800e334:	f000 fb0a 	bl	800e94c <TIM_OC2_SetConfig>

      /* Set the Preload enable bit for channel2 */
      htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
 800e338:	68fb      	ldr	r3, [r7, #12]
 800e33a:	681b      	ldr	r3, [r3, #0]
 800e33c:	699a      	ldr	r2, [r3, #24]
 800e33e:	68fb      	ldr	r3, [r7, #12]
 800e340:	681b      	ldr	r3, [r3, #0]
 800e342:	f442 6200 	orr.w	r2, r2, #2048	@ 0x800
 800e346:	619a      	str	r2, [r3, #24]

      /* Configure the Output Fast mode */
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
 800e348:	68fb      	ldr	r3, [r7, #12]
 800e34a:	681b      	ldr	r3, [r3, #0]
 800e34c:	699a      	ldr	r2, [r3, #24]
 800e34e:	68fb      	ldr	r3, [r7, #12]
 800e350:	681b      	ldr	r3, [r3, #0]
 800e352:	f422 6280 	bic.w	r2, r2, #1024	@ 0x400
 800e356:	619a      	str	r2, [r3, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode << 8U;
 800e358:	68fb      	ldr	r3, [r7, #12]
 800e35a:	681b      	ldr	r3, [r3, #0]
 800e35c:	6999      	ldr	r1, [r3, #24]
 800e35e:	68bb      	ldr	r3, [r7, #8]
 800e360:	691b      	ldr	r3, [r3, #16]
 800e362:	021a      	lsls	r2, r3, #8
 800e364:	68fb      	ldr	r3, [r7, #12]
 800e366:	681b      	ldr	r3, [r3, #0]
 800e368:	430a      	orrs	r2, r1
 800e36a:	619a      	str	r2, [r3, #24]
      break;
 800e36c:	e084      	b.n	800e478 <HAL_TIM_PWM_ConfigChannel+0x214>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));

      /* Configure the Channel 3 in PWM mode */
      TIM_OC3_SetConfig(htim->Instance, sConfig);
 800e36e:	68fb      	ldr	r3, [r7, #12]
 800e370:	681b      	ldr	r3, [r3, #0]
 800e372:	68b9      	ldr	r1, [r7, #8]
 800e374:	4618      	mov	r0, r3
 800e376:	f000 fb73 	bl	800ea60 <TIM_OC3_SetConfig>

      /* Set the Preload enable bit for channel3 */
      htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
 800e37a:	68fb      	ldr	r3, [r7, #12]
 800e37c:	681b      	ldr	r3, [r3, #0]
 800e37e:	69da      	ldr	r2, [r3, #28]
 800e380:	68fb      	ldr	r3, [r7, #12]
 800e382:	681b      	ldr	r3, [r3, #0]
 800e384:	f042 0208 	orr.w	r2, r2, #8
 800e388:	61da      	str	r2, [r3, #28]

      /* Configure the Output Fast mode */
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
 800e38a:	68fb      	ldr	r3, [r7, #12]
 800e38c:	681b      	ldr	r3, [r3, #0]
 800e38e:	69da      	ldr	r2, [r3, #28]
 800e390:	68fb      	ldr	r3, [r7, #12]
 800e392:	681b      	ldr	r3, [r3, #0]
 800e394:	f022 0204 	bic.w	r2, r2, #4
 800e398:	61da      	str	r2, [r3, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode;
 800e39a:	68fb      	ldr	r3, [r7, #12]
 800e39c:	681b      	ldr	r3, [r3, #0]
 800e39e:	69d9      	ldr	r1, [r3, #28]
 800e3a0:	68bb      	ldr	r3, [r7, #8]
 800e3a2:	691a      	ldr	r2, [r3, #16]
 800e3a4:	68fb      	ldr	r3, [r7, #12]
 800e3a6:	681b      	ldr	r3, [r3, #0]
 800e3a8:	430a      	orrs	r2, r1
 800e3aa:	61da      	str	r2, [r3, #28]
      break;
 800e3ac:	e064      	b.n	800e478 <HAL_TIM_PWM_ConfigChannel+0x214>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));

      /* Configure the Channel 4 in PWM mode */
      TIM_OC4_SetConfig(htim->Instance, sConfig);
 800e3ae:	68fb      	ldr	r3, [r7, #12]
 800e3b0:	681b      	ldr	r3, [r3, #0]
 800e3b2:	68b9      	ldr	r1, [r7, #8]
 800e3b4:	4618      	mov	r0, r3
 800e3b6:	f000 fbdb 	bl	800eb70 <TIM_OC4_SetConfig>

      /* Set the Preload enable bit for channel4 */
      htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
 800e3ba:	68fb      	ldr	r3, [r7, #12]
 800e3bc:	681b      	ldr	r3, [r3, #0]
 800e3be:	69da      	ldr	r2, [r3, #28]
 800e3c0:	68fb      	ldr	r3, [r7, #12]
 800e3c2:	681b      	ldr	r3, [r3, #0]
 800e3c4:	f442 6200 	orr.w	r2, r2, #2048	@ 0x800
 800e3c8:	61da      	str	r2, [r3, #28]

      /* Configure the Output Fast mode */
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
 800e3ca:	68fb      	ldr	r3, [r7, #12]
 800e3cc:	681b      	ldr	r3, [r3, #0]
 800e3ce:	69da      	ldr	r2, [r3, #28]
 800e3d0:	68fb      	ldr	r3, [r7, #12]
 800e3d2:	681b      	ldr	r3, [r3, #0]
 800e3d4:	f422 6280 	bic.w	r2, r2, #1024	@ 0x400
 800e3d8:	61da      	str	r2, [r3, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode << 8U;
 800e3da:	68fb      	ldr	r3, [r7, #12]
 800e3dc:	681b      	ldr	r3, [r3, #0]
 800e3de:	69d9      	ldr	r1, [r3, #28]
 800e3e0:	68bb      	ldr	r3, [r7, #8]
 800e3e2:	691b      	ldr	r3, [r3, #16]
 800e3e4:	021a      	lsls	r2, r3, #8
 800e3e6:	68fb      	ldr	r3, [r7, #12]
 800e3e8:	681b      	ldr	r3, [r3, #0]
 800e3ea:	430a      	orrs	r2, r1
 800e3ec:	61da      	str	r2, [r3, #28]
      break;
 800e3ee:	e043      	b.n	800e478 <HAL_TIM_PWM_ConfigChannel+0x214>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC5_INSTANCE(htim->Instance));

      /* Configure the Channel 5 in PWM mode */
      TIM_OC5_SetConfig(htim->Instance, sConfig);
 800e3f0:	68fb      	ldr	r3, [r7, #12]
 800e3f2:	681b      	ldr	r3, [r3, #0]
 800e3f4:	68b9      	ldr	r1, [r7, #8]
 800e3f6:	4618      	mov	r0, r3
 800e3f8:	f000 fc24 	bl	800ec44 <TIM_OC5_SetConfig>

      /* Set the Preload enable bit for channel5*/
      htim->Instance->CCMR3 |= TIM_CCMR3_OC5PE;
 800e3fc:	68fb      	ldr	r3, [r7, #12]
 800e3fe:	681b      	ldr	r3, [r3, #0]
 800e400:	6d5a      	ldr	r2, [r3, #84]	@ 0x54
 800e402:	68fb      	ldr	r3, [r7, #12]
 800e404:	681b      	ldr	r3, [r3, #0]
 800e406:	f042 0208 	orr.w	r2, r2, #8
 800e40a:	655a      	str	r2, [r3, #84]	@ 0x54

      /* Configure the Output Fast mode */
      htim->Instance->CCMR3 &= ~TIM_CCMR3_OC5FE;
 800e40c:	68fb      	ldr	r3, [r7, #12]
 800e40e:	681b      	ldr	r3, [r3, #0]
 800e410:	6d5a      	ldr	r2, [r3, #84]	@ 0x54
 800e412:	68fb      	ldr	r3, [r7, #12]
 800e414:	681b      	ldr	r3, [r3, #0]
 800e416:	f022 0204 	bic.w	r2, r2, #4
 800e41a:	655a      	str	r2, [r3, #84]	@ 0x54
      htim->Instance->CCMR3 |= sConfig->OCFastMode;
 800e41c:	68fb      	ldr	r3, [r7, #12]
 800e41e:	681b      	ldr	r3, [r3, #0]
 800e420:	6d59      	ldr	r1, [r3, #84]	@ 0x54
 800e422:	68bb      	ldr	r3, [r7, #8]
 800e424:	691a      	ldr	r2, [r3, #16]
 800e426:	68fb      	ldr	r3, [r7, #12]
 800e428:	681b      	ldr	r3, [r3, #0]
 800e42a:	430a      	orrs	r2, r1
 800e42c:	655a      	str	r2, [r3, #84]	@ 0x54
      break;
 800e42e:	e023      	b.n	800e478 <HAL_TIM_PWM_ConfigChannel+0x214>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC6_INSTANCE(htim->Instance));

      /* Configure the Channel 6 in PWM mode */
      TIM_OC6_SetConfig(htim->Instance, sConfig);
 800e430:	68fb      	ldr	r3, [r7, #12]
 800e432:	681b      	ldr	r3, [r3, #0]
 800e434:	68b9      	ldr	r1, [r7, #8]
 800e436:	4618      	mov	r0, r3
 800e438:	f000 fc68 	bl	800ed0c <TIM_OC6_SetConfig>

      /* Set the Preload enable bit for channel6 */
      htim->Instance->CCMR3 |= TIM_CCMR3_OC6PE;
 800e43c:	68fb      	ldr	r3, [r7, #12]
 800e43e:	681b      	ldr	r3, [r3, #0]
 800e440:	6d5a      	ldr	r2, [r3, #84]	@ 0x54
 800e442:	68fb      	ldr	r3, [r7, #12]
 800e444:	681b      	ldr	r3, [r3, #0]
 800e446:	f442 6200 	orr.w	r2, r2, #2048	@ 0x800
 800e44a:	655a      	str	r2, [r3, #84]	@ 0x54

      /* Configure the Output Fast mode */
      htim->Instance->CCMR3 &= ~TIM_CCMR3_OC6FE;
 800e44c:	68fb      	ldr	r3, [r7, #12]
 800e44e:	681b      	ldr	r3, [r3, #0]
 800e450:	6d5a      	ldr	r2, [r3, #84]	@ 0x54
 800e452:	68fb      	ldr	r3, [r7, #12]
 800e454:	681b      	ldr	r3, [r3, #0]
 800e456:	f422 6280 	bic.w	r2, r2, #1024	@ 0x400
 800e45a:	655a      	str	r2, [r3, #84]	@ 0x54
      htim->Instance->CCMR3 |= sConfig->OCFastMode << 8U;
 800e45c:	68fb      	ldr	r3, [r7, #12]
 800e45e:	681b      	ldr	r3, [r3, #0]
 800e460:	6d59      	ldr	r1, [r3, #84]	@ 0x54
 800e462:	68bb      	ldr	r3, [r7, #8]
 800e464:	691b      	ldr	r3, [r3, #16]
 800e466:	021a      	lsls	r2, r3, #8
 800e468:	68fb      	ldr	r3, [r7, #12]
 800e46a:	681b      	ldr	r3, [r3, #0]
 800e46c:	430a      	orrs	r2, r1
 800e46e:	655a      	str	r2, [r3, #84]	@ 0x54
      break;
 800e470:	e002      	b.n	800e478 <HAL_TIM_PWM_ConfigChannel+0x214>
    }

    default:
      status = HAL_ERROR;
 800e472:	2301      	movs	r3, #1
 800e474:	75fb      	strb	r3, [r7, #23]
      break;
 800e476:	bf00      	nop
  }

  __HAL_UNLOCK(htim);
 800e478:	68fb      	ldr	r3, [r7, #12]
 800e47a:	2200      	movs	r2, #0
 800e47c:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c

  return status;
 800e480:	7dfb      	ldrb	r3, [r7, #23]
}
 800e482:	4618      	mov	r0, r3
 800e484:	3718      	adds	r7, #24
 800e486:	46bd      	mov	sp, r7
 800e488:	bd80      	pop	{r7, pc}
 800e48a:	bf00      	nop

0800e48c <HAL_TIM_ConfigClockSource>:
  * @param  sClockSourceConfig pointer to a TIM_ClockConfigTypeDef structure that
  *         contains the clock source information for the TIM peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_ConfigClockSource(TIM_HandleTypeDef *htim, const TIM_ClockConfigTypeDef *sClockSourceConfig)
{
 800e48c:	b580      	push	{r7, lr}
 800e48e:	b084      	sub	sp, #16
 800e490:	af00      	add	r7, sp, #0
 800e492:	6078      	str	r0, [r7, #4]
 800e494:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
 800e496:	2300      	movs	r3, #0
 800e498:	73fb      	strb	r3, [r7, #15]
  uint32_t tmpsmcr;

  /* Process Locked */
  __HAL_LOCK(htim);
 800e49a:	687b      	ldr	r3, [r7, #4]
 800e49c:	f893 303c 	ldrb.w	r3, [r3, #60]	@ 0x3c
 800e4a0:	2b01      	cmp	r3, #1
 800e4a2:	d101      	bne.n	800e4a8 <HAL_TIM_ConfigClockSource+0x1c>
 800e4a4:	2302      	movs	r3, #2
 800e4a6:	e0dc      	b.n	800e662 <HAL_TIM_ConfigClockSource+0x1d6>
 800e4a8:	687b      	ldr	r3, [r7, #4]
 800e4aa:	2201      	movs	r2, #1
 800e4ac:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c

  htim->State = HAL_TIM_STATE_BUSY;
 800e4b0:	687b      	ldr	r3, [r7, #4]
 800e4b2:	2202      	movs	r2, #2
 800e4b4:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d

  /* Check the parameters */
  assert_param(IS_TIM_CLOCKSOURCE(sClockSourceConfig->ClockSource));

  /* Reset the SMS, TS, ECE, ETPS and ETRF bits */
  tmpsmcr = htim->Instance->SMCR;
 800e4b8:	687b      	ldr	r3, [r7, #4]
 800e4ba:	681b      	ldr	r3, [r3, #0]
 800e4bc:	689b      	ldr	r3, [r3, #8]
 800e4be:	60bb      	str	r3, [r7, #8]
  tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
 800e4c0:	68ba      	ldr	r2, [r7, #8]
 800e4c2:	4b6a      	ldr	r3, [pc, #424]	@ (800e66c <HAL_TIM_ConfigClockSource+0x1e0>)
 800e4c4:	4013      	ands	r3, r2
 800e4c6:	60bb      	str	r3, [r7, #8]
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 800e4c8:	68bb      	ldr	r3, [r7, #8]
 800e4ca:	f423 437f 	bic.w	r3, r3, #65280	@ 0xff00
 800e4ce:	60bb      	str	r3, [r7, #8]
  htim->Instance->SMCR = tmpsmcr;
 800e4d0:	687b      	ldr	r3, [r7, #4]
 800e4d2:	681b      	ldr	r3, [r3, #0]
 800e4d4:	68ba      	ldr	r2, [r7, #8]
 800e4d6:	609a      	str	r2, [r3, #8]

  switch (sClockSourceConfig->ClockSource)
 800e4d8:	683b      	ldr	r3, [r7, #0]
 800e4da:	681b      	ldr	r3, [r3, #0]
 800e4dc:	4a64      	ldr	r2, [pc, #400]	@ (800e670 <HAL_TIM_ConfigClockSource+0x1e4>)
 800e4de:	4293      	cmp	r3, r2
 800e4e0:	f000 80a9 	beq.w	800e636 <HAL_TIM_ConfigClockSource+0x1aa>
 800e4e4:	4a62      	ldr	r2, [pc, #392]	@ (800e670 <HAL_TIM_ConfigClockSource+0x1e4>)
 800e4e6:	4293      	cmp	r3, r2
 800e4e8:	f200 80ae 	bhi.w	800e648 <HAL_TIM_ConfigClockSource+0x1bc>
 800e4ec:	4a61      	ldr	r2, [pc, #388]	@ (800e674 <HAL_TIM_ConfigClockSource+0x1e8>)
 800e4ee:	4293      	cmp	r3, r2
 800e4f0:	f000 80a1 	beq.w	800e636 <HAL_TIM_ConfigClockSource+0x1aa>
 800e4f4:	4a5f      	ldr	r2, [pc, #380]	@ (800e674 <HAL_TIM_ConfigClockSource+0x1e8>)
 800e4f6:	4293      	cmp	r3, r2
 800e4f8:	f200 80a6 	bhi.w	800e648 <HAL_TIM_ConfigClockSource+0x1bc>
 800e4fc:	4a5e      	ldr	r2, [pc, #376]	@ (800e678 <HAL_TIM_ConfigClockSource+0x1ec>)
 800e4fe:	4293      	cmp	r3, r2
 800e500:	f000 8099 	beq.w	800e636 <HAL_TIM_ConfigClockSource+0x1aa>
 800e504:	4a5c      	ldr	r2, [pc, #368]	@ (800e678 <HAL_TIM_ConfigClockSource+0x1ec>)
 800e506:	4293      	cmp	r3, r2
 800e508:	f200 809e 	bhi.w	800e648 <HAL_TIM_ConfigClockSource+0x1bc>
 800e50c:	f1b3 1f10 	cmp.w	r3, #1048592	@ 0x100010
 800e510:	f000 8091 	beq.w	800e636 <HAL_TIM_ConfigClockSource+0x1aa>
 800e514:	f1b3 1f10 	cmp.w	r3, #1048592	@ 0x100010
 800e518:	f200 8096 	bhi.w	800e648 <HAL_TIM_ConfigClockSource+0x1bc>
 800e51c:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
 800e520:	f000 8089 	beq.w	800e636 <HAL_TIM_ConfigClockSource+0x1aa>
 800e524:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
 800e528:	f200 808e 	bhi.w	800e648 <HAL_TIM_ConfigClockSource+0x1bc>
 800e52c:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 800e530:	d03e      	beq.n	800e5b0 <HAL_TIM_ConfigClockSource+0x124>
 800e532:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 800e536:	f200 8087 	bhi.w	800e648 <HAL_TIM_ConfigClockSource+0x1bc>
 800e53a:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 800e53e:	f000 8086 	beq.w	800e64e <HAL_TIM_ConfigClockSource+0x1c2>
 800e542:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 800e546:	d87f      	bhi.n	800e648 <HAL_TIM_ConfigClockSource+0x1bc>
 800e548:	2b70      	cmp	r3, #112	@ 0x70
 800e54a:	d01a      	beq.n	800e582 <HAL_TIM_ConfigClockSource+0xf6>
 800e54c:	2b70      	cmp	r3, #112	@ 0x70
 800e54e:	d87b      	bhi.n	800e648 <HAL_TIM_ConfigClockSource+0x1bc>
 800e550:	2b60      	cmp	r3, #96	@ 0x60
 800e552:	d050      	beq.n	800e5f6 <HAL_TIM_ConfigClockSource+0x16a>
 800e554:	2b60      	cmp	r3, #96	@ 0x60
 800e556:	d877      	bhi.n	800e648 <HAL_TIM_ConfigClockSource+0x1bc>
 800e558:	2b50      	cmp	r3, #80	@ 0x50
 800e55a:	d03c      	beq.n	800e5d6 <HAL_TIM_ConfigClockSource+0x14a>
 800e55c:	2b50      	cmp	r3, #80	@ 0x50
 800e55e:	d873      	bhi.n	800e648 <HAL_TIM_ConfigClockSource+0x1bc>
 800e560:	2b40      	cmp	r3, #64	@ 0x40
 800e562:	d058      	beq.n	800e616 <HAL_TIM_ConfigClockSource+0x18a>
 800e564:	2b40      	cmp	r3, #64	@ 0x40
 800e566:	d86f      	bhi.n	800e648 <HAL_TIM_ConfigClockSource+0x1bc>
 800e568:	2b30      	cmp	r3, #48	@ 0x30
 800e56a:	d064      	beq.n	800e636 <HAL_TIM_ConfigClockSource+0x1aa>
 800e56c:	2b30      	cmp	r3, #48	@ 0x30
 800e56e:	d86b      	bhi.n	800e648 <HAL_TIM_ConfigClockSource+0x1bc>
 800e570:	2b20      	cmp	r3, #32
 800e572:	d060      	beq.n	800e636 <HAL_TIM_ConfigClockSource+0x1aa>
 800e574:	2b20      	cmp	r3, #32
 800e576:	d867      	bhi.n	800e648 <HAL_TIM_ConfigClockSource+0x1bc>
 800e578:	2b00      	cmp	r3, #0
 800e57a:	d05c      	beq.n	800e636 <HAL_TIM_ConfigClockSource+0x1aa>
 800e57c:	2b10      	cmp	r3, #16
 800e57e:	d05a      	beq.n	800e636 <HAL_TIM_ConfigClockSource+0x1aa>
 800e580:	e062      	b.n	800e648 <HAL_TIM_ConfigClockSource+0x1bc>
      assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));

      /* Configure the ETR Clock source */
      TIM_ETR_SetConfig(htim->Instance,
 800e582:	687b      	ldr	r3, [r7, #4]
 800e584:	6818      	ldr	r0, [r3, #0]
                        sClockSourceConfig->ClockPrescaler,
 800e586:	683b      	ldr	r3, [r7, #0]
 800e588:	6899      	ldr	r1, [r3, #8]
                        sClockSourceConfig->ClockPolarity,
 800e58a:	683b      	ldr	r3, [r7, #0]
 800e58c:	685a      	ldr	r2, [r3, #4]
                        sClockSourceConfig->ClockFilter);
 800e58e:	683b      	ldr	r3, [r7, #0]
 800e590:	68db      	ldr	r3, [r3, #12]
      TIM_ETR_SetConfig(htim->Instance,
 800e592:	f000 fc9f 	bl	800eed4 <TIM_ETR_SetConfig>

      /* Select the External clock mode1 and the ETRF trigger */
      tmpsmcr = htim->Instance->SMCR;
 800e596:	687b      	ldr	r3, [r7, #4]
 800e598:	681b      	ldr	r3, [r3, #0]
 800e59a:	689b      	ldr	r3, [r3, #8]
 800e59c:	60bb      	str	r3, [r7, #8]
      tmpsmcr |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1);
 800e59e:	68bb      	ldr	r3, [r7, #8]
 800e5a0:	f043 0377 	orr.w	r3, r3, #119	@ 0x77
 800e5a4:	60bb      	str	r3, [r7, #8]
      /* Write to TIMx SMCR */
      htim->Instance->SMCR = tmpsmcr;
 800e5a6:	687b      	ldr	r3, [r7, #4]
 800e5a8:	681b      	ldr	r3, [r3, #0]
 800e5aa:	68ba      	ldr	r2, [r7, #8]
 800e5ac:	609a      	str	r2, [r3, #8]
      break;
 800e5ae:	e04f      	b.n	800e650 <HAL_TIM_ConfigClockSource+0x1c4>
      assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));

      /* Configure the ETR Clock source */
      TIM_ETR_SetConfig(htim->Instance,
 800e5b0:	687b      	ldr	r3, [r7, #4]
 800e5b2:	6818      	ldr	r0, [r3, #0]
                        sClockSourceConfig->ClockPrescaler,
 800e5b4:	683b      	ldr	r3, [r7, #0]
 800e5b6:	6899      	ldr	r1, [r3, #8]
                        sClockSourceConfig->ClockPolarity,
 800e5b8:	683b      	ldr	r3, [r7, #0]
 800e5ba:	685a      	ldr	r2, [r3, #4]
                        sClockSourceConfig->ClockFilter);
 800e5bc:	683b      	ldr	r3, [r7, #0]
 800e5be:	68db      	ldr	r3, [r3, #12]
      TIM_ETR_SetConfig(htim->Instance,
 800e5c0:	f000 fc88 	bl	800eed4 <TIM_ETR_SetConfig>
      /* Enable the External clock mode2 */
      htim->Instance->SMCR |= TIM_SMCR_ECE;
 800e5c4:	687b      	ldr	r3, [r7, #4]
 800e5c6:	681b      	ldr	r3, [r3, #0]
 800e5c8:	689a      	ldr	r2, [r3, #8]
 800e5ca:	687b      	ldr	r3, [r7, #4]
 800e5cc:	681b      	ldr	r3, [r3, #0]
 800e5ce:	f442 4280 	orr.w	r2, r2, #16384	@ 0x4000
 800e5d2:	609a      	str	r2, [r3, #8]
      break;
 800e5d4:	e03c      	b.n	800e650 <HAL_TIM_ConfigClockSource+0x1c4>

      /* Check TI1 input conditioning related parameters */
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));

      TIM_TI1_ConfigInputStage(htim->Instance,
 800e5d6:	687b      	ldr	r3, [r7, #4]
 800e5d8:	6818      	ldr	r0, [r3, #0]
                               sClockSourceConfig->ClockPolarity,
 800e5da:	683b      	ldr	r3, [r7, #0]
 800e5dc:	6859      	ldr	r1, [r3, #4]
                               sClockSourceConfig->ClockFilter);
 800e5de:	683b      	ldr	r3, [r7, #0]
 800e5e0:	68db      	ldr	r3, [r3, #12]
      TIM_TI1_ConfigInputStage(htim->Instance,
 800e5e2:	461a      	mov	r2, r3
 800e5e4:	f000 fbf8 	bl	800edd8 <TIM_TI1_ConfigInputStage>
      TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1);
 800e5e8:	687b      	ldr	r3, [r7, #4]
 800e5ea:	681b      	ldr	r3, [r3, #0]
 800e5ec:	2150      	movs	r1, #80	@ 0x50
 800e5ee:	4618      	mov	r0, r3
 800e5f0:	f000 fc52 	bl	800ee98 <TIM_ITRx_SetConfig>
      break;
 800e5f4:	e02c      	b.n	800e650 <HAL_TIM_ConfigClockSource+0x1c4>

      /* Check TI2 input conditioning related parameters */
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));

      TIM_TI2_ConfigInputStage(htim->Instance,
 800e5f6:	687b      	ldr	r3, [r7, #4]
 800e5f8:	6818      	ldr	r0, [r3, #0]
                               sClockSourceConfig->ClockPolarity,
 800e5fa:	683b      	ldr	r3, [r7, #0]
 800e5fc:	6859      	ldr	r1, [r3, #4]
                               sClockSourceConfig->ClockFilter);
 800e5fe:	683b      	ldr	r3, [r7, #0]
 800e600:	68db      	ldr	r3, [r3, #12]
      TIM_TI2_ConfigInputStage(htim->Instance,
 800e602:	461a      	mov	r2, r3
 800e604:	f000 fc17 	bl	800ee36 <TIM_TI2_ConfigInputStage>
      TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI2);
 800e608:	687b      	ldr	r3, [r7, #4]
 800e60a:	681b      	ldr	r3, [r3, #0]
 800e60c:	2160      	movs	r1, #96	@ 0x60
 800e60e:	4618      	mov	r0, r3
 800e610:	f000 fc42 	bl	800ee98 <TIM_ITRx_SetConfig>
      break;
 800e614:	e01c      	b.n	800e650 <HAL_TIM_ConfigClockSource+0x1c4>

      /* Check TI1 input conditioning related parameters */
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));

      TIM_TI1_ConfigInputStage(htim->Instance,
 800e616:	687b      	ldr	r3, [r7, #4]
 800e618:	6818      	ldr	r0, [r3, #0]
                               sClockSourceConfig->ClockPolarity,
 800e61a:	683b      	ldr	r3, [r7, #0]
 800e61c:	6859      	ldr	r1, [r3, #4]
                               sClockSourceConfig->ClockFilter);
 800e61e:	683b      	ldr	r3, [r7, #0]
 800e620:	68db      	ldr	r3, [r3, #12]
      TIM_TI1_ConfigInputStage(htim->Instance,
 800e622:	461a      	mov	r2, r3
 800e624:	f000 fbd8 	bl	800edd8 <TIM_TI1_ConfigInputStage>
      TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1ED);
 800e628:	687b      	ldr	r3, [r7, #4]
 800e62a:	681b      	ldr	r3, [r3, #0]
 800e62c:	2140      	movs	r1, #64	@ 0x40
 800e62e:	4618      	mov	r0, r3
 800e630:	f000 fc32 	bl	800ee98 <TIM_ITRx_SetConfig>
      break;
 800e634:	e00c      	b.n	800e650 <HAL_TIM_ConfigClockSource+0x1c4>
    case TIM_CLOCKSOURCE_ITR8:
    {
      /* Check whether or not the timer instance supports internal trigger input */
      assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));

      TIM_ITRx_SetConfig(htim->Instance, sClockSourceConfig->ClockSource);
 800e636:	687b      	ldr	r3, [r7, #4]
 800e638:	681a      	ldr	r2, [r3, #0]
 800e63a:	683b      	ldr	r3, [r7, #0]
 800e63c:	681b      	ldr	r3, [r3, #0]
 800e63e:	4619      	mov	r1, r3
 800e640:	4610      	mov	r0, r2
 800e642:	f000 fc29 	bl	800ee98 <TIM_ITRx_SetConfig>
      break;
 800e646:	e003      	b.n	800e650 <HAL_TIM_ConfigClockSource+0x1c4>
    }

    default:
      status = HAL_ERROR;
 800e648:	2301      	movs	r3, #1
 800e64a:	73fb      	strb	r3, [r7, #15]
      break;
 800e64c:	e000      	b.n	800e650 <HAL_TIM_ConfigClockSource+0x1c4>
      break;
 800e64e:	bf00      	nop
  }
  htim->State = HAL_TIM_STATE_READY;
 800e650:	687b      	ldr	r3, [r7, #4]
 800e652:	2201      	movs	r2, #1
 800e654:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d

  __HAL_UNLOCK(htim);
 800e658:	687b      	ldr	r3, [r7, #4]
 800e65a:	2200      	movs	r2, #0
 800e65c:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c

  return status;
 800e660:	7bfb      	ldrb	r3, [r7, #15]
}
 800e662:	4618      	mov	r0, r3
 800e664:	3710      	adds	r7, #16
 800e666:	46bd      	mov	sp, r7
 800e668:	bd80      	pop	{r7, pc}
 800e66a:	bf00      	nop
 800e66c:	ffceff88 	.word	0xffceff88
 800e670:	00100040 	.word	0x00100040
 800e674:	00100030 	.word	0x00100030
 800e678:	00100020 	.word	0x00100020

0800e67c <HAL_TIM_PeriodElapsedCallback>:
  * @brief  Period elapsed callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
 800e67c:	b480      	push	{r7}
 800e67e:	b083      	sub	sp, #12
 800e680:	af00      	add	r7, sp, #0
 800e682:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_PeriodElapsedCallback could be implemented in the user file
   */
}
 800e684:	bf00      	nop
 800e686:	370c      	adds	r7, #12
 800e688:	46bd      	mov	sp, r7
 800e68a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e68e:	4770      	bx	lr

0800e690 <HAL_TIM_OC_DelayElapsedCallback>:
  * @brief  Output Compare callback in non-blocking mode
  * @param  htim TIM OC handle
  * @retval None
  */
__weak void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim)
{
 800e690:	b480      	push	{r7}
 800e692:	b083      	sub	sp, #12
 800e694:	af00      	add	r7, sp, #0
 800e696:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_OC_DelayElapsedCallback could be implemented in the user file
   */
}
 800e698:	bf00      	nop
 800e69a:	370c      	adds	r7, #12
 800e69c:	46bd      	mov	sp, r7
 800e69e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e6a2:	4770      	bx	lr

0800e6a4 <HAL_TIM_IC_CaptureCallback>:
  * @brief  Input Capture callback in non-blocking mode
  * @param  htim TIM IC handle
  * @retval None
  */
__weak void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
{
 800e6a4:	b480      	push	{r7}
 800e6a6:	b083      	sub	sp, #12
 800e6a8:	af00      	add	r7, sp, #0
 800e6aa:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_IC_CaptureCallback could be implemented in the user file
   */
}
 800e6ac:	bf00      	nop
 800e6ae:	370c      	adds	r7, #12
 800e6b0:	46bd      	mov	sp, r7
 800e6b2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e6b6:	4770      	bx	lr

0800e6b8 <HAL_TIM_PWM_PulseFinishedCallback>:
  * @brief  PWM Pulse finished callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim)
{
 800e6b8:	b480      	push	{r7}
 800e6ba:	b083      	sub	sp, #12
 800e6bc:	af00      	add	r7, sp, #0
 800e6be:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_PWM_PulseFinishedCallback could be implemented in the user file
   */
}
 800e6c0:	bf00      	nop
 800e6c2:	370c      	adds	r7, #12
 800e6c4:	46bd      	mov	sp, r7
 800e6c6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e6ca:	4770      	bx	lr

0800e6cc <HAL_TIM_TriggerCallback>:
  * @brief  Hall Trigger detection callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim)
{
 800e6cc:	b480      	push	{r7}
 800e6ce:	b083      	sub	sp, #12
 800e6d0:	af00      	add	r7, sp, #0
 800e6d2:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_TriggerCallback could be implemented in the user file
   */
}
 800e6d4:	bf00      	nop
 800e6d6:	370c      	adds	r7, #12
 800e6d8:	46bd      	mov	sp, r7
 800e6da:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e6de:	4770      	bx	lr

0800e6e0 <TIM_Base_SetConfig>:
  * @param  TIMx TIM peripheral
  * @param  Structure TIM Base configuration structure
  * @retval None
  */
void TIM_Base_SetConfig(TIM_TypeDef *TIMx, const TIM_Base_InitTypeDef *Structure)
{
 800e6e0:	b480      	push	{r7}
 800e6e2:	b085      	sub	sp, #20
 800e6e4:	af00      	add	r7, sp, #0
 800e6e6:	6078      	str	r0, [r7, #4]
 800e6e8:	6039      	str	r1, [r7, #0]
  uint32_t tmpcr1;
  tmpcr1 = TIMx->CR1;
 800e6ea:	687b      	ldr	r3, [r7, #4]
 800e6ec:	681b      	ldr	r3, [r3, #0]
 800e6ee:	60fb      	str	r3, [r7, #12]

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 800e6f0:	687b      	ldr	r3, [r7, #4]
 800e6f2:	4a46      	ldr	r2, [pc, #280]	@ (800e80c <TIM_Base_SetConfig+0x12c>)
 800e6f4:	4293      	cmp	r3, r2
 800e6f6:	d013      	beq.n	800e720 <TIM_Base_SetConfig+0x40>
 800e6f8:	687b      	ldr	r3, [r7, #4]
 800e6fa:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 800e6fe:	d00f      	beq.n	800e720 <TIM_Base_SetConfig+0x40>
 800e700:	687b      	ldr	r3, [r7, #4]
 800e702:	4a43      	ldr	r2, [pc, #268]	@ (800e810 <TIM_Base_SetConfig+0x130>)
 800e704:	4293      	cmp	r3, r2
 800e706:	d00b      	beq.n	800e720 <TIM_Base_SetConfig+0x40>
 800e708:	687b      	ldr	r3, [r7, #4]
 800e70a:	4a42      	ldr	r2, [pc, #264]	@ (800e814 <TIM_Base_SetConfig+0x134>)
 800e70c:	4293      	cmp	r3, r2
 800e70e:	d007      	beq.n	800e720 <TIM_Base_SetConfig+0x40>
 800e710:	687b      	ldr	r3, [r7, #4]
 800e712:	4a41      	ldr	r2, [pc, #260]	@ (800e818 <TIM_Base_SetConfig+0x138>)
 800e714:	4293      	cmp	r3, r2
 800e716:	d003      	beq.n	800e720 <TIM_Base_SetConfig+0x40>
 800e718:	687b      	ldr	r3, [r7, #4]
 800e71a:	4a40      	ldr	r2, [pc, #256]	@ (800e81c <TIM_Base_SetConfig+0x13c>)
 800e71c:	4293      	cmp	r3, r2
 800e71e:	d108      	bne.n	800e732 <TIM_Base_SetConfig+0x52>
  {
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 800e720:	68fb      	ldr	r3, [r7, #12]
 800e722:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
 800e726:	60fb      	str	r3, [r7, #12]
    tmpcr1 |= Structure->CounterMode;
 800e728:	683b      	ldr	r3, [r7, #0]
 800e72a:	685b      	ldr	r3, [r3, #4]
 800e72c:	68fa      	ldr	r2, [r7, #12]
 800e72e:	4313      	orrs	r3, r2
 800e730:	60fb      	str	r3, [r7, #12]
  }

  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 800e732:	687b      	ldr	r3, [r7, #4]
 800e734:	4a35      	ldr	r2, [pc, #212]	@ (800e80c <TIM_Base_SetConfig+0x12c>)
 800e736:	4293      	cmp	r3, r2
 800e738:	d01f      	beq.n	800e77a <TIM_Base_SetConfig+0x9a>
 800e73a:	687b      	ldr	r3, [r7, #4]
 800e73c:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 800e740:	d01b      	beq.n	800e77a <TIM_Base_SetConfig+0x9a>
 800e742:	687b      	ldr	r3, [r7, #4]
 800e744:	4a32      	ldr	r2, [pc, #200]	@ (800e810 <TIM_Base_SetConfig+0x130>)
 800e746:	4293      	cmp	r3, r2
 800e748:	d017      	beq.n	800e77a <TIM_Base_SetConfig+0x9a>
 800e74a:	687b      	ldr	r3, [r7, #4]
 800e74c:	4a31      	ldr	r2, [pc, #196]	@ (800e814 <TIM_Base_SetConfig+0x134>)
 800e74e:	4293      	cmp	r3, r2
 800e750:	d013      	beq.n	800e77a <TIM_Base_SetConfig+0x9a>
 800e752:	687b      	ldr	r3, [r7, #4]
 800e754:	4a30      	ldr	r2, [pc, #192]	@ (800e818 <TIM_Base_SetConfig+0x138>)
 800e756:	4293      	cmp	r3, r2
 800e758:	d00f      	beq.n	800e77a <TIM_Base_SetConfig+0x9a>
 800e75a:	687b      	ldr	r3, [r7, #4]
 800e75c:	4a2f      	ldr	r2, [pc, #188]	@ (800e81c <TIM_Base_SetConfig+0x13c>)
 800e75e:	4293      	cmp	r3, r2
 800e760:	d00b      	beq.n	800e77a <TIM_Base_SetConfig+0x9a>
 800e762:	687b      	ldr	r3, [r7, #4]
 800e764:	4a2e      	ldr	r2, [pc, #184]	@ (800e820 <TIM_Base_SetConfig+0x140>)
 800e766:	4293      	cmp	r3, r2
 800e768:	d007      	beq.n	800e77a <TIM_Base_SetConfig+0x9a>
 800e76a:	687b      	ldr	r3, [r7, #4]
 800e76c:	4a2d      	ldr	r2, [pc, #180]	@ (800e824 <TIM_Base_SetConfig+0x144>)
 800e76e:	4293      	cmp	r3, r2
 800e770:	d003      	beq.n	800e77a <TIM_Base_SetConfig+0x9a>
 800e772:	687b      	ldr	r3, [r7, #4]
 800e774:	4a2c      	ldr	r2, [pc, #176]	@ (800e828 <TIM_Base_SetConfig+0x148>)
 800e776:	4293      	cmp	r3, r2
 800e778:	d108      	bne.n	800e78c <TIM_Base_SetConfig+0xac>
  {
    /* Set the clock division */
    tmpcr1 &= ~TIM_CR1_CKD;
 800e77a:	68fb      	ldr	r3, [r7, #12]
 800e77c:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
 800e780:	60fb      	str	r3, [r7, #12]
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 800e782:	683b      	ldr	r3, [r7, #0]
 800e784:	68db      	ldr	r3, [r3, #12]
 800e786:	68fa      	ldr	r2, [r7, #12]
 800e788:	4313      	orrs	r3, r2
 800e78a:	60fb      	str	r3, [r7, #12]
  }

  /* Set the auto-reload preload */
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 800e78c:	68fb      	ldr	r3, [r7, #12]
 800e78e:	f023 0280 	bic.w	r2, r3, #128	@ 0x80
 800e792:	683b      	ldr	r3, [r7, #0]
 800e794:	695b      	ldr	r3, [r3, #20]
 800e796:	4313      	orrs	r3, r2
 800e798:	60fb      	str	r3, [r7, #12]

  TIMx->CR1 = tmpcr1;
 800e79a:	687b      	ldr	r3, [r7, #4]
 800e79c:	68fa      	ldr	r2, [r7, #12]
 800e79e:	601a      	str	r2, [r3, #0]

  /* Set the Autoreload value */
  TIMx->ARR = (uint32_t)Structure->Period ;
 800e7a0:	683b      	ldr	r3, [r7, #0]
 800e7a2:	689a      	ldr	r2, [r3, #8]
 800e7a4:	687b      	ldr	r3, [r7, #4]
 800e7a6:	62da      	str	r2, [r3, #44]	@ 0x2c

  /* Set the Prescaler value */
  TIMx->PSC = Structure->Prescaler;
 800e7a8:	683b      	ldr	r3, [r7, #0]
 800e7aa:	681a      	ldr	r2, [r3, #0]
 800e7ac:	687b      	ldr	r3, [r7, #4]
 800e7ae:	629a      	str	r2, [r3, #40]	@ 0x28

  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 800e7b0:	687b      	ldr	r3, [r7, #4]
 800e7b2:	4a16      	ldr	r2, [pc, #88]	@ (800e80c <TIM_Base_SetConfig+0x12c>)
 800e7b4:	4293      	cmp	r3, r2
 800e7b6:	d00f      	beq.n	800e7d8 <TIM_Base_SetConfig+0xf8>
 800e7b8:	687b      	ldr	r3, [r7, #4]
 800e7ba:	4a18      	ldr	r2, [pc, #96]	@ (800e81c <TIM_Base_SetConfig+0x13c>)
 800e7bc:	4293      	cmp	r3, r2
 800e7be:	d00b      	beq.n	800e7d8 <TIM_Base_SetConfig+0xf8>
 800e7c0:	687b      	ldr	r3, [r7, #4]
 800e7c2:	4a17      	ldr	r2, [pc, #92]	@ (800e820 <TIM_Base_SetConfig+0x140>)
 800e7c4:	4293      	cmp	r3, r2
 800e7c6:	d007      	beq.n	800e7d8 <TIM_Base_SetConfig+0xf8>
 800e7c8:	687b      	ldr	r3, [r7, #4]
 800e7ca:	4a16      	ldr	r2, [pc, #88]	@ (800e824 <TIM_Base_SetConfig+0x144>)
 800e7cc:	4293      	cmp	r3, r2
 800e7ce:	d003      	beq.n	800e7d8 <TIM_Base_SetConfig+0xf8>
 800e7d0:	687b      	ldr	r3, [r7, #4]
 800e7d2:	4a15      	ldr	r2, [pc, #84]	@ (800e828 <TIM_Base_SetConfig+0x148>)
 800e7d4:	4293      	cmp	r3, r2
 800e7d6:	d103      	bne.n	800e7e0 <TIM_Base_SetConfig+0x100>
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = Structure->RepetitionCounter;
 800e7d8:	683b      	ldr	r3, [r7, #0]
 800e7da:	691a      	ldr	r2, [r3, #16]
 800e7dc:	687b      	ldr	r3, [r7, #4]
 800e7de:	631a      	str	r2, [r3, #48]	@ 0x30
  }

  /* Generate an update event to reload the Prescaler
     and the repetition counter (only for advanced timer) value immediately */
  TIMx->EGR = TIM_EGR_UG;
 800e7e0:	687b      	ldr	r3, [r7, #4]
 800e7e2:	2201      	movs	r2, #1
 800e7e4:	615a      	str	r2, [r3, #20]

  /* Check if the update flag is set after the Update Generation, if so clear the UIF flag */
  if (HAL_IS_BIT_SET(TIMx->SR, TIM_FLAG_UPDATE))
 800e7e6:	687b      	ldr	r3, [r7, #4]
 800e7e8:	691b      	ldr	r3, [r3, #16]
 800e7ea:	f003 0301 	and.w	r3, r3, #1
 800e7ee:	2b01      	cmp	r3, #1
 800e7f0:	d105      	bne.n	800e7fe <TIM_Base_SetConfig+0x11e>
  {
    /* Clear the update flag */
    CLEAR_BIT(TIMx->SR, TIM_FLAG_UPDATE);
 800e7f2:	687b      	ldr	r3, [r7, #4]
 800e7f4:	691b      	ldr	r3, [r3, #16]
 800e7f6:	f023 0201 	bic.w	r2, r3, #1
 800e7fa:	687b      	ldr	r3, [r7, #4]
 800e7fc:	611a      	str	r2, [r3, #16]
  }
}
 800e7fe:	bf00      	nop
 800e800:	3714      	adds	r7, #20
 800e802:	46bd      	mov	sp, r7
 800e804:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e808:	4770      	bx	lr
 800e80a:	bf00      	nop
 800e80c:	40010000 	.word	0x40010000
 800e810:	40000400 	.word	0x40000400
 800e814:	40000800 	.word	0x40000800
 800e818:	40000c00 	.word	0x40000c00
 800e81c:	40010400 	.word	0x40010400
 800e820:	40014000 	.word	0x40014000
 800e824:	40014400 	.word	0x40014400
 800e828:	40014800 	.word	0x40014800

0800e82c <TIM_OC1_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The output configuration structure
  * @retval None
  */
static void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, const TIM_OC_InitTypeDef *OC_Config)
{
 800e82c:	b480      	push	{r7}
 800e82e:	b087      	sub	sp, #28
 800e830:	af00      	add	r7, sp, #0
 800e832:	6078      	str	r0, [r7, #4]
 800e834:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 800e836:	687b      	ldr	r3, [r7, #4]
 800e838:	6a1b      	ldr	r3, [r3, #32]
 800e83a:	617b      	str	r3, [r7, #20]

  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= ~TIM_CCER_CC1E;
 800e83c:	687b      	ldr	r3, [r7, #4]
 800e83e:	6a1b      	ldr	r3, [r3, #32]
 800e840:	f023 0201 	bic.w	r2, r3, #1
 800e844:	687b      	ldr	r3, [r7, #4]
 800e846:	621a      	str	r2, [r3, #32]

  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 800e848:	687b      	ldr	r3, [r7, #4]
 800e84a:	685b      	ldr	r3, [r3, #4]
 800e84c:	613b      	str	r3, [r7, #16]

  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 800e84e:	687b      	ldr	r3, [r7, #4]
 800e850:	699b      	ldr	r3, [r3, #24]
 800e852:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~TIM_CCMR1_OC1M;
 800e854:	68fa      	ldr	r2, [r7, #12]
 800e856:	4b37      	ldr	r3, [pc, #220]	@ (800e934 <TIM_OC1_SetConfig+0x108>)
 800e858:	4013      	ands	r3, r2
 800e85a:	60fb      	str	r3, [r7, #12]
  tmpccmrx &= ~TIM_CCMR1_CC1S;
 800e85c:	68fb      	ldr	r3, [r7, #12]
 800e85e:	f023 0303 	bic.w	r3, r3, #3
 800e862:	60fb      	str	r3, [r7, #12]
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 800e864:	683b      	ldr	r3, [r7, #0]
 800e866:	681b      	ldr	r3, [r3, #0]
 800e868:	68fa      	ldr	r2, [r7, #12]
 800e86a:	4313      	orrs	r3, r2
 800e86c:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC1P;
 800e86e:	697b      	ldr	r3, [r7, #20]
 800e870:	f023 0302 	bic.w	r3, r3, #2
 800e874:	617b      	str	r3, [r7, #20]
  /* Set the Output Compare Polarity */
  tmpccer |= OC_Config->OCPolarity;
 800e876:	683b      	ldr	r3, [r7, #0]
 800e878:	689b      	ldr	r3, [r3, #8]
 800e87a:	697a      	ldr	r2, [r7, #20]
 800e87c:	4313      	orrs	r3, r2
 800e87e:	617b      	str	r3, [r7, #20]

  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))
 800e880:	687b      	ldr	r3, [r7, #4]
 800e882:	4a2d      	ldr	r2, [pc, #180]	@ (800e938 <TIM_OC1_SetConfig+0x10c>)
 800e884:	4293      	cmp	r3, r2
 800e886:	d00f      	beq.n	800e8a8 <TIM_OC1_SetConfig+0x7c>
 800e888:	687b      	ldr	r3, [r7, #4]
 800e88a:	4a2c      	ldr	r2, [pc, #176]	@ (800e93c <TIM_OC1_SetConfig+0x110>)
 800e88c:	4293      	cmp	r3, r2
 800e88e:	d00b      	beq.n	800e8a8 <TIM_OC1_SetConfig+0x7c>
 800e890:	687b      	ldr	r3, [r7, #4]
 800e892:	4a2b      	ldr	r2, [pc, #172]	@ (800e940 <TIM_OC1_SetConfig+0x114>)
 800e894:	4293      	cmp	r3, r2
 800e896:	d007      	beq.n	800e8a8 <TIM_OC1_SetConfig+0x7c>
 800e898:	687b      	ldr	r3, [r7, #4]
 800e89a:	4a2a      	ldr	r2, [pc, #168]	@ (800e944 <TIM_OC1_SetConfig+0x118>)
 800e89c:	4293      	cmp	r3, r2
 800e89e:	d003      	beq.n	800e8a8 <TIM_OC1_SetConfig+0x7c>
 800e8a0:	687b      	ldr	r3, [r7, #4]
 800e8a2:	4a29      	ldr	r2, [pc, #164]	@ (800e948 <TIM_OC1_SetConfig+0x11c>)
 800e8a4:	4293      	cmp	r3, r2
 800e8a6:	d10c      	bne.n	800e8c2 <TIM_OC1_SetConfig+0x96>
  {
    /* Check parameters */
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC1NP;
 800e8a8:	697b      	ldr	r3, [r7, #20]
 800e8aa:	f023 0308 	bic.w	r3, r3, #8
 800e8ae:	617b      	str	r3, [r7, #20]
    /* Set the Output N Polarity */
    tmpccer |= OC_Config->OCNPolarity;
 800e8b0:	683b      	ldr	r3, [r7, #0]
 800e8b2:	68db      	ldr	r3, [r3, #12]
 800e8b4:	697a      	ldr	r2, [r7, #20]
 800e8b6:	4313      	orrs	r3, r2
 800e8b8:	617b      	str	r3, [r7, #20]
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC1NE;
 800e8ba:	697b      	ldr	r3, [r7, #20]
 800e8bc:	f023 0304 	bic.w	r3, r3, #4
 800e8c0:	617b      	str	r3, [r7, #20]
  }

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 800e8c2:	687b      	ldr	r3, [r7, #4]
 800e8c4:	4a1c      	ldr	r2, [pc, #112]	@ (800e938 <TIM_OC1_SetConfig+0x10c>)
 800e8c6:	4293      	cmp	r3, r2
 800e8c8:	d00f      	beq.n	800e8ea <TIM_OC1_SetConfig+0xbe>
 800e8ca:	687b      	ldr	r3, [r7, #4]
 800e8cc:	4a1b      	ldr	r2, [pc, #108]	@ (800e93c <TIM_OC1_SetConfig+0x110>)
 800e8ce:	4293      	cmp	r3, r2
 800e8d0:	d00b      	beq.n	800e8ea <TIM_OC1_SetConfig+0xbe>
 800e8d2:	687b      	ldr	r3, [r7, #4]
 800e8d4:	4a1a      	ldr	r2, [pc, #104]	@ (800e940 <TIM_OC1_SetConfig+0x114>)
 800e8d6:	4293      	cmp	r3, r2
 800e8d8:	d007      	beq.n	800e8ea <TIM_OC1_SetConfig+0xbe>
 800e8da:	687b      	ldr	r3, [r7, #4]
 800e8dc:	4a19      	ldr	r2, [pc, #100]	@ (800e944 <TIM_OC1_SetConfig+0x118>)
 800e8de:	4293      	cmp	r3, r2
 800e8e0:	d003      	beq.n	800e8ea <TIM_OC1_SetConfig+0xbe>
 800e8e2:	687b      	ldr	r3, [r7, #4]
 800e8e4:	4a18      	ldr	r2, [pc, #96]	@ (800e948 <TIM_OC1_SetConfig+0x11c>)
 800e8e6:	4293      	cmp	r3, r2
 800e8e8:	d111      	bne.n	800e90e <TIM_OC1_SetConfig+0xe2>
    /* Check parameters */
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS1;
 800e8ea:	693b      	ldr	r3, [r7, #16]
 800e8ec:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
 800e8f0:	613b      	str	r3, [r7, #16]
    tmpcr2 &= ~TIM_CR2_OIS1N;
 800e8f2:	693b      	ldr	r3, [r7, #16]
 800e8f4:	f423 7300 	bic.w	r3, r3, #512	@ 0x200
 800e8f8:	613b      	str	r3, [r7, #16]
    /* Set the Output Idle state */
    tmpcr2 |= OC_Config->OCIdleState;
 800e8fa:	683b      	ldr	r3, [r7, #0]
 800e8fc:	695b      	ldr	r3, [r3, #20]
 800e8fe:	693a      	ldr	r2, [r7, #16]
 800e900:	4313      	orrs	r3, r2
 800e902:	613b      	str	r3, [r7, #16]
    /* Set the Output N Idle state */
    tmpcr2 |= OC_Config->OCNIdleState;
 800e904:	683b      	ldr	r3, [r7, #0]
 800e906:	699b      	ldr	r3, [r3, #24]
 800e908:	693a      	ldr	r2, [r7, #16]
 800e90a:	4313      	orrs	r3, r2
 800e90c:	613b      	str	r3, [r7, #16]
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 800e90e:	687b      	ldr	r3, [r7, #4]
 800e910:	693a      	ldr	r2, [r7, #16]
 800e912:	605a      	str	r2, [r3, #4]

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
 800e914:	687b      	ldr	r3, [r7, #4]
 800e916:	68fa      	ldr	r2, [r7, #12]
 800e918:	619a      	str	r2, [r3, #24]

  /* Set the Capture Compare Register value */
  TIMx->CCR1 = OC_Config->Pulse;
 800e91a:	683b      	ldr	r3, [r7, #0]
 800e91c:	685a      	ldr	r2, [r3, #4]
 800e91e:	687b      	ldr	r3, [r7, #4]
 800e920:	635a      	str	r2, [r3, #52]	@ 0x34

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 800e922:	687b      	ldr	r3, [r7, #4]
 800e924:	697a      	ldr	r2, [r7, #20]
 800e926:	621a      	str	r2, [r3, #32]
}
 800e928:	bf00      	nop
 800e92a:	371c      	adds	r7, #28
 800e92c:	46bd      	mov	sp, r7
 800e92e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e932:	4770      	bx	lr
 800e934:	fffeff8f 	.word	0xfffeff8f
 800e938:	40010000 	.word	0x40010000
 800e93c:	40010400 	.word	0x40010400
 800e940:	40014000 	.word	0x40014000
 800e944:	40014400 	.word	0x40014400
 800e948:	40014800 	.word	0x40014800

0800e94c <TIM_OC2_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The output configuration structure
  * @retval None
  */
void TIM_OC2_SetConfig(TIM_TypeDef *TIMx, const TIM_OC_InitTypeDef *OC_Config)
{
 800e94c:	b480      	push	{r7}
 800e94e:	b087      	sub	sp, #28
 800e950:	af00      	add	r7, sp, #0
 800e952:	6078      	str	r0, [r7, #4]
 800e954:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 800e956:	687b      	ldr	r3, [r7, #4]
 800e958:	6a1b      	ldr	r3, [r3, #32]
 800e95a:	617b      	str	r3, [r7, #20]

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC2E;
 800e95c:	687b      	ldr	r3, [r7, #4]
 800e95e:	6a1b      	ldr	r3, [r3, #32]
 800e960:	f023 0210 	bic.w	r2, r3, #16
 800e964:	687b      	ldr	r3, [r7, #4]
 800e966:	621a      	str	r2, [r3, #32]

  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 800e968:	687b      	ldr	r3, [r7, #4]
 800e96a:	685b      	ldr	r3, [r3, #4]
 800e96c:	613b      	str	r3, [r7, #16]

  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 800e96e:	687b      	ldr	r3, [r7, #4]
 800e970:	699b      	ldr	r3, [r3, #24]
 800e972:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR1_OC2M;
 800e974:	68fa      	ldr	r2, [r7, #12]
 800e976:	4b34      	ldr	r3, [pc, #208]	@ (800ea48 <TIM_OC2_SetConfig+0xfc>)
 800e978:	4013      	ands	r3, r2
 800e97a:	60fb      	str	r3, [r7, #12]
  tmpccmrx &= ~TIM_CCMR1_CC2S;
 800e97c:	68fb      	ldr	r3, [r7, #12]
 800e97e:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
 800e982:	60fb      	str	r3, [r7, #12]

  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8U);
 800e984:	683b      	ldr	r3, [r7, #0]
 800e986:	681b      	ldr	r3, [r3, #0]
 800e988:	021b      	lsls	r3, r3, #8
 800e98a:	68fa      	ldr	r2, [r7, #12]
 800e98c:	4313      	orrs	r3, r2
 800e98e:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC2P;
 800e990:	697b      	ldr	r3, [r7, #20]
 800e992:	f023 0320 	bic.w	r3, r3, #32
 800e996:	617b      	str	r3, [r7, #20]
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 4U);
 800e998:	683b      	ldr	r3, [r7, #0]
 800e99a:	689b      	ldr	r3, [r3, #8]
 800e99c:	011b      	lsls	r3, r3, #4
 800e99e:	697a      	ldr	r2, [r7, #20]
 800e9a0:	4313      	orrs	r3, r2
 800e9a2:	617b      	str	r3, [r7, #20]

  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
 800e9a4:	687b      	ldr	r3, [r7, #4]
 800e9a6:	4a29      	ldr	r2, [pc, #164]	@ (800ea4c <TIM_OC2_SetConfig+0x100>)
 800e9a8:	4293      	cmp	r3, r2
 800e9aa:	d003      	beq.n	800e9b4 <TIM_OC2_SetConfig+0x68>
 800e9ac:	687b      	ldr	r3, [r7, #4]
 800e9ae:	4a28      	ldr	r2, [pc, #160]	@ (800ea50 <TIM_OC2_SetConfig+0x104>)
 800e9b0:	4293      	cmp	r3, r2
 800e9b2:	d10d      	bne.n	800e9d0 <TIM_OC2_SetConfig+0x84>
  {
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC2NP;
 800e9b4:	697b      	ldr	r3, [r7, #20]
 800e9b6:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
 800e9ba:	617b      	str	r3, [r7, #20]
    /* Set the Output N Polarity */
    tmpccer |= (OC_Config->OCNPolarity << 4U);
 800e9bc:	683b      	ldr	r3, [r7, #0]
 800e9be:	68db      	ldr	r3, [r3, #12]
 800e9c0:	011b      	lsls	r3, r3, #4
 800e9c2:	697a      	ldr	r2, [r7, #20]
 800e9c4:	4313      	orrs	r3, r2
 800e9c6:	617b      	str	r3, [r7, #20]
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC2NE;
 800e9c8:	697b      	ldr	r3, [r7, #20]
 800e9ca:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
 800e9ce:	617b      	str	r3, [r7, #20]
  }

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 800e9d0:	687b      	ldr	r3, [r7, #4]
 800e9d2:	4a1e      	ldr	r2, [pc, #120]	@ (800ea4c <TIM_OC2_SetConfig+0x100>)
 800e9d4:	4293      	cmp	r3, r2
 800e9d6:	d00f      	beq.n	800e9f8 <TIM_OC2_SetConfig+0xac>
 800e9d8:	687b      	ldr	r3, [r7, #4]
 800e9da:	4a1d      	ldr	r2, [pc, #116]	@ (800ea50 <TIM_OC2_SetConfig+0x104>)
 800e9dc:	4293      	cmp	r3, r2
 800e9de:	d00b      	beq.n	800e9f8 <TIM_OC2_SetConfig+0xac>
 800e9e0:	687b      	ldr	r3, [r7, #4]
 800e9e2:	4a1c      	ldr	r2, [pc, #112]	@ (800ea54 <TIM_OC2_SetConfig+0x108>)
 800e9e4:	4293      	cmp	r3, r2
 800e9e6:	d007      	beq.n	800e9f8 <TIM_OC2_SetConfig+0xac>
 800e9e8:	687b      	ldr	r3, [r7, #4]
 800e9ea:	4a1b      	ldr	r2, [pc, #108]	@ (800ea58 <TIM_OC2_SetConfig+0x10c>)
 800e9ec:	4293      	cmp	r3, r2
 800e9ee:	d003      	beq.n	800e9f8 <TIM_OC2_SetConfig+0xac>
 800e9f0:	687b      	ldr	r3, [r7, #4]
 800e9f2:	4a1a      	ldr	r2, [pc, #104]	@ (800ea5c <TIM_OC2_SetConfig+0x110>)
 800e9f4:	4293      	cmp	r3, r2
 800e9f6:	d113      	bne.n	800ea20 <TIM_OC2_SetConfig+0xd4>
    /* Check parameters */
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS2;
 800e9f8:	693b      	ldr	r3, [r7, #16]
 800e9fa:	f423 6380 	bic.w	r3, r3, #1024	@ 0x400
 800e9fe:	613b      	str	r3, [r7, #16]
    tmpcr2 &= ~TIM_CR2_OIS2N;
 800ea00:	693b      	ldr	r3, [r7, #16]
 800ea02:	f423 6300 	bic.w	r3, r3, #2048	@ 0x800
 800ea06:	613b      	str	r3, [r7, #16]
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 2U);
 800ea08:	683b      	ldr	r3, [r7, #0]
 800ea0a:	695b      	ldr	r3, [r3, #20]
 800ea0c:	009b      	lsls	r3, r3, #2
 800ea0e:	693a      	ldr	r2, [r7, #16]
 800ea10:	4313      	orrs	r3, r2
 800ea12:	613b      	str	r3, [r7, #16]
    /* Set the Output N Idle state */
    tmpcr2 |= (OC_Config->OCNIdleState << 2U);
 800ea14:	683b      	ldr	r3, [r7, #0]
 800ea16:	699b      	ldr	r3, [r3, #24]
 800ea18:	009b      	lsls	r3, r3, #2
 800ea1a:	693a      	ldr	r2, [r7, #16]
 800ea1c:	4313      	orrs	r3, r2
 800ea1e:	613b      	str	r3, [r7, #16]
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 800ea20:	687b      	ldr	r3, [r7, #4]
 800ea22:	693a      	ldr	r2, [r7, #16]
 800ea24:	605a      	str	r2, [r3, #4]

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
 800ea26:	687b      	ldr	r3, [r7, #4]
 800ea28:	68fa      	ldr	r2, [r7, #12]
 800ea2a:	619a      	str	r2, [r3, #24]

  /* Set the Capture Compare Register value */
  TIMx->CCR2 = OC_Config->Pulse;
 800ea2c:	683b      	ldr	r3, [r7, #0]
 800ea2e:	685a      	ldr	r2, [r3, #4]
 800ea30:	687b      	ldr	r3, [r7, #4]
 800ea32:	639a      	str	r2, [r3, #56]	@ 0x38

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 800ea34:	687b      	ldr	r3, [r7, #4]
 800ea36:	697a      	ldr	r2, [r7, #20]
 800ea38:	621a      	str	r2, [r3, #32]
}
 800ea3a:	bf00      	nop
 800ea3c:	371c      	adds	r7, #28
 800ea3e:	46bd      	mov	sp, r7
 800ea40:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ea44:	4770      	bx	lr
 800ea46:	bf00      	nop
 800ea48:	feff8fff 	.word	0xfeff8fff
 800ea4c:	40010000 	.word	0x40010000
 800ea50:	40010400 	.word	0x40010400
 800ea54:	40014000 	.word	0x40014000
 800ea58:	40014400 	.word	0x40014400
 800ea5c:	40014800 	.word	0x40014800

0800ea60 <TIM_OC3_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The output configuration structure
  * @retval None
  */
static void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, const TIM_OC_InitTypeDef *OC_Config)
{
 800ea60:	b480      	push	{r7}
 800ea62:	b087      	sub	sp, #28
 800ea64:	af00      	add	r7, sp, #0
 800ea66:	6078      	str	r0, [r7, #4]
 800ea68:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 800ea6a:	687b      	ldr	r3, [r7, #4]
 800ea6c:	6a1b      	ldr	r3, [r3, #32]
 800ea6e:	617b      	str	r3, [r7, #20]

  /* Disable the Channel 3: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC3E;
 800ea70:	687b      	ldr	r3, [r7, #4]
 800ea72:	6a1b      	ldr	r3, [r3, #32]
 800ea74:	f423 7280 	bic.w	r2, r3, #256	@ 0x100
 800ea78:	687b      	ldr	r3, [r7, #4]
 800ea7a:	621a      	str	r2, [r3, #32]

  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 800ea7c:	687b      	ldr	r3, [r7, #4]
 800ea7e:	685b      	ldr	r3, [r3, #4]
 800ea80:	613b      	str	r3, [r7, #16]

  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 800ea82:	687b      	ldr	r3, [r7, #4]
 800ea84:	69db      	ldr	r3, [r3, #28]
 800ea86:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC3M;
 800ea88:	68fa      	ldr	r2, [r7, #12]
 800ea8a:	4b33      	ldr	r3, [pc, #204]	@ (800eb58 <TIM_OC3_SetConfig+0xf8>)
 800ea8c:	4013      	ands	r3, r2
 800ea8e:	60fb      	str	r3, [r7, #12]
  tmpccmrx &= ~TIM_CCMR2_CC3S;
 800ea90:	68fb      	ldr	r3, [r7, #12]
 800ea92:	f023 0303 	bic.w	r3, r3, #3
 800ea96:	60fb      	str	r3, [r7, #12]
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 800ea98:	683b      	ldr	r3, [r7, #0]
 800ea9a:	681b      	ldr	r3, [r3, #0]
 800ea9c:	68fa      	ldr	r2, [r7, #12]
 800ea9e:	4313      	orrs	r3, r2
 800eaa0:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC3P;
 800eaa2:	697b      	ldr	r3, [r7, #20]
 800eaa4:	f423 7300 	bic.w	r3, r3, #512	@ 0x200
 800eaa8:	617b      	str	r3, [r7, #20]
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 8U);
 800eaaa:	683b      	ldr	r3, [r7, #0]
 800eaac:	689b      	ldr	r3, [r3, #8]
 800eaae:	021b      	lsls	r3, r3, #8
 800eab0:	697a      	ldr	r2, [r7, #20]
 800eab2:	4313      	orrs	r3, r2
 800eab4:	617b      	str	r3, [r7, #20]

  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
 800eab6:	687b      	ldr	r3, [r7, #4]
 800eab8:	4a28      	ldr	r2, [pc, #160]	@ (800eb5c <TIM_OC3_SetConfig+0xfc>)
 800eaba:	4293      	cmp	r3, r2
 800eabc:	d003      	beq.n	800eac6 <TIM_OC3_SetConfig+0x66>
 800eabe:	687b      	ldr	r3, [r7, #4]
 800eac0:	4a27      	ldr	r2, [pc, #156]	@ (800eb60 <TIM_OC3_SetConfig+0x100>)
 800eac2:	4293      	cmp	r3, r2
 800eac4:	d10d      	bne.n	800eae2 <TIM_OC3_SetConfig+0x82>
  {
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC3NP;
 800eac6:	697b      	ldr	r3, [r7, #20]
 800eac8:	f423 6300 	bic.w	r3, r3, #2048	@ 0x800
 800eacc:	617b      	str	r3, [r7, #20]
    /* Set the Output N Polarity */
    tmpccer |= (OC_Config->OCNPolarity << 8U);
 800eace:	683b      	ldr	r3, [r7, #0]
 800ead0:	68db      	ldr	r3, [r3, #12]
 800ead2:	021b      	lsls	r3, r3, #8
 800ead4:	697a      	ldr	r2, [r7, #20]
 800ead6:	4313      	orrs	r3, r2
 800ead8:	617b      	str	r3, [r7, #20]
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC3NE;
 800eada:	697b      	ldr	r3, [r7, #20]
 800eadc:	f423 6380 	bic.w	r3, r3, #1024	@ 0x400
 800eae0:	617b      	str	r3, [r7, #20]
  }

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 800eae2:	687b      	ldr	r3, [r7, #4]
 800eae4:	4a1d      	ldr	r2, [pc, #116]	@ (800eb5c <TIM_OC3_SetConfig+0xfc>)
 800eae6:	4293      	cmp	r3, r2
 800eae8:	d00f      	beq.n	800eb0a <TIM_OC3_SetConfig+0xaa>
 800eaea:	687b      	ldr	r3, [r7, #4]
 800eaec:	4a1c      	ldr	r2, [pc, #112]	@ (800eb60 <TIM_OC3_SetConfig+0x100>)
 800eaee:	4293      	cmp	r3, r2
 800eaf0:	d00b      	beq.n	800eb0a <TIM_OC3_SetConfig+0xaa>
 800eaf2:	687b      	ldr	r3, [r7, #4]
 800eaf4:	4a1b      	ldr	r2, [pc, #108]	@ (800eb64 <TIM_OC3_SetConfig+0x104>)
 800eaf6:	4293      	cmp	r3, r2
 800eaf8:	d007      	beq.n	800eb0a <TIM_OC3_SetConfig+0xaa>
 800eafa:	687b      	ldr	r3, [r7, #4]
 800eafc:	4a1a      	ldr	r2, [pc, #104]	@ (800eb68 <TIM_OC3_SetConfig+0x108>)
 800eafe:	4293      	cmp	r3, r2
 800eb00:	d003      	beq.n	800eb0a <TIM_OC3_SetConfig+0xaa>
 800eb02:	687b      	ldr	r3, [r7, #4]
 800eb04:	4a19      	ldr	r2, [pc, #100]	@ (800eb6c <TIM_OC3_SetConfig+0x10c>)
 800eb06:	4293      	cmp	r3, r2
 800eb08:	d113      	bne.n	800eb32 <TIM_OC3_SetConfig+0xd2>
    /* Check parameters */
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS3;
 800eb0a:	693b      	ldr	r3, [r7, #16]
 800eb0c:	f423 5380 	bic.w	r3, r3, #4096	@ 0x1000
 800eb10:	613b      	str	r3, [r7, #16]
    tmpcr2 &= ~TIM_CR2_OIS3N;
 800eb12:	693b      	ldr	r3, [r7, #16]
 800eb14:	f423 5300 	bic.w	r3, r3, #8192	@ 0x2000
 800eb18:	613b      	str	r3, [r7, #16]
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 4U);
 800eb1a:	683b      	ldr	r3, [r7, #0]
 800eb1c:	695b      	ldr	r3, [r3, #20]
 800eb1e:	011b      	lsls	r3, r3, #4
 800eb20:	693a      	ldr	r2, [r7, #16]
 800eb22:	4313      	orrs	r3, r2
 800eb24:	613b      	str	r3, [r7, #16]
    /* Set the Output N Idle state */
    tmpcr2 |= (OC_Config->OCNIdleState << 4U);
 800eb26:	683b      	ldr	r3, [r7, #0]
 800eb28:	699b      	ldr	r3, [r3, #24]
 800eb2a:	011b      	lsls	r3, r3, #4
 800eb2c:	693a      	ldr	r2, [r7, #16]
 800eb2e:	4313      	orrs	r3, r2
 800eb30:	613b      	str	r3, [r7, #16]
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 800eb32:	687b      	ldr	r3, [r7, #4]
 800eb34:	693a      	ldr	r2, [r7, #16]
 800eb36:	605a      	str	r2, [r3, #4]

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;
 800eb38:	687b      	ldr	r3, [r7, #4]
 800eb3a:	68fa      	ldr	r2, [r7, #12]
 800eb3c:	61da      	str	r2, [r3, #28]

  /* Set the Capture Compare Register value */
  TIMx->CCR3 = OC_Config->Pulse;
 800eb3e:	683b      	ldr	r3, [r7, #0]
 800eb40:	685a      	ldr	r2, [r3, #4]
 800eb42:	687b      	ldr	r3, [r7, #4]
 800eb44:	63da      	str	r2, [r3, #60]	@ 0x3c

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 800eb46:	687b      	ldr	r3, [r7, #4]
 800eb48:	697a      	ldr	r2, [r7, #20]
 800eb4a:	621a      	str	r2, [r3, #32]
}
 800eb4c:	bf00      	nop
 800eb4e:	371c      	adds	r7, #28
 800eb50:	46bd      	mov	sp, r7
 800eb52:	f85d 7b04 	ldr.w	r7, [sp], #4
 800eb56:	4770      	bx	lr
 800eb58:	fffeff8f 	.word	0xfffeff8f
 800eb5c:	40010000 	.word	0x40010000
 800eb60:	40010400 	.word	0x40010400
 800eb64:	40014000 	.word	0x40014000
 800eb68:	40014400 	.word	0x40014400
 800eb6c:	40014800 	.word	0x40014800

0800eb70 <TIM_OC4_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The output configuration structure
  * @retval None
  */
static void TIM_OC4_SetConfig(TIM_TypeDef *TIMx, const TIM_OC_InitTypeDef *OC_Config)
{
 800eb70:	b480      	push	{r7}
 800eb72:	b087      	sub	sp, #28
 800eb74:	af00      	add	r7, sp, #0
 800eb76:	6078      	str	r0, [r7, #4]
 800eb78:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 800eb7a:	687b      	ldr	r3, [r7, #4]
 800eb7c:	6a1b      	ldr	r3, [r3, #32]
 800eb7e:	613b      	str	r3, [r7, #16]

  /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= ~TIM_CCER_CC4E;
 800eb80:	687b      	ldr	r3, [r7, #4]
 800eb82:	6a1b      	ldr	r3, [r3, #32]
 800eb84:	f423 5280 	bic.w	r2, r3, #4096	@ 0x1000
 800eb88:	687b      	ldr	r3, [r7, #4]
 800eb8a:	621a      	str	r2, [r3, #32]

  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 800eb8c:	687b      	ldr	r3, [r7, #4]
 800eb8e:	685b      	ldr	r3, [r3, #4]
 800eb90:	617b      	str	r3, [r7, #20]

  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 800eb92:	687b      	ldr	r3, [r7, #4]
 800eb94:	69db      	ldr	r3, [r3, #28]
 800eb96:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC4M;
 800eb98:	68fa      	ldr	r2, [r7, #12]
 800eb9a:	4b24      	ldr	r3, [pc, #144]	@ (800ec2c <TIM_OC4_SetConfig+0xbc>)
 800eb9c:	4013      	ands	r3, r2
 800eb9e:	60fb      	str	r3, [r7, #12]
  tmpccmrx &= ~TIM_CCMR2_CC4S;
 800eba0:	68fb      	ldr	r3, [r7, #12]
 800eba2:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
 800eba6:	60fb      	str	r3, [r7, #12]

  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8U);
 800eba8:	683b      	ldr	r3, [r7, #0]
 800ebaa:	681b      	ldr	r3, [r3, #0]
 800ebac:	021b      	lsls	r3, r3, #8
 800ebae:	68fa      	ldr	r2, [r7, #12]
 800ebb0:	4313      	orrs	r3, r2
 800ebb2:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC4P;
 800ebb4:	693b      	ldr	r3, [r7, #16]
 800ebb6:	f423 5300 	bic.w	r3, r3, #8192	@ 0x2000
 800ebba:	613b      	str	r3, [r7, #16]
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 12U);
 800ebbc:	683b      	ldr	r3, [r7, #0]
 800ebbe:	689b      	ldr	r3, [r3, #8]
 800ebc0:	031b      	lsls	r3, r3, #12
 800ebc2:	693a      	ldr	r2, [r7, #16]
 800ebc4:	4313      	orrs	r3, r2
 800ebc6:	613b      	str	r3, [r7, #16]

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 800ebc8:	687b      	ldr	r3, [r7, #4]
 800ebca:	4a19      	ldr	r2, [pc, #100]	@ (800ec30 <TIM_OC4_SetConfig+0xc0>)
 800ebcc:	4293      	cmp	r3, r2
 800ebce:	d00f      	beq.n	800ebf0 <TIM_OC4_SetConfig+0x80>
 800ebd0:	687b      	ldr	r3, [r7, #4]
 800ebd2:	4a18      	ldr	r2, [pc, #96]	@ (800ec34 <TIM_OC4_SetConfig+0xc4>)
 800ebd4:	4293      	cmp	r3, r2
 800ebd6:	d00b      	beq.n	800ebf0 <TIM_OC4_SetConfig+0x80>
 800ebd8:	687b      	ldr	r3, [r7, #4]
 800ebda:	4a17      	ldr	r2, [pc, #92]	@ (800ec38 <TIM_OC4_SetConfig+0xc8>)
 800ebdc:	4293      	cmp	r3, r2
 800ebde:	d007      	beq.n	800ebf0 <TIM_OC4_SetConfig+0x80>
 800ebe0:	687b      	ldr	r3, [r7, #4]
 800ebe2:	4a16      	ldr	r2, [pc, #88]	@ (800ec3c <TIM_OC4_SetConfig+0xcc>)
 800ebe4:	4293      	cmp	r3, r2
 800ebe6:	d003      	beq.n	800ebf0 <TIM_OC4_SetConfig+0x80>
 800ebe8:	687b      	ldr	r3, [r7, #4]
 800ebea:	4a15      	ldr	r2, [pc, #84]	@ (800ec40 <TIM_OC4_SetConfig+0xd0>)
 800ebec:	4293      	cmp	r3, r2
 800ebee:	d109      	bne.n	800ec04 <TIM_OC4_SetConfig+0x94>
  {
    /* Check parameters */
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

    /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS4;
 800ebf0:	697b      	ldr	r3, [r7, #20]
 800ebf2:	f423 4380 	bic.w	r3, r3, #16384	@ 0x4000
 800ebf6:	617b      	str	r3, [r7, #20]

    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 6U);
 800ebf8:	683b      	ldr	r3, [r7, #0]
 800ebfa:	695b      	ldr	r3, [r3, #20]
 800ebfc:	019b      	lsls	r3, r3, #6
 800ebfe:	697a      	ldr	r2, [r7, #20]
 800ec00:	4313      	orrs	r3, r2
 800ec02:	617b      	str	r3, [r7, #20]
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 800ec04:	687b      	ldr	r3, [r7, #4]
 800ec06:	697a      	ldr	r2, [r7, #20]
 800ec08:	605a      	str	r2, [r3, #4]

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;
 800ec0a:	687b      	ldr	r3, [r7, #4]
 800ec0c:	68fa      	ldr	r2, [r7, #12]
 800ec0e:	61da      	str	r2, [r3, #28]

  /* Set the Capture Compare Register value */
  TIMx->CCR4 = OC_Config->Pulse;
 800ec10:	683b      	ldr	r3, [r7, #0]
 800ec12:	685a      	ldr	r2, [r3, #4]
 800ec14:	687b      	ldr	r3, [r7, #4]
 800ec16:	641a      	str	r2, [r3, #64]	@ 0x40

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 800ec18:	687b      	ldr	r3, [r7, #4]
 800ec1a:	693a      	ldr	r2, [r7, #16]
 800ec1c:	621a      	str	r2, [r3, #32]
}
 800ec1e:	bf00      	nop
 800ec20:	371c      	adds	r7, #28
 800ec22:	46bd      	mov	sp, r7
 800ec24:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ec28:	4770      	bx	lr
 800ec2a:	bf00      	nop
 800ec2c:	feff8fff 	.word	0xfeff8fff
 800ec30:	40010000 	.word	0x40010000
 800ec34:	40010400 	.word	0x40010400
 800ec38:	40014000 	.word	0x40014000
 800ec3c:	40014400 	.word	0x40014400
 800ec40:	40014800 	.word	0x40014800

0800ec44 <TIM_OC5_SetConfig>:
  * @param  OC_Config The output configuration structure
  * @retval None
  */
static void TIM_OC5_SetConfig(TIM_TypeDef *TIMx,
                              const TIM_OC_InitTypeDef *OC_Config)
{
 800ec44:	b480      	push	{r7}
 800ec46:	b087      	sub	sp, #28
 800ec48:	af00      	add	r7, sp, #0
 800ec4a:	6078      	str	r0, [r7, #4]
 800ec4c:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 800ec4e:	687b      	ldr	r3, [r7, #4]
 800ec50:	6a1b      	ldr	r3, [r3, #32]
 800ec52:	613b      	str	r3, [r7, #16]

  /* Disable the output: Reset the CCxE Bit */
  TIMx->CCER &= ~TIM_CCER_CC5E;
 800ec54:	687b      	ldr	r3, [r7, #4]
 800ec56:	6a1b      	ldr	r3, [r3, #32]
 800ec58:	f423 3280 	bic.w	r2, r3, #65536	@ 0x10000
 800ec5c:	687b      	ldr	r3, [r7, #4]
 800ec5e:	621a      	str	r2, [r3, #32]

  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 800ec60:	687b      	ldr	r3, [r7, #4]
 800ec62:	685b      	ldr	r3, [r3, #4]
 800ec64:	617b      	str	r3, [r7, #20]
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR3;
 800ec66:	687b      	ldr	r3, [r7, #4]
 800ec68:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 800ec6a:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~(TIM_CCMR3_OC5M);
 800ec6c:	68fa      	ldr	r2, [r7, #12]
 800ec6e:	4b21      	ldr	r3, [pc, #132]	@ (800ecf4 <TIM_OC5_SetConfig+0xb0>)
 800ec70:	4013      	ands	r3, r2
 800ec72:	60fb      	str	r3, [r7, #12]
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 800ec74:	683b      	ldr	r3, [r7, #0]
 800ec76:	681b      	ldr	r3, [r3, #0]
 800ec78:	68fa      	ldr	r2, [r7, #12]
 800ec7a:	4313      	orrs	r3, r2
 800ec7c:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC5P;
 800ec7e:	693b      	ldr	r3, [r7, #16]
 800ec80:	f423 3300 	bic.w	r3, r3, #131072	@ 0x20000
 800ec84:	613b      	str	r3, [r7, #16]
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 16U);
 800ec86:	683b      	ldr	r3, [r7, #0]
 800ec88:	689b      	ldr	r3, [r3, #8]
 800ec8a:	041b      	lsls	r3, r3, #16
 800ec8c:	693a      	ldr	r2, [r7, #16]
 800ec8e:	4313      	orrs	r3, r2
 800ec90:	613b      	str	r3, [r7, #16]

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 800ec92:	687b      	ldr	r3, [r7, #4]
 800ec94:	4a18      	ldr	r2, [pc, #96]	@ (800ecf8 <TIM_OC5_SetConfig+0xb4>)
 800ec96:	4293      	cmp	r3, r2
 800ec98:	d00f      	beq.n	800ecba <TIM_OC5_SetConfig+0x76>
 800ec9a:	687b      	ldr	r3, [r7, #4]
 800ec9c:	4a17      	ldr	r2, [pc, #92]	@ (800ecfc <TIM_OC5_SetConfig+0xb8>)
 800ec9e:	4293      	cmp	r3, r2
 800eca0:	d00b      	beq.n	800ecba <TIM_OC5_SetConfig+0x76>
 800eca2:	687b      	ldr	r3, [r7, #4]
 800eca4:	4a16      	ldr	r2, [pc, #88]	@ (800ed00 <TIM_OC5_SetConfig+0xbc>)
 800eca6:	4293      	cmp	r3, r2
 800eca8:	d007      	beq.n	800ecba <TIM_OC5_SetConfig+0x76>
 800ecaa:	687b      	ldr	r3, [r7, #4]
 800ecac:	4a15      	ldr	r2, [pc, #84]	@ (800ed04 <TIM_OC5_SetConfig+0xc0>)
 800ecae:	4293      	cmp	r3, r2
 800ecb0:	d003      	beq.n	800ecba <TIM_OC5_SetConfig+0x76>
 800ecb2:	687b      	ldr	r3, [r7, #4]
 800ecb4:	4a14      	ldr	r2, [pc, #80]	@ (800ed08 <TIM_OC5_SetConfig+0xc4>)
 800ecb6:	4293      	cmp	r3, r2
 800ecb8:	d109      	bne.n	800ecce <TIM_OC5_SetConfig+0x8a>
  {
    /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS5;
 800ecba:	697b      	ldr	r3, [r7, #20]
 800ecbc:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
 800ecc0:	617b      	str	r3, [r7, #20]
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 8U);
 800ecc2:	683b      	ldr	r3, [r7, #0]
 800ecc4:	695b      	ldr	r3, [r3, #20]
 800ecc6:	021b      	lsls	r3, r3, #8
 800ecc8:	697a      	ldr	r2, [r7, #20]
 800ecca:	4313      	orrs	r3, r2
 800eccc:	617b      	str	r3, [r7, #20]
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 800ecce:	687b      	ldr	r3, [r7, #4]
 800ecd0:	697a      	ldr	r2, [r7, #20]
 800ecd2:	605a      	str	r2, [r3, #4]

  /* Write to TIMx CCMR3 */
  TIMx->CCMR3 = tmpccmrx;
 800ecd4:	687b      	ldr	r3, [r7, #4]
 800ecd6:	68fa      	ldr	r2, [r7, #12]
 800ecd8:	655a      	str	r2, [r3, #84]	@ 0x54

  /* Set the Capture Compare Register value */
  TIMx->CCR5 = OC_Config->Pulse;
 800ecda:	683b      	ldr	r3, [r7, #0]
 800ecdc:	685a      	ldr	r2, [r3, #4]
 800ecde:	687b      	ldr	r3, [r7, #4]
 800ece0:	659a      	str	r2, [r3, #88]	@ 0x58

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 800ece2:	687b      	ldr	r3, [r7, #4]
 800ece4:	693a      	ldr	r2, [r7, #16]
 800ece6:	621a      	str	r2, [r3, #32]
}
 800ece8:	bf00      	nop
 800ecea:	371c      	adds	r7, #28
 800ecec:	46bd      	mov	sp, r7
 800ecee:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ecf2:	4770      	bx	lr
 800ecf4:	fffeff8f 	.word	0xfffeff8f
 800ecf8:	40010000 	.word	0x40010000
 800ecfc:	40010400 	.word	0x40010400
 800ed00:	40014000 	.word	0x40014000
 800ed04:	40014400 	.word	0x40014400
 800ed08:	40014800 	.word	0x40014800

0800ed0c <TIM_OC6_SetConfig>:
  * @param  OC_Config The output configuration structure
  * @retval None
  */
static void TIM_OC6_SetConfig(TIM_TypeDef *TIMx,
                              const TIM_OC_InitTypeDef *OC_Config)
{
 800ed0c:	b480      	push	{r7}
 800ed0e:	b087      	sub	sp, #28
 800ed10:	af00      	add	r7, sp, #0
 800ed12:	6078      	str	r0, [r7, #4]
 800ed14:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 800ed16:	687b      	ldr	r3, [r7, #4]
 800ed18:	6a1b      	ldr	r3, [r3, #32]
 800ed1a:	613b      	str	r3, [r7, #16]

  /* Disable the output: Reset the CCxE Bit */
  TIMx->CCER &= ~TIM_CCER_CC6E;
 800ed1c:	687b      	ldr	r3, [r7, #4]
 800ed1e:	6a1b      	ldr	r3, [r3, #32]
 800ed20:	f423 1280 	bic.w	r2, r3, #1048576	@ 0x100000
 800ed24:	687b      	ldr	r3, [r7, #4]
 800ed26:	621a      	str	r2, [r3, #32]

  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 800ed28:	687b      	ldr	r3, [r7, #4]
 800ed2a:	685b      	ldr	r3, [r3, #4]
 800ed2c:	617b      	str	r3, [r7, #20]
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR3;
 800ed2e:	687b      	ldr	r3, [r7, #4]
 800ed30:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 800ed32:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~(TIM_CCMR3_OC6M);
 800ed34:	68fa      	ldr	r2, [r7, #12]
 800ed36:	4b22      	ldr	r3, [pc, #136]	@ (800edc0 <TIM_OC6_SetConfig+0xb4>)
 800ed38:	4013      	ands	r3, r2
 800ed3a:	60fb      	str	r3, [r7, #12]
  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8U);
 800ed3c:	683b      	ldr	r3, [r7, #0]
 800ed3e:	681b      	ldr	r3, [r3, #0]
 800ed40:	021b      	lsls	r3, r3, #8
 800ed42:	68fa      	ldr	r2, [r7, #12]
 800ed44:	4313      	orrs	r3, r2
 800ed46:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Polarity level */
  tmpccer &= (uint32_t)~TIM_CCER_CC6P;
 800ed48:	693b      	ldr	r3, [r7, #16]
 800ed4a:	f423 1300 	bic.w	r3, r3, #2097152	@ 0x200000
 800ed4e:	613b      	str	r3, [r7, #16]
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 20U);
 800ed50:	683b      	ldr	r3, [r7, #0]
 800ed52:	689b      	ldr	r3, [r3, #8]
 800ed54:	051b      	lsls	r3, r3, #20
 800ed56:	693a      	ldr	r2, [r7, #16]
 800ed58:	4313      	orrs	r3, r2
 800ed5a:	613b      	str	r3, [r7, #16]

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 800ed5c:	687b      	ldr	r3, [r7, #4]
 800ed5e:	4a19      	ldr	r2, [pc, #100]	@ (800edc4 <TIM_OC6_SetConfig+0xb8>)
 800ed60:	4293      	cmp	r3, r2
 800ed62:	d00f      	beq.n	800ed84 <TIM_OC6_SetConfig+0x78>
 800ed64:	687b      	ldr	r3, [r7, #4]
 800ed66:	4a18      	ldr	r2, [pc, #96]	@ (800edc8 <TIM_OC6_SetConfig+0xbc>)
 800ed68:	4293      	cmp	r3, r2
 800ed6a:	d00b      	beq.n	800ed84 <TIM_OC6_SetConfig+0x78>
 800ed6c:	687b      	ldr	r3, [r7, #4]
 800ed6e:	4a17      	ldr	r2, [pc, #92]	@ (800edcc <TIM_OC6_SetConfig+0xc0>)
 800ed70:	4293      	cmp	r3, r2
 800ed72:	d007      	beq.n	800ed84 <TIM_OC6_SetConfig+0x78>
 800ed74:	687b      	ldr	r3, [r7, #4]
 800ed76:	4a16      	ldr	r2, [pc, #88]	@ (800edd0 <TIM_OC6_SetConfig+0xc4>)
 800ed78:	4293      	cmp	r3, r2
 800ed7a:	d003      	beq.n	800ed84 <TIM_OC6_SetConfig+0x78>
 800ed7c:	687b      	ldr	r3, [r7, #4]
 800ed7e:	4a15      	ldr	r2, [pc, #84]	@ (800edd4 <TIM_OC6_SetConfig+0xc8>)
 800ed80:	4293      	cmp	r3, r2
 800ed82:	d109      	bne.n	800ed98 <TIM_OC6_SetConfig+0x8c>
  {
    /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS6;
 800ed84:	697b      	ldr	r3, [r7, #20]
 800ed86:	f423 2380 	bic.w	r3, r3, #262144	@ 0x40000
 800ed8a:	617b      	str	r3, [r7, #20]
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 10U);
 800ed8c:	683b      	ldr	r3, [r7, #0]
 800ed8e:	695b      	ldr	r3, [r3, #20]
 800ed90:	029b      	lsls	r3, r3, #10
 800ed92:	697a      	ldr	r2, [r7, #20]
 800ed94:	4313      	orrs	r3, r2
 800ed96:	617b      	str	r3, [r7, #20]
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 800ed98:	687b      	ldr	r3, [r7, #4]
 800ed9a:	697a      	ldr	r2, [r7, #20]
 800ed9c:	605a      	str	r2, [r3, #4]

  /* Write to TIMx CCMR3 */
  TIMx->CCMR3 = tmpccmrx;
 800ed9e:	687b      	ldr	r3, [r7, #4]
 800eda0:	68fa      	ldr	r2, [r7, #12]
 800eda2:	655a      	str	r2, [r3, #84]	@ 0x54

  /* Set the Capture Compare Register value */
  TIMx->CCR6 = OC_Config->Pulse;
 800eda4:	683b      	ldr	r3, [r7, #0]
 800eda6:	685a      	ldr	r2, [r3, #4]
 800eda8:	687b      	ldr	r3, [r7, #4]
 800edaa:	65da      	str	r2, [r3, #92]	@ 0x5c

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 800edac:	687b      	ldr	r3, [r7, #4]
 800edae:	693a      	ldr	r2, [r7, #16]
 800edb0:	621a      	str	r2, [r3, #32]
}
 800edb2:	bf00      	nop
 800edb4:	371c      	adds	r7, #28
 800edb6:	46bd      	mov	sp, r7
 800edb8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800edbc:	4770      	bx	lr
 800edbe:	bf00      	nop
 800edc0:	feff8fff 	.word	0xfeff8fff
 800edc4:	40010000 	.word	0x40010000
 800edc8:	40010400 	.word	0x40010400
 800edcc:	40014000 	.word	0x40014000
 800edd0:	40014400 	.word	0x40014400
 800edd4:	40014800 	.word	0x40014800

0800edd8 <TIM_TI1_ConfigInputStage>:
  * @param  TIM_ICFilter Specifies the Input Capture Filter.
  *          This parameter must be a value between 0x00 and 0x0F.
  * @retval None
  */
static void TIM_TI1_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
{
 800edd8:	b480      	push	{r7}
 800edda:	b087      	sub	sp, #28
 800eddc:	af00      	add	r7, sp, #0
 800edde:	60f8      	str	r0, [r7, #12]
 800ede0:	60b9      	str	r1, [r7, #8]
 800ede2:	607a      	str	r2, [r7, #4]
  uint32_t tmpccmr1;
  uint32_t tmpccer;

  /* Disable the Channel 1: Reset the CC1E Bit */
  tmpccer = TIMx->CCER;
 800ede4:	68fb      	ldr	r3, [r7, #12]
 800ede6:	6a1b      	ldr	r3, [r3, #32]
 800ede8:	617b      	str	r3, [r7, #20]
  TIMx->CCER &= ~TIM_CCER_CC1E;
 800edea:	68fb      	ldr	r3, [r7, #12]
 800edec:	6a1b      	ldr	r3, [r3, #32]
 800edee:	f023 0201 	bic.w	r2, r3, #1
 800edf2:	68fb      	ldr	r3, [r7, #12]
 800edf4:	621a      	str	r2, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;
 800edf6:	68fb      	ldr	r3, [r7, #12]
 800edf8:	699b      	ldr	r3, [r3, #24]
 800edfa:	613b      	str	r3, [r7, #16]

  /* Set the filter */
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
 800edfc:	693b      	ldr	r3, [r7, #16]
 800edfe:	f023 03f0 	bic.w	r3, r3, #240	@ 0xf0
 800ee02:	613b      	str	r3, [r7, #16]
  tmpccmr1 |= (TIM_ICFilter << 4U);
 800ee04:	687b      	ldr	r3, [r7, #4]
 800ee06:	011b      	lsls	r3, r3, #4
 800ee08:	693a      	ldr	r2, [r7, #16]
 800ee0a:	4313      	orrs	r3, r2
 800ee0c:	613b      	str	r3, [r7, #16]

  /* Select the Polarity and set the CC1E Bit */
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
 800ee0e:	697b      	ldr	r3, [r7, #20]
 800ee10:	f023 030a 	bic.w	r3, r3, #10
 800ee14:	617b      	str	r3, [r7, #20]
  tmpccer |= TIM_ICPolarity;
 800ee16:	697a      	ldr	r2, [r7, #20]
 800ee18:	68bb      	ldr	r3, [r7, #8]
 800ee1a:	4313      	orrs	r3, r2
 800ee1c:	617b      	str	r3, [r7, #20]

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1;
 800ee1e:	68fb      	ldr	r3, [r7, #12]
 800ee20:	693a      	ldr	r2, [r7, #16]
 800ee22:	619a      	str	r2, [r3, #24]
  TIMx->CCER = tmpccer;
 800ee24:	68fb      	ldr	r3, [r7, #12]
 800ee26:	697a      	ldr	r2, [r7, #20]
 800ee28:	621a      	str	r2, [r3, #32]
}
 800ee2a:	bf00      	nop
 800ee2c:	371c      	adds	r7, #28
 800ee2e:	46bd      	mov	sp, r7
 800ee30:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ee34:	4770      	bx	lr

0800ee36 <TIM_TI2_ConfigInputStage>:
  * @param  TIM_ICFilter Specifies the Input Capture Filter.
  *          This parameter must be a value between 0x00 and 0x0F.
  * @retval None
  */
static void TIM_TI2_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
{
 800ee36:	b480      	push	{r7}
 800ee38:	b087      	sub	sp, #28
 800ee3a:	af00      	add	r7, sp, #0
 800ee3c:	60f8      	str	r0, [r7, #12]
 800ee3e:	60b9      	str	r1, [r7, #8]
 800ee40:	607a      	str	r2, [r7, #4]
  uint32_t tmpccmr1;
  uint32_t tmpccer;

  /* Disable the Channel 2: Reset the CC2E Bit */
  tmpccer = TIMx->CCER;
 800ee42:	68fb      	ldr	r3, [r7, #12]
 800ee44:	6a1b      	ldr	r3, [r3, #32]
 800ee46:	617b      	str	r3, [r7, #20]
  TIMx->CCER &= ~TIM_CCER_CC2E;
 800ee48:	68fb      	ldr	r3, [r7, #12]
 800ee4a:	6a1b      	ldr	r3, [r3, #32]
 800ee4c:	f023 0210 	bic.w	r2, r3, #16
 800ee50:	68fb      	ldr	r3, [r7, #12]
 800ee52:	621a      	str	r2, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;
 800ee54:	68fb      	ldr	r3, [r7, #12]
 800ee56:	699b      	ldr	r3, [r3, #24]
 800ee58:	613b      	str	r3, [r7, #16]

  /* Set the filter */
  tmpccmr1 &= ~TIM_CCMR1_IC2F;
 800ee5a:	693b      	ldr	r3, [r7, #16]
 800ee5c:	f423 4370 	bic.w	r3, r3, #61440	@ 0xf000
 800ee60:	613b      	str	r3, [r7, #16]
  tmpccmr1 |= (TIM_ICFilter << 12U);
 800ee62:	687b      	ldr	r3, [r7, #4]
 800ee64:	031b      	lsls	r3, r3, #12
 800ee66:	693a      	ldr	r2, [r7, #16]
 800ee68:	4313      	orrs	r3, r2
 800ee6a:	613b      	str	r3, [r7, #16]

  /* Select the Polarity and set the CC2E Bit */
  tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
 800ee6c:	697b      	ldr	r3, [r7, #20]
 800ee6e:	f023 03a0 	bic.w	r3, r3, #160	@ 0xa0
 800ee72:	617b      	str	r3, [r7, #20]
  tmpccer |= (TIM_ICPolarity << 4U);
 800ee74:	68bb      	ldr	r3, [r7, #8]
 800ee76:	011b      	lsls	r3, r3, #4
 800ee78:	697a      	ldr	r2, [r7, #20]
 800ee7a:	4313      	orrs	r3, r2
 800ee7c:	617b      	str	r3, [r7, #20]

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1 ;
 800ee7e:	68fb      	ldr	r3, [r7, #12]
 800ee80:	693a      	ldr	r2, [r7, #16]
 800ee82:	619a      	str	r2, [r3, #24]
  TIMx->CCER = tmpccer;
 800ee84:	68fb      	ldr	r3, [r7, #12]
 800ee86:	697a      	ldr	r2, [r7, #20]
 800ee88:	621a      	str	r2, [r3, #32]
}
 800ee8a:	bf00      	nop
 800ee8c:	371c      	adds	r7, #28
 800ee8e:	46bd      	mov	sp, r7
 800ee90:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ee94:	4770      	bx	lr
	...

0800ee98 <TIM_ITRx_SetConfig>:
  *       (*)  Value not defined in all devices.
  *
  * @retval None
  */
static void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint32_t InputTriggerSource)
{
 800ee98:	b480      	push	{r7}
 800ee9a:	b085      	sub	sp, #20
 800ee9c:	af00      	add	r7, sp, #0
 800ee9e:	6078      	str	r0, [r7, #4]
 800eea0:	6039      	str	r1, [r7, #0]
  uint32_t tmpsmcr;

  /* Get the TIMx SMCR register value */
  tmpsmcr = TIMx->SMCR;
 800eea2:	687b      	ldr	r3, [r7, #4]
 800eea4:	689b      	ldr	r3, [r3, #8]
 800eea6:	60fb      	str	r3, [r7, #12]
  /* Reset the TS Bits */
  tmpsmcr &= ~TIM_SMCR_TS;
 800eea8:	68fa      	ldr	r2, [r7, #12]
 800eeaa:	4b09      	ldr	r3, [pc, #36]	@ (800eed0 <TIM_ITRx_SetConfig+0x38>)
 800eeac:	4013      	ands	r3, r2
 800eeae:	60fb      	str	r3, [r7, #12]
  /* Set the Input Trigger source and the slave mode*/
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 800eeb0:	683a      	ldr	r2, [r7, #0]
 800eeb2:	68fb      	ldr	r3, [r7, #12]
 800eeb4:	4313      	orrs	r3, r2
 800eeb6:	f043 0307 	orr.w	r3, r3, #7
 800eeba:	60fb      	str	r3, [r7, #12]
  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 800eebc:	687b      	ldr	r3, [r7, #4]
 800eebe:	68fa      	ldr	r2, [r7, #12]
 800eec0:	609a      	str	r2, [r3, #8]
}
 800eec2:	bf00      	nop
 800eec4:	3714      	adds	r7, #20
 800eec6:	46bd      	mov	sp, r7
 800eec8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800eecc:	4770      	bx	lr
 800eece:	bf00      	nop
 800eed0:	ffcfff8f 	.word	0xffcfff8f

0800eed4 <TIM_ETR_SetConfig>:
  *          This parameter must be a value between 0x00 and 0x0F
  * @retval None
  */
void TIM_ETR_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ExtTRGPrescaler,
                       uint32_t TIM_ExtTRGPolarity, uint32_t ExtTRGFilter)
{
 800eed4:	b480      	push	{r7}
 800eed6:	b087      	sub	sp, #28
 800eed8:	af00      	add	r7, sp, #0
 800eeda:	60f8      	str	r0, [r7, #12]
 800eedc:	60b9      	str	r1, [r7, #8]
 800eede:	607a      	str	r2, [r7, #4]
 800eee0:	603b      	str	r3, [r7, #0]
  uint32_t tmpsmcr;

  tmpsmcr = TIMx->SMCR;
 800eee2:	68fb      	ldr	r3, [r7, #12]
 800eee4:	689b      	ldr	r3, [r3, #8]
 800eee6:	617b      	str	r3, [r7, #20]

  /* Reset the ETR Bits */
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 800eee8:	697b      	ldr	r3, [r7, #20]
 800eeea:	f423 437f 	bic.w	r3, r3, #65280	@ 0xff00
 800eeee:	617b      	str	r3, [r7, #20]

  /* Set the Prescaler, the Filter value and the Polarity */
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 800eef0:	683b      	ldr	r3, [r7, #0]
 800eef2:	021a      	lsls	r2, r3, #8
 800eef4:	687b      	ldr	r3, [r7, #4]
 800eef6:	431a      	orrs	r2, r3
 800eef8:	68bb      	ldr	r3, [r7, #8]
 800eefa:	4313      	orrs	r3, r2
 800eefc:	697a      	ldr	r2, [r7, #20]
 800eefe:	4313      	orrs	r3, r2
 800ef00:	617b      	str	r3, [r7, #20]

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 800ef02:	68fb      	ldr	r3, [r7, #12]
 800ef04:	697a      	ldr	r2, [r7, #20]
 800ef06:	609a      	str	r2, [r3, #8]
}
 800ef08:	bf00      	nop
 800ef0a:	371c      	adds	r7, #28
 800ef0c:	46bd      	mov	sp, r7
 800ef0e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ef12:	4770      	bx	lr

0800ef14 <TIM_CCxChannelCmd>:
  * @param  ChannelState specifies the TIM Channel CCxE bit new state.
  *          This parameter can be: TIM_CCx_ENABLE or TIM_CCx_DISABLE.
  * @retval None
  */
void TIM_CCxChannelCmd(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ChannelState)
{
 800ef14:	b480      	push	{r7}
 800ef16:	b087      	sub	sp, #28
 800ef18:	af00      	add	r7, sp, #0
 800ef1a:	60f8      	str	r0, [r7, #12]
 800ef1c:	60b9      	str	r1, [r7, #8]
 800ef1e:	607a      	str	r2, [r7, #4]

  /* Check the parameters */
  assert_param(IS_TIM_CC1_INSTANCE(TIMx));
  assert_param(IS_TIM_CHANNELS(Channel));

  tmp = TIM_CCER_CC1E << (Channel & 0x1FU); /* 0x1FU = 31 bits max shift */
 800ef20:	68bb      	ldr	r3, [r7, #8]
 800ef22:	f003 031f 	and.w	r3, r3, #31
 800ef26:	2201      	movs	r2, #1
 800ef28:	fa02 f303 	lsl.w	r3, r2, r3
 800ef2c:	617b      	str	r3, [r7, #20]

  /* Reset the CCxE Bit */
  TIMx->CCER &= ~tmp;
 800ef2e:	68fb      	ldr	r3, [r7, #12]
 800ef30:	6a1a      	ldr	r2, [r3, #32]
 800ef32:	697b      	ldr	r3, [r7, #20]
 800ef34:	43db      	mvns	r3, r3
 800ef36:	401a      	ands	r2, r3
 800ef38:	68fb      	ldr	r3, [r7, #12]
 800ef3a:	621a      	str	r2, [r3, #32]

  /* Set or reset the CCxE Bit */
  TIMx->CCER |= (uint32_t)(ChannelState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
 800ef3c:	68fb      	ldr	r3, [r7, #12]
 800ef3e:	6a1a      	ldr	r2, [r3, #32]
 800ef40:	68bb      	ldr	r3, [r7, #8]
 800ef42:	f003 031f 	and.w	r3, r3, #31
 800ef46:	6879      	ldr	r1, [r7, #4]
 800ef48:	fa01 f303 	lsl.w	r3, r1, r3
 800ef4c:	431a      	orrs	r2, r3
 800ef4e:	68fb      	ldr	r3, [r7, #12]
 800ef50:	621a      	str	r2, [r3, #32]
}
 800ef52:	bf00      	nop
 800ef54:	371c      	adds	r7, #28
 800ef56:	46bd      	mov	sp, r7
 800ef58:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ef5c:	4770      	bx	lr
	...

0800ef60 <HAL_TIMEx_MasterConfigSynchronization>:
  *         mode.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIMEx_MasterConfigSynchronization(TIM_HandleTypeDef *htim,
                                                        const TIM_MasterConfigTypeDef *sMasterConfig)
{
 800ef60:	b480      	push	{r7}
 800ef62:	b085      	sub	sp, #20
 800ef64:	af00      	add	r7, sp, #0
 800ef66:	6078      	str	r0, [r7, #4]
 800ef68:	6039      	str	r1, [r7, #0]
  assert_param(IS_TIM_MASTER_INSTANCE(htim->Instance));
  assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
  assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));

  /* Check input state */
  __HAL_LOCK(htim);
 800ef6a:	687b      	ldr	r3, [r7, #4]
 800ef6c:	f893 303c 	ldrb.w	r3, [r3, #60]	@ 0x3c
 800ef70:	2b01      	cmp	r3, #1
 800ef72:	d101      	bne.n	800ef78 <HAL_TIMEx_MasterConfigSynchronization+0x18>
 800ef74:	2302      	movs	r3, #2
 800ef76:	e06d      	b.n	800f054 <HAL_TIMEx_MasterConfigSynchronization+0xf4>
 800ef78:	687b      	ldr	r3, [r7, #4]
 800ef7a:	2201      	movs	r2, #1
 800ef7c:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c

  /* Change the handler state */
  htim->State = HAL_TIM_STATE_BUSY;
 800ef80:	687b      	ldr	r3, [r7, #4]
 800ef82:	2202      	movs	r2, #2
 800ef84:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d

  /* Get the TIMx CR2 register value */
  tmpcr2 = htim->Instance->CR2;
 800ef88:	687b      	ldr	r3, [r7, #4]
 800ef8a:	681b      	ldr	r3, [r3, #0]
 800ef8c:	685b      	ldr	r3, [r3, #4]
 800ef8e:	60fb      	str	r3, [r7, #12]

  /* Get the TIMx SMCR register value */
  tmpsmcr = htim->Instance->SMCR;
 800ef90:	687b      	ldr	r3, [r7, #4]
 800ef92:	681b      	ldr	r3, [r3, #0]
 800ef94:	689b      	ldr	r3, [r3, #8]
 800ef96:	60bb      	str	r3, [r7, #8]

  /* If the timer supports ADC synchronization through TRGO2, set the master mode selection 2 */
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
 800ef98:	687b      	ldr	r3, [r7, #4]
 800ef9a:	681b      	ldr	r3, [r3, #0]
 800ef9c:	4a30      	ldr	r2, [pc, #192]	@ (800f060 <HAL_TIMEx_MasterConfigSynchronization+0x100>)
 800ef9e:	4293      	cmp	r3, r2
 800efa0:	d004      	beq.n	800efac <HAL_TIMEx_MasterConfigSynchronization+0x4c>
 800efa2:	687b      	ldr	r3, [r7, #4]
 800efa4:	681b      	ldr	r3, [r3, #0]
 800efa6:	4a2f      	ldr	r2, [pc, #188]	@ (800f064 <HAL_TIMEx_MasterConfigSynchronization+0x104>)
 800efa8:	4293      	cmp	r3, r2
 800efaa:	d108      	bne.n	800efbe <HAL_TIMEx_MasterConfigSynchronization+0x5e>
  {
    /* Check the parameters */
    assert_param(IS_TIM_TRGO2_SOURCE(sMasterConfig->MasterOutputTrigger2));

    /* Clear the MMS2 bits */
    tmpcr2 &= ~TIM_CR2_MMS2;
 800efac:	68fb      	ldr	r3, [r7, #12]
 800efae:	f423 0370 	bic.w	r3, r3, #15728640	@ 0xf00000
 800efb2:	60fb      	str	r3, [r7, #12]
    /* Select the TRGO2 source*/
    tmpcr2 |= sMasterConfig->MasterOutputTrigger2;
 800efb4:	683b      	ldr	r3, [r7, #0]
 800efb6:	685b      	ldr	r3, [r3, #4]
 800efb8:	68fa      	ldr	r2, [r7, #12]
 800efba:	4313      	orrs	r3, r2
 800efbc:	60fb      	str	r3, [r7, #12]
  }

  /* Reset the MMS Bits */
  tmpcr2 &= ~TIM_CR2_MMS;
 800efbe:	68fb      	ldr	r3, [r7, #12]
 800efc0:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
 800efc4:	60fb      	str	r3, [r7, #12]
  /* Select the TRGO source */
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 800efc6:	683b      	ldr	r3, [r7, #0]
 800efc8:	681b      	ldr	r3, [r3, #0]
 800efca:	68fa      	ldr	r2, [r7, #12]
 800efcc:	4313      	orrs	r3, r2
 800efce:	60fb      	str	r3, [r7, #12]

  /* Update TIMx CR2 */
  htim->Instance->CR2 = tmpcr2;
 800efd0:	687b      	ldr	r3, [r7, #4]
 800efd2:	681b      	ldr	r3, [r3, #0]
 800efd4:	68fa      	ldr	r2, [r7, #12]
 800efd6:	605a      	str	r2, [r3, #4]

  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 800efd8:	687b      	ldr	r3, [r7, #4]
 800efda:	681b      	ldr	r3, [r3, #0]
 800efdc:	4a20      	ldr	r2, [pc, #128]	@ (800f060 <HAL_TIMEx_MasterConfigSynchronization+0x100>)
 800efde:	4293      	cmp	r3, r2
 800efe0:	d022      	beq.n	800f028 <HAL_TIMEx_MasterConfigSynchronization+0xc8>
 800efe2:	687b      	ldr	r3, [r7, #4]
 800efe4:	681b      	ldr	r3, [r3, #0]
 800efe6:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 800efea:	d01d      	beq.n	800f028 <HAL_TIMEx_MasterConfigSynchronization+0xc8>
 800efec:	687b      	ldr	r3, [r7, #4]
 800efee:	681b      	ldr	r3, [r3, #0]
 800eff0:	4a1d      	ldr	r2, [pc, #116]	@ (800f068 <HAL_TIMEx_MasterConfigSynchronization+0x108>)
 800eff2:	4293      	cmp	r3, r2
 800eff4:	d018      	beq.n	800f028 <HAL_TIMEx_MasterConfigSynchronization+0xc8>
 800eff6:	687b      	ldr	r3, [r7, #4]
 800eff8:	681b      	ldr	r3, [r3, #0]
 800effa:	4a1c      	ldr	r2, [pc, #112]	@ (800f06c <HAL_TIMEx_MasterConfigSynchronization+0x10c>)
 800effc:	4293      	cmp	r3, r2
 800effe:	d013      	beq.n	800f028 <HAL_TIMEx_MasterConfigSynchronization+0xc8>
 800f000:	687b      	ldr	r3, [r7, #4]
 800f002:	681b      	ldr	r3, [r3, #0]
 800f004:	4a1a      	ldr	r2, [pc, #104]	@ (800f070 <HAL_TIMEx_MasterConfigSynchronization+0x110>)
 800f006:	4293      	cmp	r3, r2
 800f008:	d00e      	beq.n	800f028 <HAL_TIMEx_MasterConfigSynchronization+0xc8>
 800f00a:	687b      	ldr	r3, [r7, #4]
 800f00c:	681b      	ldr	r3, [r3, #0]
 800f00e:	4a15      	ldr	r2, [pc, #84]	@ (800f064 <HAL_TIMEx_MasterConfigSynchronization+0x104>)
 800f010:	4293      	cmp	r3, r2
 800f012:	d009      	beq.n	800f028 <HAL_TIMEx_MasterConfigSynchronization+0xc8>
 800f014:	687b      	ldr	r3, [r7, #4]
 800f016:	681b      	ldr	r3, [r3, #0]
 800f018:	4a16      	ldr	r2, [pc, #88]	@ (800f074 <HAL_TIMEx_MasterConfigSynchronization+0x114>)
 800f01a:	4293      	cmp	r3, r2
 800f01c:	d004      	beq.n	800f028 <HAL_TIMEx_MasterConfigSynchronization+0xc8>
 800f01e:	687b      	ldr	r3, [r7, #4]
 800f020:	681b      	ldr	r3, [r3, #0]
 800f022:	4a15      	ldr	r2, [pc, #84]	@ (800f078 <HAL_TIMEx_MasterConfigSynchronization+0x118>)
 800f024:	4293      	cmp	r3, r2
 800f026:	d10c      	bne.n	800f042 <HAL_TIMEx_MasterConfigSynchronization+0xe2>
  {
    /* Reset the MSM Bit */
    tmpsmcr &= ~TIM_SMCR_MSM;
 800f028:	68bb      	ldr	r3, [r7, #8]
 800f02a:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
 800f02e:	60bb      	str	r3, [r7, #8]
    /* Set master mode */
    tmpsmcr |= sMasterConfig->MasterSlaveMode;
 800f030:	683b      	ldr	r3, [r7, #0]
 800f032:	689b      	ldr	r3, [r3, #8]
 800f034:	68ba      	ldr	r2, [r7, #8]
 800f036:	4313      	orrs	r3, r2
 800f038:	60bb      	str	r3, [r7, #8]

    /* Update TIMx SMCR */
    htim->Instance->SMCR = tmpsmcr;
 800f03a:	687b      	ldr	r3, [r7, #4]
 800f03c:	681b      	ldr	r3, [r3, #0]
 800f03e:	68ba      	ldr	r2, [r7, #8]
 800f040:	609a      	str	r2, [r3, #8]
  }

  /* Change the htim state */
  htim->State = HAL_TIM_STATE_READY;
 800f042:	687b      	ldr	r3, [r7, #4]
 800f044:	2201      	movs	r2, #1
 800f046:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d

  __HAL_UNLOCK(htim);
 800f04a:	687b      	ldr	r3, [r7, #4]
 800f04c:	2200      	movs	r2, #0
 800f04e:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c

  return HAL_OK;
 800f052:	2300      	movs	r3, #0
}
 800f054:	4618      	mov	r0, r3
 800f056:	3714      	adds	r7, #20
 800f058:	46bd      	mov	sp, r7
 800f05a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f05e:	4770      	bx	lr
 800f060:	40010000 	.word	0x40010000
 800f064:	40010400 	.word	0x40010400
 800f068:	40000400 	.word	0x40000400
 800f06c:	40000800 	.word	0x40000800
 800f070:	40000c00 	.word	0x40000c00
 800f074:	40001800 	.word	0x40001800
 800f078:	40014000 	.word	0x40014000

0800f07c <HAL_TIMEx_ConfigBreakDeadTime>:
  *         interrupt can be enabled by calling the @ref __HAL_TIM_ENABLE_IT macro.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIMEx_ConfigBreakDeadTime(TIM_HandleTypeDef *htim,
                                                const TIM_BreakDeadTimeConfigTypeDef *sBreakDeadTimeConfig)
{
 800f07c:	b480      	push	{r7}
 800f07e:	b085      	sub	sp, #20
 800f080:	af00      	add	r7, sp, #0
 800f082:	6078      	str	r0, [r7, #4]
 800f084:	6039      	str	r1, [r7, #0]
  /* Keep this variable initialized to 0 as it is used to configure BDTR register */
  uint32_t tmpbdtr = 0U;
 800f086:	2300      	movs	r3, #0
 800f088:	60fb      	str	r3, [r7, #12]
#if defined(TIM_BDTR_BKBID)
  assert_param(IS_TIM_BREAK_AFMODE(sBreakDeadTimeConfig->BreakAFMode));
#endif /* TIM_BDTR_BKBID */

  /* Check input state */
  __HAL_LOCK(htim);
 800f08a:	687b      	ldr	r3, [r7, #4]
 800f08c:	f893 303c 	ldrb.w	r3, [r3, #60]	@ 0x3c
 800f090:	2b01      	cmp	r3, #1
 800f092:	d101      	bne.n	800f098 <HAL_TIMEx_ConfigBreakDeadTime+0x1c>
 800f094:	2302      	movs	r3, #2
 800f096:	e073      	b.n	800f180 <HAL_TIMEx_ConfigBreakDeadTime+0x104>
 800f098:	687b      	ldr	r3, [r7, #4]
 800f09a:	2201      	movs	r2, #1
 800f09c:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c

  /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
     the OSSI State, the dead time value and the Automatic Output Enable Bit */

  /* Set the BDTR bits */
  MODIFY_REG(tmpbdtr, TIM_BDTR_DTG, sBreakDeadTimeConfig->DeadTime);
 800f0a0:	68fb      	ldr	r3, [r7, #12]
 800f0a2:	f023 02ff 	bic.w	r2, r3, #255	@ 0xff
 800f0a6:	683b      	ldr	r3, [r7, #0]
 800f0a8:	68db      	ldr	r3, [r3, #12]
 800f0aa:	4313      	orrs	r3, r2
 800f0ac:	60fb      	str	r3, [r7, #12]
  MODIFY_REG(tmpbdtr, TIM_BDTR_LOCK, sBreakDeadTimeConfig->LockLevel);
 800f0ae:	68fb      	ldr	r3, [r7, #12]
 800f0b0:	f423 7240 	bic.w	r2, r3, #768	@ 0x300
 800f0b4:	683b      	ldr	r3, [r7, #0]
 800f0b6:	689b      	ldr	r3, [r3, #8]
 800f0b8:	4313      	orrs	r3, r2
 800f0ba:	60fb      	str	r3, [r7, #12]
  MODIFY_REG(tmpbdtr, TIM_BDTR_OSSI, sBreakDeadTimeConfig->OffStateIDLEMode);
 800f0bc:	68fb      	ldr	r3, [r7, #12]
 800f0be:	f423 6280 	bic.w	r2, r3, #1024	@ 0x400
 800f0c2:	683b      	ldr	r3, [r7, #0]
 800f0c4:	685b      	ldr	r3, [r3, #4]
 800f0c6:	4313      	orrs	r3, r2
 800f0c8:	60fb      	str	r3, [r7, #12]
  MODIFY_REG(tmpbdtr, TIM_BDTR_OSSR, sBreakDeadTimeConfig->OffStateRunMode);
 800f0ca:	68fb      	ldr	r3, [r7, #12]
 800f0cc:	f423 6200 	bic.w	r2, r3, #2048	@ 0x800
 800f0d0:	683b      	ldr	r3, [r7, #0]
 800f0d2:	681b      	ldr	r3, [r3, #0]
 800f0d4:	4313      	orrs	r3, r2
 800f0d6:	60fb      	str	r3, [r7, #12]
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKE, sBreakDeadTimeConfig->BreakState);
 800f0d8:	68fb      	ldr	r3, [r7, #12]
 800f0da:	f423 5280 	bic.w	r2, r3, #4096	@ 0x1000
 800f0de:	683b      	ldr	r3, [r7, #0]
 800f0e0:	691b      	ldr	r3, [r3, #16]
 800f0e2:	4313      	orrs	r3, r2
 800f0e4:	60fb      	str	r3, [r7, #12]
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKP, sBreakDeadTimeConfig->BreakPolarity);
 800f0e6:	68fb      	ldr	r3, [r7, #12]
 800f0e8:	f423 5200 	bic.w	r2, r3, #8192	@ 0x2000
 800f0ec:	683b      	ldr	r3, [r7, #0]
 800f0ee:	695b      	ldr	r3, [r3, #20]
 800f0f0:	4313      	orrs	r3, r2
 800f0f2:	60fb      	str	r3, [r7, #12]
  MODIFY_REG(tmpbdtr, TIM_BDTR_AOE, sBreakDeadTimeConfig->AutomaticOutput);
 800f0f4:	68fb      	ldr	r3, [r7, #12]
 800f0f6:	f423 4280 	bic.w	r2, r3, #16384	@ 0x4000
 800f0fa:	683b      	ldr	r3, [r7, #0]
 800f0fc:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800f0fe:	4313      	orrs	r3, r2
 800f100:	60fb      	str	r3, [r7, #12]
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKF, (sBreakDeadTimeConfig->BreakFilter << TIM_BDTR_BKF_Pos));
 800f102:	68fb      	ldr	r3, [r7, #12]
 800f104:	f423 2270 	bic.w	r2, r3, #983040	@ 0xf0000
 800f108:	683b      	ldr	r3, [r7, #0]
 800f10a:	699b      	ldr	r3, [r3, #24]
 800f10c:	041b      	lsls	r3, r3, #16
 800f10e:	4313      	orrs	r3, r2
 800f110:	60fb      	str	r3, [r7, #12]
#if defined(TIM_BDTR_BKBID)
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKBID, sBreakDeadTimeConfig->BreakAFMode);
 800f112:	68fb      	ldr	r3, [r7, #12]
 800f114:	f023 5280 	bic.w	r2, r3, #268435456	@ 0x10000000
 800f118:	683b      	ldr	r3, [r7, #0]
 800f11a:	69db      	ldr	r3, [r3, #28]
 800f11c:	4313      	orrs	r3, r2
 800f11e:	60fb      	str	r3, [r7, #12]
#endif /* TIM_BDTR_BKBID */

  if (IS_TIM_BKIN2_INSTANCE(htim->Instance))
 800f120:	687b      	ldr	r3, [r7, #4]
 800f122:	681b      	ldr	r3, [r3, #0]
 800f124:	4a19      	ldr	r2, [pc, #100]	@ (800f18c <HAL_TIMEx_ConfigBreakDeadTime+0x110>)
 800f126:	4293      	cmp	r3, r2
 800f128:	d004      	beq.n	800f134 <HAL_TIMEx_ConfigBreakDeadTime+0xb8>
 800f12a:	687b      	ldr	r3, [r7, #4]
 800f12c:	681b      	ldr	r3, [r3, #0]
 800f12e:	4a18      	ldr	r2, [pc, #96]	@ (800f190 <HAL_TIMEx_ConfigBreakDeadTime+0x114>)
 800f130:	4293      	cmp	r3, r2
 800f132:	d11c      	bne.n	800f16e <HAL_TIMEx_ConfigBreakDeadTime+0xf2>
#if defined(TIM_BDTR_BKBID)
    assert_param(IS_TIM_BREAK2_AFMODE(sBreakDeadTimeConfig->Break2AFMode));
#endif /* TIM_BDTR_BKBID */

    /* Set the BREAK2 input related BDTR bits */
    MODIFY_REG(tmpbdtr, TIM_BDTR_BK2F, (sBreakDeadTimeConfig->Break2Filter << TIM_BDTR_BK2F_Pos));
 800f134:	68fb      	ldr	r3, [r7, #12]
 800f136:	f423 0270 	bic.w	r2, r3, #15728640	@ 0xf00000
 800f13a:	683b      	ldr	r3, [r7, #0]
 800f13c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800f13e:	051b      	lsls	r3, r3, #20
 800f140:	4313      	orrs	r3, r2
 800f142:	60fb      	str	r3, [r7, #12]
    MODIFY_REG(tmpbdtr, TIM_BDTR_BK2E, sBreakDeadTimeConfig->Break2State);
 800f144:	68fb      	ldr	r3, [r7, #12]
 800f146:	f023 7280 	bic.w	r2, r3, #16777216	@ 0x1000000
 800f14a:	683b      	ldr	r3, [r7, #0]
 800f14c:	6a1b      	ldr	r3, [r3, #32]
 800f14e:	4313      	orrs	r3, r2
 800f150:	60fb      	str	r3, [r7, #12]
    MODIFY_REG(tmpbdtr, TIM_BDTR_BK2P, sBreakDeadTimeConfig->Break2Polarity);
 800f152:	68fb      	ldr	r3, [r7, #12]
 800f154:	f023 7200 	bic.w	r2, r3, #33554432	@ 0x2000000
 800f158:	683b      	ldr	r3, [r7, #0]
 800f15a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800f15c:	4313      	orrs	r3, r2
 800f15e:	60fb      	str	r3, [r7, #12]
#if defined(TIM_BDTR_BKBID)
    MODIFY_REG(tmpbdtr, TIM_BDTR_BK2BID, sBreakDeadTimeConfig->Break2AFMode);
 800f160:	68fb      	ldr	r3, [r7, #12]
 800f162:	f023 5200 	bic.w	r2, r3, #536870912	@ 0x20000000
 800f166:	683b      	ldr	r3, [r7, #0]
 800f168:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800f16a:	4313      	orrs	r3, r2
 800f16c:	60fb      	str	r3, [r7, #12]
#endif /* TIM_BDTR_BKBID */
  }

  /* Set TIMx_BDTR */
  htim->Instance->BDTR = tmpbdtr;
 800f16e:	687b      	ldr	r3, [r7, #4]
 800f170:	681b      	ldr	r3, [r3, #0]
 800f172:	68fa      	ldr	r2, [r7, #12]
 800f174:	645a      	str	r2, [r3, #68]	@ 0x44

  __HAL_UNLOCK(htim);
 800f176:	687b      	ldr	r3, [r7, #4]
 800f178:	2200      	movs	r2, #0
 800f17a:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c

  return HAL_OK;
 800f17e:	2300      	movs	r3, #0
}
 800f180:	4618      	mov	r0, r3
 800f182:	3714      	adds	r7, #20
 800f184:	46bd      	mov	sp, r7
 800f186:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f18a:	4770      	bx	lr
 800f18c:	40010000 	.word	0x40010000
 800f190:	40010400 	.word	0x40010400

0800f194 <HAL_TIMEx_CommutCallback>:
  * @brief  Commutation callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_CommutCallback(TIM_HandleTypeDef *htim)
{
 800f194:	b480      	push	{r7}
 800f196:	b083      	sub	sp, #12
 800f198:	af00      	add	r7, sp, #0
 800f19a:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIMEx_CommutCallback could be implemented in the user file
   */
}
 800f19c:	bf00      	nop
 800f19e:	370c      	adds	r7, #12
 800f1a0:	46bd      	mov	sp, r7
 800f1a2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f1a6:	4770      	bx	lr

0800f1a8 <HAL_TIMEx_BreakCallback>:
  * @brief  Break detection callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_BreakCallback(TIM_HandleTypeDef *htim)
{
 800f1a8:	b480      	push	{r7}
 800f1aa:	b083      	sub	sp, #12
 800f1ac:	af00      	add	r7, sp, #0
 800f1ae:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIMEx_BreakCallback could be implemented in the user file
   */
}
 800f1b0:	bf00      	nop
 800f1b2:	370c      	adds	r7, #12
 800f1b4:	46bd      	mov	sp, r7
 800f1b6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f1ba:	4770      	bx	lr

0800f1bc <HAL_TIMEx_Break2Callback>:
  * @brief  Break2 detection callback in non blocking mode
  * @param  htim: TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_Break2Callback(TIM_HandleTypeDef *htim)
{
 800f1bc:	b480      	push	{r7}
 800f1be:	b083      	sub	sp, #12
 800f1c0:	af00      	add	r7, sp, #0
 800f1c2:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_TIMEx_Break2Callback could be implemented in the user file
   */
}
 800f1c4:	bf00      	nop
 800f1c6:	370c      	adds	r7, #12
 800f1c8:	46bd      	mov	sp, r7
 800f1ca:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f1ce:	4770      	bx	lr

0800f1d0 <USB_CoreInit>:
  * @param  cfg pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
 800f1d0:	b084      	sub	sp, #16
 800f1d2:	b580      	push	{r7, lr}
 800f1d4:	b084      	sub	sp, #16
 800f1d6:	af00      	add	r7, sp, #0
 800f1d8:	6078      	str	r0, [r7, #4]
 800f1da:	f107 001c 	add.w	r0, r7, #28
 800f1de:	e880 000e 	stmia.w	r0, {r1, r2, r3}
  HAL_StatusTypeDef ret;
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
 800f1e2:	f897 3021 	ldrb.w	r3, [r7, #33]	@ 0x21
 800f1e6:	2b01      	cmp	r3, #1
 800f1e8:	d121      	bne.n	800f22e <USB_CoreInit+0x5e>
  {
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
 800f1ea:	687b      	ldr	r3, [r7, #4]
 800f1ec:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800f1ee:	f423 3280 	bic.w	r2, r3, #65536	@ 0x10000
 800f1f2:	687b      	ldr	r3, [r7, #4]
 800f1f4:	639a      	str	r2, [r3, #56]	@ 0x38

    /* Init The ULPI Interface */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
 800f1f6:	687b      	ldr	r3, [r7, #4]
 800f1f8:	68da      	ldr	r2, [r3, #12]
 800f1fa:	4b2c      	ldr	r3, [pc, #176]	@ (800f2ac <USB_CoreInit+0xdc>)
 800f1fc:	4013      	ands	r3, r2
 800f1fe:	687a      	ldr	r2, [r7, #4]
 800f200:	60d3      	str	r3, [r2, #12]

    /* Select vbus source */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
 800f202:	687b      	ldr	r3, [r7, #4]
 800f204:	68db      	ldr	r3, [r3, #12]
 800f206:	f423 1240 	bic.w	r2, r3, #3145728	@ 0x300000
 800f20a:	687b      	ldr	r3, [r7, #4]
 800f20c:	60da      	str	r2, [r3, #12]
    if (cfg.use_external_vbus == 1U)
 800f20e:	f897 3028 	ldrb.w	r3, [r7, #40]	@ 0x28
 800f212:	2b01      	cmp	r3, #1
 800f214:	d105      	bne.n	800f222 <USB_CoreInit+0x52>
    {
      USBx->GUSBCFG |= USB_OTG_GUSBCFG_ULPIEVBUSD;
 800f216:	687b      	ldr	r3, [r7, #4]
 800f218:	68db      	ldr	r3, [r3, #12]
 800f21a:	f443 1280 	orr.w	r2, r3, #1048576	@ 0x100000
 800f21e:	687b      	ldr	r3, [r7, #4]
 800f220:	60da      	str	r2, [r3, #12]
    }

    /* Reset after a PHY select */
    ret = USB_CoreReset(USBx);
 800f222:	6878      	ldr	r0, [r7, #4]
 800f224:	f001 faf6 	bl	8010814 <USB_CoreReset>
 800f228:	4603      	mov	r3, r0
 800f22a:	73fb      	strb	r3, [r7, #15]
 800f22c:	e01b      	b.n	800f266 <USB_CoreInit+0x96>
  }
  else /* FS interface (embedded Phy) */
  {
    /* Select FS Embedded PHY */
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_PHYSEL;
 800f22e:	687b      	ldr	r3, [r7, #4]
 800f230:	68db      	ldr	r3, [r3, #12]
 800f232:	f043 0240 	orr.w	r2, r3, #64	@ 0x40
 800f236:	687b      	ldr	r3, [r7, #4]
 800f238:	60da      	str	r2, [r3, #12]

    /* Reset after a PHY select */
    ret = USB_CoreReset(USBx);
 800f23a:	6878      	ldr	r0, [r7, #4]
 800f23c:	f001 faea 	bl	8010814 <USB_CoreReset>
 800f240:	4603      	mov	r3, r0
 800f242:	73fb      	strb	r3, [r7, #15]

    if (cfg.battery_charging_enable == 0U)
 800f244:	f897 3025 	ldrb.w	r3, [r7, #37]	@ 0x25
 800f248:	2b00      	cmp	r3, #0
 800f24a:	d106      	bne.n	800f25a <USB_CoreInit+0x8a>
    {
      /* Activate the USB Transceiver */
      USBx->GCCFG |= USB_OTG_GCCFG_PWRDWN;
 800f24c:	687b      	ldr	r3, [r7, #4]
 800f24e:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800f250:	f443 3280 	orr.w	r2, r3, #65536	@ 0x10000
 800f254:	687b      	ldr	r3, [r7, #4]
 800f256:	639a      	str	r2, [r3, #56]	@ 0x38
 800f258:	e005      	b.n	800f266 <USB_CoreInit+0x96>
    }
    else
    {
      /* Deactivate the USB Transceiver */
      USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
 800f25a:	687b      	ldr	r3, [r7, #4]
 800f25c:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800f25e:	f423 3280 	bic.w	r2, r3, #65536	@ 0x10000
 800f262:	687b      	ldr	r3, [r7, #4]
 800f264:	639a      	str	r2, [r3, #56]	@ 0x38
    }
  }

  if (cfg.dma_enable == 1U)
 800f266:	7fbb      	ldrb	r3, [r7, #30]
 800f268:	2b01      	cmp	r3, #1
 800f26a:	d116      	bne.n	800f29a <USB_CoreInit+0xca>
  {
    /* make sure to reserve 18 fifo Locations for DMA buffers */
    USBx->GDFIFOCFG &= ~(0xFFFFU << 16);
 800f26c:	687b      	ldr	r3, [r7, #4]
 800f26e:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 800f270:	b29a      	uxth	r2, r3
 800f272:	687b      	ldr	r3, [r7, #4]
 800f274:	65da      	str	r2, [r3, #92]	@ 0x5c
    USBx->GDFIFOCFG |= 0x3EEU << 16;
 800f276:	687b      	ldr	r3, [r7, #4]
 800f278:	6dda      	ldr	r2, [r3, #92]	@ 0x5c
 800f27a:	4b0d      	ldr	r3, [pc, #52]	@ (800f2b0 <USB_CoreInit+0xe0>)
 800f27c:	4313      	orrs	r3, r2
 800f27e:	687a      	ldr	r2, [r7, #4]
 800f280:	65d3      	str	r3, [r2, #92]	@ 0x5c

    USBx->GAHBCFG |= USB_OTG_GAHBCFG_HBSTLEN_2;
 800f282:	687b      	ldr	r3, [r7, #4]
 800f284:	689b      	ldr	r3, [r3, #8]
 800f286:	f043 0206 	orr.w	r2, r3, #6
 800f28a:	687b      	ldr	r3, [r7, #4]
 800f28c:	609a      	str	r2, [r3, #8]
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_DMAEN;
 800f28e:	687b      	ldr	r3, [r7, #4]
 800f290:	689b      	ldr	r3, [r3, #8]
 800f292:	f043 0220 	orr.w	r2, r3, #32
 800f296:	687b      	ldr	r3, [r7, #4]
 800f298:	609a      	str	r2, [r3, #8]
  }

  return ret;
 800f29a:	7bfb      	ldrb	r3, [r7, #15]
}
 800f29c:	4618      	mov	r0, r3
 800f29e:	3710      	adds	r7, #16
 800f2a0:	46bd      	mov	sp, r7
 800f2a2:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 800f2a6:	b004      	add	sp, #16
 800f2a8:	4770      	bx	lr
 800f2aa:	bf00      	nop
 800f2ac:	ffbdffbf 	.word	0xffbdffbf
 800f2b0:	03ee0000 	.word	0x03ee0000

0800f2b4 <USB_SetTurnaroundTime>:
  * @param  hclk: AHB clock frequency
  * @retval USB turnaround time In PHY Clocks number
  */
HAL_StatusTypeDef USB_SetTurnaroundTime(USB_OTG_GlobalTypeDef *USBx,
                                        uint32_t hclk, uint8_t speed)
{
 800f2b4:	b480      	push	{r7}
 800f2b6:	b087      	sub	sp, #28
 800f2b8:	af00      	add	r7, sp, #0
 800f2ba:	60f8      	str	r0, [r7, #12]
 800f2bc:	60b9      	str	r1, [r7, #8]
 800f2be:	4613      	mov	r3, r2
 800f2c0:	71fb      	strb	r3, [r7, #7]

  /* The USBTRD is configured according to the tables below, depending on AHB frequency
  used by application. In the low AHB frequency range it is used to stretch enough the USB response
  time to IN tokens, the USB turnaround time, so to compensate for the longer AHB read access
  latency to the Data FIFO */
  if (speed == USBD_FS_SPEED)
 800f2c2:	79fb      	ldrb	r3, [r7, #7]
 800f2c4:	2b02      	cmp	r3, #2
 800f2c6:	d165      	bne.n	800f394 <USB_SetTurnaroundTime+0xe0>
  {
    if ((hclk >= 14200000U) && (hclk < 15000000U))
 800f2c8:	68bb      	ldr	r3, [r7, #8]
 800f2ca:	4a41      	ldr	r2, [pc, #260]	@ (800f3d0 <USB_SetTurnaroundTime+0x11c>)
 800f2cc:	4293      	cmp	r3, r2
 800f2ce:	d906      	bls.n	800f2de <USB_SetTurnaroundTime+0x2a>
 800f2d0:	68bb      	ldr	r3, [r7, #8]
 800f2d2:	4a40      	ldr	r2, [pc, #256]	@ (800f3d4 <USB_SetTurnaroundTime+0x120>)
 800f2d4:	4293      	cmp	r3, r2
 800f2d6:	d202      	bcs.n	800f2de <USB_SetTurnaroundTime+0x2a>
    {
      /* hclk Clock Range between 14.2-15 MHz */
      UsbTrd = 0xFU;
 800f2d8:	230f      	movs	r3, #15
 800f2da:	617b      	str	r3, [r7, #20]
 800f2dc:	e062      	b.n	800f3a4 <USB_SetTurnaroundTime+0xf0>
    }
    else if ((hclk >= 15000000U) && (hclk < 16000000U))
 800f2de:	68bb      	ldr	r3, [r7, #8]
 800f2e0:	4a3c      	ldr	r2, [pc, #240]	@ (800f3d4 <USB_SetTurnaroundTime+0x120>)
 800f2e2:	4293      	cmp	r3, r2
 800f2e4:	d306      	bcc.n	800f2f4 <USB_SetTurnaroundTime+0x40>
 800f2e6:	68bb      	ldr	r3, [r7, #8]
 800f2e8:	4a3b      	ldr	r2, [pc, #236]	@ (800f3d8 <USB_SetTurnaroundTime+0x124>)
 800f2ea:	4293      	cmp	r3, r2
 800f2ec:	d202      	bcs.n	800f2f4 <USB_SetTurnaroundTime+0x40>
    {
      /* hclk Clock Range between 15-16 MHz */
      UsbTrd = 0xEU;
 800f2ee:	230e      	movs	r3, #14
 800f2f0:	617b      	str	r3, [r7, #20]
 800f2f2:	e057      	b.n	800f3a4 <USB_SetTurnaroundTime+0xf0>
    }
    else if ((hclk >= 16000000U) && (hclk < 17200000U))
 800f2f4:	68bb      	ldr	r3, [r7, #8]
 800f2f6:	4a38      	ldr	r2, [pc, #224]	@ (800f3d8 <USB_SetTurnaroundTime+0x124>)
 800f2f8:	4293      	cmp	r3, r2
 800f2fa:	d306      	bcc.n	800f30a <USB_SetTurnaroundTime+0x56>
 800f2fc:	68bb      	ldr	r3, [r7, #8]
 800f2fe:	4a37      	ldr	r2, [pc, #220]	@ (800f3dc <USB_SetTurnaroundTime+0x128>)
 800f300:	4293      	cmp	r3, r2
 800f302:	d202      	bcs.n	800f30a <USB_SetTurnaroundTime+0x56>
    {
      /* hclk Clock Range between 16-17.2 MHz */
      UsbTrd = 0xDU;
 800f304:	230d      	movs	r3, #13
 800f306:	617b      	str	r3, [r7, #20]
 800f308:	e04c      	b.n	800f3a4 <USB_SetTurnaroundTime+0xf0>
    }
    else if ((hclk >= 17200000U) && (hclk < 18500000U))
 800f30a:	68bb      	ldr	r3, [r7, #8]
 800f30c:	4a33      	ldr	r2, [pc, #204]	@ (800f3dc <USB_SetTurnaroundTime+0x128>)
 800f30e:	4293      	cmp	r3, r2
 800f310:	d306      	bcc.n	800f320 <USB_SetTurnaroundTime+0x6c>
 800f312:	68bb      	ldr	r3, [r7, #8]
 800f314:	4a32      	ldr	r2, [pc, #200]	@ (800f3e0 <USB_SetTurnaroundTime+0x12c>)
 800f316:	4293      	cmp	r3, r2
 800f318:	d802      	bhi.n	800f320 <USB_SetTurnaroundTime+0x6c>
    {
      /* hclk Clock Range between 17.2-18.5 MHz */
      UsbTrd = 0xCU;
 800f31a:	230c      	movs	r3, #12
 800f31c:	617b      	str	r3, [r7, #20]
 800f31e:	e041      	b.n	800f3a4 <USB_SetTurnaroundTime+0xf0>
    }
    else if ((hclk >= 18500000U) && (hclk < 20000000U))
 800f320:	68bb      	ldr	r3, [r7, #8]
 800f322:	4a2f      	ldr	r2, [pc, #188]	@ (800f3e0 <USB_SetTurnaroundTime+0x12c>)
 800f324:	4293      	cmp	r3, r2
 800f326:	d906      	bls.n	800f336 <USB_SetTurnaroundTime+0x82>
 800f328:	68bb      	ldr	r3, [r7, #8]
 800f32a:	4a2e      	ldr	r2, [pc, #184]	@ (800f3e4 <USB_SetTurnaroundTime+0x130>)
 800f32c:	4293      	cmp	r3, r2
 800f32e:	d802      	bhi.n	800f336 <USB_SetTurnaroundTime+0x82>
    {
      /* hclk Clock Range between 18.5-20 MHz */
      UsbTrd = 0xBU;
 800f330:	230b      	movs	r3, #11
 800f332:	617b      	str	r3, [r7, #20]
 800f334:	e036      	b.n	800f3a4 <USB_SetTurnaroundTime+0xf0>
    }
    else if ((hclk >= 20000000U) && (hclk < 21800000U))
 800f336:	68bb      	ldr	r3, [r7, #8]
 800f338:	4a2a      	ldr	r2, [pc, #168]	@ (800f3e4 <USB_SetTurnaroundTime+0x130>)
 800f33a:	4293      	cmp	r3, r2
 800f33c:	d906      	bls.n	800f34c <USB_SetTurnaroundTime+0x98>
 800f33e:	68bb      	ldr	r3, [r7, #8]
 800f340:	4a29      	ldr	r2, [pc, #164]	@ (800f3e8 <USB_SetTurnaroundTime+0x134>)
 800f342:	4293      	cmp	r3, r2
 800f344:	d802      	bhi.n	800f34c <USB_SetTurnaroundTime+0x98>
    {
      /* hclk Clock Range between 20-21.8 MHz */
      UsbTrd = 0xAU;
 800f346:	230a      	movs	r3, #10
 800f348:	617b      	str	r3, [r7, #20]
 800f34a:	e02b      	b.n	800f3a4 <USB_SetTurnaroundTime+0xf0>
    }
    else if ((hclk >= 21800000U) && (hclk < 24000000U))
 800f34c:	68bb      	ldr	r3, [r7, #8]
 800f34e:	4a26      	ldr	r2, [pc, #152]	@ (800f3e8 <USB_SetTurnaroundTime+0x134>)
 800f350:	4293      	cmp	r3, r2
 800f352:	d906      	bls.n	800f362 <USB_SetTurnaroundTime+0xae>
 800f354:	68bb      	ldr	r3, [r7, #8]
 800f356:	4a25      	ldr	r2, [pc, #148]	@ (800f3ec <USB_SetTurnaroundTime+0x138>)
 800f358:	4293      	cmp	r3, r2
 800f35a:	d202      	bcs.n	800f362 <USB_SetTurnaroundTime+0xae>
    {
      /* hclk Clock Range between 21.8-24 MHz */
      UsbTrd = 0x9U;
 800f35c:	2309      	movs	r3, #9
 800f35e:	617b      	str	r3, [r7, #20]
 800f360:	e020      	b.n	800f3a4 <USB_SetTurnaroundTime+0xf0>
    }
    else if ((hclk >= 24000000U) && (hclk < 27700000U))
 800f362:	68bb      	ldr	r3, [r7, #8]
 800f364:	4a21      	ldr	r2, [pc, #132]	@ (800f3ec <USB_SetTurnaroundTime+0x138>)
 800f366:	4293      	cmp	r3, r2
 800f368:	d306      	bcc.n	800f378 <USB_SetTurnaroundTime+0xc4>
 800f36a:	68bb      	ldr	r3, [r7, #8]
 800f36c:	4a20      	ldr	r2, [pc, #128]	@ (800f3f0 <USB_SetTurnaroundTime+0x13c>)
 800f36e:	4293      	cmp	r3, r2
 800f370:	d802      	bhi.n	800f378 <USB_SetTurnaroundTime+0xc4>
    {
      /* hclk Clock Range between 24-27.7 MHz */
      UsbTrd = 0x8U;
 800f372:	2308      	movs	r3, #8
 800f374:	617b      	str	r3, [r7, #20]
 800f376:	e015      	b.n	800f3a4 <USB_SetTurnaroundTime+0xf0>
    }
    else if ((hclk >= 27700000U) && (hclk < 32000000U))
 800f378:	68bb      	ldr	r3, [r7, #8]
 800f37a:	4a1d      	ldr	r2, [pc, #116]	@ (800f3f0 <USB_SetTurnaroundTime+0x13c>)
 800f37c:	4293      	cmp	r3, r2
 800f37e:	d906      	bls.n	800f38e <USB_SetTurnaroundTime+0xda>
 800f380:	68bb      	ldr	r3, [r7, #8]
 800f382:	4a1c      	ldr	r2, [pc, #112]	@ (800f3f4 <USB_SetTurnaroundTime+0x140>)
 800f384:	4293      	cmp	r3, r2
 800f386:	d202      	bcs.n	800f38e <USB_SetTurnaroundTime+0xda>
    {
      /* hclk Clock Range between 27.7-32 MHz */
      UsbTrd = 0x7U;
 800f388:	2307      	movs	r3, #7
 800f38a:	617b      	str	r3, [r7, #20]
 800f38c:	e00a      	b.n	800f3a4 <USB_SetTurnaroundTime+0xf0>
    }
    else /* if(hclk >= 32000000) */
    {
      /* hclk Clock Range between 32-200 MHz */
      UsbTrd = 0x6U;
 800f38e:	2306      	movs	r3, #6
 800f390:	617b      	str	r3, [r7, #20]
 800f392:	e007      	b.n	800f3a4 <USB_SetTurnaroundTime+0xf0>
    }
  }
  else if (speed == USBD_HS_SPEED)
 800f394:	79fb      	ldrb	r3, [r7, #7]
 800f396:	2b00      	cmp	r3, #0
 800f398:	d102      	bne.n	800f3a0 <USB_SetTurnaroundTime+0xec>
  {
    UsbTrd = USBD_HS_TRDT_VALUE;
 800f39a:	2309      	movs	r3, #9
 800f39c:	617b      	str	r3, [r7, #20]
 800f39e:	e001      	b.n	800f3a4 <USB_SetTurnaroundTime+0xf0>
  }
  else
  {
    UsbTrd = USBD_DEFAULT_TRDT_VALUE;
 800f3a0:	2309      	movs	r3, #9
 800f3a2:	617b      	str	r3, [r7, #20]
  }

  USBx->GUSBCFG &= ~USB_OTG_GUSBCFG_TRDT;
 800f3a4:	68fb      	ldr	r3, [r7, #12]
 800f3a6:	68db      	ldr	r3, [r3, #12]
 800f3a8:	f423 5270 	bic.w	r2, r3, #15360	@ 0x3c00
 800f3ac:	68fb      	ldr	r3, [r7, #12]
 800f3ae:	60da      	str	r2, [r3, #12]
  USBx->GUSBCFG |= (uint32_t)((UsbTrd << 10) & USB_OTG_GUSBCFG_TRDT);
 800f3b0:	68fb      	ldr	r3, [r7, #12]
 800f3b2:	68da      	ldr	r2, [r3, #12]
 800f3b4:	697b      	ldr	r3, [r7, #20]
 800f3b6:	029b      	lsls	r3, r3, #10
 800f3b8:	f403 5370 	and.w	r3, r3, #15360	@ 0x3c00
 800f3bc:	431a      	orrs	r2, r3
 800f3be:	68fb      	ldr	r3, [r7, #12]
 800f3c0:	60da      	str	r2, [r3, #12]

  return HAL_OK;
 800f3c2:	2300      	movs	r3, #0
}
 800f3c4:	4618      	mov	r0, r3
 800f3c6:	371c      	adds	r7, #28
 800f3c8:	46bd      	mov	sp, r7
 800f3ca:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f3ce:	4770      	bx	lr
 800f3d0:	00d8acbf 	.word	0x00d8acbf
 800f3d4:	00e4e1c0 	.word	0x00e4e1c0
 800f3d8:	00f42400 	.word	0x00f42400
 800f3dc:	01067380 	.word	0x01067380
 800f3e0:	011a499f 	.word	0x011a499f
 800f3e4:	01312cff 	.word	0x01312cff
 800f3e8:	014ca43f 	.word	0x014ca43f
 800f3ec:	016e3600 	.word	0x016e3600
 800f3f0:	01a6ab1f 	.word	0x01a6ab1f
 800f3f4:	01e84800 	.word	0x01e84800

0800f3f8 <USB_EnableGlobalInt>:
  *         Enables the controller's Global Int in the AHB Config reg
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EnableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
{
 800f3f8:	b480      	push	{r7}
 800f3fa:	b083      	sub	sp, #12
 800f3fc:	af00      	add	r7, sp, #0
 800f3fe:	6078      	str	r0, [r7, #4]
  USBx->GAHBCFG |= USB_OTG_GAHBCFG_GINT;
 800f400:	687b      	ldr	r3, [r7, #4]
 800f402:	689b      	ldr	r3, [r3, #8]
 800f404:	f043 0201 	orr.w	r2, r3, #1
 800f408:	687b      	ldr	r3, [r7, #4]
 800f40a:	609a      	str	r2, [r3, #8]
  return HAL_OK;
 800f40c:	2300      	movs	r3, #0
}
 800f40e:	4618      	mov	r0, r3
 800f410:	370c      	adds	r7, #12
 800f412:	46bd      	mov	sp, r7
 800f414:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f418:	4770      	bx	lr

0800f41a <USB_DisableGlobalInt>:
  *         Disable the controller's Global Int in the AHB Config reg
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DisableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
{
 800f41a:	b480      	push	{r7}
 800f41c:	b083      	sub	sp, #12
 800f41e:	af00      	add	r7, sp, #0
 800f420:	6078      	str	r0, [r7, #4]
  USBx->GAHBCFG &= ~USB_OTG_GAHBCFG_GINT;
 800f422:	687b      	ldr	r3, [r7, #4]
 800f424:	689b      	ldr	r3, [r3, #8]
 800f426:	f023 0201 	bic.w	r2, r3, #1
 800f42a:	687b      	ldr	r3, [r7, #4]
 800f42c:	609a      	str	r2, [r3, #8]
  return HAL_OK;
 800f42e:	2300      	movs	r3, #0
}
 800f430:	4618      	mov	r0, r3
 800f432:	370c      	adds	r7, #12
 800f434:	46bd      	mov	sp, r7
 800f436:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f43a:	4770      	bx	lr

0800f43c <USB_SetCurrentMode>:
  *            @arg USB_DEVICE_MODE Peripheral mode
  *            @arg USB_HOST_MODE Host mode
  * @retval HAL status
  */
HAL_StatusTypeDef USB_SetCurrentMode(USB_OTG_GlobalTypeDef *USBx, USB_OTG_ModeTypeDef mode)
{
 800f43c:	b580      	push	{r7, lr}
 800f43e:	b084      	sub	sp, #16
 800f440:	af00      	add	r7, sp, #0
 800f442:	6078      	str	r0, [r7, #4]
 800f444:	460b      	mov	r3, r1
 800f446:	70fb      	strb	r3, [r7, #3]
  uint32_t ms = 0U;
 800f448:	2300      	movs	r3, #0
 800f44a:	60fb      	str	r3, [r7, #12]

  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD);
 800f44c:	687b      	ldr	r3, [r7, #4]
 800f44e:	68db      	ldr	r3, [r3, #12]
 800f450:	f023 42c0 	bic.w	r2, r3, #1610612736	@ 0x60000000
 800f454:	687b      	ldr	r3, [r7, #4]
 800f456:	60da      	str	r2, [r3, #12]

  if (mode == USB_HOST_MODE)
 800f458:	78fb      	ldrb	r3, [r7, #3]
 800f45a:	2b01      	cmp	r3, #1
 800f45c:	d115      	bne.n	800f48a <USB_SetCurrentMode+0x4e>
  {
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FHMOD;
 800f45e:	687b      	ldr	r3, [r7, #4]
 800f460:	68db      	ldr	r3, [r3, #12]
 800f462:	f043 5200 	orr.w	r2, r3, #536870912	@ 0x20000000
 800f466:	687b      	ldr	r3, [r7, #4]
 800f468:	60da      	str	r2, [r3, #12]

    do
    {
      HAL_Delay(10U);
 800f46a:	200a      	movs	r0, #10
 800f46c:	f7f3 fa84 	bl	8002978 <HAL_Delay>
      ms += 10U;
 800f470:	68fb      	ldr	r3, [r7, #12]
 800f472:	330a      	adds	r3, #10
 800f474:	60fb      	str	r3, [r7, #12]
    } while ((USB_GetMode(USBx) != (uint32_t)USB_HOST_MODE) && (ms < HAL_USB_CURRENT_MODE_MAX_DELAY_MS));
 800f476:	6878      	ldr	r0, [r7, #4]
 800f478:	f001 f93b 	bl	80106f2 <USB_GetMode>
 800f47c:	4603      	mov	r3, r0
 800f47e:	2b01      	cmp	r3, #1
 800f480:	d01e      	beq.n	800f4c0 <USB_SetCurrentMode+0x84>
 800f482:	68fb      	ldr	r3, [r7, #12]
 800f484:	2bc7      	cmp	r3, #199	@ 0xc7
 800f486:	d9f0      	bls.n	800f46a <USB_SetCurrentMode+0x2e>
 800f488:	e01a      	b.n	800f4c0 <USB_SetCurrentMode+0x84>
  }
  else if (mode == USB_DEVICE_MODE)
 800f48a:	78fb      	ldrb	r3, [r7, #3]
 800f48c:	2b00      	cmp	r3, #0
 800f48e:	d115      	bne.n	800f4bc <USB_SetCurrentMode+0x80>
  {
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FDMOD;
 800f490:	687b      	ldr	r3, [r7, #4]
 800f492:	68db      	ldr	r3, [r3, #12]
 800f494:	f043 4280 	orr.w	r2, r3, #1073741824	@ 0x40000000
 800f498:	687b      	ldr	r3, [r7, #4]
 800f49a:	60da      	str	r2, [r3, #12]

    do
    {
      HAL_Delay(10U);
 800f49c:	200a      	movs	r0, #10
 800f49e:	f7f3 fa6b 	bl	8002978 <HAL_Delay>
      ms += 10U;
 800f4a2:	68fb      	ldr	r3, [r7, #12]
 800f4a4:	330a      	adds	r3, #10
 800f4a6:	60fb      	str	r3, [r7, #12]
    } while ((USB_GetMode(USBx) != (uint32_t)USB_DEVICE_MODE) && (ms < HAL_USB_CURRENT_MODE_MAX_DELAY_MS));
 800f4a8:	6878      	ldr	r0, [r7, #4]
 800f4aa:	f001 f922 	bl	80106f2 <USB_GetMode>
 800f4ae:	4603      	mov	r3, r0
 800f4b0:	2b00      	cmp	r3, #0
 800f4b2:	d005      	beq.n	800f4c0 <USB_SetCurrentMode+0x84>
 800f4b4:	68fb      	ldr	r3, [r7, #12]
 800f4b6:	2bc7      	cmp	r3, #199	@ 0xc7
 800f4b8:	d9f0      	bls.n	800f49c <USB_SetCurrentMode+0x60>
 800f4ba:	e001      	b.n	800f4c0 <USB_SetCurrentMode+0x84>
  }
  else
  {
    return HAL_ERROR;
 800f4bc:	2301      	movs	r3, #1
 800f4be:	e005      	b.n	800f4cc <USB_SetCurrentMode+0x90>
  }

  if (ms == HAL_USB_CURRENT_MODE_MAX_DELAY_MS)
 800f4c0:	68fb      	ldr	r3, [r7, #12]
 800f4c2:	2bc8      	cmp	r3, #200	@ 0xc8
 800f4c4:	d101      	bne.n	800f4ca <USB_SetCurrentMode+0x8e>
  {
    return HAL_ERROR;
 800f4c6:	2301      	movs	r3, #1
 800f4c8:	e000      	b.n	800f4cc <USB_SetCurrentMode+0x90>
  }

  return HAL_OK;
 800f4ca:	2300      	movs	r3, #0
}
 800f4cc:	4618      	mov	r0, r3
 800f4ce:	3710      	adds	r7, #16
 800f4d0:	46bd      	mov	sp, r7
 800f4d2:	bd80      	pop	{r7, pc}

0800f4d4 <USB_DevInit>:
  * @param  cfg   pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DevInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
 800f4d4:	b084      	sub	sp, #16
 800f4d6:	b580      	push	{r7, lr}
 800f4d8:	b086      	sub	sp, #24
 800f4da:	af00      	add	r7, sp, #0
 800f4dc:	6078      	str	r0, [r7, #4]
 800f4de:	f107 0024 	add.w	r0, r7, #36	@ 0x24
 800f4e2:	e880 000e 	stmia.w	r0, {r1, r2, r3}
  HAL_StatusTypeDef ret = HAL_OK;
 800f4e6:	2300      	movs	r3, #0
 800f4e8:	75fb      	strb	r3, [r7, #23]
  uint32_t USBx_BASE = (uint32_t)USBx;
 800f4ea:	687b      	ldr	r3, [r7, #4]
 800f4ec:	60fb      	str	r3, [r7, #12]
  uint32_t i;

  for (i = 0U; i < 15U; i++)
 800f4ee:	2300      	movs	r3, #0
 800f4f0:	613b      	str	r3, [r7, #16]
 800f4f2:	e009      	b.n	800f508 <USB_DevInit+0x34>
  {
    USBx->DIEPTXF[i] = 0U;
 800f4f4:	687a      	ldr	r2, [r7, #4]
 800f4f6:	693b      	ldr	r3, [r7, #16]
 800f4f8:	3340      	adds	r3, #64	@ 0x40
 800f4fa:	009b      	lsls	r3, r3, #2
 800f4fc:	4413      	add	r3, r2
 800f4fe:	2200      	movs	r2, #0
 800f500:	605a      	str	r2, [r3, #4]
  for (i = 0U; i < 15U; i++)
 800f502:	693b      	ldr	r3, [r7, #16]
 800f504:	3301      	adds	r3, #1
 800f506:	613b      	str	r3, [r7, #16]
 800f508:	693b      	ldr	r3, [r7, #16]
 800f50a:	2b0e      	cmp	r3, #14
 800f50c:	d9f2      	bls.n	800f4f4 <USB_DevInit+0x20>
  }

  /* VBUS Sensing setup */
  if (cfg.vbus_sensing_enable == 0U)
 800f50e:	f897 302e 	ldrb.w	r3, [r7, #46]	@ 0x2e
 800f512:	2b00      	cmp	r3, #0
 800f514:	d11c      	bne.n	800f550 <USB_DevInit+0x7c>
  {
    USBx_DEVICE->DCTL |= USB_OTG_DCTL_SDIS;
 800f516:	68fb      	ldr	r3, [r7, #12]
 800f518:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 800f51c:	685b      	ldr	r3, [r3, #4]
 800f51e:	68fa      	ldr	r2, [r7, #12]
 800f520:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 800f524:	f043 0302 	orr.w	r3, r3, #2
 800f528:	6053      	str	r3, [r2, #4]

    /* Deactivate VBUS Sensing B */
    USBx->GCCFG &= ~USB_OTG_GCCFG_VBDEN;
 800f52a:	687b      	ldr	r3, [r7, #4]
 800f52c:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800f52e:	f423 1200 	bic.w	r2, r3, #2097152	@ 0x200000
 800f532:	687b      	ldr	r3, [r7, #4]
 800f534:	639a      	str	r2, [r3, #56]	@ 0x38

    /* B-peripheral session valid override enable */
    USBx->GOTGCTL |= USB_OTG_GOTGCTL_BVALOEN;
 800f536:	687b      	ldr	r3, [r7, #4]
 800f538:	681b      	ldr	r3, [r3, #0]
 800f53a:	f043 0240 	orr.w	r2, r3, #64	@ 0x40
 800f53e:	687b      	ldr	r3, [r7, #4]
 800f540:	601a      	str	r2, [r3, #0]
    USBx->GOTGCTL |= USB_OTG_GOTGCTL_BVALOVAL;
 800f542:	687b      	ldr	r3, [r7, #4]
 800f544:	681b      	ldr	r3, [r3, #0]
 800f546:	f043 0280 	orr.w	r2, r3, #128	@ 0x80
 800f54a:	687b      	ldr	r3, [r7, #4]
 800f54c:	601a      	str	r2, [r3, #0]
 800f54e:	e005      	b.n	800f55c <USB_DevInit+0x88>
  }
  else
  {
    /* Enable HW VBUS sensing */
    USBx->GCCFG |= USB_OTG_GCCFG_VBDEN;
 800f550:	687b      	ldr	r3, [r7, #4]
 800f552:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800f554:	f443 1200 	orr.w	r2, r3, #2097152	@ 0x200000
 800f558:	687b      	ldr	r3, [r7, #4]
 800f55a:	639a      	str	r2, [r3, #56]	@ 0x38
  }

  /* Restart the Phy Clock */
  USBx_PCGCCTL = 0U;
 800f55c:	68fb      	ldr	r3, [r7, #12]
 800f55e:	f503 6360 	add.w	r3, r3, #3584	@ 0xe00
 800f562:	461a      	mov	r2, r3
 800f564:	2300      	movs	r3, #0
 800f566:	6013      	str	r3, [r2, #0]

  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
 800f568:	f897 3029 	ldrb.w	r3, [r7, #41]	@ 0x29
 800f56c:	2b01      	cmp	r3, #1
 800f56e:	d10d      	bne.n	800f58c <USB_DevInit+0xb8>
  {
    if (cfg.speed == USBD_HS_SPEED)
 800f570:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 800f574:	2b00      	cmp	r3, #0
 800f576:	d104      	bne.n	800f582 <USB_DevInit+0xae>
    {
      /* Set Core speed to High speed mode */
      (void)USB_SetDevSpeed(USBx, USB_OTG_SPEED_HIGH);
 800f578:	2100      	movs	r1, #0
 800f57a:	6878      	ldr	r0, [r7, #4]
 800f57c:	f000 f968 	bl	800f850 <USB_SetDevSpeed>
 800f580:	e008      	b.n	800f594 <USB_DevInit+0xc0>
    }
    else
    {
      /* Set Core speed to Full speed mode */
      (void)USB_SetDevSpeed(USBx, USB_OTG_SPEED_HIGH_IN_FULL);
 800f582:	2101      	movs	r1, #1
 800f584:	6878      	ldr	r0, [r7, #4]
 800f586:	f000 f963 	bl	800f850 <USB_SetDevSpeed>
 800f58a:	e003      	b.n	800f594 <USB_DevInit+0xc0>
    }
  }
  else
  {
    /* Set Core speed to Full speed mode */
    (void)USB_SetDevSpeed(USBx, USB_OTG_SPEED_FULL);
 800f58c:	2103      	movs	r1, #3
 800f58e:	6878      	ldr	r0, [r7, #4]
 800f590:	f000 f95e 	bl	800f850 <USB_SetDevSpeed>
  }

  /* Flush the FIFOs */
  if (USB_FlushTxFifo(USBx, 0x10U) != HAL_OK) /* all Tx FIFOs */
 800f594:	2110      	movs	r1, #16
 800f596:	6878      	ldr	r0, [r7, #4]
 800f598:	f000 f8fa 	bl	800f790 <USB_FlushTxFifo>
 800f59c:	4603      	mov	r3, r0
 800f59e:	2b00      	cmp	r3, #0
 800f5a0:	d001      	beq.n	800f5a6 <USB_DevInit+0xd2>
  {
    ret = HAL_ERROR;
 800f5a2:	2301      	movs	r3, #1
 800f5a4:	75fb      	strb	r3, [r7, #23]
  }

  if (USB_FlushRxFifo(USBx) != HAL_OK)
 800f5a6:	6878      	ldr	r0, [r7, #4]
 800f5a8:	f000 f924 	bl	800f7f4 <USB_FlushRxFifo>
 800f5ac:	4603      	mov	r3, r0
 800f5ae:	2b00      	cmp	r3, #0
 800f5b0:	d001      	beq.n	800f5b6 <USB_DevInit+0xe2>
  {
    ret = HAL_ERROR;
 800f5b2:	2301      	movs	r3, #1
 800f5b4:	75fb      	strb	r3, [r7, #23]
  }

  /* Clear all pending Device Interrupts */
  USBx_DEVICE->DIEPMSK = 0U;
 800f5b6:	68fb      	ldr	r3, [r7, #12]
 800f5b8:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 800f5bc:	461a      	mov	r2, r3
 800f5be:	2300      	movs	r3, #0
 800f5c0:	6113      	str	r3, [r2, #16]
  USBx_DEVICE->DOEPMSK = 0U;
 800f5c2:	68fb      	ldr	r3, [r7, #12]
 800f5c4:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 800f5c8:	461a      	mov	r2, r3
 800f5ca:	2300      	movs	r3, #0
 800f5cc:	6153      	str	r3, [r2, #20]
  USBx_DEVICE->DAINTMSK = 0U;
 800f5ce:	68fb      	ldr	r3, [r7, #12]
 800f5d0:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 800f5d4:	461a      	mov	r2, r3
 800f5d6:	2300      	movs	r3, #0
 800f5d8:	61d3      	str	r3, [r2, #28]

  for (i = 0U; i < cfg.dev_endpoints; i++)
 800f5da:	2300      	movs	r3, #0
 800f5dc:	613b      	str	r3, [r7, #16]
 800f5de:	e043      	b.n	800f668 <USB_DevInit+0x194>
  {
    if ((USBx_INEP(i)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
 800f5e0:	693b      	ldr	r3, [r7, #16]
 800f5e2:	015a      	lsls	r2, r3, #5
 800f5e4:	68fb      	ldr	r3, [r7, #12]
 800f5e6:	4413      	add	r3, r2
 800f5e8:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 800f5ec:	681b      	ldr	r3, [r3, #0]
 800f5ee:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
 800f5f2:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 800f5f6:	d118      	bne.n	800f62a <USB_DevInit+0x156>
    {
      if (i == 0U)
 800f5f8:	693b      	ldr	r3, [r7, #16]
 800f5fa:	2b00      	cmp	r3, #0
 800f5fc:	d10a      	bne.n	800f614 <USB_DevInit+0x140>
      {
        USBx_INEP(i)->DIEPCTL = USB_OTG_DIEPCTL_SNAK;
 800f5fe:	693b      	ldr	r3, [r7, #16]
 800f600:	015a      	lsls	r2, r3, #5
 800f602:	68fb      	ldr	r3, [r7, #12]
 800f604:	4413      	add	r3, r2
 800f606:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 800f60a:	461a      	mov	r2, r3
 800f60c:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
 800f610:	6013      	str	r3, [r2, #0]
 800f612:	e013      	b.n	800f63c <USB_DevInit+0x168>
      }
      else
      {
        USBx_INEP(i)->DIEPCTL = USB_OTG_DIEPCTL_EPDIS | USB_OTG_DIEPCTL_SNAK;
 800f614:	693b      	ldr	r3, [r7, #16]
 800f616:	015a      	lsls	r2, r3, #5
 800f618:	68fb      	ldr	r3, [r7, #12]
 800f61a:	4413      	add	r3, r2
 800f61c:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 800f620:	461a      	mov	r2, r3
 800f622:	f04f 4390 	mov.w	r3, #1207959552	@ 0x48000000
 800f626:	6013      	str	r3, [r2, #0]
 800f628:	e008      	b.n	800f63c <USB_DevInit+0x168>
      }
    }
    else
    {
      USBx_INEP(i)->DIEPCTL = 0U;
 800f62a:	693b      	ldr	r3, [r7, #16]
 800f62c:	015a      	lsls	r2, r3, #5
 800f62e:	68fb      	ldr	r3, [r7, #12]
 800f630:	4413      	add	r3, r2
 800f632:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 800f636:	461a      	mov	r2, r3
 800f638:	2300      	movs	r3, #0
 800f63a:	6013      	str	r3, [r2, #0]
    }

    USBx_INEP(i)->DIEPTSIZ = 0U;
 800f63c:	693b      	ldr	r3, [r7, #16]
 800f63e:	015a      	lsls	r2, r3, #5
 800f640:	68fb      	ldr	r3, [r7, #12]
 800f642:	4413      	add	r3, r2
 800f644:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 800f648:	461a      	mov	r2, r3
 800f64a:	2300      	movs	r3, #0
 800f64c:	6113      	str	r3, [r2, #16]
    USBx_INEP(i)->DIEPINT  = 0xFB7FU;
 800f64e:	693b      	ldr	r3, [r7, #16]
 800f650:	015a      	lsls	r2, r3, #5
 800f652:	68fb      	ldr	r3, [r7, #12]
 800f654:	4413      	add	r3, r2
 800f656:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 800f65a:	461a      	mov	r2, r3
 800f65c:	f64f 337f 	movw	r3, #64383	@ 0xfb7f
 800f660:	6093      	str	r3, [r2, #8]
  for (i = 0U; i < cfg.dev_endpoints; i++)
 800f662:	693b      	ldr	r3, [r7, #16]
 800f664:	3301      	adds	r3, #1
 800f666:	613b      	str	r3, [r7, #16]
 800f668:	f897 3024 	ldrb.w	r3, [r7, #36]	@ 0x24
 800f66c:	461a      	mov	r2, r3
 800f66e:	693b      	ldr	r3, [r7, #16]
 800f670:	4293      	cmp	r3, r2
 800f672:	d3b5      	bcc.n	800f5e0 <USB_DevInit+0x10c>
  }

  for (i = 0U; i < cfg.dev_endpoints; i++)
 800f674:	2300      	movs	r3, #0
 800f676:	613b      	str	r3, [r7, #16]
 800f678:	e043      	b.n	800f702 <USB_DevInit+0x22e>
  {
    if ((USBx_OUTEP(i)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 800f67a:	693b      	ldr	r3, [r7, #16]
 800f67c:	015a      	lsls	r2, r3, #5
 800f67e:	68fb      	ldr	r3, [r7, #12]
 800f680:	4413      	add	r3, r2
 800f682:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 800f686:	681b      	ldr	r3, [r3, #0]
 800f688:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
 800f68c:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 800f690:	d118      	bne.n	800f6c4 <USB_DevInit+0x1f0>
    {
      if (i == 0U)
 800f692:	693b      	ldr	r3, [r7, #16]
 800f694:	2b00      	cmp	r3, #0
 800f696:	d10a      	bne.n	800f6ae <USB_DevInit+0x1da>
      {
        USBx_OUTEP(i)->DOEPCTL = USB_OTG_DOEPCTL_SNAK;
 800f698:	693b      	ldr	r3, [r7, #16]
 800f69a:	015a      	lsls	r2, r3, #5
 800f69c:	68fb      	ldr	r3, [r7, #12]
 800f69e:	4413      	add	r3, r2
 800f6a0:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 800f6a4:	461a      	mov	r2, r3
 800f6a6:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
 800f6aa:	6013      	str	r3, [r2, #0]
 800f6ac:	e013      	b.n	800f6d6 <USB_DevInit+0x202>
      }
      else
      {
        USBx_OUTEP(i)->DOEPCTL = USB_OTG_DOEPCTL_EPDIS | USB_OTG_DOEPCTL_SNAK;
 800f6ae:	693b      	ldr	r3, [r7, #16]
 800f6b0:	015a      	lsls	r2, r3, #5
 800f6b2:	68fb      	ldr	r3, [r7, #12]
 800f6b4:	4413      	add	r3, r2
 800f6b6:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 800f6ba:	461a      	mov	r2, r3
 800f6bc:	f04f 4390 	mov.w	r3, #1207959552	@ 0x48000000
 800f6c0:	6013      	str	r3, [r2, #0]
 800f6c2:	e008      	b.n	800f6d6 <USB_DevInit+0x202>
      }
    }
    else
    {
      USBx_OUTEP(i)->DOEPCTL = 0U;
 800f6c4:	693b      	ldr	r3, [r7, #16]
 800f6c6:	015a      	lsls	r2, r3, #5
 800f6c8:	68fb      	ldr	r3, [r7, #12]
 800f6ca:	4413      	add	r3, r2
 800f6cc:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 800f6d0:	461a      	mov	r2, r3
 800f6d2:	2300      	movs	r3, #0
 800f6d4:	6013      	str	r3, [r2, #0]
    }

    USBx_OUTEP(i)->DOEPTSIZ = 0U;
 800f6d6:	693b      	ldr	r3, [r7, #16]
 800f6d8:	015a      	lsls	r2, r3, #5
 800f6da:	68fb      	ldr	r3, [r7, #12]
 800f6dc:	4413      	add	r3, r2
 800f6de:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 800f6e2:	461a      	mov	r2, r3
 800f6e4:	2300      	movs	r3, #0
 800f6e6:	6113      	str	r3, [r2, #16]
    USBx_OUTEP(i)->DOEPINT  = 0xFB7FU;
 800f6e8:	693b      	ldr	r3, [r7, #16]
 800f6ea:	015a      	lsls	r2, r3, #5
 800f6ec:	68fb      	ldr	r3, [r7, #12]
 800f6ee:	4413      	add	r3, r2
 800f6f0:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 800f6f4:	461a      	mov	r2, r3
 800f6f6:	f64f 337f 	movw	r3, #64383	@ 0xfb7f
 800f6fa:	6093      	str	r3, [r2, #8]
  for (i = 0U; i < cfg.dev_endpoints; i++)
 800f6fc:	693b      	ldr	r3, [r7, #16]
 800f6fe:	3301      	adds	r3, #1
 800f700:	613b      	str	r3, [r7, #16]
 800f702:	f897 3024 	ldrb.w	r3, [r7, #36]	@ 0x24
 800f706:	461a      	mov	r2, r3
 800f708:	693b      	ldr	r3, [r7, #16]
 800f70a:	4293      	cmp	r3, r2
 800f70c:	d3b5      	bcc.n	800f67a <USB_DevInit+0x1a6>
  }

  USBx_DEVICE->DIEPMSK &= ~(USB_OTG_DIEPMSK_TXFURM);
 800f70e:	68fb      	ldr	r3, [r7, #12]
 800f710:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 800f714:	691b      	ldr	r3, [r3, #16]
 800f716:	68fa      	ldr	r2, [r7, #12]
 800f718:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 800f71c:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
 800f720:	6113      	str	r3, [r2, #16]

  /* Disable all interrupts. */
  USBx->GINTMSK = 0U;
 800f722:	687b      	ldr	r3, [r7, #4]
 800f724:	2200      	movs	r2, #0
 800f726:	619a      	str	r2, [r3, #24]

  /* Clear any pending interrupts */
  USBx->GINTSTS = 0xBFFFFFFFU;
 800f728:	687b      	ldr	r3, [r7, #4]
 800f72a:	f06f 4280 	mvn.w	r2, #1073741824	@ 0x40000000
 800f72e:	615a      	str	r2, [r3, #20]

  /* Enable the common interrupts */
  if (cfg.dma_enable == 0U)
 800f730:	f897 3026 	ldrb.w	r3, [r7, #38]	@ 0x26
 800f734:	2b00      	cmp	r3, #0
 800f736:	d105      	bne.n	800f744 <USB_DevInit+0x270>
  {
    USBx->GINTMSK |= USB_OTG_GINTMSK_RXFLVLM;
 800f738:	687b      	ldr	r3, [r7, #4]
 800f73a:	699b      	ldr	r3, [r3, #24]
 800f73c:	f043 0210 	orr.w	r2, r3, #16
 800f740:	687b      	ldr	r3, [r7, #4]
 800f742:	619a      	str	r2, [r3, #24]
  }

  /* Enable interrupts matching to the Device mode ONLY */
  USBx->GINTMSK |= USB_OTG_GINTMSK_USBSUSPM | USB_OTG_GINTMSK_USBRST |
 800f744:	687b      	ldr	r3, [r7, #4]
 800f746:	699a      	ldr	r2, [r3, #24]
 800f748:	4b0f      	ldr	r3, [pc, #60]	@ (800f788 <USB_DevInit+0x2b4>)
 800f74a:	4313      	orrs	r3, r2
 800f74c:	687a      	ldr	r2, [r7, #4]
 800f74e:	6193      	str	r3, [r2, #24]
                   USB_OTG_GINTMSK_ENUMDNEM | USB_OTG_GINTMSK_IEPINT |
                   USB_OTG_GINTMSK_OEPINT   | USB_OTG_GINTMSK_IISOIXFRM |
                   USB_OTG_GINTMSK_PXFRM_IISOOXFRM | USB_OTG_GINTMSK_WUIM;

  if (cfg.Sof_enable != 0U)
 800f750:	f897 302a 	ldrb.w	r3, [r7, #42]	@ 0x2a
 800f754:	2b00      	cmp	r3, #0
 800f756:	d005      	beq.n	800f764 <USB_DevInit+0x290>
  {
    USBx->GINTMSK |= USB_OTG_GINTMSK_SOFM;
 800f758:	687b      	ldr	r3, [r7, #4]
 800f75a:	699b      	ldr	r3, [r3, #24]
 800f75c:	f043 0208 	orr.w	r2, r3, #8
 800f760:	687b      	ldr	r3, [r7, #4]
 800f762:	619a      	str	r2, [r3, #24]
  }

  if (cfg.vbus_sensing_enable == 1U)
 800f764:	f897 302e 	ldrb.w	r3, [r7, #46]	@ 0x2e
 800f768:	2b01      	cmp	r3, #1
 800f76a:	d105      	bne.n	800f778 <USB_DevInit+0x2a4>
  {
    USBx->GINTMSK |= (USB_OTG_GINTMSK_SRQIM | USB_OTG_GINTMSK_OTGINT);
 800f76c:	687b      	ldr	r3, [r7, #4]
 800f76e:	699a      	ldr	r2, [r3, #24]
 800f770:	4b06      	ldr	r3, [pc, #24]	@ (800f78c <USB_DevInit+0x2b8>)
 800f772:	4313      	orrs	r3, r2
 800f774:	687a      	ldr	r2, [r7, #4]
 800f776:	6193      	str	r3, [r2, #24]
  }

  return ret;
 800f778:	7dfb      	ldrb	r3, [r7, #23]
}
 800f77a:	4618      	mov	r0, r3
 800f77c:	3718      	adds	r7, #24
 800f77e:	46bd      	mov	sp, r7
 800f780:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 800f784:	b004      	add	sp, #16
 800f786:	4770      	bx	lr
 800f788:	803c3800 	.word	0x803c3800
 800f78c:	40000004 	.word	0x40000004

0800f790 <USB_FlushTxFifo>:
  *         This parameter can be a value from 1 to 15
            15 means Flush all Tx FIFOs
  * @retval HAL status
  */
HAL_StatusTypeDef USB_FlushTxFifo(USB_OTG_GlobalTypeDef *USBx, uint32_t num)
{
 800f790:	b480      	push	{r7}
 800f792:	b085      	sub	sp, #20
 800f794:	af00      	add	r7, sp, #0
 800f796:	6078      	str	r0, [r7, #4]
 800f798:	6039      	str	r1, [r7, #0]
  __IO uint32_t count = 0U;
 800f79a:	2300      	movs	r3, #0
 800f79c:	60fb      	str	r3, [r7, #12]

  /* Wait for AHB master IDLE state. */
  do
  {
    count++;
 800f79e:	68fb      	ldr	r3, [r7, #12]
 800f7a0:	3301      	adds	r3, #1
 800f7a2:	60fb      	str	r3, [r7, #12]

    if (count > HAL_USB_TIMEOUT)
 800f7a4:	68fb      	ldr	r3, [r7, #12]
 800f7a6:	f1b3 6f70 	cmp.w	r3, #251658240	@ 0xf000000
 800f7aa:	d901      	bls.n	800f7b0 <USB_FlushTxFifo+0x20>
    {
      return HAL_TIMEOUT;
 800f7ac:	2303      	movs	r3, #3
 800f7ae:	e01b      	b.n	800f7e8 <USB_FlushTxFifo+0x58>
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 800f7b0:	687b      	ldr	r3, [r7, #4]
 800f7b2:	691b      	ldr	r3, [r3, #16]
 800f7b4:	2b00      	cmp	r3, #0
 800f7b6:	daf2      	bge.n	800f79e <USB_FlushTxFifo+0xe>

  /* Flush TX Fifo */
  count = 0U;
 800f7b8:	2300      	movs	r3, #0
 800f7ba:	60fb      	str	r3, [r7, #12]
  USBx->GRSTCTL = (USB_OTG_GRSTCTL_TXFFLSH | (num << 6));
 800f7bc:	683b      	ldr	r3, [r7, #0]
 800f7be:	019b      	lsls	r3, r3, #6
 800f7c0:	f043 0220 	orr.w	r2, r3, #32
 800f7c4:	687b      	ldr	r3, [r7, #4]
 800f7c6:	611a      	str	r2, [r3, #16]

  do
  {
    count++;
 800f7c8:	68fb      	ldr	r3, [r7, #12]
 800f7ca:	3301      	adds	r3, #1
 800f7cc:	60fb      	str	r3, [r7, #12]

    if (count > HAL_USB_TIMEOUT)
 800f7ce:	68fb      	ldr	r3, [r7, #12]
 800f7d0:	f1b3 6f70 	cmp.w	r3, #251658240	@ 0xf000000
 800f7d4:	d901      	bls.n	800f7da <USB_FlushTxFifo+0x4a>
    {
      return HAL_TIMEOUT;
 800f7d6:	2303      	movs	r3, #3
 800f7d8:	e006      	b.n	800f7e8 <USB_FlushTxFifo+0x58>
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH) == USB_OTG_GRSTCTL_TXFFLSH);
 800f7da:	687b      	ldr	r3, [r7, #4]
 800f7dc:	691b      	ldr	r3, [r3, #16]
 800f7de:	f003 0320 	and.w	r3, r3, #32
 800f7e2:	2b20      	cmp	r3, #32
 800f7e4:	d0f0      	beq.n	800f7c8 <USB_FlushTxFifo+0x38>

  return HAL_OK;
 800f7e6:	2300      	movs	r3, #0
}
 800f7e8:	4618      	mov	r0, r3
 800f7ea:	3714      	adds	r7, #20
 800f7ec:	46bd      	mov	sp, r7
 800f7ee:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f7f2:	4770      	bx	lr

0800f7f4 <USB_FlushRxFifo>:
  * @brief  USB_FlushRxFifo  Flush Rx FIFO
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_FlushRxFifo(USB_OTG_GlobalTypeDef *USBx)
{
 800f7f4:	b480      	push	{r7}
 800f7f6:	b085      	sub	sp, #20
 800f7f8:	af00      	add	r7, sp, #0
 800f7fa:	6078      	str	r0, [r7, #4]
  __IO uint32_t count = 0U;
 800f7fc:	2300      	movs	r3, #0
 800f7fe:	60fb      	str	r3, [r7, #12]

  /* Wait for AHB master IDLE state. */
  do
  {
    count++;
 800f800:	68fb      	ldr	r3, [r7, #12]
 800f802:	3301      	adds	r3, #1
 800f804:	60fb      	str	r3, [r7, #12]

    if (count > HAL_USB_TIMEOUT)
 800f806:	68fb      	ldr	r3, [r7, #12]
 800f808:	f1b3 6f70 	cmp.w	r3, #251658240	@ 0xf000000
 800f80c:	d901      	bls.n	800f812 <USB_FlushRxFifo+0x1e>
    {
      return HAL_TIMEOUT;
 800f80e:	2303      	movs	r3, #3
 800f810:	e018      	b.n	800f844 <USB_FlushRxFifo+0x50>
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 800f812:	687b      	ldr	r3, [r7, #4]
 800f814:	691b      	ldr	r3, [r3, #16]
 800f816:	2b00      	cmp	r3, #0
 800f818:	daf2      	bge.n	800f800 <USB_FlushRxFifo+0xc>

  /* Flush RX Fifo */
  count = 0U;
 800f81a:	2300      	movs	r3, #0
 800f81c:	60fb      	str	r3, [r7, #12]
  USBx->GRSTCTL = USB_OTG_GRSTCTL_RXFFLSH;
 800f81e:	687b      	ldr	r3, [r7, #4]
 800f820:	2210      	movs	r2, #16
 800f822:	611a      	str	r2, [r3, #16]

  do
  {
    count++;
 800f824:	68fb      	ldr	r3, [r7, #12]
 800f826:	3301      	adds	r3, #1
 800f828:	60fb      	str	r3, [r7, #12]

    if (count > HAL_USB_TIMEOUT)
 800f82a:	68fb      	ldr	r3, [r7, #12]
 800f82c:	f1b3 6f70 	cmp.w	r3, #251658240	@ 0xf000000
 800f830:	d901      	bls.n	800f836 <USB_FlushRxFifo+0x42>
    {
      return HAL_TIMEOUT;
 800f832:	2303      	movs	r3, #3
 800f834:	e006      	b.n	800f844 <USB_FlushRxFifo+0x50>
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_RXFFLSH) == USB_OTG_GRSTCTL_RXFFLSH);
 800f836:	687b      	ldr	r3, [r7, #4]
 800f838:	691b      	ldr	r3, [r3, #16]
 800f83a:	f003 0310 	and.w	r3, r3, #16
 800f83e:	2b10      	cmp	r3, #16
 800f840:	d0f0      	beq.n	800f824 <USB_FlushRxFifo+0x30>

  return HAL_OK;
 800f842:	2300      	movs	r3, #0
}
 800f844:	4618      	mov	r0, r3
 800f846:	3714      	adds	r7, #20
 800f848:	46bd      	mov	sp, r7
 800f84a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f84e:	4770      	bx	lr

0800f850 <USB_SetDevSpeed>:
  *            @arg USB_OTG_SPEED_HIGH_IN_FULL: High speed core in Full Speed mode
  *            @arg USB_OTG_SPEED_FULL: Full speed mode
  * @retval  Hal status
  */
HAL_StatusTypeDef USB_SetDevSpeed(const USB_OTG_GlobalTypeDef *USBx, uint8_t speed)
{
 800f850:	b480      	push	{r7}
 800f852:	b085      	sub	sp, #20
 800f854:	af00      	add	r7, sp, #0
 800f856:	6078      	str	r0, [r7, #4]
 800f858:	460b      	mov	r3, r1
 800f85a:	70fb      	strb	r3, [r7, #3]
  uint32_t USBx_BASE = (uint32_t)USBx;
 800f85c:	687b      	ldr	r3, [r7, #4]
 800f85e:	60fb      	str	r3, [r7, #12]

  USBx_DEVICE->DCFG |= speed;
 800f860:	68fb      	ldr	r3, [r7, #12]
 800f862:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 800f866:	681a      	ldr	r2, [r3, #0]
 800f868:	78fb      	ldrb	r3, [r7, #3]
 800f86a:	68f9      	ldr	r1, [r7, #12]
 800f86c:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
 800f870:	4313      	orrs	r3, r2
 800f872:	600b      	str	r3, [r1, #0]
  return HAL_OK;
 800f874:	2300      	movs	r3, #0
}
 800f876:	4618      	mov	r0, r3
 800f878:	3714      	adds	r7, #20
 800f87a:	46bd      	mov	sp, r7
 800f87c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f880:	4770      	bx	lr

0800f882 <USB_GetDevSpeed>:
  *          This parameter can be one of these values:
  *            @arg USBD_HS_SPEED: High speed mode
  *            @arg USBD_FS_SPEED: Full speed mode
  */
uint8_t USB_GetDevSpeed(const USB_OTG_GlobalTypeDef *USBx)
{
 800f882:	b480      	push	{r7}
 800f884:	b087      	sub	sp, #28
 800f886:	af00      	add	r7, sp, #0
 800f888:	6078      	str	r0, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
 800f88a:	687b      	ldr	r3, [r7, #4]
 800f88c:	613b      	str	r3, [r7, #16]
  uint8_t speed;
  uint32_t DevEnumSpeed = USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD;
 800f88e:	693b      	ldr	r3, [r7, #16]
 800f890:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 800f894:	689b      	ldr	r3, [r3, #8]
 800f896:	f003 0306 	and.w	r3, r3, #6
 800f89a:	60fb      	str	r3, [r7, #12]

  if (DevEnumSpeed == DSTS_ENUMSPD_HS_PHY_30MHZ_OR_60MHZ)
 800f89c:	68fb      	ldr	r3, [r7, #12]
 800f89e:	2b00      	cmp	r3, #0
 800f8a0:	d102      	bne.n	800f8a8 <USB_GetDevSpeed+0x26>
  {
    speed = USBD_HS_SPEED;
 800f8a2:	2300      	movs	r3, #0
 800f8a4:	75fb      	strb	r3, [r7, #23]
 800f8a6:	e00a      	b.n	800f8be <USB_GetDevSpeed+0x3c>
  }
  else if ((DevEnumSpeed == DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ) ||
 800f8a8:	68fb      	ldr	r3, [r7, #12]
 800f8aa:	2b02      	cmp	r3, #2
 800f8ac:	d002      	beq.n	800f8b4 <USB_GetDevSpeed+0x32>
 800f8ae:	68fb      	ldr	r3, [r7, #12]
 800f8b0:	2b06      	cmp	r3, #6
 800f8b2:	d102      	bne.n	800f8ba <USB_GetDevSpeed+0x38>
           (DevEnumSpeed == DSTS_ENUMSPD_FS_PHY_48MHZ))
  {
    speed = USBD_FS_SPEED;
 800f8b4:	2302      	movs	r3, #2
 800f8b6:	75fb      	strb	r3, [r7, #23]
 800f8b8:	e001      	b.n	800f8be <USB_GetDevSpeed+0x3c>
  }
  else
  {
    speed = 0xFU;
 800f8ba:	230f      	movs	r3, #15
 800f8bc:	75fb      	strb	r3, [r7, #23]
  }

  return speed;
 800f8be:	7dfb      	ldrb	r3, [r7, #23]
}
 800f8c0:	4618      	mov	r0, r3
 800f8c2:	371c      	adds	r7, #28
 800f8c4:	46bd      	mov	sp, r7
 800f8c6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f8ca:	4770      	bx	lr

0800f8cc <USB_ActivateEndpoint>:
  * @param  USBx  Selected device
  * @param  ep pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_ActivateEndpoint(const USB_OTG_GlobalTypeDef *USBx, const USB_OTG_EPTypeDef *ep)
{
 800f8cc:	b480      	push	{r7}
 800f8ce:	b085      	sub	sp, #20
 800f8d0:	af00      	add	r7, sp, #0
 800f8d2:	6078      	str	r0, [r7, #4]
 800f8d4:	6039      	str	r1, [r7, #0]
  uint32_t USBx_BASE = (uint32_t)USBx;
 800f8d6:	687b      	ldr	r3, [r7, #4]
 800f8d8:	60fb      	str	r3, [r7, #12]
  uint32_t epnum = (uint32_t)ep->num;
 800f8da:	683b      	ldr	r3, [r7, #0]
 800f8dc:	781b      	ldrb	r3, [r3, #0]
 800f8de:	60bb      	str	r3, [r7, #8]

  if (ep->is_in == 1U)
 800f8e0:	683b      	ldr	r3, [r7, #0]
 800f8e2:	785b      	ldrb	r3, [r3, #1]
 800f8e4:	2b01      	cmp	r3, #1
 800f8e6:	d139      	bne.n	800f95c <USB_ActivateEndpoint+0x90>
  {
    USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK));
 800f8e8:	68fb      	ldr	r3, [r7, #12]
 800f8ea:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 800f8ee:	69da      	ldr	r2, [r3, #28]
 800f8f0:	683b      	ldr	r3, [r7, #0]
 800f8f2:	781b      	ldrb	r3, [r3, #0]
 800f8f4:	f003 030f 	and.w	r3, r3, #15
 800f8f8:	2101      	movs	r1, #1
 800f8fa:	fa01 f303 	lsl.w	r3, r1, r3
 800f8fe:	b29b      	uxth	r3, r3
 800f900:	68f9      	ldr	r1, [r7, #12]
 800f902:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
 800f906:	4313      	orrs	r3, r2
 800f908:	61cb      	str	r3, [r1, #28]

    if ((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_USBAEP) == 0U)
 800f90a:	68bb      	ldr	r3, [r7, #8]
 800f90c:	015a      	lsls	r2, r3, #5
 800f90e:	68fb      	ldr	r3, [r7, #12]
 800f910:	4413      	add	r3, r2
 800f912:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 800f916:	681b      	ldr	r3, [r3, #0]
 800f918:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
 800f91c:	2b00      	cmp	r3, #0
 800f91e:	d153      	bne.n	800f9c8 <USB_ActivateEndpoint+0xfc>
    {
      USBx_INEP(epnum)->DIEPCTL |= (ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ) |
 800f920:	68bb      	ldr	r3, [r7, #8]
 800f922:	015a      	lsls	r2, r3, #5
 800f924:	68fb      	ldr	r3, [r7, #12]
 800f926:	4413      	add	r3, r2
 800f928:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 800f92c:	681a      	ldr	r2, [r3, #0]
 800f92e:	683b      	ldr	r3, [r7, #0]
 800f930:	689b      	ldr	r3, [r3, #8]
 800f932:	f3c3 010a 	ubfx	r1, r3, #0, #11
                                   ((uint32_t)ep->type << 18) | (epnum << 22) |
 800f936:	683b      	ldr	r3, [r7, #0]
 800f938:	791b      	ldrb	r3, [r3, #4]
 800f93a:	049b      	lsls	r3, r3, #18
      USBx_INEP(epnum)->DIEPCTL |= (ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ) |
 800f93c:	4319      	orrs	r1, r3
                                   ((uint32_t)ep->type << 18) | (epnum << 22) |
 800f93e:	68bb      	ldr	r3, [r7, #8]
 800f940:	059b      	lsls	r3, r3, #22
 800f942:	430b      	orrs	r3, r1
      USBx_INEP(epnum)->DIEPCTL |= (ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ) |
 800f944:	431a      	orrs	r2, r3
 800f946:	68bb      	ldr	r3, [r7, #8]
 800f948:	0159      	lsls	r1, r3, #5
 800f94a:	68fb      	ldr	r3, [r7, #12]
 800f94c:	440b      	add	r3, r1
 800f94e:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 800f952:	4619      	mov	r1, r3
 800f954:	4b20      	ldr	r3, [pc, #128]	@ (800f9d8 <USB_ActivateEndpoint+0x10c>)
 800f956:	4313      	orrs	r3, r2
 800f958:	600b      	str	r3, [r1, #0]
 800f95a:	e035      	b.n	800f9c8 <USB_ActivateEndpoint+0xfc>
                                   USB_OTG_DIEPCTL_USBAEP;
    }
  }
  else
  {
    USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16);
 800f95c:	68fb      	ldr	r3, [r7, #12]
 800f95e:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 800f962:	69da      	ldr	r2, [r3, #28]
 800f964:	683b      	ldr	r3, [r7, #0]
 800f966:	781b      	ldrb	r3, [r3, #0]
 800f968:	f003 030f 	and.w	r3, r3, #15
 800f96c:	2101      	movs	r1, #1
 800f96e:	fa01 f303 	lsl.w	r3, r1, r3
 800f972:	041b      	lsls	r3, r3, #16
 800f974:	68f9      	ldr	r1, [r7, #12]
 800f976:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
 800f97a:	4313      	orrs	r3, r2
 800f97c:	61cb      	str	r3, [r1, #28]

    if (((USBx_OUTEP(epnum)->DOEPCTL) & USB_OTG_DOEPCTL_USBAEP) == 0U)
 800f97e:	68bb      	ldr	r3, [r7, #8]
 800f980:	015a      	lsls	r2, r3, #5
 800f982:	68fb      	ldr	r3, [r7, #12]
 800f984:	4413      	add	r3, r2
 800f986:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 800f98a:	681b      	ldr	r3, [r3, #0]
 800f98c:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
 800f990:	2b00      	cmp	r3, #0
 800f992:	d119      	bne.n	800f9c8 <USB_ActivateEndpoint+0xfc>
    {
      USBx_OUTEP(epnum)->DOEPCTL |= (ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ) |
 800f994:	68bb      	ldr	r3, [r7, #8]
 800f996:	015a      	lsls	r2, r3, #5
 800f998:	68fb      	ldr	r3, [r7, #12]
 800f99a:	4413      	add	r3, r2
 800f99c:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 800f9a0:	681a      	ldr	r2, [r3, #0]
 800f9a2:	683b      	ldr	r3, [r7, #0]
 800f9a4:	689b      	ldr	r3, [r3, #8]
 800f9a6:	f3c3 010a 	ubfx	r1, r3, #0, #11
                                    ((uint32_t)ep->type << 18) |
 800f9aa:	683b      	ldr	r3, [r7, #0]
 800f9ac:	791b      	ldrb	r3, [r3, #4]
 800f9ae:	049b      	lsls	r3, r3, #18
      USBx_OUTEP(epnum)->DOEPCTL |= (ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ) |
 800f9b0:	430b      	orrs	r3, r1
 800f9b2:	431a      	orrs	r2, r3
 800f9b4:	68bb      	ldr	r3, [r7, #8]
 800f9b6:	0159      	lsls	r1, r3, #5
 800f9b8:	68fb      	ldr	r3, [r7, #12]
 800f9ba:	440b      	add	r3, r1
 800f9bc:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 800f9c0:	4619      	mov	r1, r3
 800f9c2:	4b05      	ldr	r3, [pc, #20]	@ (800f9d8 <USB_ActivateEndpoint+0x10c>)
 800f9c4:	4313      	orrs	r3, r2
 800f9c6:	600b      	str	r3, [r1, #0]
                                    USB_OTG_DIEPCTL_SD0PID_SEVNFRM |
                                    USB_OTG_DOEPCTL_USBAEP;
    }
  }
  return HAL_OK;
 800f9c8:	2300      	movs	r3, #0
}
 800f9ca:	4618      	mov	r0, r3
 800f9cc:	3714      	adds	r7, #20
 800f9ce:	46bd      	mov	sp, r7
 800f9d0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f9d4:	4770      	bx	lr
 800f9d6:	bf00      	nop
 800f9d8:	10008000 	.word	0x10008000

0800f9dc <USB_DeactivateEndpoint>:
  * @param  USBx  Selected device
  * @param  ep pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DeactivateEndpoint(const USB_OTG_GlobalTypeDef *USBx, const USB_OTG_EPTypeDef *ep)
{
 800f9dc:	b480      	push	{r7}
 800f9de:	b085      	sub	sp, #20
 800f9e0:	af00      	add	r7, sp, #0
 800f9e2:	6078      	str	r0, [r7, #4]
 800f9e4:	6039      	str	r1, [r7, #0]
  uint32_t USBx_BASE = (uint32_t)USBx;
 800f9e6:	687b      	ldr	r3, [r7, #4]
 800f9e8:	60fb      	str	r3, [r7, #12]
  uint32_t epnum = (uint32_t)ep->num;
 800f9ea:	683b      	ldr	r3, [r7, #0]
 800f9ec:	781b      	ldrb	r3, [r3, #0]
 800f9ee:	60bb      	str	r3, [r7, #8]

  /* Read DEPCTLn register */
  if (ep->is_in == 1U)
 800f9f0:	683b      	ldr	r3, [r7, #0]
 800f9f2:	785b      	ldrb	r3, [r3, #1]
 800f9f4:	2b01      	cmp	r3, #1
 800f9f6:	d161      	bne.n	800fabc <USB_DeactivateEndpoint+0xe0>
  {
    if ((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
 800f9f8:	68bb      	ldr	r3, [r7, #8]
 800f9fa:	015a      	lsls	r2, r3, #5
 800f9fc:	68fb      	ldr	r3, [r7, #12]
 800f9fe:	4413      	add	r3, r2
 800fa00:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 800fa04:	681b      	ldr	r3, [r3, #0]
 800fa06:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
 800fa0a:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 800fa0e:	d11f      	bne.n	800fa50 <USB_DeactivateEndpoint+0x74>
    {
      USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SNAK;
 800fa10:	68bb      	ldr	r3, [r7, #8]
 800fa12:	015a      	lsls	r2, r3, #5
 800fa14:	68fb      	ldr	r3, [r7, #12]
 800fa16:	4413      	add	r3, r2
 800fa18:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 800fa1c:	681b      	ldr	r3, [r3, #0]
 800fa1e:	68ba      	ldr	r2, [r7, #8]
 800fa20:	0151      	lsls	r1, r2, #5
 800fa22:	68fa      	ldr	r2, [r7, #12]
 800fa24:	440a      	add	r2, r1
 800fa26:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 800fa2a:	f043 6300 	orr.w	r3, r3, #134217728	@ 0x8000000
 800fa2e:	6013      	str	r3, [r2, #0]
      USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_EPDIS;
 800fa30:	68bb      	ldr	r3, [r7, #8]
 800fa32:	015a      	lsls	r2, r3, #5
 800fa34:	68fb      	ldr	r3, [r7, #12]
 800fa36:	4413      	add	r3, r2
 800fa38:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 800fa3c:	681b      	ldr	r3, [r3, #0]
 800fa3e:	68ba      	ldr	r2, [r7, #8]
 800fa40:	0151      	lsls	r1, r2, #5
 800fa42:	68fa      	ldr	r2, [r7, #12]
 800fa44:	440a      	add	r2, r1
 800fa46:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 800fa4a:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
 800fa4e:	6013      	str	r3, [r2, #0]
    }

    USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK)));
 800fa50:	68fb      	ldr	r3, [r7, #12]
 800fa52:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 800fa56:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 800fa58:	683b      	ldr	r3, [r7, #0]
 800fa5a:	781b      	ldrb	r3, [r3, #0]
 800fa5c:	f003 030f 	and.w	r3, r3, #15
 800fa60:	2101      	movs	r1, #1
 800fa62:	fa01 f303 	lsl.w	r3, r1, r3
 800fa66:	b29b      	uxth	r3, r3
 800fa68:	43db      	mvns	r3, r3
 800fa6a:	68f9      	ldr	r1, [r7, #12]
 800fa6c:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
 800fa70:	4013      	ands	r3, r2
 800fa72:	63cb      	str	r3, [r1, #60]	@ 0x3c
    USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK)));
 800fa74:	68fb      	ldr	r3, [r7, #12]
 800fa76:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 800fa7a:	69da      	ldr	r2, [r3, #28]
 800fa7c:	683b      	ldr	r3, [r7, #0]
 800fa7e:	781b      	ldrb	r3, [r3, #0]
 800fa80:	f003 030f 	and.w	r3, r3, #15
 800fa84:	2101      	movs	r1, #1
 800fa86:	fa01 f303 	lsl.w	r3, r1, r3
 800fa8a:	b29b      	uxth	r3, r3
 800fa8c:	43db      	mvns	r3, r3
 800fa8e:	68f9      	ldr	r1, [r7, #12]
 800fa90:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
 800fa94:	4013      	ands	r3, r2
 800fa96:	61cb      	str	r3, [r1, #28]
    USBx_INEP(epnum)->DIEPCTL &= ~(USB_OTG_DIEPCTL_USBAEP |
 800fa98:	68bb      	ldr	r3, [r7, #8]
 800fa9a:	015a      	lsls	r2, r3, #5
 800fa9c:	68fb      	ldr	r3, [r7, #12]
 800fa9e:	4413      	add	r3, r2
 800faa0:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 800faa4:	681a      	ldr	r2, [r3, #0]
 800faa6:	68bb      	ldr	r3, [r7, #8]
 800faa8:	0159      	lsls	r1, r3, #5
 800faaa:	68fb      	ldr	r3, [r7, #12]
 800faac:	440b      	add	r3, r1
 800faae:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 800fab2:	4619      	mov	r1, r3
 800fab4:	4b35      	ldr	r3, [pc, #212]	@ (800fb8c <USB_DeactivateEndpoint+0x1b0>)
 800fab6:	4013      	ands	r3, r2
 800fab8:	600b      	str	r3, [r1, #0]
 800faba:	e060      	b.n	800fb7e <USB_DeactivateEndpoint+0x1a2>
                                   USB_OTG_DIEPCTL_SD0PID_SEVNFRM |
                                   USB_OTG_DIEPCTL_EPTYP);
  }
  else
  {
    if ((USBx_OUTEP(epnum)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 800fabc:	68bb      	ldr	r3, [r7, #8]
 800fabe:	015a      	lsls	r2, r3, #5
 800fac0:	68fb      	ldr	r3, [r7, #12]
 800fac2:	4413      	add	r3, r2
 800fac4:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 800fac8:	681b      	ldr	r3, [r3, #0]
 800faca:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
 800face:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 800fad2:	d11f      	bne.n	800fb14 <USB_DeactivateEndpoint+0x138>
    {
      USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SNAK;
 800fad4:	68bb      	ldr	r3, [r7, #8]
 800fad6:	015a      	lsls	r2, r3, #5
 800fad8:	68fb      	ldr	r3, [r7, #12]
 800fada:	4413      	add	r3, r2
 800fadc:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 800fae0:	681b      	ldr	r3, [r3, #0]
 800fae2:	68ba      	ldr	r2, [r7, #8]
 800fae4:	0151      	lsls	r1, r2, #5
 800fae6:	68fa      	ldr	r2, [r7, #12]
 800fae8:	440a      	add	r2, r1
 800faea:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 800faee:	f043 6300 	orr.w	r3, r3, #134217728	@ 0x8000000
 800faf2:	6013      	str	r3, [r2, #0]
      USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_EPDIS;
 800faf4:	68bb      	ldr	r3, [r7, #8]
 800faf6:	015a      	lsls	r2, r3, #5
 800faf8:	68fb      	ldr	r3, [r7, #12]
 800fafa:	4413      	add	r3, r2
 800fafc:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 800fb00:	681b      	ldr	r3, [r3, #0]
 800fb02:	68ba      	ldr	r2, [r7, #8]
 800fb04:	0151      	lsls	r1, r2, #5
 800fb06:	68fa      	ldr	r2, [r7, #12]
 800fb08:	440a      	add	r2, r1
 800fb0a:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 800fb0e:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
 800fb12:	6013      	str	r3, [r2, #0]
    }

    USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16));
 800fb14:	68fb      	ldr	r3, [r7, #12]
 800fb16:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 800fb1a:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 800fb1c:	683b      	ldr	r3, [r7, #0]
 800fb1e:	781b      	ldrb	r3, [r3, #0]
 800fb20:	f003 030f 	and.w	r3, r3, #15
 800fb24:	2101      	movs	r1, #1
 800fb26:	fa01 f303 	lsl.w	r3, r1, r3
 800fb2a:	041b      	lsls	r3, r3, #16
 800fb2c:	43db      	mvns	r3, r3
 800fb2e:	68f9      	ldr	r1, [r7, #12]
 800fb30:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
 800fb34:	4013      	ands	r3, r2
 800fb36:	63cb      	str	r3, [r1, #60]	@ 0x3c
    USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16));
 800fb38:	68fb      	ldr	r3, [r7, #12]
 800fb3a:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 800fb3e:	69da      	ldr	r2, [r3, #28]
 800fb40:	683b      	ldr	r3, [r7, #0]
 800fb42:	781b      	ldrb	r3, [r3, #0]
 800fb44:	f003 030f 	and.w	r3, r3, #15
 800fb48:	2101      	movs	r1, #1
 800fb4a:	fa01 f303 	lsl.w	r3, r1, r3
 800fb4e:	041b      	lsls	r3, r3, #16
 800fb50:	43db      	mvns	r3, r3
 800fb52:	68f9      	ldr	r1, [r7, #12]
 800fb54:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
 800fb58:	4013      	ands	r3, r2
 800fb5a:	61cb      	str	r3, [r1, #28]
    USBx_OUTEP(epnum)->DOEPCTL &= ~(USB_OTG_DOEPCTL_USBAEP |
 800fb5c:	68bb      	ldr	r3, [r7, #8]
 800fb5e:	015a      	lsls	r2, r3, #5
 800fb60:	68fb      	ldr	r3, [r7, #12]
 800fb62:	4413      	add	r3, r2
 800fb64:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 800fb68:	681a      	ldr	r2, [r3, #0]
 800fb6a:	68bb      	ldr	r3, [r7, #8]
 800fb6c:	0159      	lsls	r1, r3, #5
 800fb6e:	68fb      	ldr	r3, [r7, #12]
 800fb70:	440b      	add	r3, r1
 800fb72:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 800fb76:	4619      	mov	r1, r3
 800fb78:	4b05      	ldr	r3, [pc, #20]	@ (800fb90 <USB_DeactivateEndpoint+0x1b4>)
 800fb7a:	4013      	ands	r3, r2
 800fb7c:	600b      	str	r3, [r1, #0]
                                    USB_OTG_DOEPCTL_MPSIZ |
                                    USB_OTG_DOEPCTL_SD0PID_SEVNFRM |
                                    USB_OTG_DOEPCTL_EPTYP);
  }

  return HAL_OK;
 800fb7e:	2300      	movs	r3, #0
}
 800fb80:	4618      	mov	r0, r3
 800fb82:	3714      	adds	r7, #20
 800fb84:	46bd      	mov	sp, r7
 800fb86:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fb8a:	4770      	bx	lr
 800fb8c:	ec337800 	.word	0xec337800
 800fb90:	eff37800 	.word	0xeff37800

0800fb94 <USB_EPStartXfer>:
  *           0 : DMA feature not used
  *           1 : DMA feature used
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPStartXfer(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep, uint8_t dma)
{
 800fb94:	b580      	push	{r7, lr}
 800fb96:	b08a      	sub	sp, #40	@ 0x28
 800fb98:	af02      	add	r7, sp, #8
 800fb9a:	60f8      	str	r0, [r7, #12]
 800fb9c:	60b9      	str	r1, [r7, #8]
 800fb9e:	4613      	mov	r3, r2
 800fba0:	71fb      	strb	r3, [r7, #7]
  uint32_t USBx_BASE = (uint32_t)USBx;
 800fba2:	68fb      	ldr	r3, [r7, #12]
 800fba4:	61fb      	str	r3, [r7, #28]
  uint32_t epnum = (uint32_t)ep->num;
 800fba6:	68bb      	ldr	r3, [r7, #8]
 800fba8:	781b      	ldrb	r3, [r3, #0]
 800fbaa:	61bb      	str	r3, [r7, #24]
  uint16_t pktcnt;

  /* IN endpoint */
  if (ep->is_in == 1U)
 800fbac:	68bb      	ldr	r3, [r7, #8]
 800fbae:	785b      	ldrb	r3, [r3, #1]
 800fbb0:	2b01      	cmp	r3, #1
 800fbb2:	f040 8181 	bne.w	800feb8 <USB_EPStartXfer+0x324>
  {
    /* Zero Length Packet? */
    if (ep->xfer_len == 0U)
 800fbb6:	68bb      	ldr	r3, [r7, #8]
 800fbb8:	691b      	ldr	r3, [r3, #16]
 800fbba:	2b00      	cmp	r3, #0
 800fbbc:	d132      	bne.n	800fc24 <USB_EPStartXfer+0x90>
    {
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 800fbbe:	69bb      	ldr	r3, [r7, #24]
 800fbc0:	015a      	lsls	r2, r3, #5
 800fbc2:	69fb      	ldr	r3, [r7, #28]
 800fbc4:	4413      	add	r3, r2
 800fbc6:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 800fbca:	691a      	ldr	r2, [r3, #16]
 800fbcc:	69bb      	ldr	r3, [r7, #24]
 800fbce:	0159      	lsls	r1, r3, #5
 800fbd0:	69fb      	ldr	r3, [r7, #28]
 800fbd2:	440b      	add	r3, r1
 800fbd4:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 800fbd8:	4619      	mov	r1, r3
 800fbda:	4ba5      	ldr	r3, [pc, #660]	@ (800fe70 <USB_EPStartXfer+0x2dc>)
 800fbdc:	4013      	ands	r3, r2
 800fbde:	610b      	str	r3, [r1, #16]
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19));
 800fbe0:	69bb      	ldr	r3, [r7, #24]
 800fbe2:	015a      	lsls	r2, r3, #5
 800fbe4:	69fb      	ldr	r3, [r7, #28]
 800fbe6:	4413      	add	r3, r2
 800fbe8:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 800fbec:	691b      	ldr	r3, [r3, #16]
 800fbee:	69ba      	ldr	r2, [r7, #24]
 800fbf0:	0151      	lsls	r1, r2, #5
 800fbf2:	69fa      	ldr	r2, [r7, #28]
 800fbf4:	440a      	add	r2, r1
 800fbf6:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 800fbfa:	f443 2300 	orr.w	r3, r3, #524288	@ 0x80000
 800fbfe:	6113      	str	r3, [r2, #16]
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 800fc00:	69bb      	ldr	r3, [r7, #24]
 800fc02:	015a      	lsls	r2, r3, #5
 800fc04:	69fb      	ldr	r3, [r7, #28]
 800fc06:	4413      	add	r3, r2
 800fc08:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 800fc0c:	691a      	ldr	r2, [r3, #16]
 800fc0e:	69bb      	ldr	r3, [r7, #24]
 800fc10:	0159      	lsls	r1, r3, #5
 800fc12:	69fb      	ldr	r3, [r7, #28]
 800fc14:	440b      	add	r3, r1
 800fc16:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 800fc1a:	4619      	mov	r1, r3
 800fc1c:	4b95      	ldr	r3, [pc, #596]	@ (800fe74 <USB_EPStartXfer+0x2e0>)
 800fc1e:	4013      	ands	r3, r2
 800fc20:	610b      	str	r3, [r1, #16]
 800fc22:	e092      	b.n	800fd4a <USB_EPStartXfer+0x1b6>
      /* Program the transfer size and packet count
      * as follows: xfersize = N * maxpacket +
      * short_packet pktcnt = N + (short_packet
      * exist ? 1 : 0)
      */
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 800fc24:	69bb      	ldr	r3, [r7, #24]
 800fc26:	015a      	lsls	r2, r3, #5
 800fc28:	69fb      	ldr	r3, [r7, #28]
 800fc2a:	4413      	add	r3, r2
 800fc2c:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 800fc30:	691a      	ldr	r2, [r3, #16]
 800fc32:	69bb      	ldr	r3, [r7, #24]
 800fc34:	0159      	lsls	r1, r3, #5
 800fc36:	69fb      	ldr	r3, [r7, #28]
 800fc38:	440b      	add	r3, r1
 800fc3a:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 800fc3e:	4619      	mov	r1, r3
 800fc40:	4b8c      	ldr	r3, [pc, #560]	@ (800fe74 <USB_EPStartXfer+0x2e0>)
 800fc42:	4013      	ands	r3, r2
 800fc44:	610b      	str	r3, [r1, #16]
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 800fc46:	69bb      	ldr	r3, [r7, #24]
 800fc48:	015a      	lsls	r2, r3, #5
 800fc4a:	69fb      	ldr	r3, [r7, #28]
 800fc4c:	4413      	add	r3, r2
 800fc4e:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 800fc52:	691a      	ldr	r2, [r3, #16]
 800fc54:	69bb      	ldr	r3, [r7, #24]
 800fc56:	0159      	lsls	r1, r3, #5
 800fc58:	69fb      	ldr	r3, [r7, #28]
 800fc5a:	440b      	add	r3, r1
 800fc5c:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 800fc60:	4619      	mov	r1, r3
 800fc62:	4b83      	ldr	r3, [pc, #524]	@ (800fe70 <USB_EPStartXfer+0x2dc>)
 800fc64:	4013      	ands	r3, r2
 800fc66:	610b      	str	r3, [r1, #16]

      if (epnum == 0U)
 800fc68:	69bb      	ldr	r3, [r7, #24]
 800fc6a:	2b00      	cmp	r3, #0
 800fc6c:	d11a      	bne.n	800fca4 <USB_EPStartXfer+0x110>
      {
        if (ep->xfer_len > ep->maxpacket)
 800fc6e:	68bb      	ldr	r3, [r7, #8]
 800fc70:	691a      	ldr	r2, [r3, #16]
 800fc72:	68bb      	ldr	r3, [r7, #8]
 800fc74:	689b      	ldr	r3, [r3, #8]
 800fc76:	429a      	cmp	r2, r3
 800fc78:	d903      	bls.n	800fc82 <USB_EPStartXfer+0xee>
        {
          ep->xfer_len = ep->maxpacket;
 800fc7a:	68bb      	ldr	r3, [r7, #8]
 800fc7c:	689a      	ldr	r2, [r3, #8]
 800fc7e:	68bb      	ldr	r3, [r7, #8]
 800fc80:	611a      	str	r2, [r3, #16]
        }

        USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19));
 800fc82:	69bb      	ldr	r3, [r7, #24]
 800fc84:	015a      	lsls	r2, r3, #5
 800fc86:	69fb      	ldr	r3, [r7, #28]
 800fc88:	4413      	add	r3, r2
 800fc8a:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 800fc8e:	691b      	ldr	r3, [r3, #16]
 800fc90:	69ba      	ldr	r2, [r7, #24]
 800fc92:	0151      	lsls	r1, r2, #5
 800fc94:	69fa      	ldr	r2, [r7, #28]
 800fc96:	440a      	add	r2, r1
 800fc98:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 800fc9c:	f443 2300 	orr.w	r3, r3, #524288	@ 0x80000
 800fca0:	6113      	str	r3, [r2, #16]
 800fca2:	e01b      	b.n	800fcdc <USB_EPStartXfer+0x148>
      }
      else
      {
        USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT &
 800fca4:	69bb      	ldr	r3, [r7, #24]
 800fca6:	015a      	lsls	r2, r3, #5
 800fca8:	69fb      	ldr	r3, [r7, #28]
 800fcaa:	4413      	add	r3, r2
 800fcac:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 800fcb0:	691a      	ldr	r2, [r3, #16]
                                       (((ep->xfer_len + ep->maxpacket - 1U) / ep->maxpacket) << 19));
 800fcb2:	68bb      	ldr	r3, [r7, #8]
 800fcb4:	6919      	ldr	r1, [r3, #16]
 800fcb6:	68bb      	ldr	r3, [r7, #8]
 800fcb8:	689b      	ldr	r3, [r3, #8]
 800fcba:	440b      	add	r3, r1
 800fcbc:	1e59      	subs	r1, r3, #1
 800fcbe:	68bb      	ldr	r3, [r7, #8]
 800fcc0:	689b      	ldr	r3, [r3, #8]
 800fcc2:	fbb1 f3f3 	udiv	r3, r1, r3
 800fcc6:	04d9      	lsls	r1, r3, #19
        USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT &
 800fcc8:	4b6b      	ldr	r3, [pc, #428]	@ (800fe78 <USB_EPStartXfer+0x2e4>)
 800fcca:	400b      	ands	r3, r1
 800fccc:	69b9      	ldr	r1, [r7, #24]
 800fcce:	0148      	lsls	r0, r1, #5
 800fcd0:	69f9      	ldr	r1, [r7, #28]
 800fcd2:	4401      	add	r1, r0
 800fcd4:	f501 6110 	add.w	r1, r1, #2304	@ 0x900
 800fcd8:	4313      	orrs	r3, r2
 800fcda:	610b      	str	r3, [r1, #16]
      }

      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len);
 800fcdc:	69bb      	ldr	r3, [r7, #24]
 800fcde:	015a      	lsls	r2, r3, #5
 800fce0:	69fb      	ldr	r3, [r7, #28]
 800fce2:	4413      	add	r3, r2
 800fce4:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 800fce8:	691a      	ldr	r2, [r3, #16]
 800fcea:	68bb      	ldr	r3, [r7, #8]
 800fcec:	691b      	ldr	r3, [r3, #16]
 800fcee:	f3c3 0312 	ubfx	r3, r3, #0, #19
 800fcf2:	69b9      	ldr	r1, [r7, #24]
 800fcf4:	0148      	lsls	r0, r1, #5
 800fcf6:	69f9      	ldr	r1, [r7, #28]
 800fcf8:	4401      	add	r1, r0
 800fcfa:	f501 6110 	add.w	r1, r1, #2304	@ 0x900
 800fcfe:	4313      	orrs	r3, r2
 800fd00:	610b      	str	r3, [r1, #16]

      if (ep->type == EP_TYPE_ISOC)
 800fd02:	68bb      	ldr	r3, [r7, #8]
 800fd04:	791b      	ldrb	r3, [r3, #4]
 800fd06:	2b01      	cmp	r3, #1
 800fd08:	d11f      	bne.n	800fd4a <USB_EPStartXfer+0x1b6>
      {
        USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_MULCNT);
 800fd0a:	69bb      	ldr	r3, [r7, #24]
 800fd0c:	015a      	lsls	r2, r3, #5
 800fd0e:	69fb      	ldr	r3, [r7, #28]
 800fd10:	4413      	add	r3, r2
 800fd12:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 800fd16:	691b      	ldr	r3, [r3, #16]
 800fd18:	69ba      	ldr	r2, [r7, #24]
 800fd1a:	0151      	lsls	r1, r2, #5
 800fd1c:	69fa      	ldr	r2, [r7, #28]
 800fd1e:	440a      	add	r2, r1
 800fd20:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 800fd24:	f023 43c0 	bic.w	r3, r3, #1610612736	@ 0x60000000
 800fd28:	6113      	str	r3, [r2, #16]
        USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_MULCNT & (1U << 29));
 800fd2a:	69bb      	ldr	r3, [r7, #24]
 800fd2c:	015a      	lsls	r2, r3, #5
 800fd2e:	69fb      	ldr	r3, [r7, #28]
 800fd30:	4413      	add	r3, r2
 800fd32:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 800fd36:	691b      	ldr	r3, [r3, #16]
 800fd38:	69ba      	ldr	r2, [r7, #24]
 800fd3a:	0151      	lsls	r1, r2, #5
 800fd3c:	69fa      	ldr	r2, [r7, #28]
 800fd3e:	440a      	add	r2, r1
 800fd40:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 800fd44:	f043 5300 	orr.w	r3, r3, #536870912	@ 0x20000000
 800fd48:	6113      	str	r3, [r2, #16]
      }
    }

    if (dma == 1U)
 800fd4a:	79fb      	ldrb	r3, [r7, #7]
 800fd4c:	2b01      	cmp	r3, #1
 800fd4e:	d14b      	bne.n	800fde8 <USB_EPStartXfer+0x254>
    {
      if ((uint32_t)ep->dma_addr != 0U)
 800fd50:	68bb      	ldr	r3, [r7, #8]
 800fd52:	69db      	ldr	r3, [r3, #28]
 800fd54:	2b00      	cmp	r3, #0
 800fd56:	d009      	beq.n	800fd6c <USB_EPStartXfer+0x1d8>
      {
        USBx_INEP(epnum)->DIEPDMA = (uint32_t)(ep->dma_addr);
 800fd58:	69bb      	ldr	r3, [r7, #24]
 800fd5a:	015a      	lsls	r2, r3, #5
 800fd5c:	69fb      	ldr	r3, [r7, #28]
 800fd5e:	4413      	add	r3, r2
 800fd60:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 800fd64:	461a      	mov	r2, r3
 800fd66:	68bb      	ldr	r3, [r7, #8]
 800fd68:	69db      	ldr	r3, [r3, #28]
 800fd6a:	6153      	str	r3, [r2, #20]
      }

      if (ep->type == EP_TYPE_ISOC)
 800fd6c:	68bb      	ldr	r3, [r7, #8]
 800fd6e:	791b      	ldrb	r3, [r3, #4]
 800fd70:	2b01      	cmp	r3, #1
 800fd72:	d128      	bne.n	800fdc6 <USB_EPStartXfer+0x232>
      {
        if ((USBx_DEVICE->DSTS & (1U << 8)) == 0U)
 800fd74:	69fb      	ldr	r3, [r7, #28]
 800fd76:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 800fd7a:	689b      	ldr	r3, [r3, #8]
 800fd7c:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 800fd80:	2b00      	cmp	r3, #0
 800fd82:	d110      	bne.n	800fda6 <USB_EPStartXfer+0x212>
        {
          USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SODDFRM;
 800fd84:	69bb      	ldr	r3, [r7, #24]
 800fd86:	015a      	lsls	r2, r3, #5
 800fd88:	69fb      	ldr	r3, [r7, #28]
 800fd8a:	4413      	add	r3, r2
 800fd8c:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 800fd90:	681b      	ldr	r3, [r3, #0]
 800fd92:	69ba      	ldr	r2, [r7, #24]
 800fd94:	0151      	lsls	r1, r2, #5
 800fd96:	69fa      	ldr	r2, [r7, #28]
 800fd98:	440a      	add	r2, r1
 800fd9a:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 800fd9e:	f043 5300 	orr.w	r3, r3, #536870912	@ 0x20000000
 800fda2:	6013      	str	r3, [r2, #0]
 800fda4:	e00f      	b.n	800fdc6 <USB_EPStartXfer+0x232>
        }
        else
        {
          USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM;
 800fda6:	69bb      	ldr	r3, [r7, #24]
 800fda8:	015a      	lsls	r2, r3, #5
 800fdaa:	69fb      	ldr	r3, [r7, #28]
 800fdac:	4413      	add	r3, r2
 800fdae:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 800fdb2:	681b      	ldr	r3, [r3, #0]
 800fdb4:	69ba      	ldr	r2, [r7, #24]
 800fdb6:	0151      	lsls	r1, r2, #5
 800fdb8:	69fa      	ldr	r2, [r7, #28]
 800fdba:	440a      	add	r2, r1
 800fdbc:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 800fdc0:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 800fdc4:	6013      	str	r3, [r2, #0]
        }
      }

      /* EP enable, IN data in FIFO */
      USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 800fdc6:	69bb      	ldr	r3, [r7, #24]
 800fdc8:	015a      	lsls	r2, r3, #5
 800fdca:	69fb      	ldr	r3, [r7, #28]
 800fdcc:	4413      	add	r3, r2
 800fdce:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 800fdd2:	681b      	ldr	r3, [r3, #0]
 800fdd4:	69ba      	ldr	r2, [r7, #24]
 800fdd6:	0151      	lsls	r1, r2, #5
 800fdd8:	69fa      	ldr	r2, [r7, #28]
 800fdda:	440a      	add	r2, r1
 800fddc:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 800fde0:	f043 4304 	orr.w	r3, r3, #2214592512	@ 0x84000000
 800fde4:	6013      	str	r3, [r2, #0]
 800fde6:	e16a      	b.n	80100be <USB_EPStartXfer+0x52a>
    }
    else
    {
      /* EP enable, IN data in FIFO */
      USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 800fde8:	69bb      	ldr	r3, [r7, #24]
 800fdea:	015a      	lsls	r2, r3, #5
 800fdec:	69fb      	ldr	r3, [r7, #28]
 800fdee:	4413      	add	r3, r2
 800fdf0:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 800fdf4:	681b      	ldr	r3, [r3, #0]
 800fdf6:	69ba      	ldr	r2, [r7, #24]
 800fdf8:	0151      	lsls	r1, r2, #5
 800fdfa:	69fa      	ldr	r2, [r7, #28]
 800fdfc:	440a      	add	r2, r1
 800fdfe:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 800fe02:	f043 4304 	orr.w	r3, r3, #2214592512	@ 0x84000000
 800fe06:	6013      	str	r3, [r2, #0]

      if (ep->type != EP_TYPE_ISOC)
 800fe08:	68bb      	ldr	r3, [r7, #8]
 800fe0a:	791b      	ldrb	r3, [r3, #4]
 800fe0c:	2b01      	cmp	r3, #1
 800fe0e:	d015      	beq.n	800fe3c <USB_EPStartXfer+0x2a8>
      {
        /* Enable the Tx FIFO Empty Interrupt for this EP */
        if (ep->xfer_len > 0U)
 800fe10:	68bb      	ldr	r3, [r7, #8]
 800fe12:	691b      	ldr	r3, [r3, #16]
 800fe14:	2b00      	cmp	r3, #0
 800fe16:	f000 8152 	beq.w	80100be <USB_EPStartXfer+0x52a>
        {
          USBx_DEVICE->DIEPEMPMSK |= 1UL << (ep->num & EP_ADDR_MSK);
 800fe1a:	69fb      	ldr	r3, [r7, #28]
 800fe1c:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 800fe20:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 800fe22:	68bb      	ldr	r3, [r7, #8]
 800fe24:	781b      	ldrb	r3, [r3, #0]
 800fe26:	f003 030f 	and.w	r3, r3, #15
 800fe2a:	2101      	movs	r1, #1
 800fe2c:	fa01 f303 	lsl.w	r3, r1, r3
 800fe30:	69f9      	ldr	r1, [r7, #28]
 800fe32:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
 800fe36:	4313      	orrs	r3, r2
 800fe38:	634b      	str	r3, [r1, #52]	@ 0x34
 800fe3a:	e140      	b.n	80100be <USB_EPStartXfer+0x52a>
        }
      }
      else
      {
        if ((USBx_DEVICE->DSTS & (1U << 8)) == 0U)
 800fe3c:	69fb      	ldr	r3, [r7, #28]
 800fe3e:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 800fe42:	689b      	ldr	r3, [r3, #8]
 800fe44:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 800fe48:	2b00      	cmp	r3, #0
 800fe4a:	d117      	bne.n	800fe7c <USB_EPStartXfer+0x2e8>
        {
          USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SODDFRM;
 800fe4c:	69bb      	ldr	r3, [r7, #24]
 800fe4e:	015a      	lsls	r2, r3, #5
 800fe50:	69fb      	ldr	r3, [r7, #28]
 800fe52:	4413      	add	r3, r2
 800fe54:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 800fe58:	681b      	ldr	r3, [r3, #0]
 800fe5a:	69ba      	ldr	r2, [r7, #24]
 800fe5c:	0151      	lsls	r1, r2, #5
 800fe5e:	69fa      	ldr	r2, [r7, #28]
 800fe60:	440a      	add	r2, r1
 800fe62:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 800fe66:	f043 5300 	orr.w	r3, r3, #536870912	@ 0x20000000
 800fe6a:	6013      	str	r3, [r2, #0]
 800fe6c:	e016      	b.n	800fe9c <USB_EPStartXfer+0x308>
 800fe6e:	bf00      	nop
 800fe70:	e007ffff 	.word	0xe007ffff
 800fe74:	fff80000 	.word	0xfff80000
 800fe78:	1ff80000 	.word	0x1ff80000
        }
        else
        {
          USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM;
 800fe7c:	69bb      	ldr	r3, [r7, #24]
 800fe7e:	015a      	lsls	r2, r3, #5
 800fe80:	69fb      	ldr	r3, [r7, #28]
 800fe82:	4413      	add	r3, r2
 800fe84:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 800fe88:	681b      	ldr	r3, [r3, #0]
 800fe8a:	69ba      	ldr	r2, [r7, #24]
 800fe8c:	0151      	lsls	r1, r2, #5
 800fe8e:	69fa      	ldr	r2, [r7, #28]
 800fe90:	440a      	add	r2, r1
 800fe92:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 800fe96:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 800fe9a:	6013      	str	r3, [r2, #0]
        }

        (void)USB_WritePacket(USBx, ep->xfer_buff, ep->num, (uint16_t)ep->xfer_len, dma);
 800fe9c:	68bb      	ldr	r3, [r7, #8]
 800fe9e:	68d9      	ldr	r1, [r3, #12]
 800fea0:	68bb      	ldr	r3, [r7, #8]
 800fea2:	781a      	ldrb	r2, [r3, #0]
 800fea4:	68bb      	ldr	r3, [r7, #8]
 800fea6:	691b      	ldr	r3, [r3, #16]
 800fea8:	b298      	uxth	r0, r3
 800feaa:	79fb      	ldrb	r3, [r7, #7]
 800feac:	9300      	str	r3, [sp, #0]
 800feae:	4603      	mov	r3, r0
 800feb0:	68f8      	ldr	r0, [r7, #12]
 800feb2:	f000 f9b9 	bl	8010228 <USB_WritePacket>
 800feb6:	e102      	b.n	80100be <USB_EPStartXfer+0x52a>
  {
    /* Program the transfer size and packet count as follows:
    * pktcnt = N
    * xfersize = N * maxpacket
    */
    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_XFRSIZ);
 800feb8:	69bb      	ldr	r3, [r7, #24]
 800feba:	015a      	lsls	r2, r3, #5
 800febc:	69fb      	ldr	r3, [r7, #28]
 800febe:	4413      	add	r3, r2
 800fec0:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 800fec4:	691a      	ldr	r2, [r3, #16]
 800fec6:	69bb      	ldr	r3, [r7, #24]
 800fec8:	0159      	lsls	r1, r3, #5
 800feca:	69fb      	ldr	r3, [r7, #28]
 800fecc:	440b      	add	r3, r1
 800fece:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 800fed2:	4619      	mov	r1, r3
 800fed4:	4b7c      	ldr	r3, [pc, #496]	@ (80100c8 <USB_EPStartXfer+0x534>)
 800fed6:	4013      	ands	r3, r2
 800fed8:	610b      	str	r3, [r1, #16]
    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_PKTCNT);
 800feda:	69bb      	ldr	r3, [r7, #24]
 800fedc:	015a      	lsls	r2, r3, #5
 800fede:	69fb      	ldr	r3, [r7, #28]
 800fee0:	4413      	add	r3, r2
 800fee2:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 800fee6:	691a      	ldr	r2, [r3, #16]
 800fee8:	69bb      	ldr	r3, [r7, #24]
 800feea:	0159      	lsls	r1, r3, #5
 800feec:	69fb      	ldr	r3, [r7, #28]
 800feee:	440b      	add	r3, r1
 800fef0:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 800fef4:	4619      	mov	r1, r3
 800fef6:	4b75      	ldr	r3, [pc, #468]	@ (80100cc <USB_EPStartXfer+0x538>)
 800fef8:	4013      	ands	r3, r2
 800fefa:	610b      	str	r3, [r1, #16]

    if (epnum == 0U)
 800fefc:	69bb      	ldr	r3, [r7, #24]
 800fefe:	2b00      	cmp	r3, #0
 800ff00:	d12f      	bne.n	800ff62 <USB_EPStartXfer+0x3ce>
    {
      if (ep->xfer_len > 0U)
 800ff02:	68bb      	ldr	r3, [r7, #8]
 800ff04:	691b      	ldr	r3, [r3, #16]
 800ff06:	2b00      	cmp	r3, #0
 800ff08:	d003      	beq.n	800ff12 <USB_EPStartXfer+0x37e>
      {
        ep->xfer_len = ep->maxpacket;
 800ff0a:	68bb      	ldr	r3, [r7, #8]
 800ff0c:	689a      	ldr	r2, [r3, #8]
 800ff0e:	68bb      	ldr	r3, [r7, #8]
 800ff10:	611a      	str	r2, [r3, #16]
      }

      /* Store transfer size, for EP0 this is equal to endpoint max packet size */
      ep->xfer_size = ep->maxpacket;
 800ff12:	68bb      	ldr	r3, [r7, #8]
 800ff14:	689a      	ldr	r2, [r3, #8]
 800ff16:	68bb      	ldr	r3, [r7, #8]
 800ff18:	621a      	str	r2, [r3, #32]

      USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & ep->xfer_size);
 800ff1a:	69bb      	ldr	r3, [r7, #24]
 800ff1c:	015a      	lsls	r2, r3, #5
 800ff1e:	69fb      	ldr	r3, [r7, #28]
 800ff20:	4413      	add	r3, r2
 800ff22:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 800ff26:	691a      	ldr	r2, [r3, #16]
 800ff28:	68bb      	ldr	r3, [r7, #8]
 800ff2a:	6a1b      	ldr	r3, [r3, #32]
 800ff2c:	f3c3 0312 	ubfx	r3, r3, #0, #19
 800ff30:	69b9      	ldr	r1, [r7, #24]
 800ff32:	0148      	lsls	r0, r1, #5
 800ff34:	69f9      	ldr	r1, [r7, #28]
 800ff36:	4401      	add	r1, r0
 800ff38:	f501 6130 	add.w	r1, r1, #2816	@ 0xb00
 800ff3c:	4313      	orrs	r3, r2
 800ff3e:	610b      	str	r3, [r1, #16]
      USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19));
 800ff40:	69bb      	ldr	r3, [r7, #24]
 800ff42:	015a      	lsls	r2, r3, #5
 800ff44:	69fb      	ldr	r3, [r7, #28]
 800ff46:	4413      	add	r3, r2
 800ff48:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 800ff4c:	691b      	ldr	r3, [r3, #16]
 800ff4e:	69ba      	ldr	r2, [r7, #24]
 800ff50:	0151      	lsls	r1, r2, #5
 800ff52:	69fa      	ldr	r2, [r7, #28]
 800ff54:	440a      	add	r2, r1
 800ff56:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 800ff5a:	f443 2300 	orr.w	r3, r3, #524288	@ 0x80000
 800ff5e:	6113      	str	r3, [r2, #16]
 800ff60:	e05f      	b.n	8010022 <USB_EPStartXfer+0x48e>
    }
    else
    {
      if (ep->xfer_len == 0U)
 800ff62:	68bb      	ldr	r3, [r7, #8]
 800ff64:	691b      	ldr	r3, [r3, #16]
 800ff66:	2b00      	cmp	r3, #0
 800ff68:	d123      	bne.n	800ffb2 <USB_EPStartXfer+0x41e>
      {
        USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & ep->maxpacket);
 800ff6a:	69bb      	ldr	r3, [r7, #24]
 800ff6c:	015a      	lsls	r2, r3, #5
 800ff6e:	69fb      	ldr	r3, [r7, #28]
 800ff70:	4413      	add	r3, r2
 800ff72:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 800ff76:	691a      	ldr	r2, [r3, #16]
 800ff78:	68bb      	ldr	r3, [r7, #8]
 800ff7a:	689b      	ldr	r3, [r3, #8]
 800ff7c:	f3c3 0312 	ubfx	r3, r3, #0, #19
 800ff80:	69b9      	ldr	r1, [r7, #24]
 800ff82:	0148      	lsls	r0, r1, #5
 800ff84:	69f9      	ldr	r1, [r7, #28]
 800ff86:	4401      	add	r1, r0
 800ff88:	f501 6130 	add.w	r1, r1, #2816	@ 0xb00
 800ff8c:	4313      	orrs	r3, r2
 800ff8e:	610b      	str	r3, [r1, #16]
        USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19));
 800ff90:	69bb      	ldr	r3, [r7, #24]
 800ff92:	015a      	lsls	r2, r3, #5
 800ff94:	69fb      	ldr	r3, [r7, #28]
 800ff96:	4413      	add	r3, r2
 800ff98:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 800ff9c:	691b      	ldr	r3, [r3, #16]
 800ff9e:	69ba      	ldr	r2, [r7, #24]
 800ffa0:	0151      	lsls	r1, r2, #5
 800ffa2:	69fa      	ldr	r2, [r7, #28]
 800ffa4:	440a      	add	r2, r1
 800ffa6:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 800ffaa:	f443 2300 	orr.w	r3, r3, #524288	@ 0x80000
 800ffae:	6113      	str	r3, [r2, #16]
 800ffb0:	e037      	b.n	8010022 <USB_EPStartXfer+0x48e>
      }
      else
      {
        pktcnt = (uint16_t)((ep->xfer_len + ep->maxpacket - 1U) / ep->maxpacket);
 800ffb2:	68bb      	ldr	r3, [r7, #8]
 800ffb4:	691a      	ldr	r2, [r3, #16]
 800ffb6:	68bb      	ldr	r3, [r7, #8]
 800ffb8:	689b      	ldr	r3, [r3, #8]
 800ffba:	4413      	add	r3, r2
 800ffbc:	1e5a      	subs	r2, r3, #1
 800ffbe:	68bb      	ldr	r3, [r7, #8]
 800ffc0:	689b      	ldr	r3, [r3, #8]
 800ffc2:	fbb2 f3f3 	udiv	r3, r2, r3
 800ffc6:	82fb      	strh	r3, [r7, #22]
        ep->xfer_size = ep->maxpacket * pktcnt;
 800ffc8:	68bb      	ldr	r3, [r7, #8]
 800ffca:	689b      	ldr	r3, [r3, #8]
 800ffcc:	8afa      	ldrh	r2, [r7, #22]
 800ffce:	fb03 f202 	mul.w	r2, r3, r2
 800ffd2:	68bb      	ldr	r3, [r7, #8]
 800ffd4:	621a      	str	r2, [r3, #32]

        USBx_OUTEP(epnum)->DOEPTSIZ |= USB_OTG_DOEPTSIZ_PKTCNT & ((uint32_t)pktcnt << 19);
 800ffd6:	69bb      	ldr	r3, [r7, #24]
 800ffd8:	015a      	lsls	r2, r3, #5
 800ffda:	69fb      	ldr	r3, [r7, #28]
 800ffdc:	4413      	add	r3, r2
 800ffde:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 800ffe2:	691a      	ldr	r2, [r3, #16]
 800ffe4:	8afb      	ldrh	r3, [r7, #22]
 800ffe6:	04d9      	lsls	r1, r3, #19
 800ffe8:	4b39      	ldr	r3, [pc, #228]	@ (80100d0 <USB_EPStartXfer+0x53c>)
 800ffea:	400b      	ands	r3, r1
 800ffec:	69b9      	ldr	r1, [r7, #24]
 800ffee:	0148      	lsls	r0, r1, #5
 800fff0:	69f9      	ldr	r1, [r7, #28]
 800fff2:	4401      	add	r1, r0
 800fff4:	f501 6130 	add.w	r1, r1, #2816	@ 0xb00
 800fff8:	4313      	orrs	r3, r2
 800fffa:	610b      	str	r3, [r1, #16]
        USBx_OUTEP(epnum)->DOEPTSIZ |= USB_OTG_DOEPTSIZ_XFRSIZ & ep->xfer_size;
 800fffc:	69bb      	ldr	r3, [r7, #24]
 800fffe:	015a      	lsls	r2, r3, #5
 8010000:	69fb      	ldr	r3, [r7, #28]
 8010002:	4413      	add	r3, r2
 8010004:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8010008:	691a      	ldr	r2, [r3, #16]
 801000a:	68bb      	ldr	r3, [r7, #8]
 801000c:	6a1b      	ldr	r3, [r3, #32]
 801000e:	f3c3 0312 	ubfx	r3, r3, #0, #19
 8010012:	69b9      	ldr	r1, [r7, #24]
 8010014:	0148      	lsls	r0, r1, #5
 8010016:	69f9      	ldr	r1, [r7, #28]
 8010018:	4401      	add	r1, r0
 801001a:	f501 6130 	add.w	r1, r1, #2816	@ 0xb00
 801001e:	4313      	orrs	r3, r2
 8010020:	610b      	str	r3, [r1, #16]
      }
    }

    if (dma == 1U)
 8010022:	79fb      	ldrb	r3, [r7, #7]
 8010024:	2b01      	cmp	r3, #1
 8010026:	d10d      	bne.n	8010044 <USB_EPStartXfer+0x4b0>
    {
      if ((uint32_t)ep->xfer_buff != 0U)
 8010028:	68bb      	ldr	r3, [r7, #8]
 801002a:	68db      	ldr	r3, [r3, #12]
 801002c:	2b00      	cmp	r3, #0
 801002e:	d009      	beq.n	8010044 <USB_EPStartXfer+0x4b0>
      {
        USBx_OUTEP(epnum)->DOEPDMA = (uint32_t)(ep->xfer_buff);
 8010030:	68bb      	ldr	r3, [r7, #8]
 8010032:	68d9      	ldr	r1, [r3, #12]
 8010034:	69bb      	ldr	r3, [r7, #24]
 8010036:	015a      	lsls	r2, r3, #5
 8010038:	69fb      	ldr	r3, [r7, #28]
 801003a:	4413      	add	r3, r2
 801003c:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8010040:	460a      	mov	r2, r1
 8010042:	615a      	str	r2, [r3, #20]
      }
    }

    if (ep->type == EP_TYPE_ISOC)
 8010044:	68bb      	ldr	r3, [r7, #8]
 8010046:	791b      	ldrb	r3, [r3, #4]
 8010048:	2b01      	cmp	r3, #1
 801004a:	d128      	bne.n	801009e <USB_EPStartXfer+0x50a>
    {
      if ((USBx_DEVICE->DSTS & (1U << 8)) == 0U)
 801004c:	69fb      	ldr	r3, [r7, #28]
 801004e:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8010052:	689b      	ldr	r3, [r3, #8]
 8010054:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8010058:	2b00      	cmp	r3, #0
 801005a:	d110      	bne.n	801007e <USB_EPStartXfer+0x4ea>
      {
        USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SODDFRM;
 801005c:	69bb      	ldr	r3, [r7, #24]
 801005e:	015a      	lsls	r2, r3, #5
 8010060:	69fb      	ldr	r3, [r7, #28]
 8010062:	4413      	add	r3, r2
 8010064:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8010068:	681b      	ldr	r3, [r3, #0]
 801006a:	69ba      	ldr	r2, [r7, #24]
 801006c:	0151      	lsls	r1, r2, #5
 801006e:	69fa      	ldr	r2, [r7, #28]
 8010070:	440a      	add	r2, r1
 8010072:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 8010076:	f043 5300 	orr.w	r3, r3, #536870912	@ 0x20000000
 801007a:	6013      	str	r3, [r2, #0]
 801007c:	e00f      	b.n	801009e <USB_EPStartXfer+0x50a>
      }
      else
      {
        USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM;
 801007e:	69bb      	ldr	r3, [r7, #24]
 8010080:	015a      	lsls	r2, r3, #5
 8010082:	69fb      	ldr	r3, [r7, #28]
 8010084:	4413      	add	r3, r2
 8010086:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 801008a:	681b      	ldr	r3, [r3, #0]
 801008c:	69ba      	ldr	r2, [r7, #24]
 801008e:	0151      	lsls	r1, r2, #5
 8010090:	69fa      	ldr	r2, [r7, #28]
 8010092:	440a      	add	r2, r1
 8010094:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 8010098:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 801009c:	6013      	str	r3, [r2, #0]
      }
    }
    /* EP enable */
    USBx_OUTEP(epnum)->DOEPCTL |= (USB_OTG_DOEPCTL_CNAK | USB_OTG_DOEPCTL_EPENA);
 801009e:	69bb      	ldr	r3, [r7, #24]
 80100a0:	015a      	lsls	r2, r3, #5
 80100a2:	69fb      	ldr	r3, [r7, #28]
 80100a4:	4413      	add	r3, r2
 80100a6:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 80100aa:	681b      	ldr	r3, [r3, #0]
 80100ac:	69ba      	ldr	r2, [r7, #24]
 80100ae:	0151      	lsls	r1, r2, #5
 80100b0:	69fa      	ldr	r2, [r7, #28]
 80100b2:	440a      	add	r2, r1
 80100b4:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 80100b8:	f043 4304 	orr.w	r3, r3, #2214592512	@ 0x84000000
 80100bc:	6013      	str	r3, [r2, #0]
  }

  return HAL_OK;
 80100be:	2300      	movs	r3, #0
}
 80100c0:	4618      	mov	r0, r3
 80100c2:	3720      	adds	r7, #32
 80100c4:	46bd      	mov	sp, r7
 80100c6:	bd80      	pop	{r7, pc}
 80100c8:	fff80000 	.word	0xfff80000
 80100cc:	e007ffff 	.word	0xe007ffff
 80100d0:	1ff80000 	.word	0x1ff80000

080100d4 <USB_EPStopXfer>:
   * @param  USBx  usb device instance
   * @param  ep pointer to endpoint structure
   * @retval HAL status
   */
HAL_StatusTypeDef USB_EPStopXfer(const USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
{
 80100d4:	b480      	push	{r7}
 80100d6:	b087      	sub	sp, #28
 80100d8:	af00      	add	r7, sp, #0
 80100da:	6078      	str	r0, [r7, #4]
 80100dc:	6039      	str	r1, [r7, #0]
  __IO uint32_t count = 0U;
 80100de:	2300      	movs	r3, #0
 80100e0:	60fb      	str	r3, [r7, #12]
  HAL_StatusTypeDef ret = HAL_OK;
 80100e2:	2300      	movs	r3, #0
 80100e4:	75fb      	strb	r3, [r7, #23]
  uint32_t USBx_BASE = (uint32_t)USBx;
 80100e6:	687b      	ldr	r3, [r7, #4]
 80100e8:	613b      	str	r3, [r7, #16]

  /* IN endpoint */
  if (ep->is_in == 1U)
 80100ea:	683b      	ldr	r3, [r7, #0]
 80100ec:	785b      	ldrb	r3, [r3, #1]
 80100ee:	2b01      	cmp	r3, #1
 80100f0:	d14a      	bne.n	8010188 <USB_EPStopXfer+0xb4>
  {
    /* EP enable, IN data in FIFO */
    if (((USBx_INEP(ep->num)->DIEPCTL) & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
 80100f2:	683b      	ldr	r3, [r7, #0]
 80100f4:	781b      	ldrb	r3, [r3, #0]
 80100f6:	015a      	lsls	r2, r3, #5
 80100f8:	693b      	ldr	r3, [r7, #16]
 80100fa:	4413      	add	r3, r2
 80100fc:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8010100:	681b      	ldr	r3, [r3, #0]
 8010102:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
 8010106:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 801010a:	f040 8086 	bne.w	801021a <USB_EPStopXfer+0x146>
    {
      USBx_INEP(ep->num)->DIEPCTL |= (USB_OTG_DIEPCTL_SNAK);
 801010e:	683b      	ldr	r3, [r7, #0]
 8010110:	781b      	ldrb	r3, [r3, #0]
 8010112:	015a      	lsls	r2, r3, #5
 8010114:	693b      	ldr	r3, [r7, #16]
 8010116:	4413      	add	r3, r2
 8010118:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 801011c:	681b      	ldr	r3, [r3, #0]
 801011e:	683a      	ldr	r2, [r7, #0]
 8010120:	7812      	ldrb	r2, [r2, #0]
 8010122:	0151      	lsls	r1, r2, #5
 8010124:	693a      	ldr	r2, [r7, #16]
 8010126:	440a      	add	r2, r1
 8010128:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 801012c:	f043 6300 	orr.w	r3, r3, #134217728	@ 0x8000000
 8010130:	6013      	str	r3, [r2, #0]
      USBx_INEP(ep->num)->DIEPCTL |= (USB_OTG_DIEPCTL_EPDIS);
 8010132:	683b      	ldr	r3, [r7, #0]
 8010134:	781b      	ldrb	r3, [r3, #0]
 8010136:	015a      	lsls	r2, r3, #5
 8010138:	693b      	ldr	r3, [r7, #16]
 801013a:	4413      	add	r3, r2
 801013c:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8010140:	681b      	ldr	r3, [r3, #0]
 8010142:	683a      	ldr	r2, [r7, #0]
 8010144:	7812      	ldrb	r2, [r2, #0]
 8010146:	0151      	lsls	r1, r2, #5
 8010148:	693a      	ldr	r2, [r7, #16]
 801014a:	440a      	add	r2, r1
 801014c:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 8010150:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
 8010154:	6013      	str	r3, [r2, #0]

      do
      {
        count++;
 8010156:	68fb      	ldr	r3, [r7, #12]
 8010158:	3301      	adds	r3, #1
 801015a:	60fb      	str	r3, [r7, #12]

        if (count > 10000U)
 801015c:	68fb      	ldr	r3, [r7, #12]
 801015e:	f242 7210 	movw	r2, #10000	@ 0x2710
 8010162:	4293      	cmp	r3, r2
 8010164:	d902      	bls.n	801016c <USB_EPStopXfer+0x98>
        {
          ret = HAL_ERROR;
 8010166:	2301      	movs	r3, #1
 8010168:	75fb      	strb	r3, [r7, #23]
          break;
 801016a:	e056      	b.n	801021a <USB_EPStopXfer+0x146>
        }
      } while (((USBx_INEP(ep->num)->DIEPCTL) & USB_OTG_DIEPCTL_EPENA) ==  USB_OTG_DIEPCTL_EPENA);
 801016c:	683b      	ldr	r3, [r7, #0]
 801016e:	781b      	ldrb	r3, [r3, #0]
 8010170:	015a      	lsls	r2, r3, #5
 8010172:	693b      	ldr	r3, [r7, #16]
 8010174:	4413      	add	r3, r2
 8010176:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 801017a:	681b      	ldr	r3, [r3, #0]
 801017c:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
 8010180:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 8010184:	d0e7      	beq.n	8010156 <USB_EPStopXfer+0x82>
 8010186:	e048      	b.n	801021a <USB_EPStopXfer+0x146>
    }
  }
  else /* OUT endpoint */
  {
    if (((USBx_OUTEP(ep->num)->DOEPCTL) & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 8010188:	683b      	ldr	r3, [r7, #0]
 801018a:	781b      	ldrb	r3, [r3, #0]
 801018c:	015a      	lsls	r2, r3, #5
 801018e:	693b      	ldr	r3, [r7, #16]
 8010190:	4413      	add	r3, r2
 8010192:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8010196:	681b      	ldr	r3, [r3, #0]
 8010198:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
 801019c:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 80101a0:	d13b      	bne.n	801021a <USB_EPStopXfer+0x146>
    {
      USBx_OUTEP(ep->num)->DOEPCTL |= (USB_OTG_DOEPCTL_SNAK);
 80101a2:	683b      	ldr	r3, [r7, #0]
 80101a4:	781b      	ldrb	r3, [r3, #0]
 80101a6:	015a      	lsls	r2, r3, #5
 80101a8:	693b      	ldr	r3, [r7, #16]
 80101aa:	4413      	add	r3, r2
 80101ac:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 80101b0:	681b      	ldr	r3, [r3, #0]
 80101b2:	683a      	ldr	r2, [r7, #0]
 80101b4:	7812      	ldrb	r2, [r2, #0]
 80101b6:	0151      	lsls	r1, r2, #5
 80101b8:	693a      	ldr	r2, [r7, #16]
 80101ba:	440a      	add	r2, r1
 80101bc:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 80101c0:	f043 6300 	orr.w	r3, r3, #134217728	@ 0x8000000
 80101c4:	6013      	str	r3, [r2, #0]
      USBx_OUTEP(ep->num)->DOEPCTL |= (USB_OTG_DOEPCTL_EPDIS);
 80101c6:	683b      	ldr	r3, [r7, #0]
 80101c8:	781b      	ldrb	r3, [r3, #0]
 80101ca:	015a      	lsls	r2, r3, #5
 80101cc:	693b      	ldr	r3, [r7, #16]
 80101ce:	4413      	add	r3, r2
 80101d0:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 80101d4:	681b      	ldr	r3, [r3, #0]
 80101d6:	683a      	ldr	r2, [r7, #0]
 80101d8:	7812      	ldrb	r2, [r2, #0]
 80101da:	0151      	lsls	r1, r2, #5
 80101dc:	693a      	ldr	r2, [r7, #16]
 80101de:	440a      	add	r2, r1
 80101e0:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 80101e4:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
 80101e8:	6013      	str	r3, [r2, #0]

      do
      {
        count++;
 80101ea:	68fb      	ldr	r3, [r7, #12]
 80101ec:	3301      	adds	r3, #1
 80101ee:	60fb      	str	r3, [r7, #12]

        if (count > 10000U)
 80101f0:	68fb      	ldr	r3, [r7, #12]
 80101f2:	f242 7210 	movw	r2, #10000	@ 0x2710
 80101f6:	4293      	cmp	r3, r2
 80101f8:	d902      	bls.n	8010200 <USB_EPStopXfer+0x12c>
        {
          ret = HAL_ERROR;
 80101fa:	2301      	movs	r3, #1
 80101fc:	75fb      	strb	r3, [r7, #23]
          break;
 80101fe:	e00c      	b.n	801021a <USB_EPStopXfer+0x146>
        }
      } while (((USBx_OUTEP(ep->num)->DOEPCTL) & USB_OTG_DOEPCTL_EPENA) ==  USB_OTG_DOEPCTL_EPENA);
 8010200:	683b      	ldr	r3, [r7, #0]
 8010202:	781b      	ldrb	r3, [r3, #0]
 8010204:	015a      	lsls	r2, r3, #5
 8010206:	693b      	ldr	r3, [r7, #16]
 8010208:	4413      	add	r3, r2
 801020a:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 801020e:	681b      	ldr	r3, [r3, #0]
 8010210:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
 8010214:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 8010218:	d0e7      	beq.n	80101ea <USB_EPStopXfer+0x116>
    }
  }

  return ret;
 801021a:	7dfb      	ldrb	r3, [r7, #23]
}
 801021c:	4618      	mov	r0, r3
 801021e:	371c      	adds	r7, #28
 8010220:	46bd      	mov	sp, r7
 8010222:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010226:	4770      	bx	lr

08010228 <USB_WritePacket>:
  *           1 : DMA feature used
  * @retval HAL status
  */
HAL_StatusTypeDef USB_WritePacket(const USB_OTG_GlobalTypeDef *USBx, uint8_t *src,
                                  uint8_t ch_ep_num, uint16_t len, uint8_t dma)
{
 8010228:	b480      	push	{r7}
 801022a:	b089      	sub	sp, #36	@ 0x24
 801022c:	af00      	add	r7, sp, #0
 801022e:	60f8      	str	r0, [r7, #12]
 8010230:	60b9      	str	r1, [r7, #8]
 8010232:	4611      	mov	r1, r2
 8010234:	461a      	mov	r2, r3
 8010236:	460b      	mov	r3, r1
 8010238:	71fb      	strb	r3, [r7, #7]
 801023a:	4613      	mov	r3, r2
 801023c:	80bb      	strh	r3, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
 801023e:	68fb      	ldr	r3, [r7, #12]
 8010240:	617b      	str	r3, [r7, #20]
  uint8_t *pSrc = src;
 8010242:	68bb      	ldr	r3, [r7, #8]
 8010244:	61fb      	str	r3, [r7, #28]
  uint32_t count32b;
  uint32_t i;

  if (dma == 0U)
 8010246:	f897 3028 	ldrb.w	r3, [r7, #40]	@ 0x28
 801024a:	2b00      	cmp	r3, #0
 801024c:	d123      	bne.n	8010296 <USB_WritePacket+0x6e>
  {
    count32b = ((uint32_t)len + 3U) / 4U;
 801024e:	88bb      	ldrh	r3, [r7, #4]
 8010250:	3303      	adds	r3, #3
 8010252:	089b      	lsrs	r3, r3, #2
 8010254:	613b      	str	r3, [r7, #16]
    for (i = 0U; i < count32b; i++)
 8010256:	2300      	movs	r3, #0
 8010258:	61bb      	str	r3, [r7, #24]
 801025a:	e018      	b.n	801028e <USB_WritePacket+0x66>
    {
      USBx_DFIFO((uint32_t)ch_ep_num) = __UNALIGNED_UINT32_READ(pSrc);
 801025c:	79fb      	ldrb	r3, [r7, #7]
 801025e:	031a      	lsls	r2, r3, #12
 8010260:	697b      	ldr	r3, [r7, #20]
 8010262:	4413      	add	r3, r2
 8010264:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8010268:	461a      	mov	r2, r3
 801026a:	69fb      	ldr	r3, [r7, #28]
 801026c:	681b      	ldr	r3, [r3, #0]
 801026e:	6013      	str	r3, [r2, #0]
      pSrc++;
 8010270:	69fb      	ldr	r3, [r7, #28]
 8010272:	3301      	adds	r3, #1
 8010274:	61fb      	str	r3, [r7, #28]
      pSrc++;
 8010276:	69fb      	ldr	r3, [r7, #28]
 8010278:	3301      	adds	r3, #1
 801027a:	61fb      	str	r3, [r7, #28]
      pSrc++;
 801027c:	69fb      	ldr	r3, [r7, #28]
 801027e:	3301      	adds	r3, #1
 8010280:	61fb      	str	r3, [r7, #28]
      pSrc++;
 8010282:	69fb      	ldr	r3, [r7, #28]
 8010284:	3301      	adds	r3, #1
 8010286:	61fb      	str	r3, [r7, #28]
    for (i = 0U; i < count32b; i++)
 8010288:	69bb      	ldr	r3, [r7, #24]
 801028a:	3301      	adds	r3, #1
 801028c:	61bb      	str	r3, [r7, #24]
 801028e:	69ba      	ldr	r2, [r7, #24]
 8010290:	693b      	ldr	r3, [r7, #16]
 8010292:	429a      	cmp	r2, r3
 8010294:	d3e2      	bcc.n	801025c <USB_WritePacket+0x34>
    }
  }

  return HAL_OK;
 8010296:	2300      	movs	r3, #0
}
 8010298:	4618      	mov	r0, r3
 801029a:	3724      	adds	r7, #36	@ 0x24
 801029c:	46bd      	mov	sp, r7
 801029e:	f85d 7b04 	ldr.w	r7, [sp], #4
 80102a2:	4770      	bx	lr

080102a4 <USB_ReadPacket>:
  * @param  dest  source pointer
  * @param  len  Number of bytes to read
  * @retval pointer to destination buffer
  */
void *USB_ReadPacket(const USB_OTG_GlobalTypeDef *USBx, uint8_t *dest, uint16_t len)
{
 80102a4:	b480      	push	{r7}
 80102a6:	b08b      	sub	sp, #44	@ 0x2c
 80102a8:	af00      	add	r7, sp, #0
 80102aa:	60f8      	str	r0, [r7, #12]
 80102ac:	60b9      	str	r1, [r7, #8]
 80102ae:	4613      	mov	r3, r2
 80102b0:	80fb      	strh	r3, [r7, #6]
  uint32_t USBx_BASE = (uint32_t)USBx;
 80102b2:	68fb      	ldr	r3, [r7, #12]
 80102b4:	61bb      	str	r3, [r7, #24]
  uint8_t *pDest = dest;
 80102b6:	68bb      	ldr	r3, [r7, #8]
 80102b8:	627b      	str	r3, [r7, #36]	@ 0x24
  uint32_t pData;
  uint32_t i;
  uint32_t count32b = (uint32_t)len >> 2U;
 80102ba:	88fb      	ldrh	r3, [r7, #6]
 80102bc:	089b      	lsrs	r3, r3, #2
 80102be:	b29b      	uxth	r3, r3
 80102c0:	617b      	str	r3, [r7, #20]
  uint16_t remaining_bytes = len % 4U;
 80102c2:	88fb      	ldrh	r3, [r7, #6]
 80102c4:	f003 0303 	and.w	r3, r3, #3
 80102c8:	83fb      	strh	r3, [r7, #30]

  for (i = 0U; i < count32b; i++)
 80102ca:	2300      	movs	r3, #0
 80102cc:	623b      	str	r3, [r7, #32]
 80102ce:	e014      	b.n	80102fa <USB_ReadPacket+0x56>
  {
    __UNALIGNED_UINT32_WRITE(pDest, USBx_DFIFO(0U));
 80102d0:	69bb      	ldr	r3, [r7, #24]
 80102d2:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 80102d6:	681a      	ldr	r2, [r3, #0]
 80102d8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80102da:	601a      	str	r2, [r3, #0]
    pDest++;
 80102dc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80102de:	3301      	adds	r3, #1
 80102e0:	627b      	str	r3, [r7, #36]	@ 0x24
    pDest++;
 80102e2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80102e4:	3301      	adds	r3, #1
 80102e6:	627b      	str	r3, [r7, #36]	@ 0x24
    pDest++;
 80102e8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80102ea:	3301      	adds	r3, #1
 80102ec:	627b      	str	r3, [r7, #36]	@ 0x24
    pDest++;
 80102ee:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80102f0:	3301      	adds	r3, #1
 80102f2:	627b      	str	r3, [r7, #36]	@ 0x24
  for (i = 0U; i < count32b; i++)
 80102f4:	6a3b      	ldr	r3, [r7, #32]
 80102f6:	3301      	adds	r3, #1
 80102f8:	623b      	str	r3, [r7, #32]
 80102fa:	6a3a      	ldr	r2, [r7, #32]
 80102fc:	697b      	ldr	r3, [r7, #20]
 80102fe:	429a      	cmp	r2, r3
 8010300:	d3e6      	bcc.n	80102d0 <USB_ReadPacket+0x2c>
  }

  /* When Number of data is not word aligned, read the remaining byte */
  if (remaining_bytes != 0U)
 8010302:	8bfb      	ldrh	r3, [r7, #30]
 8010304:	2b00      	cmp	r3, #0
 8010306:	d01e      	beq.n	8010346 <USB_ReadPacket+0xa2>
  {
    i = 0U;
 8010308:	2300      	movs	r3, #0
 801030a:	623b      	str	r3, [r7, #32]
    __UNALIGNED_UINT32_WRITE(&pData, USBx_DFIFO(0U));
 801030c:	69bb      	ldr	r3, [r7, #24]
 801030e:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8010312:	461a      	mov	r2, r3
 8010314:	f107 0310 	add.w	r3, r7, #16
 8010318:	6812      	ldr	r2, [r2, #0]
 801031a:	601a      	str	r2, [r3, #0]

    do
    {
      *(uint8_t *)pDest = (uint8_t)(pData >> (8U * (uint8_t)(i)));
 801031c:	693a      	ldr	r2, [r7, #16]
 801031e:	6a3b      	ldr	r3, [r7, #32]
 8010320:	b2db      	uxtb	r3, r3
 8010322:	00db      	lsls	r3, r3, #3
 8010324:	fa22 f303 	lsr.w	r3, r2, r3
 8010328:	b2da      	uxtb	r2, r3
 801032a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801032c:	701a      	strb	r2, [r3, #0]
      i++;
 801032e:	6a3b      	ldr	r3, [r7, #32]
 8010330:	3301      	adds	r3, #1
 8010332:	623b      	str	r3, [r7, #32]
      pDest++;
 8010334:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010336:	3301      	adds	r3, #1
 8010338:	627b      	str	r3, [r7, #36]	@ 0x24
      remaining_bytes--;
 801033a:	8bfb      	ldrh	r3, [r7, #30]
 801033c:	3b01      	subs	r3, #1
 801033e:	83fb      	strh	r3, [r7, #30]
    } while (remaining_bytes != 0U);
 8010340:	8bfb      	ldrh	r3, [r7, #30]
 8010342:	2b00      	cmp	r3, #0
 8010344:	d1ea      	bne.n	801031c <USB_ReadPacket+0x78>
  }

  return ((void *)pDest);
 8010346:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
}
 8010348:	4618      	mov	r0, r3
 801034a:	372c      	adds	r7, #44	@ 0x2c
 801034c:	46bd      	mov	sp, r7
 801034e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010352:	4770      	bx	lr

08010354 <USB_EPSetStall>:
  * @param  USBx  Selected device
  * @param  ep pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPSetStall(const USB_OTG_GlobalTypeDef *USBx, const USB_OTG_EPTypeDef *ep)
{
 8010354:	b480      	push	{r7}
 8010356:	b085      	sub	sp, #20
 8010358:	af00      	add	r7, sp, #0
 801035a:	6078      	str	r0, [r7, #4]
 801035c:	6039      	str	r1, [r7, #0]
  uint32_t USBx_BASE = (uint32_t)USBx;
 801035e:	687b      	ldr	r3, [r7, #4]
 8010360:	60fb      	str	r3, [r7, #12]
  uint32_t epnum = (uint32_t)ep->num;
 8010362:	683b      	ldr	r3, [r7, #0]
 8010364:	781b      	ldrb	r3, [r3, #0]
 8010366:	60bb      	str	r3, [r7, #8]

  if (ep->is_in == 1U)
 8010368:	683b      	ldr	r3, [r7, #0]
 801036a:	785b      	ldrb	r3, [r3, #1]
 801036c:	2b01      	cmp	r3, #1
 801036e:	d12c      	bne.n	80103ca <USB_EPSetStall+0x76>
  {
    if (((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == 0U) && (epnum != 0U))
 8010370:	68bb      	ldr	r3, [r7, #8]
 8010372:	015a      	lsls	r2, r3, #5
 8010374:	68fb      	ldr	r3, [r7, #12]
 8010376:	4413      	add	r3, r2
 8010378:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 801037c:	681b      	ldr	r3, [r3, #0]
 801037e:	2b00      	cmp	r3, #0
 8010380:	db12      	blt.n	80103a8 <USB_EPSetStall+0x54>
 8010382:	68bb      	ldr	r3, [r7, #8]
 8010384:	2b00      	cmp	r3, #0
 8010386:	d00f      	beq.n	80103a8 <USB_EPSetStall+0x54>
    {
      USBx_INEP(epnum)->DIEPCTL &= ~(USB_OTG_DIEPCTL_EPDIS);
 8010388:	68bb      	ldr	r3, [r7, #8]
 801038a:	015a      	lsls	r2, r3, #5
 801038c:	68fb      	ldr	r3, [r7, #12]
 801038e:	4413      	add	r3, r2
 8010390:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8010394:	681b      	ldr	r3, [r3, #0]
 8010396:	68ba      	ldr	r2, [r7, #8]
 8010398:	0151      	lsls	r1, r2, #5
 801039a:	68fa      	ldr	r2, [r7, #12]
 801039c:	440a      	add	r2, r1
 801039e:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 80103a2:	f023 4380 	bic.w	r3, r3, #1073741824	@ 0x40000000
 80103a6:	6013      	str	r3, [r2, #0]
    }
    USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_STALL;
 80103a8:	68bb      	ldr	r3, [r7, #8]
 80103aa:	015a      	lsls	r2, r3, #5
 80103ac:	68fb      	ldr	r3, [r7, #12]
 80103ae:	4413      	add	r3, r2
 80103b0:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 80103b4:	681b      	ldr	r3, [r3, #0]
 80103b6:	68ba      	ldr	r2, [r7, #8]
 80103b8:	0151      	lsls	r1, r2, #5
 80103ba:	68fa      	ldr	r2, [r7, #12]
 80103bc:	440a      	add	r2, r1
 80103be:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 80103c2:	f443 1300 	orr.w	r3, r3, #2097152	@ 0x200000
 80103c6:	6013      	str	r3, [r2, #0]
 80103c8:	e02b      	b.n	8010422 <USB_EPSetStall+0xce>
  }
  else
  {
    if (((USBx_OUTEP(epnum)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == 0U) && (epnum != 0U))
 80103ca:	68bb      	ldr	r3, [r7, #8]
 80103cc:	015a      	lsls	r2, r3, #5
 80103ce:	68fb      	ldr	r3, [r7, #12]
 80103d0:	4413      	add	r3, r2
 80103d2:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 80103d6:	681b      	ldr	r3, [r3, #0]
 80103d8:	2b00      	cmp	r3, #0
 80103da:	db12      	blt.n	8010402 <USB_EPSetStall+0xae>
 80103dc:	68bb      	ldr	r3, [r7, #8]
 80103de:	2b00      	cmp	r3, #0
 80103e0:	d00f      	beq.n	8010402 <USB_EPSetStall+0xae>
    {
      USBx_OUTEP(epnum)->DOEPCTL &= ~(USB_OTG_DOEPCTL_EPDIS);
 80103e2:	68bb      	ldr	r3, [r7, #8]
 80103e4:	015a      	lsls	r2, r3, #5
 80103e6:	68fb      	ldr	r3, [r7, #12]
 80103e8:	4413      	add	r3, r2
 80103ea:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 80103ee:	681b      	ldr	r3, [r3, #0]
 80103f0:	68ba      	ldr	r2, [r7, #8]
 80103f2:	0151      	lsls	r1, r2, #5
 80103f4:	68fa      	ldr	r2, [r7, #12]
 80103f6:	440a      	add	r2, r1
 80103f8:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 80103fc:	f023 4380 	bic.w	r3, r3, #1073741824	@ 0x40000000
 8010400:	6013      	str	r3, [r2, #0]
    }
    USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_STALL;
 8010402:	68bb      	ldr	r3, [r7, #8]
 8010404:	015a      	lsls	r2, r3, #5
 8010406:	68fb      	ldr	r3, [r7, #12]
 8010408:	4413      	add	r3, r2
 801040a:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 801040e:	681b      	ldr	r3, [r3, #0]
 8010410:	68ba      	ldr	r2, [r7, #8]
 8010412:	0151      	lsls	r1, r2, #5
 8010414:	68fa      	ldr	r2, [r7, #12]
 8010416:	440a      	add	r2, r1
 8010418:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 801041c:	f443 1300 	orr.w	r3, r3, #2097152	@ 0x200000
 8010420:	6013      	str	r3, [r2, #0]
  }

  return HAL_OK;
 8010422:	2300      	movs	r3, #0
}
 8010424:	4618      	mov	r0, r3
 8010426:	3714      	adds	r7, #20
 8010428:	46bd      	mov	sp, r7
 801042a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801042e:	4770      	bx	lr

08010430 <USB_EPClearStall>:
  * @param  USBx  Selected device
  * @param  ep pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPClearStall(const USB_OTG_GlobalTypeDef *USBx, const USB_OTG_EPTypeDef *ep)
{
 8010430:	b480      	push	{r7}
 8010432:	b085      	sub	sp, #20
 8010434:	af00      	add	r7, sp, #0
 8010436:	6078      	str	r0, [r7, #4]
 8010438:	6039      	str	r1, [r7, #0]
  uint32_t USBx_BASE = (uint32_t)USBx;
 801043a:	687b      	ldr	r3, [r7, #4]
 801043c:	60fb      	str	r3, [r7, #12]
  uint32_t epnum = (uint32_t)ep->num;
 801043e:	683b      	ldr	r3, [r7, #0]
 8010440:	781b      	ldrb	r3, [r3, #0]
 8010442:	60bb      	str	r3, [r7, #8]

  if (ep->is_in == 1U)
 8010444:	683b      	ldr	r3, [r7, #0]
 8010446:	785b      	ldrb	r3, [r3, #1]
 8010448:	2b01      	cmp	r3, #1
 801044a:	d128      	bne.n	801049e <USB_EPClearStall+0x6e>
  {
    USBx_INEP(epnum)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
 801044c:	68bb      	ldr	r3, [r7, #8]
 801044e:	015a      	lsls	r2, r3, #5
 8010450:	68fb      	ldr	r3, [r7, #12]
 8010452:	4413      	add	r3, r2
 8010454:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8010458:	681b      	ldr	r3, [r3, #0]
 801045a:	68ba      	ldr	r2, [r7, #8]
 801045c:	0151      	lsls	r1, r2, #5
 801045e:	68fa      	ldr	r2, [r7, #12]
 8010460:	440a      	add	r2, r1
 8010462:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 8010466:	f423 1300 	bic.w	r3, r3, #2097152	@ 0x200000
 801046a:	6013      	str	r3, [r2, #0]
    if ((ep->type == EP_TYPE_INTR) || (ep->type == EP_TYPE_BULK))
 801046c:	683b      	ldr	r3, [r7, #0]
 801046e:	791b      	ldrb	r3, [r3, #4]
 8010470:	2b03      	cmp	r3, #3
 8010472:	d003      	beq.n	801047c <USB_EPClearStall+0x4c>
 8010474:	683b      	ldr	r3, [r7, #0]
 8010476:	791b      	ldrb	r3, [r3, #4]
 8010478:	2b02      	cmp	r3, #2
 801047a:	d138      	bne.n	80104ee <USB_EPClearStall+0xbe>
    {
      USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM; /* DATA0 */
 801047c:	68bb      	ldr	r3, [r7, #8]
 801047e:	015a      	lsls	r2, r3, #5
 8010480:	68fb      	ldr	r3, [r7, #12]
 8010482:	4413      	add	r3, r2
 8010484:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8010488:	681b      	ldr	r3, [r3, #0]
 801048a:	68ba      	ldr	r2, [r7, #8]
 801048c:	0151      	lsls	r1, r2, #5
 801048e:	68fa      	ldr	r2, [r7, #12]
 8010490:	440a      	add	r2, r1
 8010492:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 8010496:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 801049a:	6013      	str	r3, [r2, #0]
 801049c:	e027      	b.n	80104ee <USB_EPClearStall+0xbe>
    }
  }
  else
  {
    USBx_OUTEP(epnum)->DOEPCTL &= ~USB_OTG_DOEPCTL_STALL;
 801049e:	68bb      	ldr	r3, [r7, #8]
 80104a0:	015a      	lsls	r2, r3, #5
 80104a2:	68fb      	ldr	r3, [r7, #12]
 80104a4:	4413      	add	r3, r2
 80104a6:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 80104aa:	681b      	ldr	r3, [r3, #0]
 80104ac:	68ba      	ldr	r2, [r7, #8]
 80104ae:	0151      	lsls	r1, r2, #5
 80104b0:	68fa      	ldr	r2, [r7, #12]
 80104b2:	440a      	add	r2, r1
 80104b4:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 80104b8:	f423 1300 	bic.w	r3, r3, #2097152	@ 0x200000
 80104bc:	6013      	str	r3, [r2, #0]
    if ((ep->type == EP_TYPE_INTR) || (ep->type == EP_TYPE_BULK))
 80104be:	683b      	ldr	r3, [r7, #0]
 80104c0:	791b      	ldrb	r3, [r3, #4]
 80104c2:	2b03      	cmp	r3, #3
 80104c4:	d003      	beq.n	80104ce <USB_EPClearStall+0x9e>
 80104c6:	683b      	ldr	r3, [r7, #0]
 80104c8:	791b      	ldrb	r3, [r3, #4]
 80104ca:	2b02      	cmp	r3, #2
 80104cc:	d10f      	bne.n	80104ee <USB_EPClearStall+0xbe>
    {
      USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM; /* DATA0 */
 80104ce:	68bb      	ldr	r3, [r7, #8]
 80104d0:	015a      	lsls	r2, r3, #5
 80104d2:	68fb      	ldr	r3, [r7, #12]
 80104d4:	4413      	add	r3, r2
 80104d6:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 80104da:	681b      	ldr	r3, [r3, #0]
 80104dc:	68ba      	ldr	r2, [r7, #8]
 80104de:	0151      	lsls	r1, r2, #5
 80104e0:	68fa      	ldr	r2, [r7, #12]
 80104e2:	440a      	add	r2, r1
 80104e4:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 80104e8:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 80104ec:	6013      	str	r3, [r2, #0]
    }
  }
  return HAL_OK;
 80104ee:	2300      	movs	r3, #0
}
 80104f0:	4618      	mov	r0, r3
 80104f2:	3714      	adds	r7, #20
 80104f4:	46bd      	mov	sp, r7
 80104f6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80104fa:	4770      	bx	lr

080104fc <USB_SetDevAddress>:
  * @param  address  new device address to be assigned
  *          This parameter can be a value from 0 to 255
  * @retval HAL status
  */
HAL_StatusTypeDef USB_SetDevAddress(const USB_OTG_GlobalTypeDef *USBx, uint8_t address)
{
 80104fc:	b480      	push	{r7}
 80104fe:	b085      	sub	sp, #20
 8010500:	af00      	add	r7, sp, #0
 8010502:	6078      	str	r0, [r7, #4]
 8010504:	460b      	mov	r3, r1
 8010506:	70fb      	strb	r3, [r7, #3]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8010508:	687b      	ldr	r3, [r7, #4]
 801050a:	60fb      	str	r3, [r7, #12]

  USBx_DEVICE->DCFG &= ~(USB_OTG_DCFG_DAD);
 801050c:	68fb      	ldr	r3, [r7, #12]
 801050e:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8010512:	681b      	ldr	r3, [r3, #0]
 8010514:	68fa      	ldr	r2, [r7, #12]
 8010516:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 801051a:	f423 63fe 	bic.w	r3, r3, #2032	@ 0x7f0
 801051e:	6013      	str	r3, [r2, #0]
  USBx_DEVICE->DCFG |= ((uint32_t)address << 4) & USB_OTG_DCFG_DAD;
 8010520:	68fb      	ldr	r3, [r7, #12]
 8010522:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8010526:	681a      	ldr	r2, [r3, #0]
 8010528:	78fb      	ldrb	r3, [r7, #3]
 801052a:	011b      	lsls	r3, r3, #4
 801052c:	f403 63fe 	and.w	r3, r3, #2032	@ 0x7f0
 8010530:	68f9      	ldr	r1, [r7, #12]
 8010532:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
 8010536:	4313      	orrs	r3, r2
 8010538:	600b      	str	r3, [r1, #0]

  return HAL_OK;
 801053a:	2300      	movs	r3, #0
}
 801053c:	4618      	mov	r0, r3
 801053e:	3714      	adds	r7, #20
 8010540:	46bd      	mov	sp, r7
 8010542:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010546:	4770      	bx	lr

08010548 <USB_DevConnect>:
  * @brief  USB_DevConnect : Connect the USB device by enabling Rpu
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DevConnect(const USB_OTG_GlobalTypeDef *USBx)
{
 8010548:	b480      	push	{r7}
 801054a:	b085      	sub	sp, #20
 801054c:	af00      	add	r7, sp, #0
 801054e:	6078      	str	r0, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8010550:	687b      	ldr	r3, [r7, #4]
 8010552:	60fb      	str	r3, [r7, #12]

  /* In case phy is stopped, ensure to ungate and restore the phy CLK */
  USBx_PCGCCTL &= ~(USB_OTG_PCGCCTL_STOPCLK | USB_OTG_PCGCCTL_GATECLK);
 8010554:	68fb      	ldr	r3, [r7, #12]
 8010556:	f503 6360 	add.w	r3, r3, #3584	@ 0xe00
 801055a:	681b      	ldr	r3, [r3, #0]
 801055c:	68fa      	ldr	r2, [r7, #12]
 801055e:	f502 6260 	add.w	r2, r2, #3584	@ 0xe00
 8010562:	f023 0303 	bic.w	r3, r3, #3
 8010566:	6013      	str	r3, [r2, #0]

  USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_SDIS;
 8010568:	68fb      	ldr	r3, [r7, #12]
 801056a:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 801056e:	685b      	ldr	r3, [r3, #4]
 8010570:	68fa      	ldr	r2, [r7, #12]
 8010572:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 8010576:	f023 0302 	bic.w	r3, r3, #2
 801057a:	6053      	str	r3, [r2, #4]

  return HAL_OK;
 801057c:	2300      	movs	r3, #0
}
 801057e:	4618      	mov	r0, r3
 8010580:	3714      	adds	r7, #20
 8010582:	46bd      	mov	sp, r7
 8010584:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010588:	4770      	bx	lr

0801058a <USB_DevDisconnect>:
  * @brief  USB_DevDisconnect : Disconnect the USB device by disabling Rpu
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DevDisconnect(const USB_OTG_GlobalTypeDef *USBx)
{
 801058a:	b480      	push	{r7}
 801058c:	b085      	sub	sp, #20
 801058e:	af00      	add	r7, sp, #0
 8010590:	6078      	str	r0, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8010592:	687b      	ldr	r3, [r7, #4]
 8010594:	60fb      	str	r3, [r7, #12]

  /* In case phy is stopped, ensure to ungate and restore the phy CLK */
  USBx_PCGCCTL &= ~(USB_OTG_PCGCCTL_STOPCLK | USB_OTG_PCGCCTL_GATECLK);
 8010596:	68fb      	ldr	r3, [r7, #12]
 8010598:	f503 6360 	add.w	r3, r3, #3584	@ 0xe00
 801059c:	681b      	ldr	r3, [r3, #0]
 801059e:	68fa      	ldr	r2, [r7, #12]
 80105a0:	f502 6260 	add.w	r2, r2, #3584	@ 0xe00
 80105a4:	f023 0303 	bic.w	r3, r3, #3
 80105a8:	6013      	str	r3, [r2, #0]

  USBx_DEVICE->DCTL |= USB_OTG_DCTL_SDIS;
 80105aa:	68fb      	ldr	r3, [r7, #12]
 80105ac:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 80105b0:	685b      	ldr	r3, [r3, #4]
 80105b2:	68fa      	ldr	r2, [r7, #12]
 80105b4:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 80105b8:	f043 0302 	orr.w	r3, r3, #2
 80105bc:	6053      	str	r3, [r2, #4]

  return HAL_OK;
 80105be:	2300      	movs	r3, #0
}
 80105c0:	4618      	mov	r0, r3
 80105c2:	3714      	adds	r7, #20
 80105c4:	46bd      	mov	sp, r7
 80105c6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80105ca:	4770      	bx	lr

080105cc <USB_ReadInterrupts>:
  * @brief  USB_ReadInterrupts: return the global USB interrupt status
  * @param  USBx  Selected device
  * @retval USB Global Interrupt status
  */
uint32_t USB_ReadInterrupts(USB_OTG_GlobalTypeDef const *USBx)
{
 80105cc:	b480      	push	{r7}
 80105ce:	b085      	sub	sp, #20
 80105d0:	af00      	add	r7, sp, #0
 80105d2:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg;

  tmpreg = USBx->GINTSTS;
 80105d4:	687b      	ldr	r3, [r7, #4]
 80105d6:	695b      	ldr	r3, [r3, #20]
 80105d8:	60fb      	str	r3, [r7, #12]
  tmpreg &= USBx->GINTMSK;
 80105da:	687b      	ldr	r3, [r7, #4]
 80105dc:	699b      	ldr	r3, [r3, #24]
 80105de:	68fa      	ldr	r2, [r7, #12]
 80105e0:	4013      	ands	r3, r2
 80105e2:	60fb      	str	r3, [r7, #12]

  return tmpreg;
 80105e4:	68fb      	ldr	r3, [r7, #12]
}
 80105e6:	4618      	mov	r0, r3
 80105e8:	3714      	adds	r7, #20
 80105ea:	46bd      	mov	sp, r7
 80105ec:	f85d 7b04 	ldr.w	r7, [sp], #4
 80105f0:	4770      	bx	lr

080105f2 <USB_ReadDevAllOutEpInterrupt>:
  * @brief  USB_ReadDevAllOutEpInterrupt: return the USB device OUT endpoints interrupt status
  * @param  USBx  Selected device
  * @retval USB Device OUT EP interrupt status
  */
uint32_t USB_ReadDevAllOutEpInterrupt(const USB_OTG_GlobalTypeDef *USBx)
{
 80105f2:	b480      	push	{r7}
 80105f4:	b085      	sub	sp, #20
 80105f6:	af00      	add	r7, sp, #0
 80105f8:	6078      	str	r0, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
 80105fa:	687b      	ldr	r3, [r7, #4]
 80105fc:	60fb      	str	r3, [r7, #12]
  uint32_t tmpreg;

  tmpreg  = USBx_DEVICE->DAINT;
 80105fe:	68fb      	ldr	r3, [r7, #12]
 8010600:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8010604:	699b      	ldr	r3, [r3, #24]
 8010606:	60bb      	str	r3, [r7, #8]
  tmpreg &= USBx_DEVICE->DAINTMSK;
 8010608:	68fb      	ldr	r3, [r7, #12]
 801060a:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 801060e:	69db      	ldr	r3, [r3, #28]
 8010610:	68ba      	ldr	r2, [r7, #8]
 8010612:	4013      	ands	r3, r2
 8010614:	60bb      	str	r3, [r7, #8]

  return ((tmpreg & 0xffff0000U) >> 16);
 8010616:	68bb      	ldr	r3, [r7, #8]
 8010618:	0c1b      	lsrs	r3, r3, #16
}
 801061a:	4618      	mov	r0, r3
 801061c:	3714      	adds	r7, #20
 801061e:	46bd      	mov	sp, r7
 8010620:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010624:	4770      	bx	lr

08010626 <USB_ReadDevAllInEpInterrupt>:
  * @brief  USB_ReadDevAllInEpInterrupt: return the USB device IN endpoints interrupt status
  * @param  USBx  Selected device
  * @retval USB Device IN EP interrupt status
  */
uint32_t USB_ReadDevAllInEpInterrupt(const USB_OTG_GlobalTypeDef *USBx)
{
 8010626:	b480      	push	{r7}
 8010628:	b085      	sub	sp, #20
 801062a:	af00      	add	r7, sp, #0
 801062c:	6078      	str	r0, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
 801062e:	687b      	ldr	r3, [r7, #4]
 8010630:	60fb      	str	r3, [r7, #12]
  uint32_t tmpreg;

  tmpreg  = USBx_DEVICE->DAINT;
 8010632:	68fb      	ldr	r3, [r7, #12]
 8010634:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8010638:	699b      	ldr	r3, [r3, #24]
 801063a:	60bb      	str	r3, [r7, #8]
  tmpreg &= USBx_DEVICE->DAINTMSK;
 801063c:	68fb      	ldr	r3, [r7, #12]
 801063e:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8010642:	69db      	ldr	r3, [r3, #28]
 8010644:	68ba      	ldr	r2, [r7, #8]
 8010646:	4013      	ands	r3, r2
 8010648:	60bb      	str	r3, [r7, #8]

  return ((tmpreg & 0xFFFFU));
 801064a:	68bb      	ldr	r3, [r7, #8]
 801064c:	b29b      	uxth	r3, r3
}
 801064e:	4618      	mov	r0, r3
 8010650:	3714      	adds	r7, #20
 8010652:	46bd      	mov	sp, r7
 8010654:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010658:	4770      	bx	lr

0801065a <USB_ReadDevOutEPInterrupt>:
  * @param  epnum  endpoint number
  *          This parameter can be a value from 0 to 15
  * @retval Device OUT EP Interrupt register
  */
uint32_t USB_ReadDevOutEPInterrupt(const USB_OTG_GlobalTypeDef *USBx, uint8_t epnum)
{
 801065a:	b480      	push	{r7}
 801065c:	b085      	sub	sp, #20
 801065e:	af00      	add	r7, sp, #0
 8010660:	6078      	str	r0, [r7, #4]
 8010662:	460b      	mov	r3, r1
 8010664:	70fb      	strb	r3, [r7, #3]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8010666:	687b      	ldr	r3, [r7, #4]
 8010668:	60fb      	str	r3, [r7, #12]
  uint32_t tmpreg;

  tmpreg  = USBx_OUTEP((uint32_t)epnum)->DOEPINT;
 801066a:	78fb      	ldrb	r3, [r7, #3]
 801066c:	015a      	lsls	r2, r3, #5
 801066e:	68fb      	ldr	r3, [r7, #12]
 8010670:	4413      	add	r3, r2
 8010672:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8010676:	689b      	ldr	r3, [r3, #8]
 8010678:	60bb      	str	r3, [r7, #8]
  tmpreg &= USBx_DEVICE->DOEPMSK;
 801067a:	68fb      	ldr	r3, [r7, #12]
 801067c:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8010680:	695b      	ldr	r3, [r3, #20]
 8010682:	68ba      	ldr	r2, [r7, #8]
 8010684:	4013      	ands	r3, r2
 8010686:	60bb      	str	r3, [r7, #8]

  return tmpreg;
 8010688:	68bb      	ldr	r3, [r7, #8]
}
 801068a:	4618      	mov	r0, r3
 801068c:	3714      	adds	r7, #20
 801068e:	46bd      	mov	sp, r7
 8010690:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010694:	4770      	bx	lr

08010696 <USB_ReadDevInEPInterrupt>:
  * @param  epnum  endpoint number
  *          This parameter can be a value from 0 to 15
  * @retval Device IN EP Interrupt register
  */
uint32_t USB_ReadDevInEPInterrupt(const USB_OTG_GlobalTypeDef *USBx, uint8_t epnum)
{
 8010696:	b480      	push	{r7}
 8010698:	b087      	sub	sp, #28
 801069a:	af00      	add	r7, sp, #0
 801069c:	6078      	str	r0, [r7, #4]
 801069e:	460b      	mov	r3, r1
 80106a0:	70fb      	strb	r3, [r7, #3]
  uint32_t USBx_BASE = (uint32_t)USBx;
 80106a2:	687b      	ldr	r3, [r7, #4]
 80106a4:	617b      	str	r3, [r7, #20]
  uint32_t tmpreg;
  uint32_t msk;
  uint32_t emp;

  msk = USBx_DEVICE->DIEPMSK;
 80106a6:	697b      	ldr	r3, [r7, #20]
 80106a8:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 80106ac:	691b      	ldr	r3, [r3, #16]
 80106ae:	613b      	str	r3, [r7, #16]
  emp = USBx_DEVICE->DIEPEMPMSK;
 80106b0:	697b      	ldr	r3, [r7, #20]
 80106b2:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 80106b6:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 80106b8:	60fb      	str	r3, [r7, #12]
  msk |= ((emp >> (epnum & EP_ADDR_MSK)) & 0x1U) << 7;
 80106ba:	78fb      	ldrb	r3, [r7, #3]
 80106bc:	f003 030f 	and.w	r3, r3, #15
 80106c0:	68fa      	ldr	r2, [r7, #12]
 80106c2:	fa22 f303 	lsr.w	r3, r2, r3
 80106c6:	01db      	lsls	r3, r3, #7
 80106c8:	b2db      	uxtb	r3, r3
 80106ca:	693a      	ldr	r2, [r7, #16]
 80106cc:	4313      	orrs	r3, r2
 80106ce:	613b      	str	r3, [r7, #16]
  tmpreg = USBx_INEP((uint32_t)epnum)->DIEPINT & msk;
 80106d0:	78fb      	ldrb	r3, [r7, #3]
 80106d2:	015a      	lsls	r2, r3, #5
 80106d4:	697b      	ldr	r3, [r7, #20]
 80106d6:	4413      	add	r3, r2
 80106d8:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 80106dc:	689b      	ldr	r3, [r3, #8]
 80106de:	693a      	ldr	r2, [r7, #16]
 80106e0:	4013      	ands	r3, r2
 80106e2:	60bb      	str	r3, [r7, #8]

  return tmpreg;
 80106e4:	68bb      	ldr	r3, [r7, #8]
}
 80106e6:	4618      	mov	r0, r3
 80106e8:	371c      	adds	r7, #28
 80106ea:	46bd      	mov	sp, r7
 80106ec:	f85d 7b04 	ldr.w	r7, [sp], #4
 80106f0:	4770      	bx	lr

080106f2 <USB_GetMode>:
  *          This parameter can be one of these values:
  *           0 : Host
  *           1 : Device
  */
uint32_t USB_GetMode(const USB_OTG_GlobalTypeDef *USBx)
{
 80106f2:	b480      	push	{r7}
 80106f4:	b083      	sub	sp, #12
 80106f6:	af00      	add	r7, sp, #0
 80106f8:	6078      	str	r0, [r7, #4]
  return ((USBx->GINTSTS) & 0x1U);
 80106fa:	687b      	ldr	r3, [r7, #4]
 80106fc:	695b      	ldr	r3, [r3, #20]
 80106fe:	f003 0301 	and.w	r3, r3, #1
}
 8010702:	4618      	mov	r0, r3
 8010704:	370c      	adds	r7, #12
 8010706:	46bd      	mov	sp, r7
 8010708:	f85d 7b04 	ldr.w	r7, [sp], #4
 801070c:	4770      	bx	lr
	...

08010710 <USB_ActivateSetup>:
  * @brief  Activate EP0 for Setup transactions
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_ActivateSetup(const USB_OTG_GlobalTypeDef *USBx)
{
 8010710:	b480      	push	{r7}
 8010712:	b085      	sub	sp, #20
 8010714:	af00      	add	r7, sp, #0
 8010716:	6078      	str	r0, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8010718:	687b      	ldr	r3, [r7, #4]
 801071a:	60fb      	str	r3, [r7, #12]

  /* Set the MPS of the IN EP0 to 64 bytes */
  USBx_INEP(0U)->DIEPCTL &= ~USB_OTG_DIEPCTL_MPSIZ;
 801071c:	68fb      	ldr	r3, [r7, #12]
 801071e:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8010722:	681a      	ldr	r2, [r3, #0]
 8010724:	68fb      	ldr	r3, [r7, #12]
 8010726:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 801072a:	4619      	mov	r1, r3
 801072c:	4b09      	ldr	r3, [pc, #36]	@ (8010754 <USB_ActivateSetup+0x44>)
 801072e:	4013      	ands	r3, r2
 8010730:	600b      	str	r3, [r1, #0]

  USBx_DEVICE->DCTL |= USB_OTG_DCTL_CGINAK;
 8010732:	68fb      	ldr	r3, [r7, #12]
 8010734:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8010738:	685b      	ldr	r3, [r3, #4]
 801073a:	68fa      	ldr	r2, [r7, #12]
 801073c:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 8010740:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 8010744:	6053      	str	r3, [r2, #4]

  return HAL_OK;
 8010746:	2300      	movs	r3, #0
}
 8010748:	4618      	mov	r0, r3
 801074a:	3714      	adds	r7, #20
 801074c:	46bd      	mov	sp, r7
 801074e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010752:	4770      	bx	lr
 8010754:	fffff800 	.word	0xfffff800

08010758 <USB_EP0_OutStart>:
  *           1 : DMA feature used
  * @param  psetup  pointer to setup packet
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EP0_OutStart(const USB_OTG_GlobalTypeDef *USBx, uint8_t dma, const uint8_t *psetup)
{
 8010758:	b480      	push	{r7}
 801075a:	b087      	sub	sp, #28
 801075c:	af00      	add	r7, sp, #0
 801075e:	60f8      	str	r0, [r7, #12]
 8010760:	460b      	mov	r3, r1
 8010762:	607a      	str	r2, [r7, #4]
 8010764:	72fb      	strb	r3, [r7, #11]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8010766:	68fb      	ldr	r3, [r7, #12]
 8010768:	617b      	str	r3, [r7, #20]
  uint32_t gSNPSiD = *(__IO const uint32_t *)(&USBx->CID + 0x1U);
 801076a:	68fb      	ldr	r3, [r7, #12]
 801076c:	333c      	adds	r3, #60	@ 0x3c
 801076e:	3304      	adds	r3, #4
 8010770:	681b      	ldr	r3, [r3, #0]
 8010772:	613b      	str	r3, [r7, #16]

  if (gSNPSiD > USB_OTG_CORE_ID_300A)
 8010774:	693b      	ldr	r3, [r7, #16]
 8010776:	4a26      	ldr	r2, [pc, #152]	@ (8010810 <USB_EP0_OutStart+0xb8>)
 8010778:	4293      	cmp	r3, r2
 801077a:	d90a      	bls.n	8010792 <USB_EP0_OutStart+0x3a>
  {
    if ((USBx_OUTEP(0U)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 801077c:	697b      	ldr	r3, [r7, #20]
 801077e:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8010782:	681b      	ldr	r3, [r3, #0]
 8010784:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
 8010788:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 801078c:	d101      	bne.n	8010792 <USB_EP0_OutStart+0x3a>
    {
      return HAL_OK;
 801078e:	2300      	movs	r3, #0
 8010790:	e037      	b.n	8010802 <USB_EP0_OutStart+0xaa>
    }
  }

  USBx_OUTEP(0U)->DOEPTSIZ = 0U;
 8010792:	697b      	ldr	r3, [r7, #20]
 8010794:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8010798:	461a      	mov	r2, r3
 801079a:	2300      	movs	r3, #0
 801079c:	6113      	str	r3, [r2, #16]
  USBx_OUTEP(0U)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19));
 801079e:	697b      	ldr	r3, [r7, #20]
 80107a0:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 80107a4:	691b      	ldr	r3, [r3, #16]
 80107a6:	697a      	ldr	r2, [r7, #20]
 80107a8:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 80107ac:	f443 2300 	orr.w	r3, r3, #524288	@ 0x80000
 80107b0:	6113      	str	r3, [r2, #16]
  USBx_OUTEP(0U)->DOEPTSIZ |= (3U * 8U);
 80107b2:	697b      	ldr	r3, [r7, #20]
 80107b4:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 80107b8:	691b      	ldr	r3, [r3, #16]
 80107ba:	697a      	ldr	r2, [r7, #20]
 80107bc:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 80107c0:	f043 0318 	orr.w	r3, r3, #24
 80107c4:	6113      	str	r3, [r2, #16]
  USBx_OUTEP(0U)->DOEPTSIZ |=  USB_OTG_DOEPTSIZ_STUPCNT;
 80107c6:	697b      	ldr	r3, [r7, #20]
 80107c8:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 80107cc:	691b      	ldr	r3, [r3, #16]
 80107ce:	697a      	ldr	r2, [r7, #20]
 80107d0:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 80107d4:	f043 43c0 	orr.w	r3, r3, #1610612736	@ 0x60000000
 80107d8:	6113      	str	r3, [r2, #16]

  if (dma == 1U)
 80107da:	7afb      	ldrb	r3, [r7, #11]
 80107dc:	2b01      	cmp	r3, #1
 80107de:	d10f      	bne.n	8010800 <USB_EP0_OutStart+0xa8>
  {
    USBx_OUTEP(0U)->DOEPDMA = (uint32_t)psetup;
 80107e0:	697b      	ldr	r3, [r7, #20]
 80107e2:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 80107e6:	461a      	mov	r2, r3
 80107e8:	687b      	ldr	r3, [r7, #4]
 80107ea:	6153      	str	r3, [r2, #20]
    /* EP enable */
    USBx_OUTEP(0U)->DOEPCTL |= USB_OTG_DOEPCTL_EPENA | USB_OTG_DOEPCTL_USBAEP;
 80107ec:	697b      	ldr	r3, [r7, #20]
 80107ee:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 80107f2:	681b      	ldr	r3, [r3, #0]
 80107f4:	697a      	ldr	r2, [r7, #20]
 80107f6:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 80107fa:	f043 2380 	orr.w	r3, r3, #2147516416	@ 0x80008000
 80107fe:	6013      	str	r3, [r2, #0]
  }

  return HAL_OK;
 8010800:	2300      	movs	r3, #0
}
 8010802:	4618      	mov	r0, r3
 8010804:	371c      	adds	r7, #28
 8010806:	46bd      	mov	sp, r7
 8010808:	f85d 7b04 	ldr.w	r7, [sp], #4
 801080c:	4770      	bx	lr
 801080e:	bf00      	nop
 8010810:	4f54300a 	.word	0x4f54300a

08010814 <USB_CoreReset>:
  * @brief  Reset the USB Core (needed after USB clock settings change)
  * @param  USBx  Selected device
  * @retval HAL status
  */
static HAL_StatusTypeDef USB_CoreReset(USB_OTG_GlobalTypeDef *USBx)
{
 8010814:	b480      	push	{r7}
 8010816:	b085      	sub	sp, #20
 8010818:	af00      	add	r7, sp, #0
 801081a:	6078      	str	r0, [r7, #4]
  __IO uint32_t count = 0U;
 801081c:	2300      	movs	r3, #0
 801081e:	60fb      	str	r3, [r7, #12]

  /* Wait for AHB master IDLE state. */
  do
  {
    count++;
 8010820:	68fb      	ldr	r3, [r7, #12]
 8010822:	3301      	adds	r3, #1
 8010824:	60fb      	str	r3, [r7, #12]

    if (count > HAL_USB_TIMEOUT)
 8010826:	68fb      	ldr	r3, [r7, #12]
 8010828:	f1b3 6f70 	cmp.w	r3, #251658240	@ 0xf000000
 801082c:	d901      	bls.n	8010832 <USB_CoreReset+0x1e>
    {
      return HAL_TIMEOUT;
 801082e:	2303      	movs	r3, #3
 8010830:	e01b      	b.n	801086a <USB_CoreReset+0x56>
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 8010832:	687b      	ldr	r3, [r7, #4]
 8010834:	691b      	ldr	r3, [r3, #16]
 8010836:	2b00      	cmp	r3, #0
 8010838:	daf2      	bge.n	8010820 <USB_CoreReset+0xc>

  /* Core Soft Reset */
  count = 0U;
 801083a:	2300      	movs	r3, #0
 801083c:	60fb      	str	r3, [r7, #12]
  USBx->GRSTCTL |= USB_OTG_GRSTCTL_CSRST;
 801083e:	687b      	ldr	r3, [r7, #4]
 8010840:	691b      	ldr	r3, [r3, #16]
 8010842:	f043 0201 	orr.w	r2, r3, #1
 8010846:	687b      	ldr	r3, [r7, #4]
 8010848:	611a      	str	r2, [r3, #16]

  do
  {
    count++;
 801084a:	68fb      	ldr	r3, [r7, #12]
 801084c:	3301      	adds	r3, #1
 801084e:	60fb      	str	r3, [r7, #12]

    if (count > HAL_USB_TIMEOUT)
 8010850:	68fb      	ldr	r3, [r7, #12]
 8010852:	f1b3 6f70 	cmp.w	r3, #251658240	@ 0xf000000
 8010856:	d901      	bls.n	801085c <USB_CoreReset+0x48>
    {
      return HAL_TIMEOUT;
 8010858:	2303      	movs	r3, #3
 801085a:	e006      	b.n	801086a <USB_CoreReset+0x56>
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_CSRST) == USB_OTG_GRSTCTL_CSRST);
 801085c:	687b      	ldr	r3, [r7, #4]
 801085e:	691b      	ldr	r3, [r3, #16]
 8010860:	f003 0301 	and.w	r3, r3, #1
 8010864:	2b01      	cmp	r3, #1
 8010866:	d0f0      	beq.n	801084a <USB_CoreReset+0x36>

  return HAL_OK;
 8010868:	2300      	movs	r3, #0
}
 801086a:	4618      	mov	r0, r3
 801086c:	3714      	adds	r7, #20
 801086e:	46bd      	mov	sp, r7
 8010870:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010874:	4770      	bx	lr
	...

08010878 <USBD_AUDIO_Init>:
  * @param  pdev: device instance
  * @param  cfgidx: Configuration index
  * @retval status
  */
static uint8_t USBD_AUDIO_Init(USBD_HandleTypeDef *pdev, uint8_t cfgidx)
{
 8010878:	b580      	push	{r7, lr}
 801087a:	b084      	sub	sp, #16
 801087c:	af00      	add	r7, sp, #0
 801087e:	6078      	str	r0, [r7, #4]
 8010880:	460b      	mov	r3, r1
 8010882:	70fb      	strb	r3, [r7, #3]
  UNUSED(cfgidx);
  USBD_AUDIO_HandleTypeDef *haudio;

  /* Allocate Audio structure */
  haudio = (USBD_AUDIO_HandleTypeDef *)USBD_malloc(sizeof(USBD_AUDIO_HandleTypeDef));
 8010884:	f243 7050 	movw	r0, #14160	@ 0x3750
 8010888:	f002 fb4c 	bl	8012f24 <USBD_static_malloc>
 801088c:	60f8      	str	r0, [r7, #12]

  if (haudio == NULL)
 801088e:	68fb      	ldr	r3, [r7, #12]
 8010890:	2b00      	cmp	r3, #0
 8010892:	d109      	bne.n	80108a8 <USBD_AUDIO_Init+0x30>
  {
    pdev->pClassDataCmsit[pdev->classId] = NULL;
 8010894:	687b      	ldr	r3, [r7, #4]
 8010896:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 801089a:	687b      	ldr	r3, [r7, #4]
 801089c:	32b0      	adds	r2, #176	@ 0xb0
 801089e:	2100      	movs	r1, #0
 80108a0:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    return (uint8_t)USBD_EMEM;
 80108a4:	2302      	movs	r3, #2
 80108a6:	e07e      	b.n	80109a6 <USBD_AUDIO_Init+0x12e>
  }

  pdev->pClassDataCmsit[pdev->classId] = (void *)haudio;
 80108a8:	687b      	ldr	r3, [r7, #4]
 80108aa:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 80108ae:	687b      	ldr	r3, [r7, #4]
 80108b0:	32b0      	adds	r2, #176	@ 0xb0
 80108b2:	68f9      	ldr	r1, [r7, #12]
 80108b4:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  pdev->pClassData = pdev->pClassDataCmsit[pdev->classId];
 80108b8:	687b      	ldr	r3, [r7, #4]
 80108ba:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 80108be:	687b      	ldr	r3, [r7, #4]
 80108c0:	32b0      	adds	r2, #176	@ 0xb0
 80108c2:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80108c6:	687b      	ldr	r3, [r7, #4]
 80108c8:	f8c3 22bc 	str.w	r2, [r3, #700]	@ 0x2bc
#ifdef USE_USBD_COMPOSITE
  /* Get the Endpoints addresses allocated for this class instance */
  AUDIOOutEpAdd = USBD_CoreGetEPAdd(pdev, USBD_EP_OUT, USBD_EP_TYPE_ISOC, (uint8_t)pdev->classId);
#endif /* USE_USBD_COMPOSITE */

  if (pdev->dev_speed == USBD_SPEED_HIGH)
 80108cc:	687b      	ldr	r3, [r7, #4]
 80108ce:	7c1b      	ldrb	r3, [r3, #16]
 80108d0:	2b00      	cmp	r3, #0
 80108d2:	d10e      	bne.n	80108f2 <USBD_AUDIO_Init+0x7a>
  {
    pdev->ep_out[AUDIOOutEpAdd & 0xFU].bInterval = AUDIO_HS_BINTERVAL;
 80108d4:	4b36      	ldr	r3, [pc, #216]	@ (80109b0 <USBD_AUDIO_Init+0x138>)
 80108d6:	781b      	ldrb	r3, [r3, #0]
 80108d8:	f003 020f 	and.w	r2, r3, #15
 80108dc:	6879      	ldr	r1, [r7, #4]
 80108de:	4613      	mov	r3, r2
 80108e0:	009b      	lsls	r3, r3, #2
 80108e2:	4413      	add	r3, r2
 80108e4:	009b      	lsls	r3, r3, #2
 80108e6:	440b      	add	r3, r1
 80108e8:	f503 73b3 	add.w	r3, r3, #358	@ 0x166
 80108ec:	2201      	movs	r2, #1
 80108ee:	801a      	strh	r2, [r3, #0]
 80108f0:	e00d      	b.n	801090e <USBD_AUDIO_Init+0x96>
  }
  else   /* LOW and FULL-speed endpoints */
  {
    pdev->ep_out[AUDIOOutEpAdd & 0xFU].bInterval = AUDIO_FS_BINTERVAL;
 80108f2:	4b2f      	ldr	r3, [pc, #188]	@ (80109b0 <USBD_AUDIO_Init+0x138>)
 80108f4:	781b      	ldrb	r3, [r3, #0]
 80108f6:	f003 020f 	and.w	r2, r3, #15
 80108fa:	6879      	ldr	r1, [r7, #4]
 80108fc:	4613      	mov	r3, r2
 80108fe:	009b      	lsls	r3, r3, #2
 8010900:	4413      	add	r3, r2
 8010902:	009b      	lsls	r3, r3, #2
 8010904:	440b      	add	r3, r1
 8010906:	f503 73b3 	add.w	r3, r3, #358	@ 0x166
 801090a:	2201      	movs	r2, #1
 801090c:	801a      	strh	r2, [r3, #0]
  }

  /* Open EP OUT */
  (void)USBD_LL_OpenEP(pdev, AUDIOOutEpAdd, USBD_EP_TYPE_ISOC, AUDIO_OUT_PACKET);
 801090e:	4b28      	ldr	r3, [pc, #160]	@ (80109b0 <USBD_AUDIO_Init+0x138>)
 8010910:	7819      	ldrb	r1, [r3, #0]
 8010912:	23b0      	movs	r3, #176	@ 0xb0
 8010914:	2201      	movs	r2, #1
 8010916:	6878      	ldr	r0, [r7, #4]
 8010918:	f002 f9e1 	bl	8012cde <USBD_LL_OpenEP>
  pdev->ep_out[AUDIOOutEpAdd & 0xFU].is_used = 1U;
 801091c:	4b24      	ldr	r3, [pc, #144]	@ (80109b0 <USBD_AUDIO_Init+0x138>)
 801091e:	781b      	ldrb	r3, [r3, #0]
 8010920:	f003 020f 	and.w	r2, r3, #15
 8010924:	6879      	ldr	r1, [r7, #4]
 8010926:	4613      	mov	r3, r2
 8010928:	009b      	lsls	r3, r3, #2
 801092a:	4413      	add	r3, r2
 801092c:	009b      	lsls	r3, r3, #2
 801092e:	440b      	add	r3, r1
 8010930:	f503 73b2 	add.w	r3, r3, #356	@ 0x164
 8010934:	2201      	movs	r2, #1
 8010936:	801a      	strh	r2, [r3, #0]

  haudio->alt_setting = 0U;
 8010938:	68fb      	ldr	r3, [r7, #12]
 801093a:	2200      	movs	r2, #0
 801093c:	601a      	str	r2, [r3, #0]
  haudio->offset = AUDIO_OFFSET_UNKNOWN;
 801093e:	68fb      	ldr	r3, [r7, #12]
 8010940:	f503 5340 	add.w	r3, r3, #12288	@ 0x3000
 8010944:	2203      	movs	r2, #3
 8010946:	f883 2704 	strb.w	r2, [r3, #1796]	@ 0x704
  haudio->wr_ptr = 0U;
 801094a:	68fb      	ldr	r3, [r7, #12]
 801094c:	f503 5340 	add.w	r3, r3, #12288	@ 0x3000
 8010950:	2200      	movs	r2, #0
 8010952:	f8a3 2708 	strh.w	r2, [r3, #1800]	@ 0x708
  haudio->rd_ptr = 0U;
 8010956:	68fb      	ldr	r3, [r7, #12]
 8010958:	f503 5340 	add.w	r3, r3, #12288	@ 0x3000
 801095c:	2200      	movs	r2, #0
 801095e:	f8a3 2706 	strh.w	r2, [r3, #1798]	@ 0x706
  haudio->rd_enable = 0U;
 8010962:	68fb      	ldr	r3, [r7, #12]
 8010964:	f503 5340 	add.w	r3, r3, #12288	@ 0x3000
 8010968:	2200      	movs	r2, #0
 801096a:	f883 2705 	strb.w	r2, [r3, #1797]	@ 0x705

  /* Initialize the Audio output Hardware layer */
  if (((USBD_AUDIO_ItfTypeDef *)pdev->pUserData[pdev->classId])->Init(USBD_AUDIO_FREQ,
 801096e:	687b      	ldr	r3, [r7, #4]
 8010970:	f8d3 32d4 	ldr.w	r3, [r3, #724]	@ 0x2d4
 8010974:	687a      	ldr	r2, [r7, #4]
 8010976:	33b0      	adds	r3, #176	@ 0xb0
 8010978:	009b      	lsls	r3, r3, #2
 801097a:	4413      	add	r3, r2
 801097c:	685b      	ldr	r3, [r3, #4]
 801097e:	681b      	ldr	r3, [r3, #0]
 8010980:	2200      	movs	r2, #0
 8010982:	2146      	movs	r1, #70	@ 0x46
 8010984:	f64a 4044 	movw	r0, #44100	@ 0xac44
 8010988:	4798      	blx	r3
 801098a:	4603      	mov	r3, r0
 801098c:	2b00      	cmp	r3, #0
 801098e:	d001      	beq.n	8010994 <USBD_AUDIO_Init+0x11c>
                                                                      AUDIO_DEFAULT_VOLUME,
                                                                      0U) != 0U)
  {
    return (uint8_t)USBD_FAIL;
 8010990:	2303      	movs	r3, #3
 8010992:	e008      	b.n	80109a6 <USBD_AUDIO_Init+0x12e>
  }

  /* Prepare Out endpoint to receive 1st packet */
  (void)USBD_LL_PrepareReceive(pdev, AUDIOOutEpAdd, haudio->buffer,
 8010994:	4b06      	ldr	r3, [pc, #24]	@ (80109b0 <USBD_AUDIO_Init+0x138>)
 8010996:	7819      	ldrb	r1, [r3, #0]
 8010998:	68fb      	ldr	r3, [r7, #12]
 801099a:	1d1a      	adds	r2, r3, #4
 801099c:	23b0      	movs	r3, #176	@ 0xb0
 801099e:	6878      	ldr	r0, [r7, #4]
 80109a0:	f002 fa8c 	bl	8012ebc <USBD_LL_PrepareReceive>
                               AUDIO_OUT_PACKET);

  return (uint8_t)USBD_OK;
 80109a4:	2300      	movs	r3, #0
}
 80109a6:	4618      	mov	r0, r3
 80109a8:	3710      	adds	r7, #16
 80109aa:	46bd      	mov	sp, r7
 80109ac:	bd80      	pop	{r7, pc}
 80109ae:	bf00      	nop
 80109b0:	240001de 	.word	0x240001de

080109b4 <USBD_AUDIO_DeInit>:
  * @param  pdev: device instance
  * @param  cfgidx: Configuration index
  * @retval status
  */
static uint8_t USBD_AUDIO_DeInit(USBD_HandleTypeDef *pdev, uint8_t cfgidx)
{
 80109b4:	b580      	push	{r7, lr}
 80109b6:	b082      	sub	sp, #8
 80109b8:	af00      	add	r7, sp, #0
 80109ba:	6078      	str	r0, [r7, #4]
 80109bc:	460b      	mov	r3, r1
 80109be:	70fb      	strb	r3, [r7, #3]
  /* Get the Endpoints addresses allocated for this class instance */
  AUDIOOutEpAdd = USBD_CoreGetEPAdd(pdev, USBD_EP_OUT, USBD_EP_TYPE_ISOC, (uint8_t)pdev->classId);
#endif /* USE_USBD_COMPOSITE */

  /* Open EP OUT */
  (void)USBD_LL_CloseEP(pdev, AUDIOOutEpAdd);
 80109c0:	4b28      	ldr	r3, [pc, #160]	@ (8010a64 <USBD_AUDIO_DeInit+0xb0>)
 80109c2:	781b      	ldrb	r3, [r3, #0]
 80109c4:	4619      	mov	r1, r3
 80109c6:	6878      	ldr	r0, [r7, #4]
 80109c8:	f002 f9af 	bl	8012d2a <USBD_LL_CloseEP>
  pdev->ep_out[AUDIOOutEpAdd & 0xFU].is_used = 0U;
 80109cc:	4b25      	ldr	r3, [pc, #148]	@ (8010a64 <USBD_AUDIO_DeInit+0xb0>)
 80109ce:	781b      	ldrb	r3, [r3, #0]
 80109d0:	f003 020f 	and.w	r2, r3, #15
 80109d4:	6879      	ldr	r1, [r7, #4]
 80109d6:	4613      	mov	r3, r2
 80109d8:	009b      	lsls	r3, r3, #2
 80109da:	4413      	add	r3, r2
 80109dc:	009b      	lsls	r3, r3, #2
 80109de:	440b      	add	r3, r1
 80109e0:	f503 73b2 	add.w	r3, r3, #356	@ 0x164
 80109e4:	2200      	movs	r2, #0
 80109e6:	801a      	strh	r2, [r3, #0]
  pdev->ep_out[AUDIOOutEpAdd & 0xFU].bInterval = 0U;
 80109e8:	4b1e      	ldr	r3, [pc, #120]	@ (8010a64 <USBD_AUDIO_DeInit+0xb0>)
 80109ea:	781b      	ldrb	r3, [r3, #0]
 80109ec:	f003 020f 	and.w	r2, r3, #15
 80109f0:	6879      	ldr	r1, [r7, #4]
 80109f2:	4613      	mov	r3, r2
 80109f4:	009b      	lsls	r3, r3, #2
 80109f6:	4413      	add	r3, r2
 80109f8:	009b      	lsls	r3, r3, #2
 80109fa:	440b      	add	r3, r1
 80109fc:	f503 73b3 	add.w	r3, r3, #358	@ 0x166
 8010a00:	2200      	movs	r2, #0
 8010a02:	801a      	strh	r2, [r3, #0]

  /* DeInit  physical Interface components */
  if (pdev->pClassDataCmsit[pdev->classId] != NULL)
 8010a04:	687b      	ldr	r3, [r7, #4]
 8010a06:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 8010a0a:	687b      	ldr	r3, [r7, #4]
 8010a0c:	32b0      	adds	r2, #176	@ 0xb0
 8010a0e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8010a12:	2b00      	cmp	r3, #0
 8010a14:	d020      	beq.n	8010a58 <USBD_AUDIO_DeInit+0xa4>
  {
    ((USBD_AUDIO_ItfTypeDef *)pdev->pUserData[pdev->classId])->DeInit(0U);
 8010a16:	687b      	ldr	r3, [r7, #4]
 8010a18:	f8d3 32d4 	ldr.w	r3, [r3, #724]	@ 0x2d4
 8010a1c:	687a      	ldr	r2, [r7, #4]
 8010a1e:	33b0      	adds	r3, #176	@ 0xb0
 8010a20:	009b      	lsls	r3, r3, #2
 8010a22:	4413      	add	r3, r2
 8010a24:	685b      	ldr	r3, [r3, #4]
 8010a26:	685b      	ldr	r3, [r3, #4]
 8010a28:	2000      	movs	r0, #0
 8010a2a:	4798      	blx	r3
    (void)USBD_free(pdev->pClassDataCmsit[pdev->classId]);
 8010a2c:	687b      	ldr	r3, [r7, #4]
 8010a2e:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 8010a32:	687b      	ldr	r3, [r7, #4]
 8010a34:	32b0      	adds	r2, #176	@ 0xb0
 8010a36:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8010a3a:	4618      	mov	r0, r3
 8010a3c:	f002 fa80 	bl	8012f40 <USBD_static_free>
    pdev->pClassDataCmsit[pdev->classId] = NULL;
 8010a40:	687b      	ldr	r3, [r7, #4]
 8010a42:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 8010a46:	687b      	ldr	r3, [r7, #4]
 8010a48:	32b0      	adds	r2, #176	@ 0xb0
 8010a4a:	2100      	movs	r1, #0
 8010a4c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    pdev->pClassData = NULL;
 8010a50:	687b      	ldr	r3, [r7, #4]
 8010a52:	2200      	movs	r2, #0
 8010a54:	f8c3 22bc 	str.w	r2, [r3, #700]	@ 0x2bc
  }

  return (uint8_t)USBD_OK;
 8010a58:	2300      	movs	r3, #0
}
 8010a5a:	4618      	mov	r0, r3
 8010a5c:	3708      	adds	r7, #8
 8010a5e:	46bd      	mov	sp, r7
 8010a60:	bd80      	pop	{r7, pc}
 8010a62:	bf00      	nop
 8010a64:	240001de 	.word	0x240001de

08010a68 <USBD_AUDIO_Setup>:
  * @param  req: usb requests
  * @retval status
  */
static uint8_t USBD_AUDIO_Setup(USBD_HandleTypeDef *pdev,
                                USBD_SetupReqTypedef *req)
{
 8010a68:	b580      	push	{r7, lr}
 8010a6a:	b086      	sub	sp, #24
 8010a6c:	af00      	add	r7, sp, #0
 8010a6e:	6078      	str	r0, [r7, #4]
 8010a70:	6039      	str	r1, [r7, #0]
  USBD_AUDIO_HandleTypeDef *haudio;
  uint16_t len;
  uint8_t *pbuf;
  uint16_t status_info = 0U;
 8010a72:	2300      	movs	r3, #0
 8010a74:	813b      	strh	r3, [r7, #8]
  USBD_StatusTypeDef ret = USBD_OK;
 8010a76:	2300      	movs	r3, #0
 8010a78:	75fb      	strb	r3, [r7, #23]

  haudio = (USBD_AUDIO_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 8010a7a:	687b      	ldr	r3, [r7, #4]
 8010a7c:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 8010a80:	687b      	ldr	r3, [r7, #4]
 8010a82:	32b0      	adds	r2, #176	@ 0xb0
 8010a84:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8010a88:	613b      	str	r3, [r7, #16]

  if (haudio == NULL)
 8010a8a:	693b      	ldr	r3, [r7, #16]
 8010a8c:	2b00      	cmp	r3, #0
 8010a8e:	d101      	bne.n	8010a94 <USBD_AUDIO_Setup+0x2c>
  {
    return (uint8_t)USBD_FAIL;
 8010a90:	2303      	movs	r3, #3
 8010a92:	e0c1      	b.n	8010c18 <USBD_AUDIO_Setup+0x1b0>
  }

  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8010a94:	683b      	ldr	r3, [r7, #0]
 8010a96:	781b      	ldrb	r3, [r3, #0]
 8010a98:	f003 0360 	and.w	r3, r3, #96	@ 0x60
 8010a9c:	2b00      	cmp	r3, #0
 8010a9e:	d01a      	beq.n	8010ad6 <USBD_AUDIO_Setup+0x6e>
 8010aa0:	2b20      	cmp	r3, #32
 8010aa2:	f040 80b1 	bne.w	8010c08 <USBD_AUDIO_Setup+0x1a0>
  {
    case USB_REQ_TYPE_CLASS:
      switch (req->bRequest)
 8010aa6:	683b      	ldr	r3, [r7, #0]
 8010aa8:	785b      	ldrb	r3, [r3, #1]
 8010aaa:	2b01      	cmp	r3, #1
 8010aac:	d006      	beq.n	8010abc <USBD_AUDIO_Setup+0x54>
 8010aae:	2b81      	cmp	r3, #129	@ 0x81
 8010ab0:	d109      	bne.n	8010ac6 <USBD_AUDIO_Setup+0x5e>
      {
        case AUDIO_REQ_GET_CUR:
          AUDIO_REQ_GetCurrent(pdev, req);
 8010ab2:	6839      	ldr	r1, [r7, #0]
 8010ab4:	6878      	ldr	r0, [r7, #4]
 8010ab6:	f000 f9f5 	bl	8010ea4 <AUDIO_REQ_GetCurrent>
          break;
 8010aba:	e00b      	b.n	8010ad4 <USBD_AUDIO_Setup+0x6c>

        case AUDIO_REQ_SET_CUR:
          AUDIO_REQ_SetCurrent(pdev, req);
 8010abc:	6839      	ldr	r1, [r7, #0]
 8010abe:	6878      	ldr	r0, [r7, #4]
 8010ac0:	f000 fa1c 	bl	8010efc <AUDIO_REQ_SetCurrent>
          break;
 8010ac4:	e006      	b.n	8010ad4 <USBD_AUDIO_Setup+0x6c>

        default:
          USBD_CtlError(pdev, req);
 8010ac6:	6839      	ldr	r1, [r7, #0]
 8010ac8:	6878      	ldr	r0, [r7, #4]
 8010aca:	f001 fcae 	bl	801242a <USBD_CtlError>
          ret = USBD_FAIL;
 8010ace:	2303      	movs	r3, #3
 8010ad0:	75fb      	strb	r3, [r7, #23]
          break;
 8010ad2:	bf00      	nop
      }
      break;
 8010ad4:	e09f      	b.n	8010c16 <USBD_AUDIO_Setup+0x1ae>

    case USB_REQ_TYPE_STANDARD:
      switch (req->bRequest)
 8010ad6:	683b      	ldr	r3, [r7, #0]
 8010ad8:	785b      	ldrb	r3, [r3, #1]
 8010ada:	2b0b      	cmp	r3, #11
 8010adc:	f200 8089 	bhi.w	8010bf2 <USBD_AUDIO_Setup+0x18a>
 8010ae0:	a201      	add	r2, pc, #4	@ (adr r2, 8010ae8 <USBD_AUDIO_Setup+0x80>)
 8010ae2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8010ae6:	bf00      	nop
 8010ae8:	08010b19 	.word	0x08010b19
 8010aec:	08010c01 	.word	0x08010c01
 8010af0:	08010bf3 	.word	0x08010bf3
 8010af4:	08010bf3 	.word	0x08010bf3
 8010af8:	08010bf3 	.word	0x08010bf3
 8010afc:	08010bf3 	.word	0x08010bf3
 8010b00:	08010b43 	.word	0x08010b43
 8010b04:	08010bf3 	.word	0x08010bf3
 8010b08:	08010bf3 	.word	0x08010bf3
 8010b0c:	08010bf3 	.word	0x08010bf3
 8010b10:	08010b8b 	.word	0x08010b8b
 8010b14:	08010bb3 	.word	0x08010bb3
      {
        case USB_REQ_GET_STATUS:
          if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8010b18:	687b      	ldr	r3, [r7, #4]
 8010b1a:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 8010b1e:	b2db      	uxtb	r3, r3
 8010b20:	2b03      	cmp	r3, #3
 8010b22:	d107      	bne.n	8010b34 <USBD_AUDIO_Setup+0xcc>
          {
            (void)USBD_CtlSendData(pdev, (uint8_t *)&status_info, 2U);
 8010b24:	f107 0308 	add.w	r3, r7, #8
 8010b28:	2202      	movs	r2, #2
 8010b2a:	4619      	mov	r1, r3
 8010b2c:	6878      	ldr	r0, [r7, #4]
 8010b2e:	f001 fcf9 	bl	8012524 <USBD_CtlSendData>
          else
          {
            USBD_CtlError(pdev, req);
            ret = USBD_FAIL;
          }
          break;
 8010b32:	e068      	b.n	8010c06 <USBD_AUDIO_Setup+0x19e>
            USBD_CtlError(pdev, req);
 8010b34:	6839      	ldr	r1, [r7, #0]
 8010b36:	6878      	ldr	r0, [r7, #4]
 8010b38:	f001 fc77 	bl	801242a <USBD_CtlError>
            ret = USBD_FAIL;
 8010b3c:	2303      	movs	r3, #3
 8010b3e:	75fb      	strb	r3, [r7, #23]
          break;
 8010b40:	e061      	b.n	8010c06 <USBD_AUDIO_Setup+0x19e>

        case USB_REQ_GET_DESCRIPTOR:
          if ((req->wValue >> 8) == AUDIO_DESCRIPTOR_TYPE)
 8010b42:	683b      	ldr	r3, [r7, #0]
 8010b44:	885b      	ldrh	r3, [r3, #2]
 8010b46:	0a1b      	lsrs	r3, r3, #8
 8010b48:	b29b      	uxth	r3, r3
 8010b4a:	2b21      	cmp	r3, #33	@ 0x21
 8010b4c:	d15a      	bne.n	8010c04 <USBD_AUDIO_Setup+0x19c>
          {
            pbuf = (uint8_t *)USBD_AUDIO_GetAudioHeaderDesc(pdev->pConfDesc);
 8010b4e:	687b      	ldr	r3, [r7, #4]
 8010b50:	f8d3 32d0 	ldr.w	r3, [r3, #720]	@ 0x2d0
 8010b54:	4618      	mov	r0, r3
 8010b56:	f000 fa3f 	bl	8010fd8 <USBD_AUDIO_GetAudioHeaderDesc>
 8010b5a:	60f8      	str	r0, [r7, #12]
            if (pbuf != NULL)
 8010b5c:	68fb      	ldr	r3, [r7, #12]
 8010b5e:	2b00      	cmp	r3, #0
 8010b60:	d00c      	beq.n	8010b7c <USBD_AUDIO_Setup+0x114>
            {
              len = MIN(USB_AUDIO_DESC_SIZ, req->wLength);
 8010b62:	683b      	ldr	r3, [r7, #0]
 8010b64:	88db      	ldrh	r3, [r3, #6]
 8010b66:	2b09      	cmp	r3, #9
 8010b68:	bf28      	it	cs
 8010b6a:	2309      	movcs	r3, #9
 8010b6c:	817b      	strh	r3, [r7, #10]
              (void)USBD_CtlSendData(pdev, pbuf, len);
 8010b6e:	897b      	ldrh	r3, [r7, #10]
 8010b70:	461a      	mov	r2, r3
 8010b72:	68f9      	ldr	r1, [r7, #12]
 8010b74:	6878      	ldr	r0, [r7, #4]
 8010b76:	f001 fcd5 	bl	8012524 <USBD_CtlSendData>
            {
              USBD_CtlError(pdev, req);
              ret = USBD_FAIL;
            }
          }
          break;
 8010b7a:	e043      	b.n	8010c04 <USBD_AUDIO_Setup+0x19c>
              USBD_CtlError(pdev, req);
 8010b7c:	6839      	ldr	r1, [r7, #0]
 8010b7e:	6878      	ldr	r0, [r7, #4]
 8010b80:	f001 fc53 	bl	801242a <USBD_CtlError>
              ret = USBD_FAIL;
 8010b84:	2303      	movs	r3, #3
 8010b86:	75fb      	strb	r3, [r7, #23]
          break;
 8010b88:	e03c      	b.n	8010c04 <USBD_AUDIO_Setup+0x19c>

        case USB_REQ_GET_INTERFACE:
          if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8010b8a:	687b      	ldr	r3, [r7, #4]
 8010b8c:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 8010b90:	b2db      	uxtb	r3, r3
 8010b92:	2b03      	cmp	r3, #3
 8010b94:	d106      	bne.n	8010ba4 <USBD_AUDIO_Setup+0x13c>
          {
            (void)USBD_CtlSendData(pdev, (uint8_t *)&haudio->alt_setting, 1U);
 8010b96:	693b      	ldr	r3, [r7, #16]
 8010b98:	2201      	movs	r2, #1
 8010b9a:	4619      	mov	r1, r3
 8010b9c:	6878      	ldr	r0, [r7, #4]
 8010b9e:	f001 fcc1 	bl	8012524 <USBD_CtlSendData>
          else
          {
            USBD_CtlError(pdev, req);
            ret = USBD_FAIL;
          }
          break;
 8010ba2:	e030      	b.n	8010c06 <USBD_AUDIO_Setup+0x19e>
            USBD_CtlError(pdev, req);
 8010ba4:	6839      	ldr	r1, [r7, #0]
 8010ba6:	6878      	ldr	r0, [r7, #4]
 8010ba8:	f001 fc3f 	bl	801242a <USBD_CtlError>
            ret = USBD_FAIL;
 8010bac:	2303      	movs	r3, #3
 8010bae:	75fb      	strb	r3, [r7, #23]
          break;
 8010bb0:	e029      	b.n	8010c06 <USBD_AUDIO_Setup+0x19e>

        case USB_REQ_SET_INTERFACE:
          if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8010bb2:	687b      	ldr	r3, [r7, #4]
 8010bb4:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 8010bb8:	b2db      	uxtb	r3, r3
 8010bba:	2b03      	cmp	r3, #3
 8010bbc:	d112      	bne.n	8010be4 <USBD_AUDIO_Setup+0x17c>
          {
            if ((uint8_t)(req->wValue) <= USBD_MAX_NUM_INTERFACES)
 8010bbe:	683b      	ldr	r3, [r7, #0]
 8010bc0:	885b      	ldrh	r3, [r3, #2]
 8010bc2:	b2db      	uxtb	r3, r3
 8010bc4:	2b02      	cmp	r3, #2
 8010bc6:	d806      	bhi.n	8010bd6 <USBD_AUDIO_Setup+0x16e>
            {
              haudio->alt_setting = (uint8_t)(req->wValue);
 8010bc8:	683b      	ldr	r3, [r7, #0]
 8010bca:	885b      	ldrh	r3, [r3, #2]
 8010bcc:	b2db      	uxtb	r3, r3
 8010bce:	461a      	mov	r2, r3
 8010bd0:	693b      	ldr	r3, [r7, #16]
 8010bd2:	601a      	str	r2, [r3, #0]
          else
          {
            USBD_CtlError(pdev, req);
            ret = USBD_FAIL;
          }
          break;
 8010bd4:	e017      	b.n	8010c06 <USBD_AUDIO_Setup+0x19e>
              USBD_CtlError(pdev, req);
 8010bd6:	6839      	ldr	r1, [r7, #0]
 8010bd8:	6878      	ldr	r0, [r7, #4]
 8010bda:	f001 fc26 	bl	801242a <USBD_CtlError>
              ret = USBD_FAIL;
 8010bde:	2303      	movs	r3, #3
 8010be0:	75fb      	strb	r3, [r7, #23]
          break;
 8010be2:	e010      	b.n	8010c06 <USBD_AUDIO_Setup+0x19e>
            USBD_CtlError(pdev, req);
 8010be4:	6839      	ldr	r1, [r7, #0]
 8010be6:	6878      	ldr	r0, [r7, #4]
 8010be8:	f001 fc1f 	bl	801242a <USBD_CtlError>
            ret = USBD_FAIL;
 8010bec:	2303      	movs	r3, #3
 8010bee:	75fb      	strb	r3, [r7, #23]
          break;
 8010bf0:	e009      	b.n	8010c06 <USBD_AUDIO_Setup+0x19e>

        case USB_REQ_CLEAR_FEATURE:
          break;

        default:
          USBD_CtlError(pdev, req);
 8010bf2:	6839      	ldr	r1, [r7, #0]
 8010bf4:	6878      	ldr	r0, [r7, #4]
 8010bf6:	f001 fc18 	bl	801242a <USBD_CtlError>
          ret = USBD_FAIL;
 8010bfa:	2303      	movs	r3, #3
 8010bfc:	75fb      	strb	r3, [r7, #23]
          break;
 8010bfe:	e002      	b.n	8010c06 <USBD_AUDIO_Setup+0x19e>
          break;
 8010c00:	bf00      	nop
 8010c02:	e008      	b.n	8010c16 <USBD_AUDIO_Setup+0x1ae>
          break;
 8010c04:	bf00      	nop
      }
      break;
 8010c06:	e006      	b.n	8010c16 <USBD_AUDIO_Setup+0x1ae>
    default:
      USBD_CtlError(pdev, req);
 8010c08:	6839      	ldr	r1, [r7, #0]
 8010c0a:	6878      	ldr	r0, [r7, #4]
 8010c0c:	f001 fc0d 	bl	801242a <USBD_CtlError>
      ret = USBD_FAIL;
 8010c10:	2303      	movs	r3, #3
 8010c12:	75fb      	strb	r3, [r7, #23]
      break;
 8010c14:	bf00      	nop
  }

  return (uint8_t)ret;
 8010c16:	7dfb      	ldrb	r3, [r7, #23]
}
 8010c18:	4618      	mov	r0, r3
 8010c1a:	3718      	adds	r7, #24
 8010c1c:	46bd      	mov	sp, r7
 8010c1e:	bd80      	pop	{r7, pc}

08010c20 <USBD_AUDIO_GetCfgDesc>:
  *         return configuration descriptor
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
static uint8_t *USBD_AUDIO_GetCfgDesc(uint16_t *length)
{
 8010c20:	b480      	push	{r7}
 8010c22:	b083      	sub	sp, #12
 8010c24:	af00      	add	r7, sp, #0
 8010c26:	6078      	str	r0, [r7, #4]
  *length = (uint16_t)sizeof(USBD_AUDIO_CfgDesc);
 8010c28:	687b      	ldr	r3, [r7, #4]
 8010c2a:	226d      	movs	r2, #109	@ 0x6d
 8010c2c:	801a      	strh	r2, [r3, #0]

  return USBD_AUDIO_CfgDesc;
 8010c2e:	4b03      	ldr	r3, [pc, #12]	@ (8010c3c <USBD_AUDIO_GetCfgDesc+0x1c>)
}
 8010c30:	4618      	mov	r0, r3
 8010c32:	370c      	adds	r7, #12
 8010c34:	46bd      	mov	sp, r7
 8010c36:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010c3a:	4770      	bx	lr
 8010c3c:	24000164 	.word	0x24000164

08010c40 <USBD_AUDIO_DataIn>:
  * @param  pdev: device instance
  * @param  epnum: endpoint index
  * @retval status
  */
static uint8_t USBD_AUDIO_DataIn(USBD_HandleTypeDef *pdev, uint8_t epnum)
{
 8010c40:	b480      	push	{r7}
 8010c42:	b083      	sub	sp, #12
 8010c44:	af00      	add	r7, sp, #0
 8010c46:	6078      	str	r0, [r7, #4]
 8010c48:	460b      	mov	r3, r1
 8010c4a:	70fb      	strb	r3, [r7, #3]
  UNUSED(pdev);
  UNUSED(epnum);

  /* Only OUT data are processed */
  return (uint8_t)USBD_OK;
 8010c4c:	2300      	movs	r3, #0
}
 8010c4e:	4618      	mov	r0, r3
 8010c50:	370c      	adds	r7, #12
 8010c52:	46bd      	mov	sp, r7
 8010c54:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010c58:	4770      	bx	lr

08010c5a <USBD_AUDIO_EP0_RxReady>:
  *         handle EP0 Rx Ready event
  * @param  pdev: device instance
  * @retval status
  */
static uint8_t USBD_AUDIO_EP0_RxReady(USBD_HandleTypeDef *pdev)
{
 8010c5a:	b580      	push	{r7, lr}
 8010c5c:	b084      	sub	sp, #16
 8010c5e:	af00      	add	r7, sp, #0
 8010c60:	6078      	str	r0, [r7, #4]
  USBD_AUDIO_HandleTypeDef *haudio;
  haudio = (USBD_AUDIO_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 8010c62:	687b      	ldr	r3, [r7, #4]
 8010c64:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 8010c68:	687b      	ldr	r3, [r7, #4]
 8010c6a:	32b0      	adds	r2, #176	@ 0xb0
 8010c6c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8010c70:	60fb      	str	r3, [r7, #12]

  if (haudio == NULL)
 8010c72:	68fb      	ldr	r3, [r7, #12]
 8010c74:	2b00      	cmp	r3, #0
 8010c76:	d101      	bne.n	8010c7c <USBD_AUDIO_EP0_RxReady+0x22>
  {
    return (uint8_t)USBD_FAIL;
 8010c78:	2303      	movs	r3, #3
 8010c7a:	e02a      	b.n	8010cd2 <USBD_AUDIO_EP0_RxReady+0x78>
  }

  if (haudio->control.cmd == AUDIO_REQ_SET_CUR)
 8010c7c:	68fb      	ldr	r3, [r7, #12]
 8010c7e:	f503 5340 	add.w	r3, r3, #12288	@ 0x3000
 8010c82:	f893 370a 	ldrb.w	r3, [r3, #1802]	@ 0x70a
 8010c86:	2b01      	cmp	r3, #1
 8010c88:	d122      	bne.n	8010cd0 <USBD_AUDIO_EP0_RxReady+0x76>
  {
    /* In this driver, to simplify code, only SET_CUR request is managed */

    if (haudio->control.unit == AUDIO_OUT_STREAMING_CTRL)
 8010c8a:	68fb      	ldr	r3, [r7, #12]
 8010c8c:	f503 5340 	add.w	r3, r3, #12288	@ 0x3000
 8010c90:	f893 374c 	ldrb.w	r3, [r3, #1868]	@ 0x74c
 8010c94:	2b02      	cmp	r3, #2
 8010c96:	d11b      	bne.n	8010cd0 <USBD_AUDIO_EP0_RxReady+0x76>
    {
      ((USBD_AUDIO_ItfTypeDef *)pdev->pUserData[pdev->classId])->MuteCtl(haudio->control.data[0]);
 8010c98:	687b      	ldr	r3, [r7, #4]
 8010c9a:	f8d3 32d4 	ldr.w	r3, [r3, #724]	@ 0x2d4
 8010c9e:	687a      	ldr	r2, [r7, #4]
 8010ca0:	33b0      	adds	r3, #176	@ 0xb0
 8010ca2:	009b      	lsls	r3, r3, #2
 8010ca4:	4413      	add	r3, r2
 8010ca6:	685b      	ldr	r3, [r3, #4]
 8010ca8:	691b      	ldr	r3, [r3, #16]
 8010caa:	68fa      	ldr	r2, [r7, #12]
 8010cac:	f502 5240 	add.w	r2, r2, #12288	@ 0x3000
 8010cb0:	f892 270b 	ldrb.w	r2, [r2, #1803]	@ 0x70b
 8010cb4:	4610      	mov	r0, r2
 8010cb6:	4798      	blx	r3
      haudio->control.cmd = 0U;
 8010cb8:	68fb      	ldr	r3, [r7, #12]
 8010cba:	f503 5340 	add.w	r3, r3, #12288	@ 0x3000
 8010cbe:	2200      	movs	r2, #0
 8010cc0:	f883 270a 	strb.w	r2, [r3, #1802]	@ 0x70a
      haudio->control.len = 0U;
 8010cc4:	68fb      	ldr	r3, [r7, #12]
 8010cc6:	f503 5340 	add.w	r3, r3, #12288	@ 0x3000
 8010cca:	2200      	movs	r2, #0
 8010ccc:	f883 274b 	strb.w	r2, [r3, #1867]	@ 0x74b
    }
  }

  return (uint8_t)USBD_OK;
 8010cd0:	2300      	movs	r3, #0
}
 8010cd2:	4618      	mov	r0, r3
 8010cd4:	3710      	adds	r7, #16
 8010cd6:	46bd      	mov	sp, r7
 8010cd8:	bd80      	pop	{r7, pc}

08010cda <USBD_AUDIO_EP0_TxReady>:
  *         handle EP0 TRx Ready event
  * @param  pdev: device instance
  * @retval status
  */
static uint8_t USBD_AUDIO_EP0_TxReady(USBD_HandleTypeDef *pdev)
{
 8010cda:	b480      	push	{r7}
 8010cdc:	b083      	sub	sp, #12
 8010cde:	af00      	add	r7, sp, #0
 8010ce0:	6078      	str	r0, [r7, #4]
  UNUSED(pdev);

  /* Only OUT control data are processed */
  return (uint8_t)USBD_OK;
 8010ce2:	2300      	movs	r3, #0
}
 8010ce4:	4618      	mov	r0, r3
 8010ce6:	370c      	adds	r7, #12
 8010ce8:	46bd      	mov	sp, r7
 8010cea:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010cee:	4770      	bx	lr

08010cf0 <USBD_AUDIO_SOF>:
  *         handle SOF event
  * @param  pdev: device instance
  * @retval status
  */
static uint8_t USBD_AUDIO_SOF(USBD_HandleTypeDef *pdev)
{
 8010cf0:	b480      	push	{r7}
 8010cf2:	b083      	sub	sp, #12
 8010cf4:	af00      	add	r7, sp, #0
 8010cf6:	6078      	str	r0, [r7, #4]
  UNUSED(pdev);

  return (uint8_t)USBD_OK;
 8010cf8:	2300      	movs	r3, #0
}
 8010cfa:	4618      	mov	r0, r3
 8010cfc:	370c      	adds	r7, #12
 8010cfe:	46bd      	mov	sp, r7
 8010d00:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010d04:	4770      	bx	lr

08010d06 <USBD_AUDIO_IsoINIncomplete>:
  * @param  pdev: device instance
  * @param  epnum: endpoint index
  * @retval status
  */
static uint8_t USBD_AUDIO_IsoINIncomplete(USBD_HandleTypeDef *pdev, uint8_t epnum)
{
 8010d06:	b480      	push	{r7}
 8010d08:	b083      	sub	sp, #12
 8010d0a:	af00      	add	r7, sp, #0
 8010d0c:	6078      	str	r0, [r7, #4]
 8010d0e:	460b      	mov	r3, r1
 8010d10:	70fb      	strb	r3, [r7, #3]
  UNUSED(pdev);
  UNUSED(epnum);

  return (uint8_t)USBD_OK;
 8010d12:	2300      	movs	r3, #0
}
 8010d14:	4618      	mov	r0, r3
 8010d16:	370c      	adds	r7, #12
 8010d18:	46bd      	mov	sp, r7
 8010d1a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010d1e:	4770      	bx	lr

08010d20 <USBD_AUDIO_IsoOutIncomplete>:
  * @param  pdev: device instance
  * @param  epnum: endpoint index
  * @retval status
  */
static uint8_t USBD_AUDIO_IsoOutIncomplete(USBD_HandleTypeDef *pdev, uint8_t epnum)
{
 8010d20:	b580      	push	{r7, lr}
 8010d22:	b084      	sub	sp, #16
 8010d24:	af00      	add	r7, sp, #0
 8010d26:	6078      	str	r0, [r7, #4]
 8010d28:	460b      	mov	r3, r1
 8010d2a:	70fb      	strb	r3, [r7, #3]
  USBD_AUDIO_HandleTypeDef *haudio;

  if (pdev->pClassDataCmsit[pdev->classId] == NULL)
 8010d2c:	687b      	ldr	r3, [r7, #4]
 8010d2e:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 8010d32:	687b      	ldr	r3, [r7, #4]
 8010d34:	32b0      	adds	r2, #176	@ 0xb0
 8010d36:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8010d3a:	2b00      	cmp	r3, #0
 8010d3c:	d101      	bne.n	8010d42 <USBD_AUDIO_IsoOutIncomplete+0x22>
  {
    return (uint8_t)USBD_FAIL;
 8010d3e:	2303      	movs	r3, #3
 8010d40:	e016      	b.n	8010d70 <USBD_AUDIO_IsoOutIncomplete+0x50>
  }

  haudio = (USBD_AUDIO_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 8010d42:	687b      	ldr	r3, [r7, #4]
 8010d44:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 8010d48:	687b      	ldr	r3, [r7, #4]
 8010d4a:	32b0      	adds	r2, #176	@ 0xb0
 8010d4c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8010d50:	60fb      	str	r3, [r7, #12]

  /* Prepare Out endpoint to receive next audio packet */
  (void)USBD_LL_PrepareReceive(pdev, epnum,
                               &haudio->buffer[haudio->wr_ptr],
 8010d52:	68fb      	ldr	r3, [r7, #12]
 8010d54:	f503 5340 	add.w	r3, r3, #12288	@ 0x3000
 8010d58:	f8b3 3708 	ldrh.w	r3, [r3, #1800]	@ 0x708
 8010d5c:	461a      	mov	r2, r3
  (void)USBD_LL_PrepareReceive(pdev, epnum,
 8010d5e:	68fb      	ldr	r3, [r7, #12]
 8010d60:	4413      	add	r3, r2
 8010d62:	1d1a      	adds	r2, r3, #4
 8010d64:	78f9      	ldrb	r1, [r7, #3]
 8010d66:	23b0      	movs	r3, #176	@ 0xb0
 8010d68:	6878      	ldr	r0, [r7, #4]
 8010d6a:	f002 f8a7 	bl	8012ebc <USBD_LL_PrepareReceive>
                               AUDIO_OUT_PACKET);

  return (uint8_t)USBD_OK;
 8010d6e:	2300      	movs	r3, #0
}
 8010d70:	4618      	mov	r0, r3
 8010d72:	3710      	adds	r7, #16
 8010d74:	46bd      	mov	sp, r7
 8010d76:	bd80      	pop	{r7, pc}

08010d78 <USBD_AUDIO_DataOut>:
  * @param  pdev: device instance
  * @param  epnum: endpoint index
  * @retval status
  */
static uint8_t USBD_AUDIO_DataOut(USBD_HandleTypeDef *pdev, uint8_t epnum)
{
 8010d78:	b580      	push	{r7, lr}
 8010d7a:	b084      	sub	sp, #16
 8010d7c:	af00      	add	r7, sp, #0
 8010d7e:	6078      	str	r0, [r7, #4]
 8010d80:	460b      	mov	r3, r1
 8010d82:	70fb      	strb	r3, [r7, #3]
#ifdef USE_USBD_COMPOSITE
  /* Get the Endpoints addresses allocated for this class instance */
  AUDIOOutEpAdd = USBD_CoreGetEPAdd(pdev, USBD_EP_OUT, USBD_EP_TYPE_ISOC, (uint8_t)pdev->classId);
#endif /* USE_USBD_COMPOSITE */

  haudio = (USBD_AUDIO_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 8010d84:	687b      	ldr	r3, [r7, #4]
 8010d86:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 8010d8a:	687b      	ldr	r3, [r7, #4]
 8010d8c:	32b0      	adds	r2, #176	@ 0xb0
 8010d8e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8010d92:	60fb      	str	r3, [r7, #12]

  if (haudio == NULL)
 8010d94:	68fb      	ldr	r3, [r7, #12]
 8010d96:	2b00      	cmp	r3, #0
 8010d98:	d101      	bne.n	8010d9e <USBD_AUDIO_DataOut+0x26>
  {
    return (uint8_t)USBD_FAIL;
 8010d9a:	2303      	movs	r3, #3
 8010d9c:	e07c      	b.n	8010e98 <USBD_AUDIO_DataOut+0x120>
  }

  if (epnum == AUDIOOutEpAdd)
 8010d9e:	4b40      	ldr	r3, [pc, #256]	@ (8010ea0 <USBD_AUDIO_DataOut+0x128>)
 8010da0:	781b      	ldrb	r3, [r3, #0]
 8010da2:	78fa      	ldrb	r2, [r7, #3]
 8010da4:	429a      	cmp	r2, r3
 8010da6:	d176      	bne.n	8010e96 <USBD_AUDIO_DataOut+0x11e>
  {
    /* Get received data packet length */
    PacketSize = (uint16_t)USBD_LL_GetRxDataSize(pdev, epnum);
 8010da8:	78fb      	ldrb	r3, [r7, #3]
 8010daa:	4619      	mov	r1, r3
 8010dac:	6878      	ldr	r0, [r7, #4]
 8010dae:	f002 f8a6 	bl	8012efe <USBD_LL_GetRxDataSize>
 8010db2:	4603      	mov	r3, r0
 8010db4:	817b      	strh	r3, [r7, #10]

    /* Packet received Callback */
    ((USBD_AUDIO_ItfTypeDef *)pdev->pUserData[pdev->classId])->PeriodicTC(&haudio->buffer[haudio->wr_ptr],
 8010db6:	687b      	ldr	r3, [r7, #4]
 8010db8:	f8d3 32d4 	ldr.w	r3, [r3, #724]	@ 0x2d4
 8010dbc:	687a      	ldr	r2, [r7, #4]
 8010dbe:	33b0      	adds	r3, #176	@ 0xb0
 8010dc0:	009b      	lsls	r3, r3, #2
 8010dc2:	4413      	add	r3, r2
 8010dc4:	685b      	ldr	r3, [r3, #4]
 8010dc6:	695b      	ldr	r3, [r3, #20]
 8010dc8:	68fa      	ldr	r2, [r7, #12]
 8010dca:	f502 5240 	add.w	r2, r2, #12288	@ 0x3000
 8010dce:	f8b2 2708 	ldrh.w	r2, [r2, #1800]	@ 0x708
 8010dd2:	4611      	mov	r1, r2
 8010dd4:	68fa      	ldr	r2, [r7, #12]
 8010dd6:	440a      	add	r2, r1
 8010dd8:	1d10      	adds	r0, r2, #4
 8010dda:	8979      	ldrh	r1, [r7, #10]
 8010ddc:	2201      	movs	r2, #1
 8010dde:	4798      	blx	r3
                                                                          PacketSize, AUDIO_OUT_TC);

    /* Increment the Buffer pointer or roll it back when all buffers are full */
    haudio->wr_ptr += PacketSize;
 8010de0:	68fb      	ldr	r3, [r7, #12]
 8010de2:	f503 5340 	add.w	r3, r3, #12288	@ 0x3000
 8010de6:	f8b3 2708 	ldrh.w	r2, [r3, #1800]	@ 0x708
 8010dea:	897b      	ldrh	r3, [r7, #10]
 8010dec:	4413      	add	r3, r2
 8010dee:	b29a      	uxth	r2, r3
 8010df0:	68fb      	ldr	r3, [r7, #12]
 8010df2:	f503 5340 	add.w	r3, r3, #12288	@ 0x3000
 8010df6:	f8a3 2708 	strh.w	r2, [r3, #1800]	@ 0x708

    if (haudio->wr_ptr >= AUDIO_TOTAL_BUF_SIZE)
 8010dfa:	68fb      	ldr	r3, [r7, #12]
 8010dfc:	f503 5340 	add.w	r3, r3, #12288	@ 0x3000
 8010e00:	f8b3 3708 	ldrh.w	r3, [r3, #1800]	@ 0x708
 8010e04:	f5b3 5f5c 	cmp.w	r3, #14080	@ 0x3700
 8010e08:	d321      	bcc.n	8010e4e <USBD_AUDIO_DataOut+0xd6>
    {
      /* All buffers are full: roll back */
      haudio->wr_ptr = 0U;
 8010e0a:	68fb      	ldr	r3, [r7, #12]
 8010e0c:	f503 5340 	add.w	r3, r3, #12288	@ 0x3000
 8010e10:	2200      	movs	r2, #0
 8010e12:	f8a3 2708 	strh.w	r2, [r3, #1800]	@ 0x708

      if (haudio->offset == AUDIO_OFFSET_UNKNOWN)
 8010e16:	68fb      	ldr	r3, [r7, #12]
 8010e18:	f503 5340 	add.w	r3, r3, #12288	@ 0x3000
 8010e1c:	f893 3704 	ldrb.w	r3, [r3, #1796]	@ 0x704
 8010e20:	2b03      	cmp	r3, #3
 8010e22:	d114      	bne.n	8010e4e <USBD_AUDIO_DataOut+0xd6>
      {
        ((USBD_AUDIO_ItfTypeDef *)pdev->pUserData[pdev->classId])->AudioCmd(&haudio->buffer[0],
 8010e24:	687b      	ldr	r3, [r7, #4]
 8010e26:	f8d3 32d4 	ldr.w	r3, [r3, #724]	@ 0x2d4
 8010e2a:	687a      	ldr	r2, [r7, #4]
 8010e2c:	33b0      	adds	r3, #176	@ 0xb0
 8010e2e:	009b      	lsls	r3, r3, #2
 8010e30:	4413      	add	r3, r2
 8010e32:	685b      	ldr	r3, [r3, #4]
 8010e34:	689b      	ldr	r3, [r3, #8]
 8010e36:	68fa      	ldr	r2, [r7, #12]
 8010e38:	1d10      	adds	r0, r2, #4
 8010e3a:	2201      	movs	r2, #1
 8010e3c:	f44f 51dc 	mov.w	r1, #7040	@ 0x1b80
 8010e40:	4798      	blx	r3
                                                                            AUDIO_TOTAL_BUF_SIZE / 2U,
                                                                            AUDIO_CMD_START);
        haudio->offset = AUDIO_OFFSET_NONE;
 8010e42:	68fb      	ldr	r3, [r7, #12]
 8010e44:	f503 5340 	add.w	r3, r3, #12288	@ 0x3000
 8010e48:	2200      	movs	r2, #0
 8010e4a:	f883 2704 	strb.w	r2, [r3, #1796]	@ 0x704
      }
    }

    if (haudio->rd_enable == 0U)
 8010e4e:	68fb      	ldr	r3, [r7, #12]
 8010e50:	f503 5340 	add.w	r3, r3, #12288	@ 0x3000
 8010e54:	f893 3705 	ldrb.w	r3, [r3, #1797]	@ 0x705
 8010e58:	2b00      	cmp	r3, #0
 8010e5a:	d10d      	bne.n	8010e78 <USBD_AUDIO_DataOut+0x100>
    {
      if (haudio->wr_ptr == (AUDIO_TOTAL_BUF_SIZE / 2U))
 8010e5c:	68fb      	ldr	r3, [r7, #12]
 8010e5e:	f503 5340 	add.w	r3, r3, #12288	@ 0x3000
 8010e62:	f8b3 3708 	ldrh.w	r3, [r3, #1800]	@ 0x708
 8010e66:	f5b3 5fdc 	cmp.w	r3, #7040	@ 0x1b80
 8010e6a:	d105      	bne.n	8010e78 <USBD_AUDIO_DataOut+0x100>
      {
        haudio->rd_enable = 1U;
 8010e6c:	68fb      	ldr	r3, [r7, #12]
 8010e6e:	f503 5340 	add.w	r3, r3, #12288	@ 0x3000
 8010e72:	2201      	movs	r2, #1
 8010e74:	f883 2705 	strb.w	r2, [r3, #1797]	@ 0x705
      }
    }

    /* Prepare Out endpoint to receive next audio packet */
    (void)USBD_LL_PrepareReceive(pdev, AUDIOOutEpAdd,
 8010e78:	4b09      	ldr	r3, [pc, #36]	@ (8010ea0 <USBD_AUDIO_DataOut+0x128>)
 8010e7a:	7819      	ldrb	r1, [r3, #0]
                                 &haudio->buffer[haudio->wr_ptr],
 8010e7c:	68fb      	ldr	r3, [r7, #12]
 8010e7e:	f503 5340 	add.w	r3, r3, #12288	@ 0x3000
 8010e82:	f8b3 3708 	ldrh.w	r3, [r3, #1800]	@ 0x708
 8010e86:	461a      	mov	r2, r3
    (void)USBD_LL_PrepareReceive(pdev, AUDIOOutEpAdd,
 8010e88:	68fb      	ldr	r3, [r7, #12]
 8010e8a:	4413      	add	r3, r2
 8010e8c:	1d1a      	adds	r2, r3, #4
 8010e8e:	23b0      	movs	r3, #176	@ 0xb0
 8010e90:	6878      	ldr	r0, [r7, #4]
 8010e92:	f002 f813 	bl	8012ebc <USBD_LL_PrepareReceive>
                                 AUDIO_OUT_PACKET);
  }

  return (uint8_t)USBD_OK;
 8010e96:	2300      	movs	r3, #0
}
 8010e98:	4618      	mov	r0, r3
 8010e9a:	3710      	adds	r7, #16
 8010e9c:	46bd      	mov	sp, r7
 8010e9e:	bd80      	pop	{r7, pc}
 8010ea0:	240001de 	.word	0x240001de

08010ea4 <AUDIO_REQ_GetCurrent>:
  * @param  pdev: device instance
  * @param  req: setup class request
  * @retval status
  */
static void AUDIO_REQ_GetCurrent(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 8010ea4:	b580      	push	{r7, lr}
 8010ea6:	b084      	sub	sp, #16
 8010ea8:	af00      	add	r7, sp, #0
 8010eaa:	6078      	str	r0, [r7, #4]
 8010eac:	6039      	str	r1, [r7, #0]
  USBD_AUDIO_HandleTypeDef *haudio;
  haudio = (USBD_AUDIO_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 8010eae:	687b      	ldr	r3, [r7, #4]
 8010eb0:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 8010eb4:	687b      	ldr	r3, [r7, #4]
 8010eb6:	32b0      	adds	r2, #176	@ 0xb0
 8010eb8:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8010ebc:	60fb      	str	r3, [r7, #12]

  if (haudio == NULL)
 8010ebe:	68fb      	ldr	r3, [r7, #12]
 8010ec0:	2b00      	cmp	r3, #0
 8010ec2:	d017      	beq.n	8010ef4 <AUDIO_REQ_GetCurrent+0x50>
  {
    return;
  }

  (void)USBD_memset(haudio->control.data, 0, USB_MAX_EP0_SIZE);
 8010ec4:	68fa      	ldr	r2, [r7, #12]
 8010ec6:	f243 730b 	movw	r3, #14091	@ 0x370b
 8010eca:	4413      	add	r3, r2
 8010ecc:	2240      	movs	r2, #64	@ 0x40
 8010ece:	2100      	movs	r1, #0
 8010ed0:	4618      	mov	r0, r3
 8010ed2:	f002 f86b 	bl	8012fac <memset>

  /* Send the current mute state */
  (void)USBD_CtlSendData(pdev, haudio->control.data,
 8010ed6:	68fa      	ldr	r2, [r7, #12]
 8010ed8:	f243 730b 	movw	r3, #14091	@ 0x370b
 8010edc:	4413      	add	r3, r2
                         MIN(req->wLength, USB_MAX_EP0_SIZE));
 8010ede:	683a      	ldr	r2, [r7, #0]
 8010ee0:	88d2      	ldrh	r2, [r2, #6]
 8010ee2:	2a40      	cmp	r2, #64	@ 0x40
 8010ee4:	bf28      	it	cs
 8010ee6:	2240      	movcs	r2, #64	@ 0x40
 8010ee8:	b292      	uxth	r2, r2
  (void)USBD_CtlSendData(pdev, haudio->control.data,
 8010eea:	4619      	mov	r1, r3
 8010eec:	6878      	ldr	r0, [r7, #4]
 8010eee:	f001 fb19 	bl	8012524 <USBD_CtlSendData>
 8010ef2:	e000      	b.n	8010ef6 <AUDIO_REQ_GetCurrent+0x52>
    return;
 8010ef4:	bf00      	nop
}
 8010ef6:	3710      	adds	r7, #16
 8010ef8:	46bd      	mov	sp, r7
 8010efa:	bd80      	pop	{r7, pc}

08010efc <AUDIO_REQ_SetCurrent>:
  * @param  pdev: device instance
  * @param  req: setup class request
  * @retval status
  */
static void AUDIO_REQ_SetCurrent(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 8010efc:	b580      	push	{r7, lr}
 8010efe:	b084      	sub	sp, #16
 8010f00:	af00      	add	r7, sp, #0
 8010f02:	6078      	str	r0, [r7, #4]
 8010f04:	6039      	str	r1, [r7, #0]
  USBD_AUDIO_HandleTypeDef *haudio;
  haudio = (USBD_AUDIO_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 8010f06:	687b      	ldr	r3, [r7, #4]
 8010f08:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 8010f0c:	687b      	ldr	r3, [r7, #4]
 8010f0e:	32b0      	adds	r2, #176	@ 0xb0
 8010f10:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8010f14:	60fb      	str	r3, [r7, #12]

  if (haudio == NULL)
 8010f16:	68fb      	ldr	r3, [r7, #12]
 8010f18:	2b00      	cmp	r3, #0
 8010f1a:	d02f      	beq.n	8010f7c <AUDIO_REQ_SetCurrent+0x80>
  {
    return;
  }

  if (req->wLength != 0U)
 8010f1c:	683b      	ldr	r3, [r7, #0]
 8010f1e:	88db      	ldrh	r3, [r3, #6]
 8010f20:	2b00      	cmp	r3, #0
 8010f22:	d02c      	beq.n	8010f7e <AUDIO_REQ_SetCurrent+0x82>
  {
    haudio->control.cmd = AUDIO_REQ_SET_CUR;     /* Set the request value */
 8010f24:	68fb      	ldr	r3, [r7, #12]
 8010f26:	f503 5340 	add.w	r3, r3, #12288	@ 0x3000
 8010f2a:	2201      	movs	r2, #1
 8010f2c:	f883 270a 	strb.w	r2, [r3, #1802]	@ 0x70a
    haudio->control.len = (uint8_t)MIN(req->wLength, USB_MAX_EP0_SIZE);  /* Set the request data length */
 8010f30:	683b      	ldr	r3, [r7, #0]
 8010f32:	88db      	ldrh	r3, [r3, #6]
 8010f34:	2b3f      	cmp	r3, #63	@ 0x3f
 8010f36:	d803      	bhi.n	8010f40 <AUDIO_REQ_SetCurrent+0x44>
 8010f38:	683b      	ldr	r3, [r7, #0]
 8010f3a:	88db      	ldrh	r3, [r3, #6]
 8010f3c:	b2da      	uxtb	r2, r3
 8010f3e:	e000      	b.n	8010f42 <AUDIO_REQ_SetCurrent+0x46>
 8010f40:	2240      	movs	r2, #64	@ 0x40
 8010f42:	68fb      	ldr	r3, [r7, #12]
 8010f44:	f503 5340 	add.w	r3, r3, #12288	@ 0x3000
 8010f48:	f883 274b 	strb.w	r2, [r3, #1867]	@ 0x74b
    haudio->control.unit = HIBYTE(req->wIndex);  /* Set the request target unit */
 8010f4c:	683b      	ldr	r3, [r7, #0]
 8010f4e:	889b      	ldrh	r3, [r3, #4]
 8010f50:	0a1b      	lsrs	r3, r3, #8
 8010f52:	b29b      	uxth	r3, r3
 8010f54:	b2da      	uxtb	r2, r3
 8010f56:	68fb      	ldr	r3, [r7, #12]
 8010f58:	f503 5340 	add.w	r3, r3, #12288	@ 0x3000
 8010f5c:	f883 274c 	strb.w	r2, [r3, #1868]	@ 0x74c

    /* Prepare the reception of the buffer over EP0 */
    (void)USBD_CtlPrepareRx(pdev, haudio->control.data, haudio->control.len);
 8010f60:	68fa      	ldr	r2, [r7, #12]
 8010f62:	f243 730b 	movw	r3, #14091	@ 0x370b
 8010f66:	4413      	add	r3, r2
 8010f68:	68fa      	ldr	r2, [r7, #12]
 8010f6a:	f502 5240 	add.w	r2, r2, #12288	@ 0x3000
 8010f6e:	f892 274b 	ldrb.w	r2, [r2, #1867]	@ 0x74b
 8010f72:	4619      	mov	r1, r3
 8010f74:	6878      	ldr	r0, [r7, #4]
 8010f76:	f001 fb01 	bl	801257c <USBD_CtlPrepareRx>
 8010f7a:	e000      	b.n	8010f7e <AUDIO_REQ_SetCurrent+0x82>
    return;
 8010f7c:	bf00      	nop
  }
}
 8010f7e:	3710      	adds	r7, #16
 8010f80:	46bd      	mov	sp, r7
 8010f82:	bd80      	pop	{r7, pc}

08010f84 <USBD_AUDIO_GetDeviceQualifierDesc>:
  *         return Device Qualifier descriptor
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
static uint8_t *USBD_AUDIO_GetDeviceQualifierDesc(uint16_t *length)
{
 8010f84:	b480      	push	{r7}
 8010f86:	b083      	sub	sp, #12
 8010f88:	af00      	add	r7, sp, #0
 8010f8a:	6078      	str	r0, [r7, #4]
  *length = (uint16_t)sizeof(USBD_AUDIO_DeviceQualifierDesc);
 8010f8c:	687b      	ldr	r3, [r7, #4]
 8010f8e:	220a      	movs	r2, #10
 8010f90:	801a      	strh	r2, [r3, #0]

  return USBD_AUDIO_DeviceQualifierDesc;
 8010f92:	4b03      	ldr	r3, [pc, #12]	@ (8010fa0 <USBD_AUDIO_GetDeviceQualifierDesc+0x1c>)
}
 8010f94:	4618      	mov	r0, r3
 8010f96:	370c      	adds	r7, #12
 8010f98:	46bd      	mov	sp, r7
 8010f9a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010f9e:	4770      	bx	lr
 8010fa0:	240001d4 	.word	0x240001d4

08010fa4 <USBD_AUDIO_RegisterInterface>:
  * @param  fops: Audio interface callback
  * @retval status
  */
uint8_t USBD_AUDIO_RegisterInterface(USBD_HandleTypeDef *pdev,
                                     USBD_AUDIO_ItfTypeDef *fops)
{
 8010fa4:	b480      	push	{r7}
 8010fa6:	b083      	sub	sp, #12
 8010fa8:	af00      	add	r7, sp, #0
 8010faa:	6078      	str	r0, [r7, #4]
 8010fac:	6039      	str	r1, [r7, #0]
  if (fops == NULL)
 8010fae:	683b      	ldr	r3, [r7, #0]
 8010fb0:	2b00      	cmp	r3, #0
 8010fb2:	d101      	bne.n	8010fb8 <USBD_AUDIO_RegisterInterface+0x14>
  {
    return (uint8_t)USBD_FAIL;
 8010fb4:	2303      	movs	r3, #3
 8010fb6:	e009      	b.n	8010fcc <USBD_AUDIO_RegisterInterface+0x28>
  }

  pdev->pUserData[pdev->classId] = fops;
 8010fb8:	687b      	ldr	r3, [r7, #4]
 8010fba:	f8d3 32d4 	ldr.w	r3, [r3, #724]	@ 0x2d4
 8010fbe:	687a      	ldr	r2, [r7, #4]
 8010fc0:	33b0      	adds	r3, #176	@ 0xb0
 8010fc2:	009b      	lsls	r3, r3, #2
 8010fc4:	4413      	add	r3, r2
 8010fc6:	683a      	ldr	r2, [r7, #0]
 8010fc8:	605a      	str	r2, [r3, #4]

  return (uint8_t)USBD_OK;
 8010fca:	2300      	movs	r3, #0
}
 8010fcc:	4618      	mov	r0, r3
 8010fce:	370c      	adds	r7, #12
 8010fd0:	46bd      	mov	sp, r7
 8010fd2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010fd6:	4770      	bx	lr

08010fd8 <USBD_AUDIO_GetAudioHeaderDesc>:
  * @param  pdev: device instance
  * @param  pConfDesc:  pointer to Bos descriptor
  * @retval pointer to the Audio AC Header descriptor
  */
static void *USBD_AUDIO_GetAudioHeaderDesc(uint8_t *pConfDesc)
{
 8010fd8:	b580      	push	{r7, lr}
 8010fda:	b086      	sub	sp, #24
 8010fdc:	af00      	add	r7, sp, #0
 8010fde:	6078      	str	r0, [r7, #4]
  USBD_ConfigDescTypeDef *desc = (USBD_ConfigDescTypeDef *)(void *)pConfDesc;
 8010fe0:	687b      	ldr	r3, [r7, #4]
 8010fe2:	60fb      	str	r3, [r7, #12]
  USBD_DescHeaderTypeDef *pdesc = (USBD_DescHeaderTypeDef *)(void *)pConfDesc;
 8010fe4:	687b      	ldr	r3, [r7, #4]
 8010fe6:	617b      	str	r3, [r7, #20]
  uint8_t *pAudioDesc =  NULL;
 8010fe8:	2300      	movs	r3, #0
 8010fea:	613b      	str	r3, [r7, #16]
  uint16_t ptr;

  if (desc->wTotalLength > desc->bLength)
 8010fec:	68fb      	ldr	r3, [r7, #12]
 8010fee:	885b      	ldrh	r3, [r3, #2]
 8010ff0:	b29b      	uxth	r3, r3
 8010ff2:	68fa      	ldr	r2, [r7, #12]
 8010ff4:	7812      	ldrb	r2, [r2, #0]
 8010ff6:	4293      	cmp	r3, r2
 8010ff8:	d91b      	bls.n	8011032 <USBD_AUDIO_GetAudioHeaderDesc+0x5a>
  {
    ptr = desc->bLength;
 8010ffa:	68fb      	ldr	r3, [r7, #12]
 8010ffc:	781b      	ldrb	r3, [r3, #0]
 8010ffe:	817b      	strh	r3, [r7, #10]

    while (ptr < desc->wTotalLength)
 8011000:	e011      	b.n	8011026 <USBD_AUDIO_GetAudioHeaderDesc+0x4e>
    {
      pdesc = USBD_GetNextDesc((uint8_t *)pdesc, &ptr);
 8011002:	f107 030a 	add.w	r3, r7, #10
 8011006:	4619      	mov	r1, r3
 8011008:	6978      	ldr	r0, [r7, #20]
 801100a:	f000 fbe6 	bl	80117da <USBD_GetNextDesc>
 801100e:	6178      	str	r0, [r7, #20]
      if ((pdesc->bDescriptorType == AUDIO_INTERFACE_DESCRIPTOR_TYPE) &&
 8011010:	697b      	ldr	r3, [r7, #20]
 8011012:	785b      	ldrb	r3, [r3, #1]
 8011014:	2b24      	cmp	r3, #36	@ 0x24
 8011016:	d106      	bne.n	8011026 <USBD_AUDIO_GetAudioHeaderDesc+0x4e>
          (pdesc->bDescriptorSubType == AUDIO_CONTROL_HEADER))
 8011018:	697b      	ldr	r3, [r7, #20]
 801101a:	789b      	ldrb	r3, [r3, #2]
      if ((pdesc->bDescriptorType == AUDIO_INTERFACE_DESCRIPTOR_TYPE) &&
 801101c:	2b01      	cmp	r3, #1
 801101e:	d102      	bne.n	8011026 <USBD_AUDIO_GetAudioHeaderDesc+0x4e>
      {
        pAudioDesc = (uint8_t *)pdesc;
 8011020:	697b      	ldr	r3, [r7, #20]
 8011022:	613b      	str	r3, [r7, #16]
        break;
 8011024:	e005      	b.n	8011032 <USBD_AUDIO_GetAudioHeaderDesc+0x5a>
    while (ptr < desc->wTotalLength)
 8011026:	68fb      	ldr	r3, [r7, #12]
 8011028:	885b      	ldrh	r3, [r3, #2]
 801102a:	b29a      	uxth	r2, r3
 801102c:	897b      	ldrh	r3, [r7, #10]
 801102e:	429a      	cmp	r2, r3
 8011030:	d8e7      	bhi.n	8011002 <USBD_AUDIO_GetAudioHeaderDesc+0x2a>
      }
    }
  }
  return pAudioDesc;
 8011032:	693b      	ldr	r3, [r7, #16]
}
 8011034:	4618      	mov	r0, r3
 8011036:	3718      	adds	r7, #24
 8011038:	46bd      	mov	sp, r7
 801103a:	bd80      	pop	{r7, pc}

0801103c <USBD_Init>:
  * @param  id: Low level core index
  * @retval status: USBD Status
  */
USBD_StatusTypeDef USBD_Init(USBD_HandleTypeDef *pdev,
                             USBD_DescriptorsTypeDef *pdesc, uint8_t id)
{
 801103c:	b580      	push	{r7, lr}
 801103e:	b086      	sub	sp, #24
 8011040:	af00      	add	r7, sp, #0
 8011042:	60f8      	str	r0, [r7, #12]
 8011044:	60b9      	str	r1, [r7, #8]
 8011046:	4613      	mov	r3, r2
 8011048:	71fb      	strb	r3, [r7, #7]
  USBD_StatusTypeDef ret;

  /* Check whether the USB Host handle is valid */
  if (pdev == NULL)
 801104a:	68fb      	ldr	r3, [r7, #12]
 801104c:	2b00      	cmp	r3, #0
 801104e:	d101      	bne.n	8011054 <USBD_Init+0x18>
  {
#if (USBD_DEBUG_LEVEL > 1U)
    USBD_ErrLog("Invalid Device handle");
#endif /* (USBD_DEBUG_LEVEL > 1U) */
    return USBD_FAIL;
 8011050:	2303      	movs	r3, #3
 8011052:	e01f      	b.n	8011094 <USBD_Init+0x58>
    pdev->NumClasses = 0;
    pdev->classId = 0;
  }
#else
  /* Unlink previous class*/
  pdev->pClass[0] = NULL;
 8011054:	68fb      	ldr	r3, [r7, #12]
 8011056:	2200      	movs	r2, #0
 8011058:	f8c3 22b8 	str.w	r2, [r3, #696]	@ 0x2b8
  pdev->pUserData[0] = NULL;
 801105c:	68fb      	ldr	r3, [r7, #12]
 801105e:	2200      	movs	r2, #0
 8011060:	f8c3 22c4 	str.w	r2, [r3, #708]	@ 0x2c4
#endif /* USE_USBD_COMPOSITE */

  pdev->pConfDesc = NULL;
 8011064:	68fb      	ldr	r3, [r7, #12]
 8011066:	2200      	movs	r2, #0
 8011068:	f8c3 22d0 	str.w	r2, [r3, #720]	@ 0x2d0

  /* Assign USBD Descriptors */
  if (pdesc != NULL)
 801106c:	68bb      	ldr	r3, [r7, #8]
 801106e:	2b00      	cmp	r3, #0
 8011070:	d003      	beq.n	801107a <USBD_Init+0x3e>
  {
    pdev->pDesc = pdesc;
 8011072:	68fb      	ldr	r3, [r7, #12]
 8011074:	68ba      	ldr	r2, [r7, #8]
 8011076:	f8c3 22b4 	str.w	r2, [r3, #692]	@ 0x2b4
  }

  /* Set Device initial State */
  pdev->dev_state = USBD_STATE_DEFAULT;
 801107a:	68fb      	ldr	r3, [r7, #12]
 801107c:	2201      	movs	r2, #1
 801107e:	f883 229c 	strb.w	r2, [r3, #668]	@ 0x29c
  pdev->id = id;
 8011082:	68fb      	ldr	r3, [r7, #12]
 8011084:	79fa      	ldrb	r2, [r7, #7]
 8011086:	701a      	strb	r2, [r3, #0]

  /* Initialize low level driver */
  ret = USBD_LL_Init(pdev);
 8011088:	68f8      	ldr	r0, [r7, #12]
 801108a:	f001 fdbb 	bl	8012c04 <USBD_LL_Init>
 801108e:	4603      	mov	r3, r0
 8011090:	75fb      	strb	r3, [r7, #23]

  return ret;
 8011092:	7dfb      	ldrb	r3, [r7, #23]
}
 8011094:	4618      	mov	r0, r3
 8011096:	3718      	adds	r7, #24
 8011098:	46bd      	mov	sp, r7
 801109a:	bd80      	pop	{r7, pc}

0801109c <USBD_RegisterClass>:
  * @param  pdev: Device Handle
  * @param  pclass: Class handle
  * @retval USBD Status
  */
USBD_StatusTypeDef USBD_RegisterClass(USBD_HandleTypeDef *pdev, USBD_ClassTypeDef *pclass)
{
 801109c:	b580      	push	{r7, lr}
 801109e:	b084      	sub	sp, #16
 80110a0:	af00      	add	r7, sp, #0
 80110a2:	6078      	str	r0, [r7, #4]
 80110a4:	6039      	str	r1, [r7, #0]
  uint16_t len = 0U;
 80110a6:	2300      	movs	r3, #0
 80110a8:	81fb      	strh	r3, [r7, #14]

  if (pclass == NULL)
 80110aa:	683b      	ldr	r3, [r7, #0]
 80110ac:	2b00      	cmp	r3, #0
 80110ae:	d101      	bne.n	80110b4 <USBD_RegisterClass+0x18>
  {
#if (USBD_DEBUG_LEVEL > 1U)
    USBD_ErrLog("Invalid Class handle");
#endif /* (USBD_DEBUG_LEVEL > 1U) */
    return USBD_FAIL;
 80110b0:	2303      	movs	r3, #3
 80110b2:	e025      	b.n	8011100 <USBD_RegisterClass+0x64>
  }

  /* link the class to the USB Device handle */
  pdev->pClass[0] = pclass;
 80110b4:	687b      	ldr	r3, [r7, #4]
 80110b6:	683a      	ldr	r2, [r7, #0]
 80110b8:	f8c3 22b8 	str.w	r2, [r3, #696]	@ 0x2b8
  if (pdev->pClass[pdev->classId]->GetHSConfigDescriptor != NULL)
  {
    pdev->pConfDesc = (void *)pdev->pClass[pdev->classId]->GetHSConfigDescriptor(&len);
  }
#else /* Default USE_USB_FS */
  if (pdev->pClass[pdev->classId]->GetFSConfigDescriptor != NULL)
 80110bc:	687b      	ldr	r3, [r7, #4]
 80110be:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 80110c2:	687b      	ldr	r3, [r7, #4]
 80110c4:	32ae      	adds	r2, #174	@ 0xae
 80110c6:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80110ca:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80110cc:	2b00      	cmp	r3, #0
 80110ce:	d00f      	beq.n	80110f0 <USBD_RegisterClass+0x54>
  {
    pdev->pConfDesc = (void *)pdev->pClass[pdev->classId]->GetFSConfigDescriptor(&len);
 80110d0:	687b      	ldr	r3, [r7, #4]
 80110d2:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 80110d6:	687b      	ldr	r3, [r7, #4]
 80110d8:	32ae      	adds	r2, #174	@ 0xae
 80110da:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80110de:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80110e0:	f107 020e 	add.w	r2, r7, #14
 80110e4:	4610      	mov	r0, r2
 80110e6:	4798      	blx	r3
 80110e8:	4602      	mov	r2, r0
 80110ea:	687b      	ldr	r3, [r7, #4]
 80110ec:	f8c3 22d0 	str.w	r2, [r3, #720]	@ 0x2d0
  }
#endif /* USE_USB_FS */

  /* Increment the NumClasses */
  pdev->NumClasses++;
 80110f0:	687b      	ldr	r3, [r7, #4]
 80110f2:	f8d3 32d8 	ldr.w	r3, [r3, #728]	@ 0x2d8
 80110f6:	1c5a      	adds	r2, r3, #1
 80110f8:	687b      	ldr	r3, [r7, #4]
 80110fa:	f8c3 22d8 	str.w	r2, [r3, #728]	@ 0x2d8

  return USBD_OK;
 80110fe:	2300      	movs	r3, #0
}
 8011100:	4618      	mov	r0, r3
 8011102:	3710      	adds	r7, #16
 8011104:	46bd      	mov	sp, r7
 8011106:	bd80      	pop	{r7, pc}

08011108 <USBD_Start>:
  *         Start the USB Device Core.
  * @param  pdev: Device Handle
  * @retval USBD Status
  */
USBD_StatusTypeDef USBD_Start(USBD_HandleTypeDef *pdev)
{
 8011108:	b580      	push	{r7, lr}
 801110a:	b082      	sub	sp, #8
 801110c:	af00      	add	r7, sp, #0
 801110e:	6078      	str	r0, [r7, #4]
#ifdef USE_USBD_COMPOSITE
  pdev->classId = 0U;
#endif /* USE_USBD_COMPOSITE */

  /* Start the low level driver  */
  return USBD_LL_Start(pdev);
 8011110:	6878      	ldr	r0, [r7, #4]
 8011112:	f001 fdc9 	bl	8012ca8 <USBD_LL_Start>
 8011116:	4603      	mov	r3, r0
}
 8011118:	4618      	mov	r0, r3
 801111a:	3708      	adds	r7, #8
 801111c:	46bd      	mov	sp, r7
 801111e:	bd80      	pop	{r7, pc}

08011120 <USBD_RunTestMode>:
  *         Launch test mode process
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_RunTestMode(USBD_HandleTypeDef *pdev)
{
 8011120:	b480      	push	{r7}
 8011122:	b083      	sub	sp, #12
 8011124:	af00      	add	r7, sp, #0
 8011126:	6078      	str	r0, [r7, #4]
  return ret;
#else
  /* Prevent unused argument compilation warning */
  UNUSED(pdev);

  return USBD_OK;
 8011128:	2300      	movs	r3, #0
#endif /* USBD_HS_TESTMODE_ENABLE */
}
 801112a:	4618      	mov	r0, r3
 801112c:	370c      	adds	r7, #12
 801112e:	46bd      	mov	sp, r7
 8011130:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011134:	4770      	bx	lr

08011136 <USBD_SetClassConfig>:
  * @param  cfgidx: configuration index
  * @retval status
  */

USBD_StatusTypeDef USBD_SetClassConfig(USBD_HandleTypeDef *pdev, uint8_t cfgidx)
{
 8011136:	b580      	push	{r7, lr}
 8011138:	b084      	sub	sp, #16
 801113a:	af00      	add	r7, sp, #0
 801113c:	6078      	str	r0, [r7, #4]
 801113e:	460b      	mov	r3, r1
 8011140:	70fb      	strb	r3, [r7, #3]
  USBD_StatusTypeDef ret = USBD_OK;
 8011142:	2300      	movs	r3, #0
 8011144:	73fb      	strb	r3, [r7, #15]
        }
      }
    }
  }
#else
  if (pdev->pClass[0] != NULL)
 8011146:	687b      	ldr	r3, [r7, #4]
 8011148:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 801114c:	2b00      	cmp	r3, #0
 801114e:	d009      	beq.n	8011164 <USBD_SetClassConfig+0x2e>
  {
    /* Set configuration and Start the Class */
    ret = (USBD_StatusTypeDef)pdev->pClass[0]->Init(pdev, cfgidx);
 8011150:	687b      	ldr	r3, [r7, #4]
 8011152:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 8011156:	681b      	ldr	r3, [r3, #0]
 8011158:	78fa      	ldrb	r2, [r7, #3]
 801115a:	4611      	mov	r1, r2
 801115c:	6878      	ldr	r0, [r7, #4]
 801115e:	4798      	blx	r3
 8011160:	4603      	mov	r3, r0
 8011162:	73fb      	strb	r3, [r7, #15]
  }
#endif /* USE_USBD_COMPOSITE */

  return ret;
 8011164:	7bfb      	ldrb	r3, [r7, #15]
}
 8011166:	4618      	mov	r0, r3
 8011168:	3710      	adds	r7, #16
 801116a:	46bd      	mov	sp, r7
 801116c:	bd80      	pop	{r7, pc}

0801116e <USBD_ClrClassConfig>:
  * @param  pdev: device instance
  * @param  cfgidx: configuration index
  * @retval status
  */
USBD_StatusTypeDef USBD_ClrClassConfig(USBD_HandleTypeDef *pdev, uint8_t cfgidx)
{
 801116e:	b580      	push	{r7, lr}
 8011170:	b084      	sub	sp, #16
 8011172:	af00      	add	r7, sp, #0
 8011174:	6078      	str	r0, [r7, #4]
 8011176:	460b      	mov	r3, r1
 8011178:	70fb      	strb	r3, [r7, #3]
  USBD_StatusTypeDef ret = USBD_OK;
 801117a:	2300      	movs	r3, #0
 801117c:	73fb      	strb	r3, [r7, #15]
      }
    }
  }
#else
  /* Clear configuration  and De-initialize the Class process */
  if (pdev->pClass[0]->DeInit(pdev, cfgidx) != 0U)
 801117e:	687b      	ldr	r3, [r7, #4]
 8011180:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 8011184:	685b      	ldr	r3, [r3, #4]
 8011186:	78fa      	ldrb	r2, [r7, #3]
 8011188:	4611      	mov	r1, r2
 801118a:	6878      	ldr	r0, [r7, #4]
 801118c:	4798      	blx	r3
 801118e:	4603      	mov	r3, r0
 8011190:	2b00      	cmp	r3, #0
 8011192:	d001      	beq.n	8011198 <USBD_ClrClassConfig+0x2a>
  {
    ret = USBD_FAIL;
 8011194:	2303      	movs	r3, #3
 8011196:	73fb      	strb	r3, [r7, #15]
  }
#endif /* USE_USBD_COMPOSITE */

  return ret;
 8011198:	7bfb      	ldrb	r3, [r7, #15]
}
 801119a:	4618      	mov	r0, r3
 801119c:	3710      	adds	r7, #16
 801119e:	46bd      	mov	sp, r7
 80111a0:	bd80      	pop	{r7, pc}

080111a2 <USBD_LL_SetupStage>:
  * @param  pdev: device instance
  * @param  psetup: setup packet buffer pointer
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_SetupStage(USBD_HandleTypeDef *pdev, uint8_t *psetup)
{
 80111a2:	b580      	push	{r7, lr}
 80111a4:	b084      	sub	sp, #16
 80111a6:	af00      	add	r7, sp, #0
 80111a8:	6078      	str	r0, [r7, #4]
 80111aa:	6039      	str	r1, [r7, #0]
  USBD_StatusTypeDef ret;

  USBD_ParseSetupRequest(&pdev->request, psetup);
 80111ac:	687b      	ldr	r3, [r7, #4]
 80111ae:	f203 23aa 	addw	r3, r3, #682	@ 0x2aa
 80111b2:	6839      	ldr	r1, [r7, #0]
 80111b4:	4618      	mov	r0, r3
 80111b6:	f001 f8fe 	bl	80123b6 <USBD_ParseSetupRequest>

  pdev->ep0_state = USBD_EP0_SETUP;
 80111ba:	687b      	ldr	r3, [r7, #4]
 80111bc:	2201      	movs	r2, #1
 80111be:	f8c3 2294 	str.w	r2, [r3, #660]	@ 0x294

  pdev->ep0_data_len = pdev->request.wLength;
 80111c2:	687b      	ldr	r3, [r7, #4]
 80111c4:	f8b3 32b0 	ldrh.w	r3, [r3, #688]	@ 0x2b0
 80111c8:	461a      	mov	r2, r3
 80111ca:	687b      	ldr	r3, [r7, #4]
 80111cc:	f8c3 2298 	str.w	r2, [r3, #664]	@ 0x298

  switch (pdev->request.bmRequest & 0x1FU)
 80111d0:	687b      	ldr	r3, [r7, #4]
 80111d2:	f893 32aa 	ldrb.w	r3, [r3, #682]	@ 0x2aa
 80111d6:	f003 031f 	and.w	r3, r3, #31
 80111da:	2b02      	cmp	r3, #2
 80111dc:	d01a      	beq.n	8011214 <USBD_LL_SetupStage+0x72>
 80111de:	2b02      	cmp	r3, #2
 80111e0:	d822      	bhi.n	8011228 <USBD_LL_SetupStage+0x86>
 80111e2:	2b00      	cmp	r3, #0
 80111e4:	d002      	beq.n	80111ec <USBD_LL_SetupStage+0x4a>
 80111e6:	2b01      	cmp	r3, #1
 80111e8:	d00a      	beq.n	8011200 <USBD_LL_SetupStage+0x5e>
 80111ea:	e01d      	b.n	8011228 <USBD_LL_SetupStage+0x86>
  {
    case USB_REQ_RECIPIENT_DEVICE:
      ret = USBD_StdDevReq(pdev, &pdev->request);
 80111ec:	687b      	ldr	r3, [r7, #4]
 80111ee:	f203 23aa 	addw	r3, r3, #682	@ 0x2aa
 80111f2:	4619      	mov	r1, r3
 80111f4:	6878      	ldr	r0, [r7, #4]
 80111f6:	f000 fb2b 	bl	8011850 <USBD_StdDevReq>
 80111fa:	4603      	mov	r3, r0
 80111fc:	73fb      	strb	r3, [r7, #15]
      break;
 80111fe:	e020      	b.n	8011242 <USBD_LL_SetupStage+0xa0>

    case USB_REQ_RECIPIENT_INTERFACE:
      ret = USBD_StdItfReq(pdev, &pdev->request);
 8011200:	687b      	ldr	r3, [r7, #4]
 8011202:	f203 23aa 	addw	r3, r3, #682	@ 0x2aa
 8011206:	4619      	mov	r1, r3
 8011208:	6878      	ldr	r0, [r7, #4]
 801120a:	f000 fb93 	bl	8011934 <USBD_StdItfReq>
 801120e:	4603      	mov	r3, r0
 8011210:	73fb      	strb	r3, [r7, #15]
      break;
 8011212:	e016      	b.n	8011242 <USBD_LL_SetupStage+0xa0>

    case USB_REQ_RECIPIENT_ENDPOINT:
      ret = USBD_StdEPReq(pdev, &pdev->request);
 8011214:	687b      	ldr	r3, [r7, #4]
 8011216:	f203 23aa 	addw	r3, r3, #682	@ 0x2aa
 801121a:	4619      	mov	r1, r3
 801121c:	6878      	ldr	r0, [r7, #4]
 801121e:	f000 fbf5 	bl	8011a0c <USBD_StdEPReq>
 8011222:	4603      	mov	r3, r0
 8011224:	73fb      	strb	r3, [r7, #15]
      break;
 8011226:	e00c      	b.n	8011242 <USBD_LL_SetupStage+0xa0>

    default:
      ret = USBD_LL_StallEP(pdev, (pdev->request.bmRequest & 0x80U));
 8011228:	687b      	ldr	r3, [r7, #4]
 801122a:	f893 32aa 	ldrb.w	r3, [r3, #682]	@ 0x2aa
 801122e:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
 8011232:	b2db      	uxtb	r3, r3
 8011234:	4619      	mov	r1, r3
 8011236:	6878      	ldr	r0, [r7, #4]
 8011238:	f001 fd96 	bl	8012d68 <USBD_LL_StallEP>
 801123c:	4603      	mov	r3, r0
 801123e:	73fb      	strb	r3, [r7, #15]
      break;
 8011240:	bf00      	nop
  }

  return ret;
 8011242:	7bfb      	ldrb	r3, [r7, #15]
}
 8011244:	4618      	mov	r0, r3
 8011246:	3710      	adds	r7, #16
 8011248:	46bd      	mov	sp, r7
 801124a:	bd80      	pop	{r7, pc}

0801124c <USBD_LL_DataOutStage>:
  * @param  pdata: data pointer
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_DataOutStage(USBD_HandleTypeDef *pdev,
                                        uint8_t epnum, uint8_t *pdata)
{
 801124c:	b580      	push	{r7, lr}
 801124e:	b086      	sub	sp, #24
 8011250:	af00      	add	r7, sp, #0
 8011252:	60f8      	str	r0, [r7, #12]
 8011254:	460b      	mov	r3, r1
 8011256:	607a      	str	r2, [r7, #4]
 8011258:	72fb      	strb	r3, [r7, #11]
  USBD_EndpointTypeDef *pep;
  USBD_StatusTypeDef ret = USBD_OK;
 801125a:	2300      	movs	r3, #0
 801125c:	75fb      	strb	r3, [r7, #23]
  uint8_t idx;

  if (epnum == 0U)
 801125e:	7afb      	ldrb	r3, [r7, #11]
 8011260:	2b00      	cmp	r3, #0
 8011262:	d16e      	bne.n	8011342 <USBD_LL_DataOutStage+0xf6>
  {
    pep = &pdev->ep_out[0];
 8011264:	68fb      	ldr	r3, [r7, #12]
 8011266:	f503 73aa 	add.w	r3, r3, #340	@ 0x154
 801126a:	613b      	str	r3, [r7, #16]

    if (pdev->ep0_state == USBD_EP0_DATA_OUT)
 801126c:	68fb      	ldr	r3, [r7, #12]
 801126e:	f8d3 3294 	ldr.w	r3, [r3, #660]	@ 0x294
 8011272:	2b03      	cmp	r3, #3
 8011274:	f040 8098 	bne.w	80113a8 <USBD_LL_DataOutStage+0x15c>
    {
      if (pep->rem_length > pep->maxpacket)
 8011278:	693b      	ldr	r3, [r7, #16]
 801127a:	689a      	ldr	r2, [r3, #8]
 801127c:	693b      	ldr	r3, [r7, #16]
 801127e:	68db      	ldr	r3, [r3, #12]
 8011280:	429a      	cmp	r2, r3
 8011282:	d913      	bls.n	80112ac <USBD_LL_DataOutStage+0x60>
      {
        pep->rem_length -= pep->maxpacket;
 8011284:	693b      	ldr	r3, [r7, #16]
 8011286:	689a      	ldr	r2, [r3, #8]
 8011288:	693b      	ldr	r3, [r7, #16]
 801128a:	68db      	ldr	r3, [r3, #12]
 801128c:	1ad2      	subs	r2, r2, r3
 801128e:	693b      	ldr	r3, [r7, #16]
 8011290:	609a      	str	r2, [r3, #8]

        (void)USBD_CtlContinueRx(pdev, pdata, MIN(pep->rem_length, pep->maxpacket));
 8011292:	693b      	ldr	r3, [r7, #16]
 8011294:	68da      	ldr	r2, [r3, #12]
 8011296:	693b      	ldr	r3, [r7, #16]
 8011298:	689b      	ldr	r3, [r3, #8]
 801129a:	4293      	cmp	r3, r2
 801129c:	bf28      	it	cs
 801129e:	4613      	movcs	r3, r2
 80112a0:	461a      	mov	r2, r3
 80112a2:	6879      	ldr	r1, [r7, #4]
 80112a4:	68f8      	ldr	r0, [r7, #12]
 80112a6:	f001 f986 	bl	80125b6 <USBD_CtlContinueRx>
 80112aa:	e07d      	b.n	80113a8 <USBD_LL_DataOutStage+0x15c>
      }
      else
      {
        /* Find the class ID relative to the current request */
        switch (pdev->request.bmRequest & 0x1FU)
 80112ac:	68fb      	ldr	r3, [r7, #12]
 80112ae:	f893 32aa 	ldrb.w	r3, [r3, #682]	@ 0x2aa
 80112b2:	f003 031f 	and.w	r3, r3, #31
 80112b6:	2b02      	cmp	r3, #2
 80112b8:	d014      	beq.n	80112e4 <USBD_LL_DataOutStage+0x98>
 80112ba:	2b02      	cmp	r3, #2
 80112bc:	d81d      	bhi.n	80112fa <USBD_LL_DataOutStage+0xae>
 80112be:	2b00      	cmp	r3, #0
 80112c0:	d002      	beq.n	80112c8 <USBD_LL_DataOutStage+0x7c>
 80112c2:	2b01      	cmp	r3, #1
 80112c4:	d003      	beq.n	80112ce <USBD_LL_DataOutStage+0x82>
 80112c6:	e018      	b.n	80112fa <USBD_LL_DataOutStage+0xae>
        {
          case USB_REQ_RECIPIENT_DEVICE:
            /* Device requests must be managed by the first instantiated class
               (or duplicated by all classes for simplicity) */
            idx = 0U;
 80112c8:	2300      	movs	r3, #0
 80112ca:	75bb      	strb	r3, [r7, #22]
            break;
 80112cc:	e018      	b.n	8011300 <USBD_LL_DataOutStage+0xb4>

          case USB_REQ_RECIPIENT_INTERFACE:
            idx = USBD_CoreFindIF(pdev, LOBYTE(pdev->request.wIndex));
 80112ce:	68fb      	ldr	r3, [r7, #12]
 80112d0:	f8b3 32ae 	ldrh.w	r3, [r3, #686]	@ 0x2ae
 80112d4:	b2db      	uxtb	r3, r3
 80112d6:	4619      	mov	r1, r3
 80112d8:	68f8      	ldr	r0, [r7, #12]
 80112da:	f000 fa64 	bl	80117a6 <USBD_CoreFindIF>
 80112de:	4603      	mov	r3, r0
 80112e0:	75bb      	strb	r3, [r7, #22]
            break;
 80112e2:	e00d      	b.n	8011300 <USBD_LL_DataOutStage+0xb4>

          case USB_REQ_RECIPIENT_ENDPOINT:
            idx = USBD_CoreFindEP(pdev, LOBYTE(pdev->request.wIndex));
 80112e4:	68fb      	ldr	r3, [r7, #12]
 80112e6:	f8b3 32ae 	ldrh.w	r3, [r3, #686]	@ 0x2ae
 80112ea:	b2db      	uxtb	r3, r3
 80112ec:	4619      	mov	r1, r3
 80112ee:	68f8      	ldr	r0, [r7, #12]
 80112f0:	f000 fa66 	bl	80117c0 <USBD_CoreFindEP>
 80112f4:	4603      	mov	r3, r0
 80112f6:	75bb      	strb	r3, [r7, #22]
            break;
 80112f8:	e002      	b.n	8011300 <USBD_LL_DataOutStage+0xb4>

          default:
            /* Back to the first class in case of doubt */
            idx = 0U;
 80112fa:	2300      	movs	r3, #0
 80112fc:	75bb      	strb	r3, [r7, #22]
            break;
 80112fe:	bf00      	nop
        }

        if (idx < USBD_MAX_SUPPORTED_CLASS)
 8011300:	7dbb      	ldrb	r3, [r7, #22]
 8011302:	2b00      	cmp	r3, #0
 8011304:	d119      	bne.n	801133a <USBD_LL_DataOutStage+0xee>
        {
          /* Setup the class ID and route the request to the relative class function */
          if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8011306:	68fb      	ldr	r3, [r7, #12]
 8011308:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 801130c:	b2db      	uxtb	r3, r3
 801130e:	2b03      	cmp	r3, #3
 8011310:	d113      	bne.n	801133a <USBD_LL_DataOutStage+0xee>
          {
            if (pdev->pClass[idx]->EP0_RxReady != NULL)
 8011312:	7dba      	ldrb	r2, [r7, #22]
 8011314:	68fb      	ldr	r3, [r7, #12]
 8011316:	32ae      	adds	r2, #174	@ 0xae
 8011318:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 801131c:	691b      	ldr	r3, [r3, #16]
 801131e:	2b00      	cmp	r3, #0
 8011320:	d00b      	beq.n	801133a <USBD_LL_DataOutStage+0xee>
            {
              pdev->classId = idx;
 8011322:	7dba      	ldrb	r2, [r7, #22]
 8011324:	68fb      	ldr	r3, [r7, #12]
 8011326:	f8c3 22d4 	str.w	r2, [r3, #724]	@ 0x2d4
              pdev->pClass[idx]->EP0_RxReady(pdev);
 801132a:	7dba      	ldrb	r2, [r7, #22]
 801132c:	68fb      	ldr	r3, [r7, #12]
 801132e:	32ae      	adds	r2, #174	@ 0xae
 8011330:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8011334:	691b      	ldr	r3, [r3, #16]
 8011336:	68f8      	ldr	r0, [r7, #12]
 8011338:	4798      	blx	r3
            }
          }
        }

        (void)USBD_CtlSendStatus(pdev);
 801133a:	68f8      	ldr	r0, [r7, #12]
 801133c:	f001 f94c 	bl	80125d8 <USBD_CtlSendStatus>
 8011340:	e032      	b.n	80113a8 <USBD_LL_DataOutStage+0x15c>
    }
  }
  else
  {
    /* Get the class index relative to this interface */
    idx = USBD_CoreFindEP(pdev, (epnum & 0x7FU));
 8011342:	7afb      	ldrb	r3, [r7, #11]
 8011344:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 8011348:	b2db      	uxtb	r3, r3
 801134a:	4619      	mov	r1, r3
 801134c:	68f8      	ldr	r0, [r7, #12]
 801134e:	f000 fa37 	bl	80117c0 <USBD_CoreFindEP>
 8011352:	4603      	mov	r3, r0
 8011354:	75bb      	strb	r3, [r7, #22]

    if (((uint16_t)idx != 0xFFU) && (idx < USBD_MAX_SUPPORTED_CLASS))
 8011356:	7dbb      	ldrb	r3, [r7, #22]
 8011358:	2bff      	cmp	r3, #255	@ 0xff
 801135a:	d025      	beq.n	80113a8 <USBD_LL_DataOutStage+0x15c>
 801135c:	7dbb      	ldrb	r3, [r7, #22]
 801135e:	2b00      	cmp	r3, #0
 8011360:	d122      	bne.n	80113a8 <USBD_LL_DataOutStage+0x15c>
    {
      /* Call the class data out function to manage the request */
      if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8011362:	68fb      	ldr	r3, [r7, #12]
 8011364:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 8011368:	b2db      	uxtb	r3, r3
 801136a:	2b03      	cmp	r3, #3
 801136c:	d117      	bne.n	801139e <USBD_LL_DataOutStage+0x152>
      {
        if (pdev->pClass[idx]->DataOut != NULL)
 801136e:	7dba      	ldrb	r2, [r7, #22]
 8011370:	68fb      	ldr	r3, [r7, #12]
 8011372:	32ae      	adds	r2, #174	@ 0xae
 8011374:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8011378:	699b      	ldr	r3, [r3, #24]
 801137a:	2b00      	cmp	r3, #0
 801137c:	d00f      	beq.n	801139e <USBD_LL_DataOutStage+0x152>
        {
          pdev->classId = idx;
 801137e:	7dba      	ldrb	r2, [r7, #22]
 8011380:	68fb      	ldr	r3, [r7, #12]
 8011382:	f8c3 22d4 	str.w	r2, [r3, #724]	@ 0x2d4
          ret = (USBD_StatusTypeDef)pdev->pClass[idx]->DataOut(pdev, epnum);
 8011386:	7dba      	ldrb	r2, [r7, #22]
 8011388:	68fb      	ldr	r3, [r7, #12]
 801138a:	32ae      	adds	r2, #174	@ 0xae
 801138c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8011390:	699b      	ldr	r3, [r3, #24]
 8011392:	7afa      	ldrb	r2, [r7, #11]
 8011394:	4611      	mov	r1, r2
 8011396:	68f8      	ldr	r0, [r7, #12]
 8011398:	4798      	blx	r3
 801139a:	4603      	mov	r3, r0
 801139c:	75fb      	strb	r3, [r7, #23]
        }
      }
      if (ret != USBD_OK)
 801139e:	7dfb      	ldrb	r3, [r7, #23]
 80113a0:	2b00      	cmp	r3, #0
 80113a2:	d001      	beq.n	80113a8 <USBD_LL_DataOutStage+0x15c>
      {
        return ret;
 80113a4:	7dfb      	ldrb	r3, [r7, #23]
 80113a6:	e000      	b.n	80113aa <USBD_LL_DataOutStage+0x15e>
      }
    }
  }

  return USBD_OK;
 80113a8:	2300      	movs	r3, #0
}
 80113aa:	4618      	mov	r0, r3
 80113ac:	3718      	adds	r7, #24
 80113ae:	46bd      	mov	sp, r7
 80113b0:	bd80      	pop	{r7, pc}

080113b2 <USBD_LL_DataInStage>:
  * @param  pdata: data pointer
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_DataInStage(USBD_HandleTypeDef *pdev,
                                       uint8_t epnum, uint8_t *pdata)
{
 80113b2:	b580      	push	{r7, lr}
 80113b4:	b086      	sub	sp, #24
 80113b6:	af00      	add	r7, sp, #0
 80113b8:	60f8      	str	r0, [r7, #12]
 80113ba:	460b      	mov	r3, r1
 80113bc:	607a      	str	r2, [r7, #4]
 80113be:	72fb      	strb	r3, [r7, #11]
  USBD_EndpointTypeDef *pep;
  USBD_StatusTypeDef ret;
  uint8_t idx;

  if (epnum == 0U)
 80113c0:	7afb      	ldrb	r3, [r7, #11]
 80113c2:	2b00      	cmp	r3, #0
 80113c4:	d16f      	bne.n	80114a6 <USBD_LL_DataInStage+0xf4>
  {
    pep = &pdev->ep_in[0];
 80113c6:	68fb      	ldr	r3, [r7, #12]
 80113c8:	3314      	adds	r3, #20
 80113ca:	613b      	str	r3, [r7, #16]

    if (pdev->ep0_state == USBD_EP0_DATA_IN)
 80113cc:	68fb      	ldr	r3, [r7, #12]
 80113ce:	f8d3 3294 	ldr.w	r3, [r3, #660]	@ 0x294
 80113d2:	2b02      	cmp	r3, #2
 80113d4:	d15a      	bne.n	801148c <USBD_LL_DataInStage+0xda>
    {
      if (pep->rem_length > pep->maxpacket)
 80113d6:	693b      	ldr	r3, [r7, #16]
 80113d8:	689a      	ldr	r2, [r3, #8]
 80113da:	693b      	ldr	r3, [r7, #16]
 80113dc:	68db      	ldr	r3, [r3, #12]
 80113de:	429a      	cmp	r2, r3
 80113e0:	d914      	bls.n	801140c <USBD_LL_DataInStage+0x5a>
      {
        pep->rem_length -= pep->maxpacket;
 80113e2:	693b      	ldr	r3, [r7, #16]
 80113e4:	689a      	ldr	r2, [r3, #8]
 80113e6:	693b      	ldr	r3, [r7, #16]
 80113e8:	68db      	ldr	r3, [r3, #12]
 80113ea:	1ad2      	subs	r2, r2, r3
 80113ec:	693b      	ldr	r3, [r7, #16]
 80113ee:	609a      	str	r2, [r3, #8]

        (void)USBD_CtlContinueSendData(pdev, pdata, pep->rem_length);
 80113f0:	693b      	ldr	r3, [r7, #16]
 80113f2:	689b      	ldr	r3, [r3, #8]
 80113f4:	461a      	mov	r2, r3
 80113f6:	6879      	ldr	r1, [r7, #4]
 80113f8:	68f8      	ldr	r0, [r7, #12]
 80113fa:	f001 f8ae 	bl	801255a <USBD_CtlContinueSendData>

        /* Prepare endpoint for premature end of transfer */
        (void)USBD_LL_PrepareReceive(pdev, 0U, NULL, 0U);
 80113fe:	2300      	movs	r3, #0
 8011400:	2200      	movs	r2, #0
 8011402:	2100      	movs	r1, #0
 8011404:	68f8      	ldr	r0, [r7, #12]
 8011406:	f001 fd59 	bl	8012ebc <USBD_LL_PrepareReceive>
 801140a:	e03f      	b.n	801148c <USBD_LL_DataInStage+0xda>
      }
      else
      {
        /* last packet is MPS multiple, so send ZLP packet */
        if ((pep->maxpacket == pep->rem_length) &&
 801140c:	693b      	ldr	r3, [r7, #16]
 801140e:	68da      	ldr	r2, [r3, #12]
 8011410:	693b      	ldr	r3, [r7, #16]
 8011412:	689b      	ldr	r3, [r3, #8]
 8011414:	429a      	cmp	r2, r3
 8011416:	d11c      	bne.n	8011452 <USBD_LL_DataInStage+0xa0>
            (pep->total_length >= pep->maxpacket) &&
 8011418:	693b      	ldr	r3, [r7, #16]
 801141a:	685a      	ldr	r2, [r3, #4]
 801141c:	693b      	ldr	r3, [r7, #16]
 801141e:	68db      	ldr	r3, [r3, #12]
        if ((pep->maxpacket == pep->rem_length) &&
 8011420:	429a      	cmp	r2, r3
 8011422:	d316      	bcc.n	8011452 <USBD_LL_DataInStage+0xa0>
            (pep->total_length < pdev->ep0_data_len))
 8011424:	693b      	ldr	r3, [r7, #16]
 8011426:	685a      	ldr	r2, [r3, #4]
 8011428:	68fb      	ldr	r3, [r7, #12]
 801142a:	f8d3 3298 	ldr.w	r3, [r3, #664]	@ 0x298
            (pep->total_length >= pep->maxpacket) &&
 801142e:	429a      	cmp	r2, r3
 8011430:	d20f      	bcs.n	8011452 <USBD_LL_DataInStage+0xa0>
        {
          (void)USBD_CtlContinueSendData(pdev, NULL, 0U);
 8011432:	2200      	movs	r2, #0
 8011434:	2100      	movs	r1, #0
 8011436:	68f8      	ldr	r0, [r7, #12]
 8011438:	f001 f88f 	bl	801255a <USBD_CtlContinueSendData>
          pdev->ep0_data_len = 0U;
 801143c:	68fb      	ldr	r3, [r7, #12]
 801143e:	2200      	movs	r2, #0
 8011440:	f8c3 2298 	str.w	r2, [r3, #664]	@ 0x298

          /* Prepare endpoint for premature end of transfer */
          (void)USBD_LL_PrepareReceive(pdev, 0U, NULL, 0U);
 8011444:	2300      	movs	r3, #0
 8011446:	2200      	movs	r2, #0
 8011448:	2100      	movs	r1, #0
 801144a:	68f8      	ldr	r0, [r7, #12]
 801144c:	f001 fd36 	bl	8012ebc <USBD_LL_PrepareReceive>
 8011450:	e01c      	b.n	801148c <USBD_LL_DataInStage+0xda>
        }
        else
        {
          if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8011452:	68fb      	ldr	r3, [r7, #12]
 8011454:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 8011458:	b2db      	uxtb	r3, r3
 801145a:	2b03      	cmp	r3, #3
 801145c:	d10f      	bne.n	801147e <USBD_LL_DataInStage+0xcc>
          {
            if (pdev->pClass[0]->EP0_TxSent != NULL)
 801145e:	68fb      	ldr	r3, [r7, #12]
 8011460:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 8011464:	68db      	ldr	r3, [r3, #12]
 8011466:	2b00      	cmp	r3, #0
 8011468:	d009      	beq.n	801147e <USBD_LL_DataInStage+0xcc>
            {
              pdev->classId = 0U;
 801146a:	68fb      	ldr	r3, [r7, #12]
 801146c:	2200      	movs	r2, #0
 801146e:	f8c3 22d4 	str.w	r2, [r3, #724]	@ 0x2d4
              pdev->pClass[0]->EP0_TxSent(pdev);
 8011472:	68fb      	ldr	r3, [r7, #12]
 8011474:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 8011478:	68db      	ldr	r3, [r3, #12]
 801147a:	68f8      	ldr	r0, [r7, #12]
 801147c:	4798      	blx	r3
            }
          }
          (void)USBD_LL_StallEP(pdev, 0x80U);
 801147e:	2180      	movs	r1, #128	@ 0x80
 8011480:	68f8      	ldr	r0, [r7, #12]
 8011482:	f001 fc71 	bl	8012d68 <USBD_LL_StallEP>
          (void)USBD_CtlReceiveStatus(pdev);
 8011486:	68f8      	ldr	r0, [r7, #12]
 8011488:	f001 f8b9 	bl	80125fe <USBD_CtlReceiveStatus>
        }
      }
    }

    if (pdev->dev_test_mode != 0U)
 801148c:	68fb      	ldr	r3, [r7, #12]
 801148e:	f893 32a0 	ldrb.w	r3, [r3, #672]	@ 0x2a0
 8011492:	2b00      	cmp	r3, #0
 8011494:	d03a      	beq.n	801150c <USBD_LL_DataInStage+0x15a>
    {
      (void)USBD_RunTestMode(pdev);
 8011496:	68f8      	ldr	r0, [r7, #12]
 8011498:	f7ff fe42 	bl	8011120 <USBD_RunTestMode>
      pdev->dev_test_mode = 0U;
 801149c:	68fb      	ldr	r3, [r7, #12]
 801149e:	2200      	movs	r2, #0
 80114a0:	f883 22a0 	strb.w	r2, [r3, #672]	@ 0x2a0
 80114a4:	e032      	b.n	801150c <USBD_LL_DataInStage+0x15a>
    }
  }
  else
  {
    /* Get the class index relative to this interface */
    idx = USBD_CoreFindEP(pdev, ((uint8_t)epnum | 0x80U));
 80114a6:	7afb      	ldrb	r3, [r7, #11]
 80114a8:	f063 037f 	orn	r3, r3, #127	@ 0x7f
 80114ac:	b2db      	uxtb	r3, r3
 80114ae:	4619      	mov	r1, r3
 80114b0:	68f8      	ldr	r0, [r7, #12]
 80114b2:	f000 f985 	bl	80117c0 <USBD_CoreFindEP>
 80114b6:	4603      	mov	r3, r0
 80114b8:	75fb      	strb	r3, [r7, #23]

    if (((uint16_t)idx != 0xFFU) && (idx < USBD_MAX_SUPPORTED_CLASS))
 80114ba:	7dfb      	ldrb	r3, [r7, #23]
 80114bc:	2bff      	cmp	r3, #255	@ 0xff
 80114be:	d025      	beq.n	801150c <USBD_LL_DataInStage+0x15a>
 80114c0:	7dfb      	ldrb	r3, [r7, #23]
 80114c2:	2b00      	cmp	r3, #0
 80114c4:	d122      	bne.n	801150c <USBD_LL_DataInStage+0x15a>
    {
      /* Call the class data out function to manage the request */
      if (pdev->dev_state == USBD_STATE_CONFIGURED)
 80114c6:	68fb      	ldr	r3, [r7, #12]
 80114c8:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 80114cc:	b2db      	uxtb	r3, r3
 80114ce:	2b03      	cmp	r3, #3
 80114d0:	d11c      	bne.n	801150c <USBD_LL_DataInStage+0x15a>
      {
        if (pdev->pClass[idx]->DataIn != NULL)
 80114d2:	7dfa      	ldrb	r2, [r7, #23]
 80114d4:	68fb      	ldr	r3, [r7, #12]
 80114d6:	32ae      	adds	r2, #174	@ 0xae
 80114d8:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80114dc:	695b      	ldr	r3, [r3, #20]
 80114de:	2b00      	cmp	r3, #0
 80114e0:	d014      	beq.n	801150c <USBD_LL_DataInStage+0x15a>
        {
          pdev->classId = idx;
 80114e2:	7dfa      	ldrb	r2, [r7, #23]
 80114e4:	68fb      	ldr	r3, [r7, #12]
 80114e6:	f8c3 22d4 	str.w	r2, [r3, #724]	@ 0x2d4
          ret = (USBD_StatusTypeDef)pdev->pClass[idx]->DataIn(pdev, epnum);
 80114ea:	7dfa      	ldrb	r2, [r7, #23]
 80114ec:	68fb      	ldr	r3, [r7, #12]
 80114ee:	32ae      	adds	r2, #174	@ 0xae
 80114f0:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80114f4:	695b      	ldr	r3, [r3, #20]
 80114f6:	7afa      	ldrb	r2, [r7, #11]
 80114f8:	4611      	mov	r1, r2
 80114fa:	68f8      	ldr	r0, [r7, #12]
 80114fc:	4798      	blx	r3
 80114fe:	4603      	mov	r3, r0
 8011500:	75bb      	strb	r3, [r7, #22]

          if (ret != USBD_OK)
 8011502:	7dbb      	ldrb	r3, [r7, #22]
 8011504:	2b00      	cmp	r3, #0
 8011506:	d001      	beq.n	801150c <USBD_LL_DataInStage+0x15a>
          {
            return ret;
 8011508:	7dbb      	ldrb	r3, [r7, #22]
 801150a:	e000      	b.n	801150e <USBD_LL_DataInStage+0x15c>
        }
      }
    }
  }

  return USBD_OK;
 801150c:	2300      	movs	r3, #0
}
 801150e:	4618      	mov	r0, r3
 8011510:	3718      	adds	r7, #24
 8011512:	46bd      	mov	sp, r7
 8011514:	bd80      	pop	{r7, pc}

08011516 <USBD_LL_Reset>:
  *         Handle Reset event
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_Reset(USBD_HandleTypeDef *pdev)
{
 8011516:	b580      	push	{r7, lr}
 8011518:	b084      	sub	sp, #16
 801151a:	af00      	add	r7, sp, #0
 801151c:	6078      	str	r0, [r7, #4]
  USBD_StatusTypeDef ret = USBD_OK;
 801151e:	2300      	movs	r3, #0
 8011520:	73fb      	strb	r3, [r7, #15]

  /* Upon Reset call user call back */
  pdev->dev_state = USBD_STATE_DEFAULT;
 8011522:	687b      	ldr	r3, [r7, #4]
 8011524:	2201      	movs	r2, #1
 8011526:	f883 229c 	strb.w	r2, [r3, #668]	@ 0x29c
  pdev->ep0_state = USBD_EP0_IDLE;
 801152a:	687b      	ldr	r3, [r7, #4]
 801152c:	2200      	movs	r2, #0
 801152e:	f8c3 2294 	str.w	r2, [r3, #660]	@ 0x294
  pdev->dev_config = 0U;
 8011532:	687b      	ldr	r3, [r7, #4]
 8011534:	2200      	movs	r2, #0
 8011536:	605a      	str	r2, [r3, #4]
  pdev->dev_remote_wakeup = 0U;
 8011538:	687b      	ldr	r3, [r7, #4]
 801153a:	2200      	movs	r2, #0
 801153c:	f8c3 22a4 	str.w	r2, [r3, #676]	@ 0x2a4
  pdev->dev_test_mode = 0U;
 8011540:	687b      	ldr	r3, [r7, #4]
 8011542:	2200      	movs	r2, #0
 8011544:	f883 22a0 	strb.w	r2, [r3, #672]	@ 0x2a0
      }
    }
  }
#else

  if (pdev->pClass[0] != NULL)
 8011548:	687b      	ldr	r3, [r7, #4]
 801154a:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 801154e:	2b00      	cmp	r3, #0
 8011550:	d014      	beq.n	801157c <USBD_LL_Reset+0x66>
  {
    if (pdev->pClass[0]->DeInit != NULL)
 8011552:	687b      	ldr	r3, [r7, #4]
 8011554:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 8011558:	685b      	ldr	r3, [r3, #4]
 801155a:	2b00      	cmp	r3, #0
 801155c:	d00e      	beq.n	801157c <USBD_LL_Reset+0x66>
    {
      if (pdev->pClass[0]->DeInit(pdev, (uint8_t)pdev->dev_config) != USBD_OK)
 801155e:	687b      	ldr	r3, [r7, #4]
 8011560:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 8011564:	685b      	ldr	r3, [r3, #4]
 8011566:	687a      	ldr	r2, [r7, #4]
 8011568:	6852      	ldr	r2, [r2, #4]
 801156a:	b2d2      	uxtb	r2, r2
 801156c:	4611      	mov	r1, r2
 801156e:	6878      	ldr	r0, [r7, #4]
 8011570:	4798      	blx	r3
 8011572:	4603      	mov	r3, r0
 8011574:	2b00      	cmp	r3, #0
 8011576:	d001      	beq.n	801157c <USBD_LL_Reset+0x66>
      {
        ret = USBD_FAIL;
 8011578:	2303      	movs	r3, #3
 801157a:	73fb      	strb	r3, [r7, #15]
    }
  }
#endif /* USE_USBD_COMPOSITE */

  /* Open EP0 OUT */
  (void)USBD_LL_OpenEP(pdev, 0x00U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
 801157c:	2340      	movs	r3, #64	@ 0x40
 801157e:	2200      	movs	r2, #0
 8011580:	2100      	movs	r1, #0
 8011582:	6878      	ldr	r0, [r7, #4]
 8011584:	f001 fbab 	bl	8012cde <USBD_LL_OpenEP>
  pdev->ep_out[0x00U & 0xFU].is_used = 1U;
 8011588:	687b      	ldr	r3, [r7, #4]
 801158a:	2201      	movs	r2, #1
 801158c:	f8a3 2164 	strh.w	r2, [r3, #356]	@ 0x164

  pdev->ep_out[0].maxpacket = USB_MAX_EP0_SIZE;
 8011590:	687b      	ldr	r3, [r7, #4]
 8011592:	2240      	movs	r2, #64	@ 0x40
 8011594:	f8c3 2160 	str.w	r2, [r3, #352]	@ 0x160

  /* Open EP0 IN */
  (void)USBD_LL_OpenEP(pdev, 0x80U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
 8011598:	2340      	movs	r3, #64	@ 0x40
 801159a:	2200      	movs	r2, #0
 801159c:	2180      	movs	r1, #128	@ 0x80
 801159e:	6878      	ldr	r0, [r7, #4]
 80115a0:	f001 fb9d 	bl	8012cde <USBD_LL_OpenEP>
  pdev->ep_in[0x80U & 0xFU].is_used = 1U;
 80115a4:	687b      	ldr	r3, [r7, #4]
 80115a6:	2201      	movs	r2, #1
 80115a8:	849a      	strh	r2, [r3, #36]	@ 0x24

  pdev->ep_in[0].maxpacket = USB_MAX_EP0_SIZE;
 80115aa:	687b      	ldr	r3, [r7, #4]
 80115ac:	2240      	movs	r2, #64	@ 0x40
 80115ae:	621a      	str	r2, [r3, #32]

  return ret;
 80115b0:	7bfb      	ldrb	r3, [r7, #15]
}
 80115b2:	4618      	mov	r0, r3
 80115b4:	3710      	adds	r7, #16
 80115b6:	46bd      	mov	sp, r7
 80115b8:	bd80      	pop	{r7, pc}

080115ba <USBD_LL_SetSpeed>:
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_SetSpeed(USBD_HandleTypeDef *pdev,
                                    USBD_SpeedTypeDef speed)
{
 80115ba:	b480      	push	{r7}
 80115bc:	b083      	sub	sp, #12
 80115be:	af00      	add	r7, sp, #0
 80115c0:	6078      	str	r0, [r7, #4]
 80115c2:	460b      	mov	r3, r1
 80115c4:	70fb      	strb	r3, [r7, #3]
  pdev->dev_speed = speed;
 80115c6:	687b      	ldr	r3, [r7, #4]
 80115c8:	78fa      	ldrb	r2, [r7, #3]
 80115ca:	741a      	strb	r2, [r3, #16]

  return USBD_OK;
 80115cc:	2300      	movs	r3, #0
}
 80115ce:	4618      	mov	r0, r3
 80115d0:	370c      	adds	r7, #12
 80115d2:	46bd      	mov	sp, r7
 80115d4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80115d8:	4770      	bx	lr

080115da <USBD_LL_Suspend>:
  *         Handle Suspend event
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_Suspend(USBD_HandleTypeDef *pdev)
{
 80115da:	b480      	push	{r7}
 80115dc:	b083      	sub	sp, #12
 80115de:	af00      	add	r7, sp, #0
 80115e0:	6078      	str	r0, [r7, #4]
  if (pdev->dev_state != USBD_STATE_SUSPENDED)
 80115e2:	687b      	ldr	r3, [r7, #4]
 80115e4:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 80115e8:	b2db      	uxtb	r3, r3
 80115ea:	2b04      	cmp	r3, #4
 80115ec:	d006      	beq.n	80115fc <USBD_LL_Suspend+0x22>
  {
    pdev->dev_old_state = pdev->dev_state;
 80115ee:	687b      	ldr	r3, [r7, #4]
 80115f0:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 80115f4:	b2da      	uxtb	r2, r3
 80115f6:	687b      	ldr	r3, [r7, #4]
 80115f8:	f883 229d 	strb.w	r2, [r3, #669]	@ 0x29d
  }

  pdev->dev_state = USBD_STATE_SUSPENDED;
 80115fc:	687b      	ldr	r3, [r7, #4]
 80115fe:	2204      	movs	r2, #4
 8011600:	f883 229c 	strb.w	r2, [r3, #668]	@ 0x29c

  return USBD_OK;
 8011604:	2300      	movs	r3, #0
}
 8011606:	4618      	mov	r0, r3
 8011608:	370c      	adds	r7, #12
 801160a:	46bd      	mov	sp, r7
 801160c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011610:	4770      	bx	lr

08011612 <USBD_LL_Resume>:
  *         Handle Resume event
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_Resume(USBD_HandleTypeDef *pdev)
{
 8011612:	b480      	push	{r7}
 8011614:	b083      	sub	sp, #12
 8011616:	af00      	add	r7, sp, #0
 8011618:	6078      	str	r0, [r7, #4]
  if (pdev->dev_state == USBD_STATE_SUSPENDED)
 801161a:	687b      	ldr	r3, [r7, #4]
 801161c:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 8011620:	b2db      	uxtb	r3, r3
 8011622:	2b04      	cmp	r3, #4
 8011624:	d106      	bne.n	8011634 <USBD_LL_Resume+0x22>
  {
    pdev->dev_state = pdev->dev_old_state;
 8011626:	687b      	ldr	r3, [r7, #4]
 8011628:	f893 329d 	ldrb.w	r3, [r3, #669]	@ 0x29d
 801162c:	b2da      	uxtb	r2, r3
 801162e:	687b      	ldr	r3, [r7, #4]
 8011630:	f883 229c 	strb.w	r2, [r3, #668]	@ 0x29c
  }

  return USBD_OK;
 8011634:	2300      	movs	r3, #0
}
 8011636:	4618      	mov	r0, r3
 8011638:	370c      	adds	r7, #12
 801163a:	46bd      	mov	sp, r7
 801163c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011640:	4770      	bx	lr

08011642 <USBD_LL_SOF>:
  *         Handle SOF event
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_SOF(USBD_HandleTypeDef *pdev)
{
 8011642:	b580      	push	{r7, lr}
 8011644:	b082      	sub	sp, #8
 8011646:	af00      	add	r7, sp, #0
 8011648:	6078      	str	r0, [r7, #4]
  /* The SOF event can be distributed for all classes that support it */
  if (pdev->dev_state == USBD_STATE_CONFIGURED)
 801164a:	687b      	ldr	r3, [r7, #4]
 801164c:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 8011650:	b2db      	uxtb	r3, r3
 8011652:	2b03      	cmp	r3, #3
 8011654:	d110      	bne.n	8011678 <USBD_LL_SOF+0x36>
          }
        }
      }
    }
#else
    if (pdev->pClass[0] != NULL)
 8011656:	687b      	ldr	r3, [r7, #4]
 8011658:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 801165c:	2b00      	cmp	r3, #0
 801165e:	d00b      	beq.n	8011678 <USBD_LL_SOF+0x36>
    {
      if (pdev->pClass[0]->SOF != NULL)
 8011660:	687b      	ldr	r3, [r7, #4]
 8011662:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 8011666:	69db      	ldr	r3, [r3, #28]
 8011668:	2b00      	cmp	r3, #0
 801166a:	d005      	beq.n	8011678 <USBD_LL_SOF+0x36>
      {
        (void)pdev->pClass[0]->SOF(pdev);
 801166c:	687b      	ldr	r3, [r7, #4]
 801166e:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 8011672:	69db      	ldr	r3, [r3, #28]
 8011674:	6878      	ldr	r0, [r7, #4]
 8011676:	4798      	blx	r3
      }
    }
#endif /* USE_USBD_COMPOSITE */
  }

  return USBD_OK;
 8011678:	2300      	movs	r3, #0
}
 801167a:	4618      	mov	r0, r3
 801167c:	3708      	adds	r7, #8
 801167e:	46bd      	mov	sp, r7
 8011680:	bd80      	pop	{r7, pc}

08011682 <USBD_LL_IsoINIncomplete>:
  * @param  epnum: Endpoint number
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_IsoINIncomplete(USBD_HandleTypeDef *pdev,
                                           uint8_t epnum)
{
 8011682:	b580      	push	{r7, lr}
 8011684:	b082      	sub	sp, #8
 8011686:	af00      	add	r7, sp, #0
 8011688:	6078      	str	r0, [r7, #4]
 801168a:	460b      	mov	r3, r1
 801168c:	70fb      	strb	r3, [r7, #3]
  if (pdev->pClass[pdev->classId] == NULL)
 801168e:	687b      	ldr	r3, [r7, #4]
 8011690:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 8011694:	687b      	ldr	r3, [r7, #4]
 8011696:	32ae      	adds	r2, #174	@ 0xae
 8011698:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 801169c:	2b00      	cmp	r3, #0
 801169e:	d101      	bne.n	80116a4 <USBD_LL_IsoINIncomplete+0x22>
  {
    return USBD_FAIL;
 80116a0:	2303      	movs	r3, #3
 80116a2:	e01c      	b.n	80116de <USBD_LL_IsoINIncomplete+0x5c>
  }

  if (pdev->dev_state == USBD_STATE_CONFIGURED)
 80116a4:	687b      	ldr	r3, [r7, #4]
 80116a6:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 80116aa:	b2db      	uxtb	r3, r3
 80116ac:	2b03      	cmp	r3, #3
 80116ae:	d115      	bne.n	80116dc <USBD_LL_IsoINIncomplete+0x5a>
  {
    if (pdev->pClass[pdev->classId]->IsoINIncomplete != NULL)
 80116b0:	687b      	ldr	r3, [r7, #4]
 80116b2:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 80116b6:	687b      	ldr	r3, [r7, #4]
 80116b8:	32ae      	adds	r2, #174	@ 0xae
 80116ba:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80116be:	6a1b      	ldr	r3, [r3, #32]
 80116c0:	2b00      	cmp	r3, #0
 80116c2:	d00b      	beq.n	80116dc <USBD_LL_IsoINIncomplete+0x5a>
    {
      (void)pdev->pClass[pdev->classId]->IsoINIncomplete(pdev, epnum);
 80116c4:	687b      	ldr	r3, [r7, #4]
 80116c6:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 80116ca:	687b      	ldr	r3, [r7, #4]
 80116cc:	32ae      	adds	r2, #174	@ 0xae
 80116ce:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80116d2:	6a1b      	ldr	r3, [r3, #32]
 80116d4:	78fa      	ldrb	r2, [r7, #3]
 80116d6:	4611      	mov	r1, r2
 80116d8:	6878      	ldr	r0, [r7, #4]
 80116da:	4798      	blx	r3
    }
  }

  return USBD_OK;
 80116dc:	2300      	movs	r3, #0
}
 80116de:	4618      	mov	r0, r3
 80116e0:	3708      	adds	r7, #8
 80116e2:	46bd      	mov	sp, r7
 80116e4:	bd80      	pop	{r7, pc}

080116e6 <USBD_LL_IsoOUTIncomplete>:
  * @param  epnum: Endpoint number
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_IsoOUTIncomplete(USBD_HandleTypeDef *pdev,
                                            uint8_t epnum)
{
 80116e6:	b580      	push	{r7, lr}
 80116e8:	b082      	sub	sp, #8
 80116ea:	af00      	add	r7, sp, #0
 80116ec:	6078      	str	r0, [r7, #4]
 80116ee:	460b      	mov	r3, r1
 80116f0:	70fb      	strb	r3, [r7, #3]
  if (pdev->pClass[pdev->classId] == NULL)
 80116f2:	687b      	ldr	r3, [r7, #4]
 80116f4:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 80116f8:	687b      	ldr	r3, [r7, #4]
 80116fa:	32ae      	adds	r2, #174	@ 0xae
 80116fc:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8011700:	2b00      	cmp	r3, #0
 8011702:	d101      	bne.n	8011708 <USBD_LL_IsoOUTIncomplete+0x22>
  {
    return USBD_FAIL;
 8011704:	2303      	movs	r3, #3
 8011706:	e01c      	b.n	8011742 <USBD_LL_IsoOUTIncomplete+0x5c>
  }

  if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8011708:	687b      	ldr	r3, [r7, #4]
 801170a:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 801170e:	b2db      	uxtb	r3, r3
 8011710:	2b03      	cmp	r3, #3
 8011712:	d115      	bne.n	8011740 <USBD_LL_IsoOUTIncomplete+0x5a>
  {
    if (pdev->pClass[pdev->classId]->IsoOUTIncomplete != NULL)
 8011714:	687b      	ldr	r3, [r7, #4]
 8011716:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 801171a:	687b      	ldr	r3, [r7, #4]
 801171c:	32ae      	adds	r2, #174	@ 0xae
 801171e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8011722:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8011724:	2b00      	cmp	r3, #0
 8011726:	d00b      	beq.n	8011740 <USBD_LL_IsoOUTIncomplete+0x5a>
    {
      (void)pdev->pClass[pdev->classId]->IsoOUTIncomplete(pdev, epnum);
 8011728:	687b      	ldr	r3, [r7, #4]
 801172a:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 801172e:	687b      	ldr	r3, [r7, #4]
 8011730:	32ae      	adds	r2, #174	@ 0xae
 8011732:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8011736:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8011738:	78fa      	ldrb	r2, [r7, #3]
 801173a:	4611      	mov	r1, r2
 801173c:	6878      	ldr	r0, [r7, #4]
 801173e:	4798      	blx	r3
    }
  }

  return USBD_OK;
 8011740:	2300      	movs	r3, #0
}
 8011742:	4618      	mov	r0, r3
 8011744:	3708      	adds	r7, #8
 8011746:	46bd      	mov	sp, r7
 8011748:	bd80      	pop	{r7, pc}

0801174a <USBD_LL_DevConnected>:
  *         Handle device connection event
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_DevConnected(USBD_HandleTypeDef *pdev)
{
 801174a:	b480      	push	{r7}
 801174c:	b083      	sub	sp, #12
 801174e:	af00      	add	r7, sp, #0
 8011750:	6078      	str	r0, [r7, #4]
  /* Prevent unused argument compilation warning */
  UNUSED(pdev);

  return USBD_OK;
 8011752:	2300      	movs	r3, #0
}
 8011754:	4618      	mov	r0, r3
 8011756:	370c      	adds	r7, #12
 8011758:	46bd      	mov	sp, r7
 801175a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801175e:	4770      	bx	lr

08011760 <USBD_LL_DevDisconnected>:
  *         Handle device disconnection event
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_DevDisconnected(USBD_HandleTypeDef *pdev)
{
 8011760:	b580      	push	{r7, lr}
 8011762:	b084      	sub	sp, #16
 8011764:	af00      	add	r7, sp, #0
 8011766:	6078      	str	r0, [r7, #4]
  USBD_StatusTypeDef   ret = USBD_OK;
 8011768:	2300      	movs	r3, #0
 801176a:	73fb      	strb	r3, [r7, #15]

  /* Free Class Resources */
  pdev->dev_state = USBD_STATE_DEFAULT;
 801176c:	687b      	ldr	r3, [r7, #4]
 801176e:	2201      	movs	r2, #1
 8011770:	f883 229c 	strb.w	r2, [r3, #668]	@ 0x29c
        }
      }
    }
  }
#else
  if (pdev->pClass[0] != NULL)
 8011774:	687b      	ldr	r3, [r7, #4]
 8011776:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 801177a:	2b00      	cmp	r3, #0
 801177c:	d00e      	beq.n	801179c <USBD_LL_DevDisconnected+0x3c>
  {
    if (pdev->pClass[0]->DeInit(pdev, (uint8_t)pdev->dev_config) != 0U)
 801177e:	687b      	ldr	r3, [r7, #4]
 8011780:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 8011784:	685b      	ldr	r3, [r3, #4]
 8011786:	687a      	ldr	r2, [r7, #4]
 8011788:	6852      	ldr	r2, [r2, #4]
 801178a:	b2d2      	uxtb	r2, r2
 801178c:	4611      	mov	r1, r2
 801178e:	6878      	ldr	r0, [r7, #4]
 8011790:	4798      	blx	r3
 8011792:	4603      	mov	r3, r0
 8011794:	2b00      	cmp	r3, #0
 8011796:	d001      	beq.n	801179c <USBD_LL_DevDisconnected+0x3c>
    {
      ret = USBD_FAIL;
 8011798:	2303      	movs	r3, #3
 801179a:	73fb      	strb	r3, [r7, #15]
    }
  }
#endif /* USE_USBD_COMPOSITE */

  return ret;
 801179c:	7bfb      	ldrb	r3, [r7, #15]
}
 801179e:	4618      	mov	r0, r3
 80117a0:	3710      	adds	r7, #16
 80117a2:	46bd      	mov	sp, r7
 80117a4:	bd80      	pop	{r7, pc}

080117a6 <USBD_CoreFindIF>:
  * @param  pdev: device instance
  * @param  index : selected interface number
  * @retval index of the class using the selected interface number. OxFF if no class found.
  */
uint8_t USBD_CoreFindIF(USBD_HandleTypeDef *pdev, uint8_t index)
{
 80117a6:	b480      	push	{r7}
 80117a8:	b083      	sub	sp, #12
 80117aa:	af00      	add	r7, sp, #0
 80117ac:	6078      	str	r0, [r7, #4]
 80117ae:	460b      	mov	r3, r1
 80117b0:	70fb      	strb	r3, [r7, #3]
  return 0xFFU;
#else
  UNUSED(pdev);
  UNUSED(index);

  return 0x00U;
 80117b2:	2300      	movs	r3, #0
#endif /* USE_USBD_COMPOSITE */
}
 80117b4:	4618      	mov	r0, r3
 80117b6:	370c      	adds	r7, #12
 80117b8:	46bd      	mov	sp, r7
 80117ba:	f85d 7b04 	ldr.w	r7, [sp], #4
 80117be:	4770      	bx	lr

080117c0 <USBD_CoreFindEP>:
  * @param  pdev: device instance
  * @param  index : selected endpoint number
  * @retval index of the class using the selected endpoint number. 0xFF if no class found.
  */
uint8_t USBD_CoreFindEP(USBD_HandleTypeDef *pdev, uint8_t index)
{
 80117c0:	b480      	push	{r7}
 80117c2:	b083      	sub	sp, #12
 80117c4:	af00      	add	r7, sp, #0
 80117c6:	6078      	str	r0, [r7, #4]
 80117c8:	460b      	mov	r3, r1
 80117ca:	70fb      	strb	r3, [r7, #3]
  return 0xFFU;
#else
  UNUSED(pdev);
  UNUSED(index);

  return 0x00U;
 80117cc:	2300      	movs	r3, #0
#endif /* USE_USBD_COMPOSITE */
}
 80117ce:	4618      	mov	r0, r3
 80117d0:	370c      	adds	r7, #12
 80117d2:	46bd      	mov	sp, r7
 80117d4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80117d8:	4770      	bx	lr

080117da <USBD_GetNextDesc>:
  * @param  buf: Buffer where the descriptor is available
  * @param  ptr: data pointer inside the descriptor
  * @retval next header
  */
USBD_DescHeaderTypeDef *USBD_GetNextDesc(uint8_t *pbuf, uint16_t *ptr)
{
 80117da:	b480      	push	{r7}
 80117dc:	b085      	sub	sp, #20
 80117de:	af00      	add	r7, sp, #0
 80117e0:	6078      	str	r0, [r7, #4]
 80117e2:	6039      	str	r1, [r7, #0]
  USBD_DescHeaderTypeDef *pnext = (USBD_DescHeaderTypeDef *)(void *)pbuf;
 80117e4:	687b      	ldr	r3, [r7, #4]
 80117e6:	60fb      	str	r3, [r7, #12]

  *ptr += pnext->bLength;
 80117e8:	683b      	ldr	r3, [r7, #0]
 80117ea:	881b      	ldrh	r3, [r3, #0]
 80117ec:	68fa      	ldr	r2, [r7, #12]
 80117ee:	7812      	ldrb	r2, [r2, #0]
 80117f0:	4413      	add	r3, r2
 80117f2:	b29a      	uxth	r2, r3
 80117f4:	683b      	ldr	r3, [r7, #0]
 80117f6:	801a      	strh	r2, [r3, #0]
  pnext = (USBD_DescHeaderTypeDef *)(void *)(pbuf + pnext->bLength);
 80117f8:	68fb      	ldr	r3, [r7, #12]
 80117fa:	781b      	ldrb	r3, [r3, #0]
 80117fc:	461a      	mov	r2, r3
 80117fe:	687b      	ldr	r3, [r7, #4]
 8011800:	4413      	add	r3, r2
 8011802:	60fb      	str	r3, [r7, #12]

  return (pnext);
 8011804:	68fb      	ldr	r3, [r7, #12]
}
 8011806:	4618      	mov	r0, r3
 8011808:	3714      	adds	r7, #20
 801180a:	46bd      	mov	sp, r7
 801180c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011810:	4770      	bx	lr

08011812 <SWAPBYTE>:

/** @defgroup USBD_DEF_Exported_Macros
  * @{
  */
__STATIC_INLINE uint16_t SWAPBYTE(uint8_t *addr)
{
 8011812:	b480      	push	{r7}
 8011814:	b087      	sub	sp, #28
 8011816:	af00      	add	r7, sp, #0
 8011818:	6078      	str	r0, [r7, #4]
  uint16_t _SwapVal;
  uint16_t _Byte1;
  uint16_t _Byte2;
  uint8_t *_pbuff = addr;
 801181a:	687b      	ldr	r3, [r7, #4]
 801181c:	617b      	str	r3, [r7, #20]

  _Byte1 = *(uint8_t *)_pbuff;
 801181e:	697b      	ldr	r3, [r7, #20]
 8011820:	781b      	ldrb	r3, [r3, #0]
 8011822:	827b      	strh	r3, [r7, #18]
  _pbuff++;
 8011824:	697b      	ldr	r3, [r7, #20]
 8011826:	3301      	adds	r3, #1
 8011828:	617b      	str	r3, [r7, #20]
  _Byte2 = *(uint8_t *)_pbuff;
 801182a:	697b      	ldr	r3, [r7, #20]
 801182c:	781b      	ldrb	r3, [r3, #0]
 801182e:	823b      	strh	r3, [r7, #16]

  _SwapVal = (_Byte2 << 8) | _Byte1;
 8011830:	8a3b      	ldrh	r3, [r7, #16]
 8011832:	021b      	lsls	r3, r3, #8
 8011834:	b21a      	sxth	r2, r3
 8011836:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 801183a:	4313      	orrs	r3, r2
 801183c:	b21b      	sxth	r3, r3
 801183e:	81fb      	strh	r3, [r7, #14]

  return _SwapVal;
 8011840:	89fb      	ldrh	r3, [r7, #14]
}
 8011842:	4618      	mov	r0, r3
 8011844:	371c      	adds	r7, #28
 8011846:	46bd      	mov	sp, r7
 8011848:	f85d 7b04 	ldr.w	r7, [sp], #4
 801184c:	4770      	bx	lr
	...

08011850 <USBD_StdDevReq>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval status
  */
USBD_StatusTypeDef USBD_StdDevReq(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 8011850:	b580      	push	{r7, lr}
 8011852:	b084      	sub	sp, #16
 8011854:	af00      	add	r7, sp, #0
 8011856:	6078      	str	r0, [r7, #4]
 8011858:	6039      	str	r1, [r7, #0]
  USBD_StatusTypeDef ret = USBD_OK;
 801185a:	2300      	movs	r3, #0
 801185c:	73fb      	strb	r3, [r7, #15]

  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 801185e:	683b      	ldr	r3, [r7, #0]
 8011860:	781b      	ldrb	r3, [r3, #0]
 8011862:	f003 0360 	and.w	r3, r3, #96	@ 0x60
 8011866:	2b40      	cmp	r3, #64	@ 0x40
 8011868:	d005      	beq.n	8011876 <USBD_StdDevReq+0x26>
 801186a:	2b40      	cmp	r3, #64	@ 0x40
 801186c:	d857      	bhi.n	801191e <USBD_StdDevReq+0xce>
 801186e:	2b00      	cmp	r3, #0
 8011870:	d00f      	beq.n	8011892 <USBD_StdDevReq+0x42>
 8011872:	2b20      	cmp	r3, #32
 8011874:	d153      	bne.n	801191e <USBD_StdDevReq+0xce>
  {
    case USB_REQ_TYPE_CLASS:
    case USB_REQ_TYPE_VENDOR:
      ret = (USBD_StatusTypeDef)pdev->pClass[pdev->classId]->Setup(pdev, req);
 8011876:	687b      	ldr	r3, [r7, #4]
 8011878:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 801187c:	687b      	ldr	r3, [r7, #4]
 801187e:	32ae      	adds	r2, #174	@ 0xae
 8011880:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8011884:	689b      	ldr	r3, [r3, #8]
 8011886:	6839      	ldr	r1, [r7, #0]
 8011888:	6878      	ldr	r0, [r7, #4]
 801188a:	4798      	blx	r3
 801188c:	4603      	mov	r3, r0
 801188e:	73fb      	strb	r3, [r7, #15]
      break;
 8011890:	e04a      	b.n	8011928 <USBD_StdDevReq+0xd8>

    case USB_REQ_TYPE_STANDARD:
      switch (req->bRequest)
 8011892:	683b      	ldr	r3, [r7, #0]
 8011894:	785b      	ldrb	r3, [r3, #1]
 8011896:	2b09      	cmp	r3, #9
 8011898:	d83b      	bhi.n	8011912 <USBD_StdDevReq+0xc2>
 801189a:	a201      	add	r2, pc, #4	@ (adr r2, 80118a0 <USBD_StdDevReq+0x50>)
 801189c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80118a0:	080118f5 	.word	0x080118f5
 80118a4:	08011909 	.word	0x08011909
 80118a8:	08011913 	.word	0x08011913
 80118ac:	080118ff 	.word	0x080118ff
 80118b0:	08011913 	.word	0x08011913
 80118b4:	080118d3 	.word	0x080118d3
 80118b8:	080118c9 	.word	0x080118c9
 80118bc:	08011913 	.word	0x08011913
 80118c0:	080118eb 	.word	0x080118eb
 80118c4:	080118dd 	.word	0x080118dd
      {
        case USB_REQ_GET_DESCRIPTOR:
          USBD_GetDescriptor(pdev, req);
 80118c8:	6839      	ldr	r1, [r7, #0]
 80118ca:	6878      	ldr	r0, [r7, #4]
 80118cc:	f000 fa3c 	bl	8011d48 <USBD_GetDescriptor>
          break;
 80118d0:	e024      	b.n	801191c <USBD_StdDevReq+0xcc>

        case USB_REQ_SET_ADDRESS:
          USBD_SetAddress(pdev, req);
 80118d2:	6839      	ldr	r1, [r7, #0]
 80118d4:	6878      	ldr	r0, [r7, #4]
 80118d6:	f000 fbcb 	bl	8012070 <USBD_SetAddress>
          break;
 80118da:	e01f      	b.n	801191c <USBD_StdDevReq+0xcc>

        case USB_REQ_SET_CONFIGURATION:
          ret = USBD_SetConfig(pdev, req);
 80118dc:	6839      	ldr	r1, [r7, #0]
 80118de:	6878      	ldr	r0, [r7, #4]
 80118e0:	f000 fc0a 	bl	80120f8 <USBD_SetConfig>
 80118e4:	4603      	mov	r3, r0
 80118e6:	73fb      	strb	r3, [r7, #15]
          break;
 80118e8:	e018      	b.n	801191c <USBD_StdDevReq+0xcc>

        case USB_REQ_GET_CONFIGURATION:
          USBD_GetConfig(pdev, req);
 80118ea:	6839      	ldr	r1, [r7, #0]
 80118ec:	6878      	ldr	r0, [r7, #4]
 80118ee:	f000 fcad 	bl	801224c <USBD_GetConfig>
          break;
 80118f2:	e013      	b.n	801191c <USBD_StdDevReq+0xcc>

        case USB_REQ_GET_STATUS:
          USBD_GetStatus(pdev, req);
 80118f4:	6839      	ldr	r1, [r7, #0]
 80118f6:	6878      	ldr	r0, [r7, #4]
 80118f8:	f000 fcde 	bl	80122b8 <USBD_GetStatus>
          break;
 80118fc:	e00e      	b.n	801191c <USBD_StdDevReq+0xcc>

        case USB_REQ_SET_FEATURE:
          USBD_SetFeature(pdev, req);
 80118fe:	6839      	ldr	r1, [r7, #0]
 8011900:	6878      	ldr	r0, [r7, #4]
 8011902:	f000 fd0d 	bl	8012320 <USBD_SetFeature>
          break;
 8011906:	e009      	b.n	801191c <USBD_StdDevReq+0xcc>

        case USB_REQ_CLEAR_FEATURE:
          USBD_ClrFeature(pdev, req);
 8011908:	6839      	ldr	r1, [r7, #0]
 801190a:	6878      	ldr	r0, [r7, #4]
 801190c:	f000 fd31 	bl	8012372 <USBD_ClrFeature>
          break;
 8011910:	e004      	b.n	801191c <USBD_StdDevReq+0xcc>

        default:
          USBD_CtlError(pdev, req);
 8011912:	6839      	ldr	r1, [r7, #0]
 8011914:	6878      	ldr	r0, [r7, #4]
 8011916:	f000 fd88 	bl	801242a <USBD_CtlError>
          break;
 801191a:	bf00      	nop
      }
      break;
 801191c:	e004      	b.n	8011928 <USBD_StdDevReq+0xd8>

    default:
      USBD_CtlError(pdev, req);
 801191e:	6839      	ldr	r1, [r7, #0]
 8011920:	6878      	ldr	r0, [r7, #4]
 8011922:	f000 fd82 	bl	801242a <USBD_CtlError>
      break;
 8011926:	bf00      	nop
  }

  return ret;
 8011928:	7bfb      	ldrb	r3, [r7, #15]
}
 801192a:	4618      	mov	r0, r3
 801192c:	3710      	adds	r7, #16
 801192e:	46bd      	mov	sp, r7
 8011930:	bd80      	pop	{r7, pc}
 8011932:	bf00      	nop

08011934 <USBD_StdItfReq>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval status
  */
USBD_StatusTypeDef USBD_StdItfReq(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 8011934:	b580      	push	{r7, lr}
 8011936:	b084      	sub	sp, #16
 8011938:	af00      	add	r7, sp, #0
 801193a:	6078      	str	r0, [r7, #4]
 801193c:	6039      	str	r1, [r7, #0]
  USBD_StatusTypeDef ret = USBD_OK;
 801193e:	2300      	movs	r3, #0
 8011940:	73fb      	strb	r3, [r7, #15]
  uint8_t idx;

  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8011942:	683b      	ldr	r3, [r7, #0]
 8011944:	781b      	ldrb	r3, [r3, #0]
 8011946:	f003 0360 	and.w	r3, r3, #96	@ 0x60
 801194a:	2b40      	cmp	r3, #64	@ 0x40
 801194c:	d005      	beq.n	801195a <USBD_StdItfReq+0x26>
 801194e:	2b40      	cmp	r3, #64	@ 0x40
 8011950:	d852      	bhi.n	80119f8 <USBD_StdItfReq+0xc4>
 8011952:	2b00      	cmp	r3, #0
 8011954:	d001      	beq.n	801195a <USBD_StdItfReq+0x26>
 8011956:	2b20      	cmp	r3, #32
 8011958:	d14e      	bne.n	80119f8 <USBD_StdItfReq+0xc4>
  {
    case USB_REQ_TYPE_CLASS:
    case USB_REQ_TYPE_VENDOR:
    case USB_REQ_TYPE_STANDARD:
      switch (pdev->dev_state)
 801195a:	687b      	ldr	r3, [r7, #4]
 801195c:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 8011960:	b2db      	uxtb	r3, r3
 8011962:	3b01      	subs	r3, #1
 8011964:	2b02      	cmp	r3, #2
 8011966:	d840      	bhi.n	80119ea <USBD_StdItfReq+0xb6>
      {
        case USBD_STATE_DEFAULT:
        case USBD_STATE_ADDRESSED:
        case USBD_STATE_CONFIGURED:

          if (LOBYTE(req->wIndex) <= USBD_MAX_NUM_INTERFACES)
 8011968:	683b      	ldr	r3, [r7, #0]
 801196a:	889b      	ldrh	r3, [r3, #4]
 801196c:	b2db      	uxtb	r3, r3
 801196e:	2b02      	cmp	r3, #2
 8011970:	d836      	bhi.n	80119e0 <USBD_StdItfReq+0xac>
          {
            /* Get the class index relative to this interface */
            idx = USBD_CoreFindIF(pdev, LOBYTE(req->wIndex));
 8011972:	683b      	ldr	r3, [r7, #0]
 8011974:	889b      	ldrh	r3, [r3, #4]
 8011976:	b2db      	uxtb	r3, r3
 8011978:	4619      	mov	r1, r3
 801197a:	6878      	ldr	r0, [r7, #4]
 801197c:	f7ff ff13 	bl	80117a6 <USBD_CoreFindIF>
 8011980:	4603      	mov	r3, r0
 8011982:	73bb      	strb	r3, [r7, #14]
            if (((uint8_t)idx != 0xFFU) && (idx < USBD_MAX_SUPPORTED_CLASS))
 8011984:	7bbb      	ldrb	r3, [r7, #14]
 8011986:	2bff      	cmp	r3, #255	@ 0xff
 8011988:	d01d      	beq.n	80119c6 <USBD_StdItfReq+0x92>
 801198a:	7bbb      	ldrb	r3, [r7, #14]
 801198c:	2b00      	cmp	r3, #0
 801198e:	d11a      	bne.n	80119c6 <USBD_StdItfReq+0x92>
            {
              /* Call the class data out function to manage the request */
              if (pdev->pClass[idx]->Setup != NULL)
 8011990:	7bba      	ldrb	r2, [r7, #14]
 8011992:	687b      	ldr	r3, [r7, #4]
 8011994:	32ae      	adds	r2, #174	@ 0xae
 8011996:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 801199a:	689b      	ldr	r3, [r3, #8]
 801199c:	2b00      	cmp	r3, #0
 801199e:	d00f      	beq.n	80119c0 <USBD_StdItfReq+0x8c>
              {
                pdev->classId = idx;
 80119a0:	7bba      	ldrb	r2, [r7, #14]
 80119a2:	687b      	ldr	r3, [r7, #4]
 80119a4:	f8c3 22d4 	str.w	r2, [r3, #724]	@ 0x2d4
                ret = (USBD_StatusTypeDef)(pdev->pClass[idx]->Setup(pdev, req));
 80119a8:	7bba      	ldrb	r2, [r7, #14]
 80119aa:	687b      	ldr	r3, [r7, #4]
 80119ac:	32ae      	adds	r2, #174	@ 0xae
 80119ae:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80119b2:	689b      	ldr	r3, [r3, #8]
 80119b4:	6839      	ldr	r1, [r7, #0]
 80119b6:	6878      	ldr	r0, [r7, #4]
 80119b8:	4798      	blx	r3
 80119ba:	4603      	mov	r3, r0
 80119bc:	73fb      	strb	r3, [r7, #15]
              if (pdev->pClass[idx]->Setup != NULL)
 80119be:	e004      	b.n	80119ca <USBD_StdItfReq+0x96>
              }
              else
              {
                /* should never reach this condition */
                ret = USBD_FAIL;
 80119c0:	2303      	movs	r3, #3
 80119c2:	73fb      	strb	r3, [r7, #15]
              if (pdev->pClass[idx]->Setup != NULL)
 80119c4:	e001      	b.n	80119ca <USBD_StdItfReq+0x96>
              }
            }
            else
            {
              /* No relative interface found */
              ret = USBD_FAIL;
 80119c6:	2303      	movs	r3, #3
 80119c8:	73fb      	strb	r3, [r7, #15]
            }

            if ((req->wLength == 0U) && (ret == USBD_OK))
 80119ca:	683b      	ldr	r3, [r7, #0]
 80119cc:	88db      	ldrh	r3, [r3, #6]
 80119ce:	2b00      	cmp	r3, #0
 80119d0:	d110      	bne.n	80119f4 <USBD_StdItfReq+0xc0>
 80119d2:	7bfb      	ldrb	r3, [r7, #15]
 80119d4:	2b00      	cmp	r3, #0
 80119d6:	d10d      	bne.n	80119f4 <USBD_StdItfReq+0xc0>
            {
              (void)USBD_CtlSendStatus(pdev);
 80119d8:	6878      	ldr	r0, [r7, #4]
 80119da:	f000 fdfd 	bl	80125d8 <USBD_CtlSendStatus>
          }
          else
          {
            USBD_CtlError(pdev, req);
          }
          break;
 80119de:	e009      	b.n	80119f4 <USBD_StdItfReq+0xc0>
            USBD_CtlError(pdev, req);
 80119e0:	6839      	ldr	r1, [r7, #0]
 80119e2:	6878      	ldr	r0, [r7, #4]
 80119e4:	f000 fd21 	bl	801242a <USBD_CtlError>
          break;
 80119e8:	e004      	b.n	80119f4 <USBD_StdItfReq+0xc0>

        default:
          USBD_CtlError(pdev, req);
 80119ea:	6839      	ldr	r1, [r7, #0]
 80119ec:	6878      	ldr	r0, [r7, #4]
 80119ee:	f000 fd1c 	bl	801242a <USBD_CtlError>
          break;
 80119f2:	e000      	b.n	80119f6 <USBD_StdItfReq+0xc2>
          break;
 80119f4:	bf00      	nop
      }
      break;
 80119f6:	e004      	b.n	8011a02 <USBD_StdItfReq+0xce>

    default:
      USBD_CtlError(pdev, req);
 80119f8:	6839      	ldr	r1, [r7, #0]
 80119fa:	6878      	ldr	r0, [r7, #4]
 80119fc:	f000 fd15 	bl	801242a <USBD_CtlError>
      break;
 8011a00:	bf00      	nop
  }

  return ret;
 8011a02:	7bfb      	ldrb	r3, [r7, #15]
}
 8011a04:	4618      	mov	r0, r3
 8011a06:	3710      	adds	r7, #16
 8011a08:	46bd      	mov	sp, r7
 8011a0a:	bd80      	pop	{r7, pc}

08011a0c <USBD_StdEPReq>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval status
  */
USBD_StatusTypeDef USBD_StdEPReq(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 8011a0c:	b580      	push	{r7, lr}
 8011a0e:	b084      	sub	sp, #16
 8011a10:	af00      	add	r7, sp, #0
 8011a12:	6078      	str	r0, [r7, #4]
 8011a14:	6039      	str	r1, [r7, #0]
  USBD_EndpointTypeDef *pep;
  uint8_t ep_addr;
  uint8_t idx;
  USBD_StatusTypeDef ret = USBD_OK;
 8011a16:	2300      	movs	r3, #0
 8011a18:	73fb      	strb	r3, [r7, #15]

  ep_addr = LOBYTE(req->wIndex);
 8011a1a:	683b      	ldr	r3, [r7, #0]
 8011a1c:	889b      	ldrh	r3, [r3, #4]
 8011a1e:	73bb      	strb	r3, [r7, #14]

  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8011a20:	683b      	ldr	r3, [r7, #0]
 8011a22:	781b      	ldrb	r3, [r3, #0]
 8011a24:	f003 0360 	and.w	r3, r3, #96	@ 0x60
 8011a28:	2b40      	cmp	r3, #64	@ 0x40
 8011a2a:	d007      	beq.n	8011a3c <USBD_StdEPReq+0x30>
 8011a2c:	2b40      	cmp	r3, #64	@ 0x40
 8011a2e:	f200 817f 	bhi.w	8011d30 <USBD_StdEPReq+0x324>
 8011a32:	2b00      	cmp	r3, #0
 8011a34:	d02a      	beq.n	8011a8c <USBD_StdEPReq+0x80>
 8011a36:	2b20      	cmp	r3, #32
 8011a38:	f040 817a 	bne.w	8011d30 <USBD_StdEPReq+0x324>
  {
    case USB_REQ_TYPE_CLASS:
    case USB_REQ_TYPE_VENDOR:
      /* Get the class index relative to this endpoint */
      idx = USBD_CoreFindEP(pdev, ep_addr);
 8011a3c:	7bbb      	ldrb	r3, [r7, #14]
 8011a3e:	4619      	mov	r1, r3
 8011a40:	6878      	ldr	r0, [r7, #4]
 8011a42:	f7ff febd 	bl	80117c0 <USBD_CoreFindEP>
 8011a46:	4603      	mov	r3, r0
 8011a48:	737b      	strb	r3, [r7, #13]
      if (((uint8_t)idx != 0xFFU) && (idx < USBD_MAX_SUPPORTED_CLASS))
 8011a4a:	7b7b      	ldrb	r3, [r7, #13]
 8011a4c:	2bff      	cmp	r3, #255	@ 0xff
 8011a4e:	f000 8174 	beq.w	8011d3a <USBD_StdEPReq+0x32e>
 8011a52:	7b7b      	ldrb	r3, [r7, #13]
 8011a54:	2b00      	cmp	r3, #0
 8011a56:	f040 8170 	bne.w	8011d3a <USBD_StdEPReq+0x32e>
      {
        pdev->classId = idx;
 8011a5a:	7b7a      	ldrb	r2, [r7, #13]
 8011a5c:	687b      	ldr	r3, [r7, #4]
 8011a5e:	f8c3 22d4 	str.w	r2, [r3, #724]	@ 0x2d4
        /* Call the class data out function to manage the request */
        if (pdev->pClass[idx]->Setup != NULL)
 8011a62:	7b7a      	ldrb	r2, [r7, #13]
 8011a64:	687b      	ldr	r3, [r7, #4]
 8011a66:	32ae      	adds	r2, #174	@ 0xae
 8011a68:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8011a6c:	689b      	ldr	r3, [r3, #8]
 8011a6e:	2b00      	cmp	r3, #0
 8011a70:	f000 8163 	beq.w	8011d3a <USBD_StdEPReq+0x32e>
        {
          ret = (USBD_StatusTypeDef)pdev->pClass[idx]->Setup(pdev, req);
 8011a74:	7b7a      	ldrb	r2, [r7, #13]
 8011a76:	687b      	ldr	r3, [r7, #4]
 8011a78:	32ae      	adds	r2, #174	@ 0xae
 8011a7a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8011a7e:	689b      	ldr	r3, [r3, #8]
 8011a80:	6839      	ldr	r1, [r7, #0]
 8011a82:	6878      	ldr	r0, [r7, #4]
 8011a84:	4798      	blx	r3
 8011a86:	4603      	mov	r3, r0
 8011a88:	73fb      	strb	r3, [r7, #15]
        }
      }
      break;
 8011a8a:	e156      	b.n	8011d3a <USBD_StdEPReq+0x32e>

    case USB_REQ_TYPE_STANDARD:
      switch (req->bRequest)
 8011a8c:	683b      	ldr	r3, [r7, #0]
 8011a8e:	785b      	ldrb	r3, [r3, #1]
 8011a90:	2b03      	cmp	r3, #3
 8011a92:	d008      	beq.n	8011aa6 <USBD_StdEPReq+0x9a>
 8011a94:	2b03      	cmp	r3, #3
 8011a96:	f300 8145 	bgt.w	8011d24 <USBD_StdEPReq+0x318>
 8011a9a:	2b00      	cmp	r3, #0
 8011a9c:	f000 809b 	beq.w	8011bd6 <USBD_StdEPReq+0x1ca>
 8011aa0:	2b01      	cmp	r3, #1
 8011aa2:	d03c      	beq.n	8011b1e <USBD_StdEPReq+0x112>
 8011aa4:	e13e      	b.n	8011d24 <USBD_StdEPReq+0x318>
      {
        case USB_REQ_SET_FEATURE:
          switch (pdev->dev_state)
 8011aa6:	687b      	ldr	r3, [r7, #4]
 8011aa8:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 8011aac:	b2db      	uxtb	r3, r3
 8011aae:	2b02      	cmp	r3, #2
 8011ab0:	d002      	beq.n	8011ab8 <USBD_StdEPReq+0xac>
 8011ab2:	2b03      	cmp	r3, #3
 8011ab4:	d016      	beq.n	8011ae4 <USBD_StdEPReq+0xd8>
 8011ab6:	e02c      	b.n	8011b12 <USBD_StdEPReq+0x106>
          {
            case USBD_STATE_ADDRESSED:
              if ((ep_addr != 0x00U) && (ep_addr != 0x80U))
 8011ab8:	7bbb      	ldrb	r3, [r7, #14]
 8011aba:	2b00      	cmp	r3, #0
 8011abc:	d00d      	beq.n	8011ada <USBD_StdEPReq+0xce>
 8011abe:	7bbb      	ldrb	r3, [r7, #14]
 8011ac0:	2b80      	cmp	r3, #128	@ 0x80
 8011ac2:	d00a      	beq.n	8011ada <USBD_StdEPReq+0xce>
              {
                (void)USBD_LL_StallEP(pdev, ep_addr);
 8011ac4:	7bbb      	ldrb	r3, [r7, #14]
 8011ac6:	4619      	mov	r1, r3
 8011ac8:	6878      	ldr	r0, [r7, #4]
 8011aca:	f001 f94d 	bl	8012d68 <USBD_LL_StallEP>
                (void)USBD_LL_StallEP(pdev, 0x80U);
 8011ace:	2180      	movs	r1, #128	@ 0x80
 8011ad0:	6878      	ldr	r0, [r7, #4]
 8011ad2:	f001 f949 	bl	8012d68 <USBD_LL_StallEP>
 8011ad6:	bf00      	nop
              }
              else
              {
                USBD_CtlError(pdev, req);
              }
              break;
 8011ad8:	e020      	b.n	8011b1c <USBD_StdEPReq+0x110>
                USBD_CtlError(pdev, req);
 8011ada:	6839      	ldr	r1, [r7, #0]
 8011adc:	6878      	ldr	r0, [r7, #4]
 8011ade:	f000 fca4 	bl	801242a <USBD_CtlError>
              break;
 8011ae2:	e01b      	b.n	8011b1c <USBD_StdEPReq+0x110>

            case USBD_STATE_CONFIGURED:
              if (req->wValue == USB_FEATURE_EP_HALT)
 8011ae4:	683b      	ldr	r3, [r7, #0]
 8011ae6:	885b      	ldrh	r3, [r3, #2]
 8011ae8:	2b00      	cmp	r3, #0
 8011aea:	d10e      	bne.n	8011b0a <USBD_StdEPReq+0xfe>
              {
                if ((ep_addr != 0x00U) && (ep_addr != 0x80U) && (req->wLength == 0x00U))
 8011aec:	7bbb      	ldrb	r3, [r7, #14]
 8011aee:	2b00      	cmp	r3, #0
 8011af0:	d00b      	beq.n	8011b0a <USBD_StdEPReq+0xfe>
 8011af2:	7bbb      	ldrb	r3, [r7, #14]
 8011af4:	2b80      	cmp	r3, #128	@ 0x80
 8011af6:	d008      	beq.n	8011b0a <USBD_StdEPReq+0xfe>
 8011af8:	683b      	ldr	r3, [r7, #0]
 8011afa:	88db      	ldrh	r3, [r3, #6]
 8011afc:	2b00      	cmp	r3, #0
 8011afe:	d104      	bne.n	8011b0a <USBD_StdEPReq+0xfe>
                {
                  (void)USBD_LL_StallEP(pdev, ep_addr);
 8011b00:	7bbb      	ldrb	r3, [r7, #14]
 8011b02:	4619      	mov	r1, r3
 8011b04:	6878      	ldr	r0, [r7, #4]
 8011b06:	f001 f92f 	bl	8012d68 <USBD_LL_StallEP>
                }
              }
              (void)USBD_CtlSendStatus(pdev);
 8011b0a:	6878      	ldr	r0, [r7, #4]
 8011b0c:	f000 fd64 	bl	80125d8 <USBD_CtlSendStatus>

              break;
 8011b10:	e004      	b.n	8011b1c <USBD_StdEPReq+0x110>

            default:
              USBD_CtlError(pdev, req);
 8011b12:	6839      	ldr	r1, [r7, #0]
 8011b14:	6878      	ldr	r0, [r7, #4]
 8011b16:	f000 fc88 	bl	801242a <USBD_CtlError>
              break;
 8011b1a:	bf00      	nop
          }
          break;
 8011b1c:	e107      	b.n	8011d2e <USBD_StdEPReq+0x322>

        case USB_REQ_CLEAR_FEATURE:

          switch (pdev->dev_state)
 8011b1e:	687b      	ldr	r3, [r7, #4]
 8011b20:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 8011b24:	b2db      	uxtb	r3, r3
 8011b26:	2b02      	cmp	r3, #2
 8011b28:	d002      	beq.n	8011b30 <USBD_StdEPReq+0x124>
 8011b2a:	2b03      	cmp	r3, #3
 8011b2c:	d016      	beq.n	8011b5c <USBD_StdEPReq+0x150>
 8011b2e:	e04b      	b.n	8011bc8 <USBD_StdEPReq+0x1bc>
          {
            case USBD_STATE_ADDRESSED:
              if ((ep_addr != 0x00U) && (ep_addr != 0x80U))
 8011b30:	7bbb      	ldrb	r3, [r7, #14]
 8011b32:	2b00      	cmp	r3, #0
 8011b34:	d00d      	beq.n	8011b52 <USBD_StdEPReq+0x146>
 8011b36:	7bbb      	ldrb	r3, [r7, #14]
 8011b38:	2b80      	cmp	r3, #128	@ 0x80
 8011b3a:	d00a      	beq.n	8011b52 <USBD_StdEPReq+0x146>
              {
                (void)USBD_LL_StallEP(pdev, ep_addr);
 8011b3c:	7bbb      	ldrb	r3, [r7, #14]
 8011b3e:	4619      	mov	r1, r3
 8011b40:	6878      	ldr	r0, [r7, #4]
 8011b42:	f001 f911 	bl	8012d68 <USBD_LL_StallEP>
                (void)USBD_LL_StallEP(pdev, 0x80U);
 8011b46:	2180      	movs	r1, #128	@ 0x80
 8011b48:	6878      	ldr	r0, [r7, #4]
 8011b4a:	f001 f90d 	bl	8012d68 <USBD_LL_StallEP>
 8011b4e:	bf00      	nop
              }
              else
              {
                USBD_CtlError(pdev, req);
              }
              break;
 8011b50:	e040      	b.n	8011bd4 <USBD_StdEPReq+0x1c8>
                USBD_CtlError(pdev, req);
 8011b52:	6839      	ldr	r1, [r7, #0]
 8011b54:	6878      	ldr	r0, [r7, #4]
 8011b56:	f000 fc68 	bl	801242a <USBD_CtlError>
              break;
 8011b5a:	e03b      	b.n	8011bd4 <USBD_StdEPReq+0x1c8>

            case USBD_STATE_CONFIGURED:
              if (req->wValue == USB_FEATURE_EP_HALT)
 8011b5c:	683b      	ldr	r3, [r7, #0]
 8011b5e:	885b      	ldrh	r3, [r3, #2]
 8011b60:	2b00      	cmp	r3, #0
 8011b62:	d136      	bne.n	8011bd2 <USBD_StdEPReq+0x1c6>
              {
                if ((ep_addr & 0x7FU) != 0x00U)
 8011b64:	7bbb      	ldrb	r3, [r7, #14]
 8011b66:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 8011b6a:	2b00      	cmp	r3, #0
 8011b6c:	d004      	beq.n	8011b78 <USBD_StdEPReq+0x16c>
                {
                  (void)USBD_LL_ClearStallEP(pdev, ep_addr);
 8011b6e:	7bbb      	ldrb	r3, [r7, #14]
 8011b70:	4619      	mov	r1, r3
 8011b72:	6878      	ldr	r0, [r7, #4]
 8011b74:	f001 f917 	bl	8012da6 <USBD_LL_ClearStallEP>
                }
                (void)USBD_CtlSendStatus(pdev);
 8011b78:	6878      	ldr	r0, [r7, #4]
 8011b7a:	f000 fd2d 	bl	80125d8 <USBD_CtlSendStatus>

                /* Get the class index relative to this interface */
                idx = USBD_CoreFindEP(pdev, ep_addr);
 8011b7e:	7bbb      	ldrb	r3, [r7, #14]
 8011b80:	4619      	mov	r1, r3
 8011b82:	6878      	ldr	r0, [r7, #4]
 8011b84:	f7ff fe1c 	bl	80117c0 <USBD_CoreFindEP>
 8011b88:	4603      	mov	r3, r0
 8011b8a:	737b      	strb	r3, [r7, #13]
                if (((uint8_t)idx != 0xFFU) && (idx < USBD_MAX_SUPPORTED_CLASS))
 8011b8c:	7b7b      	ldrb	r3, [r7, #13]
 8011b8e:	2bff      	cmp	r3, #255	@ 0xff
 8011b90:	d01f      	beq.n	8011bd2 <USBD_StdEPReq+0x1c6>
 8011b92:	7b7b      	ldrb	r3, [r7, #13]
 8011b94:	2b00      	cmp	r3, #0
 8011b96:	d11c      	bne.n	8011bd2 <USBD_StdEPReq+0x1c6>
                {
                  pdev->classId = idx;
 8011b98:	7b7a      	ldrb	r2, [r7, #13]
 8011b9a:	687b      	ldr	r3, [r7, #4]
 8011b9c:	f8c3 22d4 	str.w	r2, [r3, #724]	@ 0x2d4
                  /* Call the class data out function to manage the request */
                  if (pdev->pClass[idx]->Setup != NULL)
 8011ba0:	7b7a      	ldrb	r2, [r7, #13]
 8011ba2:	687b      	ldr	r3, [r7, #4]
 8011ba4:	32ae      	adds	r2, #174	@ 0xae
 8011ba6:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8011baa:	689b      	ldr	r3, [r3, #8]
 8011bac:	2b00      	cmp	r3, #0
 8011bae:	d010      	beq.n	8011bd2 <USBD_StdEPReq+0x1c6>
                  {
                    ret = (USBD_StatusTypeDef)(pdev->pClass[idx]->Setup(pdev, req));
 8011bb0:	7b7a      	ldrb	r2, [r7, #13]
 8011bb2:	687b      	ldr	r3, [r7, #4]
 8011bb4:	32ae      	adds	r2, #174	@ 0xae
 8011bb6:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8011bba:	689b      	ldr	r3, [r3, #8]
 8011bbc:	6839      	ldr	r1, [r7, #0]
 8011bbe:	6878      	ldr	r0, [r7, #4]
 8011bc0:	4798      	blx	r3
 8011bc2:	4603      	mov	r3, r0
 8011bc4:	73fb      	strb	r3, [r7, #15]
                  }
                }
              }
              break;
 8011bc6:	e004      	b.n	8011bd2 <USBD_StdEPReq+0x1c6>

            default:
              USBD_CtlError(pdev, req);
 8011bc8:	6839      	ldr	r1, [r7, #0]
 8011bca:	6878      	ldr	r0, [r7, #4]
 8011bcc:	f000 fc2d 	bl	801242a <USBD_CtlError>
              break;
 8011bd0:	e000      	b.n	8011bd4 <USBD_StdEPReq+0x1c8>
              break;
 8011bd2:	bf00      	nop
          }
          break;
 8011bd4:	e0ab      	b.n	8011d2e <USBD_StdEPReq+0x322>

        case USB_REQ_GET_STATUS:
          switch (pdev->dev_state)
 8011bd6:	687b      	ldr	r3, [r7, #4]
 8011bd8:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 8011bdc:	b2db      	uxtb	r3, r3
 8011bde:	2b02      	cmp	r3, #2
 8011be0:	d002      	beq.n	8011be8 <USBD_StdEPReq+0x1dc>
 8011be2:	2b03      	cmp	r3, #3
 8011be4:	d032      	beq.n	8011c4c <USBD_StdEPReq+0x240>
 8011be6:	e097      	b.n	8011d18 <USBD_StdEPReq+0x30c>
          {
            case USBD_STATE_ADDRESSED:
              if ((ep_addr != 0x00U) && (ep_addr != 0x80U))
 8011be8:	7bbb      	ldrb	r3, [r7, #14]
 8011bea:	2b00      	cmp	r3, #0
 8011bec:	d007      	beq.n	8011bfe <USBD_StdEPReq+0x1f2>
 8011bee:	7bbb      	ldrb	r3, [r7, #14]
 8011bf0:	2b80      	cmp	r3, #128	@ 0x80
 8011bf2:	d004      	beq.n	8011bfe <USBD_StdEPReq+0x1f2>
              {
                USBD_CtlError(pdev, req);
 8011bf4:	6839      	ldr	r1, [r7, #0]
 8011bf6:	6878      	ldr	r0, [r7, #4]
 8011bf8:	f000 fc17 	bl	801242a <USBD_CtlError>
                break;
 8011bfc:	e091      	b.n	8011d22 <USBD_StdEPReq+0x316>
              }
              pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 8011bfe:	f997 300e 	ldrsb.w	r3, [r7, #14]
 8011c02:	2b00      	cmp	r3, #0
 8011c04:	da0b      	bge.n	8011c1e <USBD_StdEPReq+0x212>
 8011c06:	7bbb      	ldrb	r3, [r7, #14]
 8011c08:	f003 027f 	and.w	r2, r3, #127	@ 0x7f
 8011c0c:	4613      	mov	r3, r2
 8011c0e:	009b      	lsls	r3, r3, #2
 8011c10:	4413      	add	r3, r2
 8011c12:	009b      	lsls	r3, r3, #2
 8011c14:	3310      	adds	r3, #16
 8011c16:	687a      	ldr	r2, [r7, #4]
 8011c18:	4413      	add	r3, r2
 8011c1a:	3304      	adds	r3, #4
 8011c1c:	e00b      	b.n	8011c36 <USBD_StdEPReq+0x22a>
                    &pdev->ep_out[ep_addr & 0x7FU];
 8011c1e:	7bbb      	ldrb	r3, [r7, #14]
 8011c20:	f003 027f 	and.w	r2, r3, #127	@ 0x7f
              pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 8011c24:	4613      	mov	r3, r2
 8011c26:	009b      	lsls	r3, r3, #2
 8011c28:	4413      	add	r3, r2
 8011c2a:	009b      	lsls	r3, r3, #2
 8011c2c:	f503 73a8 	add.w	r3, r3, #336	@ 0x150
 8011c30:	687a      	ldr	r2, [r7, #4]
 8011c32:	4413      	add	r3, r2
 8011c34:	3304      	adds	r3, #4
 8011c36:	60bb      	str	r3, [r7, #8]

              pep->status = 0x0000U;
 8011c38:	68bb      	ldr	r3, [r7, #8]
 8011c3a:	2200      	movs	r2, #0
 8011c3c:	601a      	str	r2, [r3, #0]

              (void)USBD_CtlSendData(pdev, (uint8_t *)&pep->status, 2U);
 8011c3e:	68bb      	ldr	r3, [r7, #8]
 8011c40:	2202      	movs	r2, #2
 8011c42:	4619      	mov	r1, r3
 8011c44:	6878      	ldr	r0, [r7, #4]
 8011c46:	f000 fc6d 	bl	8012524 <USBD_CtlSendData>
              break;
 8011c4a:	e06a      	b.n	8011d22 <USBD_StdEPReq+0x316>

            case USBD_STATE_CONFIGURED:
              if ((ep_addr & 0x80U) == 0x80U)
 8011c4c:	f997 300e 	ldrsb.w	r3, [r7, #14]
 8011c50:	2b00      	cmp	r3, #0
 8011c52:	da11      	bge.n	8011c78 <USBD_StdEPReq+0x26c>
              {
                if (pdev->ep_in[ep_addr & 0xFU].is_used == 0U)
 8011c54:	7bbb      	ldrb	r3, [r7, #14]
 8011c56:	f003 020f 	and.w	r2, r3, #15
 8011c5a:	6879      	ldr	r1, [r7, #4]
 8011c5c:	4613      	mov	r3, r2
 8011c5e:	009b      	lsls	r3, r3, #2
 8011c60:	4413      	add	r3, r2
 8011c62:	009b      	lsls	r3, r3, #2
 8011c64:	440b      	add	r3, r1
 8011c66:	3324      	adds	r3, #36	@ 0x24
 8011c68:	881b      	ldrh	r3, [r3, #0]
 8011c6a:	2b00      	cmp	r3, #0
 8011c6c:	d117      	bne.n	8011c9e <USBD_StdEPReq+0x292>
                {
                  USBD_CtlError(pdev, req);
 8011c6e:	6839      	ldr	r1, [r7, #0]
 8011c70:	6878      	ldr	r0, [r7, #4]
 8011c72:	f000 fbda 	bl	801242a <USBD_CtlError>
                  break;
 8011c76:	e054      	b.n	8011d22 <USBD_StdEPReq+0x316>
                }
              }
              else
              {
                if (pdev->ep_out[ep_addr & 0xFU].is_used == 0U)
 8011c78:	7bbb      	ldrb	r3, [r7, #14]
 8011c7a:	f003 020f 	and.w	r2, r3, #15
 8011c7e:	6879      	ldr	r1, [r7, #4]
 8011c80:	4613      	mov	r3, r2
 8011c82:	009b      	lsls	r3, r3, #2
 8011c84:	4413      	add	r3, r2
 8011c86:	009b      	lsls	r3, r3, #2
 8011c88:	440b      	add	r3, r1
 8011c8a:	f503 73b2 	add.w	r3, r3, #356	@ 0x164
 8011c8e:	881b      	ldrh	r3, [r3, #0]
 8011c90:	2b00      	cmp	r3, #0
 8011c92:	d104      	bne.n	8011c9e <USBD_StdEPReq+0x292>
                {
                  USBD_CtlError(pdev, req);
 8011c94:	6839      	ldr	r1, [r7, #0]
 8011c96:	6878      	ldr	r0, [r7, #4]
 8011c98:	f000 fbc7 	bl	801242a <USBD_CtlError>
                  break;
 8011c9c:	e041      	b.n	8011d22 <USBD_StdEPReq+0x316>
                }
              }

              pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 8011c9e:	f997 300e 	ldrsb.w	r3, [r7, #14]
 8011ca2:	2b00      	cmp	r3, #0
 8011ca4:	da0b      	bge.n	8011cbe <USBD_StdEPReq+0x2b2>
 8011ca6:	7bbb      	ldrb	r3, [r7, #14]
 8011ca8:	f003 027f 	and.w	r2, r3, #127	@ 0x7f
 8011cac:	4613      	mov	r3, r2
 8011cae:	009b      	lsls	r3, r3, #2
 8011cb0:	4413      	add	r3, r2
 8011cb2:	009b      	lsls	r3, r3, #2
 8011cb4:	3310      	adds	r3, #16
 8011cb6:	687a      	ldr	r2, [r7, #4]
 8011cb8:	4413      	add	r3, r2
 8011cba:	3304      	adds	r3, #4
 8011cbc:	e00b      	b.n	8011cd6 <USBD_StdEPReq+0x2ca>
                    &pdev->ep_out[ep_addr & 0x7FU];
 8011cbe:	7bbb      	ldrb	r3, [r7, #14]
 8011cc0:	f003 027f 	and.w	r2, r3, #127	@ 0x7f
              pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 8011cc4:	4613      	mov	r3, r2
 8011cc6:	009b      	lsls	r3, r3, #2
 8011cc8:	4413      	add	r3, r2
 8011cca:	009b      	lsls	r3, r3, #2
 8011ccc:	f503 73a8 	add.w	r3, r3, #336	@ 0x150
 8011cd0:	687a      	ldr	r2, [r7, #4]
 8011cd2:	4413      	add	r3, r2
 8011cd4:	3304      	adds	r3, #4
 8011cd6:	60bb      	str	r3, [r7, #8]

              if ((ep_addr == 0x00U) || (ep_addr == 0x80U))
 8011cd8:	7bbb      	ldrb	r3, [r7, #14]
 8011cda:	2b00      	cmp	r3, #0
 8011cdc:	d002      	beq.n	8011ce4 <USBD_StdEPReq+0x2d8>
 8011cde:	7bbb      	ldrb	r3, [r7, #14]
 8011ce0:	2b80      	cmp	r3, #128	@ 0x80
 8011ce2:	d103      	bne.n	8011cec <USBD_StdEPReq+0x2e0>
              {
                pep->status = 0x0000U;
 8011ce4:	68bb      	ldr	r3, [r7, #8]
 8011ce6:	2200      	movs	r2, #0
 8011ce8:	601a      	str	r2, [r3, #0]
 8011cea:	e00e      	b.n	8011d0a <USBD_StdEPReq+0x2fe>
              }
              else if (USBD_LL_IsStallEP(pdev, ep_addr) != 0U)
 8011cec:	7bbb      	ldrb	r3, [r7, #14]
 8011cee:	4619      	mov	r1, r3
 8011cf0:	6878      	ldr	r0, [r7, #4]
 8011cf2:	f001 f877 	bl	8012de4 <USBD_LL_IsStallEP>
 8011cf6:	4603      	mov	r3, r0
 8011cf8:	2b00      	cmp	r3, #0
 8011cfa:	d003      	beq.n	8011d04 <USBD_StdEPReq+0x2f8>
              {
                pep->status = 0x0001U;
 8011cfc:	68bb      	ldr	r3, [r7, #8]
 8011cfe:	2201      	movs	r2, #1
 8011d00:	601a      	str	r2, [r3, #0]
 8011d02:	e002      	b.n	8011d0a <USBD_StdEPReq+0x2fe>
              }
              else
              {
                pep->status = 0x0000U;
 8011d04:	68bb      	ldr	r3, [r7, #8]
 8011d06:	2200      	movs	r2, #0
 8011d08:	601a      	str	r2, [r3, #0]
              }

              (void)USBD_CtlSendData(pdev, (uint8_t *)&pep->status, 2U);
 8011d0a:	68bb      	ldr	r3, [r7, #8]
 8011d0c:	2202      	movs	r2, #2
 8011d0e:	4619      	mov	r1, r3
 8011d10:	6878      	ldr	r0, [r7, #4]
 8011d12:	f000 fc07 	bl	8012524 <USBD_CtlSendData>
              break;
 8011d16:	e004      	b.n	8011d22 <USBD_StdEPReq+0x316>

            default:
              USBD_CtlError(pdev, req);
 8011d18:	6839      	ldr	r1, [r7, #0]
 8011d1a:	6878      	ldr	r0, [r7, #4]
 8011d1c:	f000 fb85 	bl	801242a <USBD_CtlError>
              break;
 8011d20:	bf00      	nop
          }
          break;
 8011d22:	e004      	b.n	8011d2e <USBD_StdEPReq+0x322>

        default:
          USBD_CtlError(pdev, req);
 8011d24:	6839      	ldr	r1, [r7, #0]
 8011d26:	6878      	ldr	r0, [r7, #4]
 8011d28:	f000 fb7f 	bl	801242a <USBD_CtlError>
          break;
 8011d2c:	bf00      	nop
      }
      break;
 8011d2e:	e005      	b.n	8011d3c <USBD_StdEPReq+0x330>

    default:
      USBD_CtlError(pdev, req);
 8011d30:	6839      	ldr	r1, [r7, #0]
 8011d32:	6878      	ldr	r0, [r7, #4]
 8011d34:	f000 fb79 	bl	801242a <USBD_CtlError>
      break;
 8011d38:	e000      	b.n	8011d3c <USBD_StdEPReq+0x330>
      break;
 8011d3a:	bf00      	nop
  }

  return ret;
 8011d3c:	7bfb      	ldrb	r3, [r7, #15]
}
 8011d3e:	4618      	mov	r0, r3
 8011d40:	3710      	adds	r7, #16
 8011d42:	46bd      	mov	sp, r7
 8011d44:	bd80      	pop	{r7, pc}
	...

08011d48 <USBD_GetDescriptor>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval None
  */
static void USBD_GetDescriptor(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 8011d48:	b580      	push	{r7, lr}
 8011d4a:	b084      	sub	sp, #16
 8011d4c:	af00      	add	r7, sp, #0
 8011d4e:	6078      	str	r0, [r7, #4]
 8011d50:	6039      	str	r1, [r7, #0]
  uint16_t len = 0U;
 8011d52:	2300      	movs	r3, #0
 8011d54:	813b      	strh	r3, [r7, #8]
  uint8_t *pbuf = NULL;
 8011d56:	2300      	movs	r3, #0
 8011d58:	60fb      	str	r3, [r7, #12]
  uint8_t err = 0U;
 8011d5a:	2300      	movs	r3, #0
 8011d5c:	72fb      	strb	r3, [r7, #11]

  switch (req->wValue >> 8)
 8011d5e:	683b      	ldr	r3, [r7, #0]
 8011d60:	885b      	ldrh	r3, [r3, #2]
 8011d62:	0a1b      	lsrs	r3, r3, #8
 8011d64:	b29b      	uxth	r3, r3
 8011d66:	3b01      	subs	r3, #1
 8011d68:	2b0e      	cmp	r3, #14
 8011d6a:	f200 8152 	bhi.w	8012012 <USBD_GetDescriptor+0x2ca>
 8011d6e:	a201      	add	r2, pc, #4	@ (adr r2, 8011d74 <USBD_GetDescriptor+0x2c>)
 8011d70:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8011d74:	08011de5 	.word	0x08011de5
 8011d78:	08011dfd 	.word	0x08011dfd
 8011d7c:	08011e3d 	.word	0x08011e3d
 8011d80:	08012013 	.word	0x08012013
 8011d84:	08012013 	.word	0x08012013
 8011d88:	08011fb3 	.word	0x08011fb3
 8011d8c:	08011fdf 	.word	0x08011fdf
 8011d90:	08012013 	.word	0x08012013
 8011d94:	08012013 	.word	0x08012013
 8011d98:	08012013 	.word	0x08012013
 8011d9c:	08012013 	.word	0x08012013
 8011da0:	08012013 	.word	0x08012013
 8011da4:	08012013 	.word	0x08012013
 8011da8:	08012013 	.word	0x08012013
 8011dac:	08011db1 	.word	0x08011db1
  {
#if ((USBD_LPM_ENABLED == 1U) || (USBD_CLASS_BOS_ENABLED == 1U))
    case USB_DESC_TYPE_BOS:
      if (pdev->pDesc->GetBOSDescriptor != NULL)
 8011db0:	687b      	ldr	r3, [r7, #4]
 8011db2:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 8011db6:	69db      	ldr	r3, [r3, #28]
 8011db8:	2b00      	cmp	r3, #0
 8011dba:	d00b      	beq.n	8011dd4 <USBD_GetDescriptor+0x8c>
      {
        pbuf = pdev->pDesc->GetBOSDescriptor(pdev->dev_speed, &len);
 8011dbc:	687b      	ldr	r3, [r7, #4]
 8011dbe:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 8011dc2:	69db      	ldr	r3, [r3, #28]
 8011dc4:	687a      	ldr	r2, [r7, #4]
 8011dc6:	7c12      	ldrb	r2, [r2, #16]
 8011dc8:	f107 0108 	add.w	r1, r7, #8
 8011dcc:	4610      	mov	r0, r2
 8011dce:	4798      	blx	r3
 8011dd0:	60f8      	str	r0, [r7, #12]
      else
      {
        USBD_CtlError(pdev, req);
        err++;
      }
      break;
 8011dd2:	e126      	b.n	8012022 <USBD_GetDescriptor+0x2da>
        USBD_CtlError(pdev, req);
 8011dd4:	6839      	ldr	r1, [r7, #0]
 8011dd6:	6878      	ldr	r0, [r7, #4]
 8011dd8:	f000 fb27 	bl	801242a <USBD_CtlError>
        err++;
 8011ddc:	7afb      	ldrb	r3, [r7, #11]
 8011dde:	3301      	adds	r3, #1
 8011de0:	72fb      	strb	r3, [r7, #11]
      break;
 8011de2:	e11e      	b.n	8012022 <USBD_GetDescriptor+0x2da>
#endif /* (USBD_LPM_ENABLED == 1U) || (USBD_CLASS_BOS_ENABLED == 1U) */
    case USB_DESC_TYPE_DEVICE:
      pbuf = pdev->pDesc->GetDeviceDescriptor(pdev->dev_speed, &len);
 8011de4:	687b      	ldr	r3, [r7, #4]
 8011de6:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 8011dea:	681b      	ldr	r3, [r3, #0]
 8011dec:	687a      	ldr	r2, [r7, #4]
 8011dee:	7c12      	ldrb	r2, [r2, #16]
 8011df0:	f107 0108 	add.w	r1, r7, #8
 8011df4:	4610      	mov	r0, r2
 8011df6:	4798      	blx	r3
 8011df8:	60f8      	str	r0, [r7, #12]
      break;
 8011dfa:	e112      	b.n	8012022 <USBD_GetDescriptor+0x2da>

    case USB_DESC_TYPE_CONFIGURATION:
      if (pdev->dev_speed == USBD_SPEED_HIGH)
 8011dfc:	687b      	ldr	r3, [r7, #4]
 8011dfe:	7c1b      	ldrb	r3, [r3, #16]
 8011e00:	2b00      	cmp	r3, #0
 8011e02:	d10d      	bne.n	8011e20 <USBD_GetDescriptor+0xd8>
          pbuf = (uint8_t *)USBD_CMPSIT.GetHSConfigDescriptor(&len);
        }
        else
#endif /* USE_USBD_COMPOSITE */
        {
          pbuf = (uint8_t *)pdev->pClass[0]->GetHSConfigDescriptor(&len);
 8011e04:	687b      	ldr	r3, [r7, #4]
 8011e06:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 8011e0a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8011e0c:	f107 0208 	add.w	r2, r7, #8
 8011e10:	4610      	mov	r0, r2
 8011e12:	4798      	blx	r3
 8011e14:	60f8      	str	r0, [r7, #12]
        }
        pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
 8011e16:	68fb      	ldr	r3, [r7, #12]
 8011e18:	3301      	adds	r3, #1
 8011e1a:	2202      	movs	r2, #2
 8011e1c:	701a      	strb	r2, [r3, #0]
        {
          pbuf = (uint8_t *)pdev->pClass[0]->GetFSConfigDescriptor(&len);
        }
        pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
      }
      break;
 8011e1e:	e100      	b.n	8012022 <USBD_GetDescriptor+0x2da>
          pbuf = (uint8_t *)pdev->pClass[0]->GetFSConfigDescriptor(&len);
 8011e20:	687b      	ldr	r3, [r7, #4]
 8011e22:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 8011e26:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8011e28:	f107 0208 	add.w	r2, r7, #8
 8011e2c:	4610      	mov	r0, r2
 8011e2e:	4798      	blx	r3
 8011e30:	60f8      	str	r0, [r7, #12]
        pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
 8011e32:	68fb      	ldr	r3, [r7, #12]
 8011e34:	3301      	adds	r3, #1
 8011e36:	2202      	movs	r2, #2
 8011e38:	701a      	strb	r2, [r3, #0]
      break;
 8011e3a:	e0f2      	b.n	8012022 <USBD_GetDescriptor+0x2da>

    case USB_DESC_TYPE_STRING:
      switch ((uint8_t)(req->wValue))
 8011e3c:	683b      	ldr	r3, [r7, #0]
 8011e3e:	885b      	ldrh	r3, [r3, #2]
 8011e40:	b2db      	uxtb	r3, r3
 8011e42:	2b05      	cmp	r3, #5
 8011e44:	f200 80ac 	bhi.w	8011fa0 <USBD_GetDescriptor+0x258>
 8011e48:	a201      	add	r2, pc, #4	@ (adr r2, 8011e50 <USBD_GetDescriptor+0x108>)
 8011e4a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8011e4e:	bf00      	nop
 8011e50:	08011e69 	.word	0x08011e69
 8011e54:	08011e9d 	.word	0x08011e9d
 8011e58:	08011ed1 	.word	0x08011ed1
 8011e5c:	08011f05 	.word	0x08011f05
 8011e60:	08011f39 	.word	0x08011f39
 8011e64:	08011f6d 	.word	0x08011f6d
      {
        case USBD_IDX_LANGID_STR:
          if (pdev->pDesc->GetLangIDStrDescriptor != NULL)
 8011e68:	687b      	ldr	r3, [r7, #4]
 8011e6a:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 8011e6e:	685b      	ldr	r3, [r3, #4]
 8011e70:	2b00      	cmp	r3, #0
 8011e72:	d00b      	beq.n	8011e8c <USBD_GetDescriptor+0x144>
          {
            pbuf = pdev->pDesc->GetLangIDStrDescriptor(pdev->dev_speed, &len);
 8011e74:	687b      	ldr	r3, [r7, #4]
 8011e76:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 8011e7a:	685b      	ldr	r3, [r3, #4]
 8011e7c:	687a      	ldr	r2, [r7, #4]
 8011e7e:	7c12      	ldrb	r2, [r2, #16]
 8011e80:	f107 0108 	add.w	r1, r7, #8
 8011e84:	4610      	mov	r0, r2
 8011e86:	4798      	blx	r3
 8011e88:	60f8      	str	r0, [r7, #12]
          else
          {
            USBD_CtlError(pdev, req);
            err++;
          }
          break;
 8011e8a:	e091      	b.n	8011fb0 <USBD_GetDescriptor+0x268>
            USBD_CtlError(pdev, req);
 8011e8c:	6839      	ldr	r1, [r7, #0]
 8011e8e:	6878      	ldr	r0, [r7, #4]
 8011e90:	f000 facb 	bl	801242a <USBD_CtlError>
            err++;
 8011e94:	7afb      	ldrb	r3, [r7, #11]
 8011e96:	3301      	adds	r3, #1
 8011e98:	72fb      	strb	r3, [r7, #11]
          break;
 8011e9a:	e089      	b.n	8011fb0 <USBD_GetDescriptor+0x268>

        case USBD_IDX_MFC_STR:
          if (pdev->pDesc->GetManufacturerStrDescriptor != NULL)
 8011e9c:	687b      	ldr	r3, [r7, #4]
 8011e9e:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 8011ea2:	689b      	ldr	r3, [r3, #8]
 8011ea4:	2b00      	cmp	r3, #0
 8011ea6:	d00b      	beq.n	8011ec0 <USBD_GetDescriptor+0x178>
          {
            pbuf = pdev->pDesc->GetManufacturerStrDescriptor(pdev->dev_speed, &len);
 8011ea8:	687b      	ldr	r3, [r7, #4]
 8011eaa:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 8011eae:	689b      	ldr	r3, [r3, #8]
 8011eb0:	687a      	ldr	r2, [r7, #4]
 8011eb2:	7c12      	ldrb	r2, [r2, #16]
 8011eb4:	f107 0108 	add.w	r1, r7, #8
 8011eb8:	4610      	mov	r0, r2
 8011eba:	4798      	blx	r3
 8011ebc:	60f8      	str	r0, [r7, #12]
          else
          {
            USBD_CtlError(pdev, req);
            err++;
          }
          break;
 8011ebe:	e077      	b.n	8011fb0 <USBD_GetDescriptor+0x268>
            USBD_CtlError(pdev, req);
 8011ec0:	6839      	ldr	r1, [r7, #0]
 8011ec2:	6878      	ldr	r0, [r7, #4]
 8011ec4:	f000 fab1 	bl	801242a <USBD_CtlError>
            err++;
 8011ec8:	7afb      	ldrb	r3, [r7, #11]
 8011eca:	3301      	adds	r3, #1
 8011ecc:	72fb      	strb	r3, [r7, #11]
          break;
 8011ece:	e06f      	b.n	8011fb0 <USBD_GetDescriptor+0x268>

        case USBD_IDX_PRODUCT_STR:
          if (pdev->pDesc->GetProductStrDescriptor != NULL)
 8011ed0:	687b      	ldr	r3, [r7, #4]
 8011ed2:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 8011ed6:	68db      	ldr	r3, [r3, #12]
 8011ed8:	2b00      	cmp	r3, #0
 8011eda:	d00b      	beq.n	8011ef4 <USBD_GetDescriptor+0x1ac>
          {
            pbuf = pdev->pDesc->GetProductStrDescriptor(pdev->dev_speed, &len);
 8011edc:	687b      	ldr	r3, [r7, #4]
 8011ede:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 8011ee2:	68db      	ldr	r3, [r3, #12]
 8011ee4:	687a      	ldr	r2, [r7, #4]
 8011ee6:	7c12      	ldrb	r2, [r2, #16]
 8011ee8:	f107 0108 	add.w	r1, r7, #8
 8011eec:	4610      	mov	r0, r2
 8011eee:	4798      	blx	r3
 8011ef0:	60f8      	str	r0, [r7, #12]
          else
          {
            USBD_CtlError(pdev, req);
            err++;
          }
          break;
 8011ef2:	e05d      	b.n	8011fb0 <USBD_GetDescriptor+0x268>
            USBD_CtlError(pdev, req);
 8011ef4:	6839      	ldr	r1, [r7, #0]
 8011ef6:	6878      	ldr	r0, [r7, #4]
 8011ef8:	f000 fa97 	bl	801242a <USBD_CtlError>
            err++;
 8011efc:	7afb      	ldrb	r3, [r7, #11]
 8011efe:	3301      	adds	r3, #1
 8011f00:	72fb      	strb	r3, [r7, #11]
          break;
 8011f02:	e055      	b.n	8011fb0 <USBD_GetDescriptor+0x268>

        case USBD_IDX_SERIAL_STR:
          if (pdev->pDesc->GetSerialStrDescriptor != NULL)
 8011f04:	687b      	ldr	r3, [r7, #4]
 8011f06:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 8011f0a:	691b      	ldr	r3, [r3, #16]
 8011f0c:	2b00      	cmp	r3, #0
 8011f0e:	d00b      	beq.n	8011f28 <USBD_GetDescriptor+0x1e0>
          {
            pbuf = pdev->pDesc->GetSerialStrDescriptor(pdev->dev_speed, &len);
 8011f10:	687b      	ldr	r3, [r7, #4]
 8011f12:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 8011f16:	691b      	ldr	r3, [r3, #16]
 8011f18:	687a      	ldr	r2, [r7, #4]
 8011f1a:	7c12      	ldrb	r2, [r2, #16]
 8011f1c:	f107 0108 	add.w	r1, r7, #8
 8011f20:	4610      	mov	r0, r2
 8011f22:	4798      	blx	r3
 8011f24:	60f8      	str	r0, [r7, #12]
          else
          {
            USBD_CtlError(pdev, req);
            err++;
          }
          break;
 8011f26:	e043      	b.n	8011fb0 <USBD_GetDescriptor+0x268>
            USBD_CtlError(pdev, req);
 8011f28:	6839      	ldr	r1, [r7, #0]
 8011f2a:	6878      	ldr	r0, [r7, #4]
 8011f2c:	f000 fa7d 	bl	801242a <USBD_CtlError>
            err++;
 8011f30:	7afb      	ldrb	r3, [r7, #11]
 8011f32:	3301      	adds	r3, #1
 8011f34:	72fb      	strb	r3, [r7, #11]
          break;
 8011f36:	e03b      	b.n	8011fb0 <USBD_GetDescriptor+0x268>

        case USBD_IDX_CONFIG_STR:
          if (pdev->pDesc->GetConfigurationStrDescriptor != NULL)
 8011f38:	687b      	ldr	r3, [r7, #4]
 8011f3a:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 8011f3e:	695b      	ldr	r3, [r3, #20]
 8011f40:	2b00      	cmp	r3, #0
 8011f42:	d00b      	beq.n	8011f5c <USBD_GetDescriptor+0x214>
          {
            pbuf = pdev->pDesc->GetConfigurationStrDescriptor(pdev->dev_speed, &len);
 8011f44:	687b      	ldr	r3, [r7, #4]
 8011f46:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 8011f4a:	695b      	ldr	r3, [r3, #20]
 8011f4c:	687a      	ldr	r2, [r7, #4]
 8011f4e:	7c12      	ldrb	r2, [r2, #16]
 8011f50:	f107 0108 	add.w	r1, r7, #8
 8011f54:	4610      	mov	r0, r2
 8011f56:	4798      	blx	r3
 8011f58:	60f8      	str	r0, [r7, #12]
          else
          {
            USBD_CtlError(pdev, req);
            err++;
          }
          break;
 8011f5a:	e029      	b.n	8011fb0 <USBD_GetDescriptor+0x268>
            USBD_CtlError(pdev, req);
 8011f5c:	6839      	ldr	r1, [r7, #0]
 8011f5e:	6878      	ldr	r0, [r7, #4]
 8011f60:	f000 fa63 	bl	801242a <USBD_CtlError>
            err++;
 8011f64:	7afb      	ldrb	r3, [r7, #11]
 8011f66:	3301      	adds	r3, #1
 8011f68:	72fb      	strb	r3, [r7, #11]
          break;
 8011f6a:	e021      	b.n	8011fb0 <USBD_GetDescriptor+0x268>

        case USBD_IDX_INTERFACE_STR:
          if (pdev->pDesc->GetInterfaceStrDescriptor != NULL)
 8011f6c:	687b      	ldr	r3, [r7, #4]
 8011f6e:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 8011f72:	699b      	ldr	r3, [r3, #24]
 8011f74:	2b00      	cmp	r3, #0
 8011f76:	d00b      	beq.n	8011f90 <USBD_GetDescriptor+0x248>
          {
            pbuf = pdev->pDesc->GetInterfaceStrDescriptor(pdev->dev_speed, &len);
 8011f78:	687b      	ldr	r3, [r7, #4]
 8011f7a:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 8011f7e:	699b      	ldr	r3, [r3, #24]
 8011f80:	687a      	ldr	r2, [r7, #4]
 8011f82:	7c12      	ldrb	r2, [r2, #16]
 8011f84:	f107 0108 	add.w	r1, r7, #8
 8011f88:	4610      	mov	r0, r2
 8011f8a:	4798      	blx	r3
 8011f8c:	60f8      	str	r0, [r7, #12]
          else
          {
            USBD_CtlError(pdev, req);
            err++;
          }
          break;
 8011f8e:	e00f      	b.n	8011fb0 <USBD_GetDescriptor+0x268>
            USBD_CtlError(pdev, req);
 8011f90:	6839      	ldr	r1, [r7, #0]
 8011f92:	6878      	ldr	r0, [r7, #4]
 8011f94:	f000 fa49 	bl	801242a <USBD_CtlError>
            err++;
 8011f98:	7afb      	ldrb	r3, [r7, #11]
 8011f9a:	3301      	adds	r3, #1
 8011f9c:	72fb      	strb	r3, [r7, #11]
          break;
 8011f9e:	e007      	b.n	8011fb0 <USBD_GetDescriptor+0x268>
            err++;
          }
#endif /* USBD_SUPPORT_USER_STRING_DESC  */

#if ((USBD_CLASS_USER_STRING_DESC == 0U) && (USBD_SUPPORT_USER_STRING_DESC == 0U))
          USBD_CtlError(pdev, req);
 8011fa0:	6839      	ldr	r1, [r7, #0]
 8011fa2:	6878      	ldr	r0, [r7, #4]
 8011fa4:	f000 fa41 	bl	801242a <USBD_CtlError>
          err++;
 8011fa8:	7afb      	ldrb	r3, [r7, #11]
 8011faa:	3301      	adds	r3, #1
 8011fac:	72fb      	strb	r3, [r7, #11]
#endif /* (USBD_CLASS_USER_STRING_DESC == 0U) && (USBD_SUPPORT_USER_STRING_DESC == 0U) */
          break;
 8011fae:	bf00      	nop
      }
      break;
 8011fb0:	e037      	b.n	8012022 <USBD_GetDescriptor+0x2da>

    case USB_DESC_TYPE_DEVICE_QUALIFIER:
      if (pdev->dev_speed == USBD_SPEED_HIGH)
 8011fb2:	687b      	ldr	r3, [r7, #4]
 8011fb4:	7c1b      	ldrb	r3, [r3, #16]
 8011fb6:	2b00      	cmp	r3, #0
 8011fb8:	d109      	bne.n	8011fce <USBD_GetDescriptor+0x286>
          pbuf = (uint8_t *)USBD_CMPSIT.GetDeviceQualifierDescriptor(&len);
        }
        else
#endif /* USE_USBD_COMPOSITE */
        {
          pbuf = (uint8_t *)pdev->pClass[0]->GetDeviceQualifierDescriptor(&len);
 8011fba:	687b      	ldr	r3, [r7, #4]
 8011fbc:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 8011fc0:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8011fc2:	f107 0208 	add.w	r2, r7, #8
 8011fc6:	4610      	mov	r0, r2
 8011fc8:	4798      	blx	r3
 8011fca:	60f8      	str	r0, [r7, #12]
      else
      {
        USBD_CtlError(pdev, req);
        err++;
      }
      break;
 8011fcc:	e029      	b.n	8012022 <USBD_GetDescriptor+0x2da>
        USBD_CtlError(pdev, req);
 8011fce:	6839      	ldr	r1, [r7, #0]
 8011fd0:	6878      	ldr	r0, [r7, #4]
 8011fd2:	f000 fa2a 	bl	801242a <USBD_CtlError>
        err++;
 8011fd6:	7afb      	ldrb	r3, [r7, #11]
 8011fd8:	3301      	adds	r3, #1
 8011fda:	72fb      	strb	r3, [r7, #11]
      break;
 8011fdc:	e021      	b.n	8012022 <USBD_GetDescriptor+0x2da>

    case USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION:
      if (pdev->dev_speed == USBD_SPEED_HIGH)
 8011fde:	687b      	ldr	r3, [r7, #4]
 8011fe0:	7c1b      	ldrb	r3, [r3, #16]
 8011fe2:	2b00      	cmp	r3, #0
 8011fe4:	d10d      	bne.n	8012002 <USBD_GetDescriptor+0x2ba>
          pbuf = (uint8_t *)USBD_CMPSIT.GetOtherSpeedConfigDescriptor(&len);
        }
        else
#endif /* USE_USBD_COMPOSITE */
        {
          pbuf = (uint8_t *)pdev->pClass[0]->GetOtherSpeedConfigDescriptor(&len);
 8011fe6:	687b      	ldr	r3, [r7, #4]
 8011fe8:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 8011fec:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8011fee:	f107 0208 	add.w	r2, r7, #8
 8011ff2:	4610      	mov	r0, r2
 8011ff4:	4798      	blx	r3
 8011ff6:	60f8      	str	r0, [r7, #12]
        }
        pbuf[1] = USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION;
 8011ff8:	68fb      	ldr	r3, [r7, #12]
 8011ffa:	3301      	adds	r3, #1
 8011ffc:	2207      	movs	r2, #7
 8011ffe:	701a      	strb	r2, [r3, #0]
      else
      {
        USBD_CtlError(pdev, req);
        err++;
      }
      break;
 8012000:	e00f      	b.n	8012022 <USBD_GetDescriptor+0x2da>
        USBD_CtlError(pdev, req);
 8012002:	6839      	ldr	r1, [r7, #0]
 8012004:	6878      	ldr	r0, [r7, #4]
 8012006:	f000 fa10 	bl	801242a <USBD_CtlError>
        err++;
 801200a:	7afb      	ldrb	r3, [r7, #11]
 801200c:	3301      	adds	r3, #1
 801200e:	72fb      	strb	r3, [r7, #11]
      break;
 8012010:	e007      	b.n	8012022 <USBD_GetDescriptor+0x2da>

    default:
      USBD_CtlError(pdev, req);
 8012012:	6839      	ldr	r1, [r7, #0]
 8012014:	6878      	ldr	r0, [r7, #4]
 8012016:	f000 fa08 	bl	801242a <USBD_CtlError>
      err++;
 801201a:	7afb      	ldrb	r3, [r7, #11]
 801201c:	3301      	adds	r3, #1
 801201e:	72fb      	strb	r3, [r7, #11]
      break;
 8012020:	bf00      	nop
  }

  if (err != 0U)
 8012022:	7afb      	ldrb	r3, [r7, #11]
 8012024:	2b00      	cmp	r3, #0
 8012026:	d11e      	bne.n	8012066 <USBD_GetDescriptor+0x31e>
  {
    return;
  }

  if (req->wLength != 0U)
 8012028:	683b      	ldr	r3, [r7, #0]
 801202a:	88db      	ldrh	r3, [r3, #6]
 801202c:	2b00      	cmp	r3, #0
 801202e:	d016      	beq.n	801205e <USBD_GetDescriptor+0x316>
  {
    if (len != 0U)
 8012030:	893b      	ldrh	r3, [r7, #8]
 8012032:	2b00      	cmp	r3, #0
 8012034:	d00e      	beq.n	8012054 <USBD_GetDescriptor+0x30c>
    {
      len = MIN(len, req->wLength);
 8012036:	683b      	ldr	r3, [r7, #0]
 8012038:	88da      	ldrh	r2, [r3, #6]
 801203a:	893b      	ldrh	r3, [r7, #8]
 801203c:	4293      	cmp	r3, r2
 801203e:	bf28      	it	cs
 8012040:	4613      	movcs	r3, r2
 8012042:	b29b      	uxth	r3, r3
 8012044:	813b      	strh	r3, [r7, #8]
      (void)USBD_CtlSendData(pdev, pbuf, len);
 8012046:	893b      	ldrh	r3, [r7, #8]
 8012048:	461a      	mov	r2, r3
 801204a:	68f9      	ldr	r1, [r7, #12]
 801204c:	6878      	ldr	r0, [r7, #4]
 801204e:	f000 fa69 	bl	8012524 <USBD_CtlSendData>
 8012052:	e009      	b.n	8012068 <USBD_GetDescriptor+0x320>
    }
    else
    {
      USBD_CtlError(pdev, req);
 8012054:	6839      	ldr	r1, [r7, #0]
 8012056:	6878      	ldr	r0, [r7, #4]
 8012058:	f000 f9e7 	bl	801242a <USBD_CtlError>
 801205c:	e004      	b.n	8012068 <USBD_GetDescriptor+0x320>
    }
  }
  else
  {
    (void)USBD_CtlSendStatus(pdev);
 801205e:	6878      	ldr	r0, [r7, #4]
 8012060:	f000 faba 	bl	80125d8 <USBD_CtlSendStatus>
 8012064:	e000      	b.n	8012068 <USBD_GetDescriptor+0x320>
    return;
 8012066:	bf00      	nop
  }
}
 8012068:	3710      	adds	r7, #16
 801206a:	46bd      	mov	sp, r7
 801206c:	bd80      	pop	{r7, pc}
 801206e:	bf00      	nop

08012070 <USBD_SetAddress>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval None
  */
static void USBD_SetAddress(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 8012070:	b580      	push	{r7, lr}
 8012072:	b084      	sub	sp, #16
 8012074:	af00      	add	r7, sp, #0
 8012076:	6078      	str	r0, [r7, #4]
 8012078:	6039      	str	r1, [r7, #0]
  uint8_t  dev_addr;

  if ((req->wIndex == 0U) && (req->wLength == 0U) && (req->wValue < 128U))
 801207a:	683b      	ldr	r3, [r7, #0]
 801207c:	889b      	ldrh	r3, [r3, #4]
 801207e:	2b00      	cmp	r3, #0
 8012080:	d131      	bne.n	80120e6 <USBD_SetAddress+0x76>
 8012082:	683b      	ldr	r3, [r7, #0]
 8012084:	88db      	ldrh	r3, [r3, #6]
 8012086:	2b00      	cmp	r3, #0
 8012088:	d12d      	bne.n	80120e6 <USBD_SetAddress+0x76>
 801208a:	683b      	ldr	r3, [r7, #0]
 801208c:	885b      	ldrh	r3, [r3, #2]
 801208e:	2b7f      	cmp	r3, #127	@ 0x7f
 8012090:	d829      	bhi.n	80120e6 <USBD_SetAddress+0x76>
  {
    dev_addr = (uint8_t)(req->wValue) & 0x7FU;
 8012092:	683b      	ldr	r3, [r7, #0]
 8012094:	885b      	ldrh	r3, [r3, #2]
 8012096:	b2db      	uxtb	r3, r3
 8012098:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 801209c:	73fb      	strb	r3, [r7, #15]

    if (pdev->dev_state == USBD_STATE_CONFIGURED)
 801209e:	687b      	ldr	r3, [r7, #4]
 80120a0:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 80120a4:	b2db      	uxtb	r3, r3
 80120a6:	2b03      	cmp	r3, #3
 80120a8:	d104      	bne.n	80120b4 <USBD_SetAddress+0x44>
    {
      USBD_CtlError(pdev, req);
 80120aa:	6839      	ldr	r1, [r7, #0]
 80120ac:	6878      	ldr	r0, [r7, #4]
 80120ae:	f000 f9bc 	bl	801242a <USBD_CtlError>
    if (pdev->dev_state == USBD_STATE_CONFIGURED)
 80120b2:	e01d      	b.n	80120f0 <USBD_SetAddress+0x80>
    }
    else
    {
      pdev->dev_address = dev_addr;
 80120b4:	687b      	ldr	r3, [r7, #4]
 80120b6:	7bfa      	ldrb	r2, [r7, #15]
 80120b8:	f883 229e 	strb.w	r2, [r3, #670]	@ 0x29e
      (void)USBD_LL_SetUSBAddress(pdev, dev_addr);
 80120bc:	7bfb      	ldrb	r3, [r7, #15]
 80120be:	4619      	mov	r1, r3
 80120c0:	6878      	ldr	r0, [r7, #4]
 80120c2:	f000 febb 	bl	8012e3c <USBD_LL_SetUSBAddress>
      (void)USBD_CtlSendStatus(pdev);
 80120c6:	6878      	ldr	r0, [r7, #4]
 80120c8:	f000 fa86 	bl	80125d8 <USBD_CtlSendStatus>

      if (dev_addr != 0U)
 80120cc:	7bfb      	ldrb	r3, [r7, #15]
 80120ce:	2b00      	cmp	r3, #0
 80120d0:	d004      	beq.n	80120dc <USBD_SetAddress+0x6c>
      {
        pdev->dev_state = USBD_STATE_ADDRESSED;
 80120d2:	687b      	ldr	r3, [r7, #4]
 80120d4:	2202      	movs	r2, #2
 80120d6:	f883 229c 	strb.w	r2, [r3, #668]	@ 0x29c
    if (pdev->dev_state == USBD_STATE_CONFIGURED)
 80120da:	e009      	b.n	80120f0 <USBD_SetAddress+0x80>
      }
      else
      {
        pdev->dev_state = USBD_STATE_DEFAULT;
 80120dc:	687b      	ldr	r3, [r7, #4]
 80120de:	2201      	movs	r2, #1
 80120e0:	f883 229c 	strb.w	r2, [r3, #668]	@ 0x29c
    if (pdev->dev_state == USBD_STATE_CONFIGURED)
 80120e4:	e004      	b.n	80120f0 <USBD_SetAddress+0x80>
      }
    }
  }
  else
  {
    USBD_CtlError(pdev, req);
 80120e6:	6839      	ldr	r1, [r7, #0]
 80120e8:	6878      	ldr	r0, [r7, #4]
 80120ea:	f000 f99e 	bl	801242a <USBD_CtlError>
  }
}
 80120ee:	bf00      	nop
 80120f0:	bf00      	nop
 80120f2:	3710      	adds	r7, #16
 80120f4:	46bd      	mov	sp, r7
 80120f6:	bd80      	pop	{r7, pc}

080120f8 <USBD_SetConfig>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval status
  */
static USBD_StatusTypeDef USBD_SetConfig(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 80120f8:	b580      	push	{r7, lr}
 80120fa:	b084      	sub	sp, #16
 80120fc:	af00      	add	r7, sp, #0
 80120fe:	6078      	str	r0, [r7, #4]
 8012100:	6039      	str	r1, [r7, #0]
  USBD_StatusTypeDef ret = USBD_OK;
 8012102:	2300      	movs	r3, #0
 8012104:	73fb      	strb	r3, [r7, #15]
  static uint8_t cfgidx;

  cfgidx = (uint8_t)(req->wValue);
 8012106:	683b      	ldr	r3, [r7, #0]
 8012108:	885b      	ldrh	r3, [r3, #2]
 801210a:	b2da      	uxtb	r2, r3
 801210c:	4b4e      	ldr	r3, [pc, #312]	@ (8012248 <USBD_SetConfig+0x150>)
 801210e:	701a      	strb	r2, [r3, #0]

  if (cfgidx > USBD_MAX_NUM_CONFIGURATION)
 8012110:	4b4d      	ldr	r3, [pc, #308]	@ (8012248 <USBD_SetConfig+0x150>)
 8012112:	781b      	ldrb	r3, [r3, #0]
 8012114:	2b01      	cmp	r3, #1
 8012116:	d905      	bls.n	8012124 <USBD_SetConfig+0x2c>
  {
    USBD_CtlError(pdev, req);
 8012118:	6839      	ldr	r1, [r7, #0]
 801211a:	6878      	ldr	r0, [r7, #4]
 801211c:	f000 f985 	bl	801242a <USBD_CtlError>
    return USBD_FAIL;
 8012120:	2303      	movs	r3, #3
 8012122:	e08c      	b.n	801223e <USBD_SetConfig+0x146>
  }

  switch (pdev->dev_state)
 8012124:	687b      	ldr	r3, [r7, #4]
 8012126:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 801212a:	b2db      	uxtb	r3, r3
 801212c:	2b02      	cmp	r3, #2
 801212e:	d002      	beq.n	8012136 <USBD_SetConfig+0x3e>
 8012130:	2b03      	cmp	r3, #3
 8012132:	d029      	beq.n	8012188 <USBD_SetConfig+0x90>
 8012134:	e075      	b.n	8012222 <USBD_SetConfig+0x12a>
  {
    case USBD_STATE_ADDRESSED:
      if (cfgidx != 0U)
 8012136:	4b44      	ldr	r3, [pc, #272]	@ (8012248 <USBD_SetConfig+0x150>)
 8012138:	781b      	ldrb	r3, [r3, #0]
 801213a:	2b00      	cmp	r3, #0
 801213c:	d020      	beq.n	8012180 <USBD_SetConfig+0x88>
      {
        pdev->dev_config = cfgidx;
 801213e:	4b42      	ldr	r3, [pc, #264]	@ (8012248 <USBD_SetConfig+0x150>)
 8012140:	781b      	ldrb	r3, [r3, #0]
 8012142:	461a      	mov	r2, r3
 8012144:	687b      	ldr	r3, [r7, #4]
 8012146:	605a      	str	r2, [r3, #4]

        ret = USBD_SetClassConfig(pdev, cfgidx);
 8012148:	4b3f      	ldr	r3, [pc, #252]	@ (8012248 <USBD_SetConfig+0x150>)
 801214a:	781b      	ldrb	r3, [r3, #0]
 801214c:	4619      	mov	r1, r3
 801214e:	6878      	ldr	r0, [r7, #4]
 8012150:	f7fe fff1 	bl	8011136 <USBD_SetClassConfig>
 8012154:	4603      	mov	r3, r0
 8012156:	73fb      	strb	r3, [r7, #15]

        if (ret != USBD_OK)
 8012158:	7bfb      	ldrb	r3, [r7, #15]
 801215a:	2b00      	cmp	r3, #0
 801215c:	d008      	beq.n	8012170 <USBD_SetConfig+0x78>
        {
          USBD_CtlError(pdev, req);
 801215e:	6839      	ldr	r1, [r7, #0]
 8012160:	6878      	ldr	r0, [r7, #4]
 8012162:	f000 f962 	bl	801242a <USBD_CtlError>
          pdev->dev_state = USBD_STATE_ADDRESSED;
 8012166:	687b      	ldr	r3, [r7, #4]
 8012168:	2202      	movs	r2, #2
 801216a:	f883 229c 	strb.w	r2, [r3, #668]	@ 0x29c
      }
      else
      {
        (void)USBD_CtlSendStatus(pdev);
      }
      break;
 801216e:	e065      	b.n	801223c <USBD_SetConfig+0x144>
          (void)USBD_CtlSendStatus(pdev);
 8012170:	6878      	ldr	r0, [r7, #4]
 8012172:	f000 fa31 	bl	80125d8 <USBD_CtlSendStatus>
          pdev->dev_state = USBD_STATE_CONFIGURED;
 8012176:	687b      	ldr	r3, [r7, #4]
 8012178:	2203      	movs	r2, #3
 801217a:	f883 229c 	strb.w	r2, [r3, #668]	@ 0x29c
      break;
 801217e:	e05d      	b.n	801223c <USBD_SetConfig+0x144>
        (void)USBD_CtlSendStatus(pdev);
 8012180:	6878      	ldr	r0, [r7, #4]
 8012182:	f000 fa29 	bl	80125d8 <USBD_CtlSendStatus>
      break;
 8012186:	e059      	b.n	801223c <USBD_SetConfig+0x144>

    case USBD_STATE_CONFIGURED:
      if (cfgidx == 0U)
 8012188:	4b2f      	ldr	r3, [pc, #188]	@ (8012248 <USBD_SetConfig+0x150>)
 801218a:	781b      	ldrb	r3, [r3, #0]
 801218c:	2b00      	cmp	r3, #0
 801218e:	d112      	bne.n	80121b6 <USBD_SetConfig+0xbe>
      {
        pdev->dev_state = USBD_STATE_ADDRESSED;
 8012190:	687b      	ldr	r3, [r7, #4]
 8012192:	2202      	movs	r2, #2
 8012194:	f883 229c 	strb.w	r2, [r3, #668]	@ 0x29c
        pdev->dev_config = cfgidx;
 8012198:	4b2b      	ldr	r3, [pc, #172]	@ (8012248 <USBD_SetConfig+0x150>)
 801219a:	781b      	ldrb	r3, [r3, #0]
 801219c:	461a      	mov	r2, r3
 801219e:	687b      	ldr	r3, [r7, #4]
 80121a0:	605a      	str	r2, [r3, #4]
        (void)USBD_ClrClassConfig(pdev, cfgidx);
 80121a2:	4b29      	ldr	r3, [pc, #164]	@ (8012248 <USBD_SetConfig+0x150>)
 80121a4:	781b      	ldrb	r3, [r3, #0]
 80121a6:	4619      	mov	r1, r3
 80121a8:	6878      	ldr	r0, [r7, #4]
 80121aa:	f7fe ffe0 	bl	801116e <USBD_ClrClassConfig>
        (void)USBD_CtlSendStatus(pdev);
 80121ae:	6878      	ldr	r0, [r7, #4]
 80121b0:	f000 fa12 	bl	80125d8 <USBD_CtlSendStatus>
      }
      else
      {
        (void)USBD_CtlSendStatus(pdev);
      }
      break;
 80121b4:	e042      	b.n	801223c <USBD_SetConfig+0x144>
      else if (cfgidx != pdev->dev_config)
 80121b6:	4b24      	ldr	r3, [pc, #144]	@ (8012248 <USBD_SetConfig+0x150>)
 80121b8:	781b      	ldrb	r3, [r3, #0]
 80121ba:	461a      	mov	r2, r3
 80121bc:	687b      	ldr	r3, [r7, #4]
 80121be:	685b      	ldr	r3, [r3, #4]
 80121c0:	429a      	cmp	r2, r3
 80121c2:	d02a      	beq.n	801221a <USBD_SetConfig+0x122>
        (void)USBD_ClrClassConfig(pdev, (uint8_t)pdev->dev_config);
 80121c4:	687b      	ldr	r3, [r7, #4]
 80121c6:	685b      	ldr	r3, [r3, #4]
 80121c8:	b2db      	uxtb	r3, r3
 80121ca:	4619      	mov	r1, r3
 80121cc:	6878      	ldr	r0, [r7, #4]
 80121ce:	f7fe ffce 	bl	801116e <USBD_ClrClassConfig>
        pdev->dev_config = cfgidx;
 80121d2:	4b1d      	ldr	r3, [pc, #116]	@ (8012248 <USBD_SetConfig+0x150>)
 80121d4:	781b      	ldrb	r3, [r3, #0]
 80121d6:	461a      	mov	r2, r3
 80121d8:	687b      	ldr	r3, [r7, #4]
 80121da:	605a      	str	r2, [r3, #4]
        ret = USBD_SetClassConfig(pdev, cfgidx);
 80121dc:	4b1a      	ldr	r3, [pc, #104]	@ (8012248 <USBD_SetConfig+0x150>)
 80121de:	781b      	ldrb	r3, [r3, #0]
 80121e0:	4619      	mov	r1, r3
 80121e2:	6878      	ldr	r0, [r7, #4]
 80121e4:	f7fe ffa7 	bl	8011136 <USBD_SetClassConfig>
 80121e8:	4603      	mov	r3, r0
 80121ea:	73fb      	strb	r3, [r7, #15]
        if (ret != USBD_OK)
 80121ec:	7bfb      	ldrb	r3, [r7, #15]
 80121ee:	2b00      	cmp	r3, #0
 80121f0:	d00f      	beq.n	8012212 <USBD_SetConfig+0x11a>
          USBD_CtlError(pdev, req);
 80121f2:	6839      	ldr	r1, [r7, #0]
 80121f4:	6878      	ldr	r0, [r7, #4]
 80121f6:	f000 f918 	bl	801242a <USBD_CtlError>
          (void)USBD_ClrClassConfig(pdev, (uint8_t)pdev->dev_config);
 80121fa:	687b      	ldr	r3, [r7, #4]
 80121fc:	685b      	ldr	r3, [r3, #4]
 80121fe:	b2db      	uxtb	r3, r3
 8012200:	4619      	mov	r1, r3
 8012202:	6878      	ldr	r0, [r7, #4]
 8012204:	f7fe ffb3 	bl	801116e <USBD_ClrClassConfig>
          pdev->dev_state = USBD_STATE_ADDRESSED;
 8012208:	687b      	ldr	r3, [r7, #4]
 801220a:	2202      	movs	r2, #2
 801220c:	f883 229c 	strb.w	r2, [r3, #668]	@ 0x29c
      break;
 8012210:	e014      	b.n	801223c <USBD_SetConfig+0x144>
          (void)USBD_CtlSendStatus(pdev);
 8012212:	6878      	ldr	r0, [r7, #4]
 8012214:	f000 f9e0 	bl	80125d8 <USBD_CtlSendStatus>
      break;
 8012218:	e010      	b.n	801223c <USBD_SetConfig+0x144>
        (void)USBD_CtlSendStatus(pdev);
 801221a:	6878      	ldr	r0, [r7, #4]
 801221c:	f000 f9dc 	bl	80125d8 <USBD_CtlSendStatus>
      break;
 8012220:	e00c      	b.n	801223c <USBD_SetConfig+0x144>

    default:
      USBD_CtlError(pdev, req);
 8012222:	6839      	ldr	r1, [r7, #0]
 8012224:	6878      	ldr	r0, [r7, #4]
 8012226:	f000 f900 	bl	801242a <USBD_CtlError>
      (void)USBD_ClrClassConfig(pdev, cfgidx);
 801222a:	4b07      	ldr	r3, [pc, #28]	@ (8012248 <USBD_SetConfig+0x150>)
 801222c:	781b      	ldrb	r3, [r3, #0]
 801222e:	4619      	mov	r1, r3
 8012230:	6878      	ldr	r0, [r7, #4]
 8012232:	f7fe ff9c 	bl	801116e <USBD_ClrClassConfig>
      ret = USBD_FAIL;
 8012236:	2303      	movs	r3, #3
 8012238:	73fb      	strb	r3, [r7, #15]
      break;
 801223a:	bf00      	nop
  }

  return ret;
 801223c:	7bfb      	ldrb	r3, [r7, #15]
}
 801223e:	4618      	mov	r0, r3
 8012240:	3710      	adds	r7, #16
 8012242:	46bd      	mov	sp, r7
 8012244:	bd80      	pop	{r7, pc}
 8012246:	bf00      	nop
 8012248:	240007cc 	.word	0x240007cc

0801224c <USBD_GetConfig>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval None
  */
static void USBD_GetConfig(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 801224c:	b580      	push	{r7, lr}
 801224e:	b082      	sub	sp, #8
 8012250:	af00      	add	r7, sp, #0
 8012252:	6078      	str	r0, [r7, #4]
 8012254:	6039      	str	r1, [r7, #0]
  if (req->wLength != 1U)
 8012256:	683b      	ldr	r3, [r7, #0]
 8012258:	88db      	ldrh	r3, [r3, #6]
 801225a:	2b01      	cmp	r3, #1
 801225c:	d004      	beq.n	8012268 <USBD_GetConfig+0x1c>
  {
    USBD_CtlError(pdev, req);
 801225e:	6839      	ldr	r1, [r7, #0]
 8012260:	6878      	ldr	r0, [r7, #4]
 8012262:	f000 f8e2 	bl	801242a <USBD_CtlError>
      default:
        USBD_CtlError(pdev, req);
        break;
    }
  }
}
 8012266:	e023      	b.n	80122b0 <USBD_GetConfig+0x64>
    switch (pdev->dev_state)
 8012268:	687b      	ldr	r3, [r7, #4]
 801226a:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 801226e:	b2db      	uxtb	r3, r3
 8012270:	2b02      	cmp	r3, #2
 8012272:	dc02      	bgt.n	801227a <USBD_GetConfig+0x2e>
 8012274:	2b00      	cmp	r3, #0
 8012276:	dc03      	bgt.n	8012280 <USBD_GetConfig+0x34>
 8012278:	e015      	b.n	80122a6 <USBD_GetConfig+0x5a>
 801227a:	2b03      	cmp	r3, #3
 801227c:	d00b      	beq.n	8012296 <USBD_GetConfig+0x4a>
 801227e:	e012      	b.n	80122a6 <USBD_GetConfig+0x5a>
        pdev->dev_default_config = 0U;
 8012280:	687b      	ldr	r3, [r7, #4]
 8012282:	2200      	movs	r2, #0
 8012284:	609a      	str	r2, [r3, #8]
        (void)USBD_CtlSendData(pdev, (uint8_t *)&pdev->dev_default_config, 1U);
 8012286:	687b      	ldr	r3, [r7, #4]
 8012288:	3308      	adds	r3, #8
 801228a:	2201      	movs	r2, #1
 801228c:	4619      	mov	r1, r3
 801228e:	6878      	ldr	r0, [r7, #4]
 8012290:	f000 f948 	bl	8012524 <USBD_CtlSendData>
        break;
 8012294:	e00c      	b.n	80122b0 <USBD_GetConfig+0x64>
        (void)USBD_CtlSendData(pdev, (uint8_t *)&pdev->dev_config, 1U);
 8012296:	687b      	ldr	r3, [r7, #4]
 8012298:	3304      	adds	r3, #4
 801229a:	2201      	movs	r2, #1
 801229c:	4619      	mov	r1, r3
 801229e:	6878      	ldr	r0, [r7, #4]
 80122a0:	f000 f940 	bl	8012524 <USBD_CtlSendData>
        break;
 80122a4:	e004      	b.n	80122b0 <USBD_GetConfig+0x64>
        USBD_CtlError(pdev, req);
 80122a6:	6839      	ldr	r1, [r7, #0]
 80122a8:	6878      	ldr	r0, [r7, #4]
 80122aa:	f000 f8be 	bl	801242a <USBD_CtlError>
        break;
 80122ae:	bf00      	nop
}
 80122b0:	bf00      	nop
 80122b2:	3708      	adds	r7, #8
 80122b4:	46bd      	mov	sp, r7
 80122b6:	bd80      	pop	{r7, pc}

080122b8 <USBD_GetStatus>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval None
  */
static void USBD_GetStatus(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 80122b8:	b580      	push	{r7, lr}
 80122ba:	b082      	sub	sp, #8
 80122bc:	af00      	add	r7, sp, #0
 80122be:	6078      	str	r0, [r7, #4]
 80122c0:	6039      	str	r1, [r7, #0]
  switch (pdev->dev_state)
 80122c2:	687b      	ldr	r3, [r7, #4]
 80122c4:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 80122c8:	b2db      	uxtb	r3, r3
 80122ca:	3b01      	subs	r3, #1
 80122cc:	2b02      	cmp	r3, #2
 80122ce:	d81e      	bhi.n	801230e <USBD_GetStatus+0x56>
  {
    case USBD_STATE_DEFAULT:
    case USBD_STATE_ADDRESSED:
    case USBD_STATE_CONFIGURED:
      if (req->wLength != 0x2U)
 80122d0:	683b      	ldr	r3, [r7, #0]
 80122d2:	88db      	ldrh	r3, [r3, #6]
 80122d4:	2b02      	cmp	r3, #2
 80122d6:	d004      	beq.n	80122e2 <USBD_GetStatus+0x2a>
      {
        USBD_CtlError(pdev, req);
 80122d8:	6839      	ldr	r1, [r7, #0]
 80122da:	6878      	ldr	r0, [r7, #4]
 80122dc:	f000 f8a5 	bl	801242a <USBD_CtlError>
        break;
 80122e0:	e01a      	b.n	8012318 <USBD_GetStatus+0x60>
      }

#if (USBD_SELF_POWERED == 1U)
      pdev->dev_config_status = USB_CONFIG_SELF_POWERED;
 80122e2:	687b      	ldr	r3, [r7, #4]
 80122e4:	2201      	movs	r2, #1
 80122e6:	60da      	str	r2, [r3, #12]
#else
      pdev->dev_config_status = 0U;
#endif /* USBD_SELF_POWERED */

      if (pdev->dev_remote_wakeup != 0U)
 80122e8:	687b      	ldr	r3, [r7, #4]
 80122ea:	f8d3 32a4 	ldr.w	r3, [r3, #676]	@ 0x2a4
 80122ee:	2b00      	cmp	r3, #0
 80122f0:	d005      	beq.n	80122fe <USBD_GetStatus+0x46>
      {
        pdev->dev_config_status |= USB_CONFIG_REMOTE_WAKEUP;
 80122f2:	687b      	ldr	r3, [r7, #4]
 80122f4:	68db      	ldr	r3, [r3, #12]
 80122f6:	f043 0202 	orr.w	r2, r3, #2
 80122fa:	687b      	ldr	r3, [r7, #4]
 80122fc:	60da      	str	r2, [r3, #12]
      }

      (void)USBD_CtlSendData(pdev, (uint8_t *)&pdev->dev_config_status, 2U);
 80122fe:	687b      	ldr	r3, [r7, #4]
 8012300:	330c      	adds	r3, #12
 8012302:	2202      	movs	r2, #2
 8012304:	4619      	mov	r1, r3
 8012306:	6878      	ldr	r0, [r7, #4]
 8012308:	f000 f90c 	bl	8012524 <USBD_CtlSendData>
      break;
 801230c:	e004      	b.n	8012318 <USBD_GetStatus+0x60>

    default:
      USBD_CtlError(pdev, req);
 801230e:	6839      	ldr	r1, [r7, #0]
 8012310:	6878      	ldr	r0, [r7, #4]
 8012312:	f000 f88a 	bl	801242a <USBD_CtlError>
      break;
 8012316:	bf00      	nop
  }
}
 8012318:	bf00      	nop
 801231a:	3708      	adds	r7, #8
 801231c:	46bd      	mov	sp, r7
 801231e:	bd80      	pop	{r7, pc}

08012320 <USBD_SetFeature>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval None
  */
static void USBD_SetFeature(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 8012320:	b580      	push	{r7, lr}
 8012322:	b082      	sub	sp, #8
 8012324:	af00      	add	r7, sp, #0
 8012326:	6078      	str	r0, [r7, #4]
 8012328:	6039      	str	r1, [r7, #0]
  if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
 801232a:	683b      	ldr	r3, [r7, #0]
 801232c:	885b      	ldrh	r3, [r3, #2]
 801232e:	2b01      	cmp	r3, #1
 8012330:	d107      	bne.n	8012342 <USBD_SetFeature+0x22>
  {
    pdev->dev_remote_wakeup = 1U;
 8012332:	687b      	ldr	r3, [r7, #4]
 8012334:	2201      	movs	r2, #1
 8012336:	f8c3 22a4 	str.w	r2, [r3, #676]	@ 0x2a4
    (void)USBD_CtlSendStatus(pdev);
 801233a:	6878      	ldr	r0, [r7, #4]
 801233c:	f000 f94c 	bl	80125d8 <USBD_CtlSendStatus>
  }
  else
  {
    USBD_CtlError(pdev, req);
  }
}
 8012340:	e013      	b.n	801236a <USBD_SetFeature+0x4a>
  else if (req->wValue == USB_FEATURE_TEST_MODE)
 8012342:	683b      	ldr	r3, [r7, #0]
 8012344:	885b      	ldrh	r3, [r3, #2]
 8012346:	2b02      	cmp	r3, #2
 8012348:	d10b      	bne.n	8012362 <USBD_SetFeature+0x42>
    pdev->dev_test_mode = (uint8_t)(req->wIndex >> 8);
 801234a:	683b      	ldr	r3, [r7, #0]
 801234c:	889b      	ldrh	r3, [r3, #4]
 801234e:	0a1b      	lsrs	r3, r3, #8
 8012350:	b29b      	uxth	r3, r3
 8012352:	b2da      	uxtb	r2, r3
 8012354:	687b      	ldr	r3, [r7, #4]
 8012356:	f883 22a0 	strb.w	r2, [r3, #672]	@ 0x2a0
    (void)USBD_CtlSendStatus(pdev);
 801235a:	6878      	ldr	r0, [r7, #4]
 801235c:	f000 f93c 	bl	80125d8 <USBD_CtlSendStatus>
}
 8012360:	e003      	b.n	801236a <USBD_SetFeature+0x4a>
    USBD_CtlError(pdev, req);
 8012362:	6839      	ldr	r1, [r7, #0]
 8012364:	6878      	ldr	r0, [r7, #4]
 8012366:	f000 f860 	bl	801242a <USBD_CtlError>
}
 801236a:	bf00      	nop
 801236c:	3708      	adds	r7, #8
 801236e:	46bd      	mov	sp, r7
 8012370:	bd80      	pop	{r7, pc}

08012372 <USBD_ClrFeature>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval None
  */
static void USBD_ClrFeature(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 8012372:	b580      	push	{r7, lr}
 8012374:	b082      	sub	sp, #8
 8012376:	af00      	add	r7, sp, #0
 8012378:	6078      	str	r0, [r7, #4]
 801237a:	6039      	str	r1, [r7, #0]
  switch (pdev->dev_state)
 801237c:	687b      	ldr	r3, [r7, #4]
 801237e:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 8012382:	b2db      	uxtb	r3, r3
 8012384:	3b01      	subs	r3, #1
 8012386:	2b02      	cmp	r3, #2
 8012388:	d80b      	bhi.n	80123a2 <USBD_ClrFeature+0x30>
  {
    case USBD_STATE_DEFAULT:
    case USBD_STATE_ADDRESSED:
    case USBD_STATE_CONFIGURED:
      if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
 801238a:	683b      	ldr	r3, [r7, #0]
 801238c:	885b      	ldrh	r3, [r3, #2]
 801238e:	2b01      	cmp	r3, #1
 8012390:	d10c      	bne.n	80123ac <USBD_ClrFeature+0x3a>
      {
        pdev->dev_remote_wakeup = 0U;
 8012392:	687b      	ldr	r3, [r7, #4]
 8012394:	2200      	movs	r2, #0
 8012396:	f8c3 22a4 	str.w	r2, [r3, #676]	@ 0x2a4
        (void)USBD_CtlSendStatus(pdev);
 801239a:	6878      	ldr	r0, [r7, #4]
 801239c:	f000 f91c 	bl	80125d8 <USBD_CtlSendStatus>
      }
      break;
 80123a0:	e004      	b.n	80123ac <USBD_ClrFeature+0x3a>

    default:
      USBD_CtlError(pdev, req);
 80123a2:	6839      	ldr	r1, [r7, #0]
 80123a4:	6878      	ldr	r0, [r7, #4]
 80123a6:	f000 f840 	bl	801242a <USBD_CtlError>
      break;
 80123aa:	e000      	b.n	80123ae <USBD_ClrFeature+0x3c>
      break;
 80123ac:	bf00      	nop
  }
}
 80123ae:	bf00      	nop
 80123b0:	3708      	adds	r7, #8
 80123b2:	46bd      	mov	sp, r7
 80123b4:	bd80      	pop	{r7, pc}

080123b6 <USBD_ParseSetupRequest>:
  * @param  req: usb request
  * @param  pdata: setup data pointer
  * @retval None
  */
void USBD_ParseSetupRequest(USBD_SetupReqTypedef *req, uint8_t *pdata)
{
 80123b6:	b580      	push	{r7, lr}
 80123b8:	b084      	sub	sp, #16
 80123ba:	af00      	add	r7, sp, #0
 80123bc:	6078      	str	r0, [r7, #4]
 80123be:	6039      	str	r1, [r7, #0]
  uint8_t *pbuff = pdata;
 80123c0:	683b      	ldr	r3, [r7, #0]
 80123c2:	60fb      	str	r3, [r7, #12]

  req->bmRequest = *(uint8_t *)(pbuff);
 80123c4:	68fb      	ldr	r3, [r7, #12]
 80123c6:	781a      	ldrb	r2, [r3, #0]
 80123c8:	687b      	ldr	r3, [r7, #4]
 80123ca:	701a      	strb	r2, [r3, #0]

  pbuff++;
 80123cc:	68fb      	ldr	r3, [r7, #12]
 80123ce:	3301      	adds	r3, #1
 80123d0:	60fb      	str	r3, [r7, #12]
  req->bRequest = *(uint8_t *)(pbuff);
 80123d2:	68fb      	ldr	r3, [r7, #12]
 80123d4:	781a      	ldrb	r2, [r3, #0]
 80123d6:	687b      	ldr	r3, [r7, #4]
 80123d8:	705a      	strb	r2, [r3, #1]

  pbuff++;
 80123da:	68fb      	ldr	r3, [r7, #12]
 80123dc:	3301      	adds	r3, #1
 80123de:	60fb      	str	r3, [r7, #12]
  req->wValue = SWAPBYTE(pbuff);
 80123e0:	68f8      	ldr	r0, [r7, #12]
 80123e2:	f7ff fa16 	bl	8011812 <SWAPBYTE>
 80123e6:	4603      	mov	r3, r0
 80123e8:	461a      	mov	r2, r3
 80123ea:	687b      	ldr	r3, [r7, #4]
 80123ec:	805a      	strh	r2, [r3, #2]

  pbuff++;
 80123ee:	68fb      	ldr	r3, [r7, #12]
 80123f0:	3301      	adds	r3, #1
 80123f2:	60fb      	str	r3, [r7, #12]
  pbuff++;
 80123f4:	68fb      	ldr	r3, [r7, #12]
 80123f6:	3301      	adds	r3, #1
 80123f8:	60fb      	str	r3, [r7, #12]
  req->wIndex = SWAPBYTE(pbuff);
 80123fa:	68f8      	ldr	r0, [r7, #12]
 80123fc:	f7ff fa09 	bl	8011812 <SWAPBYTE>
 8012400:	4603      	mov	r3, r0
 8012402:	461a      	mov	r2, r3
 8012404:	687b      	ldr	r3, [r7, #4]
 8012406:	809a      	strh	r2, [r3, #4]

  pbuff++;
 8012408:	68fb      	ldr	r3, [r7, #12]
 801240a:	3301      	adds	r3, #1
 801240c:	60fb      	str	r3, [r7, #12]
  pbuff++;
 801240e:	68fb      	ldr	r3, [r7, #12]
 8012410:	3301      	adds	r3, #1
 8012412:	60fb      	str	r3, [r7, #12]
  req->wLength = SWAPBYTE(pbuff);
 8012414:	68f8      	ldr	r0, [r7, #12]
 8012416:	f7ff f9fc 	bl	8011812 <SWAPBYTE>
 801241a:	4603      	mov	r3, r0
 801241c:	461a      	mov	r2, r3
 801241e:	687b      	ldr	r3, [r7, #4]
 8012420:	80da      	strh	r2, [r3, #6]
}
 8012422:	bf00      	nop
 8012424:	3710      	adds	r7, #16
 8012426:	46bd      	mov	sp, r7
 8012428:	bd80      	pop	{r7, pc}

0801242a <USBD_CtlError>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval None
  */
void USBD_CtlError(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 801242a:	b580      	push	{r7, lr}
 801242c:	b082      	sub	sp, #8
 801242e:	af00      	add	r7, sp, #0
 8012430:	6078      	str	r0, [r7, #4]
 8012432:	6039      	str	r1, [r7, #0]
  UNUSED(req);

  (void)USBD_LL_StallEP(pdev, 0x80U);
 8012434:	2180      	movs	r1, #128	@ 0x80
 8012436:	6878      	ldr	r0, [r7, #4]
 8012438:	f000 fc96 	bl	8012d68 <USBD_LL_StallEP>
  (void)USBD_LL_StallEP(pdev, 0U);
 801243c:	2100      	movs	r1, #0
 801243e:	6878      	ldr	r0, [r7, #4]
 8012440:	f000 fc92 	bl	8012d68 <USBD_LL_StallEP>
}
 8012444:	bf00      	nop
 8012446:	3708      	adds	r7, #8
 8012448:	46bd      	mov	sp, r7
 801244a:	bd80      	pop	{r7, pc}

0801244c <USBD_GetString>:
  * @param  unicode : Formatted string buffer (unicode)
  * @param  len : descriptor length
  * @retval None
  */
void USBD_GetString(uint8_t *desc, uint8_t *unicode, uint16_t *len)
{
 801244c:	b580      	push	{r7, lr}
 801244e:	b086      	sub	sp, #24
 8012450:	af00      	add	r7, sp, #0
 8012452:	60f8      	str	r0, [r7, #12]
 8012454:	60b9      	str	r1, [r7, #8]
 8012456:	607a      	str	r2, [r7, #4]
  uint8_t idx = 0U;
 8012458:	2300      	movs	r3, #0
 801245a:	75fb      	strb	r3, [r7, #23]
  uint8_t *pdesc;

  if (desc == NULL)
 801245c:	68fb      	ldr	r3, [r7, #12]
 801245e:	2b00      	cmp	r3, #0
 8012460:	d042      	beq.n	80124e8 <USBD_GetString+0x9c>
  {
    return;
  }

  pdesc = desc;
 8012462:	68fb      	ldr	r3, [r7, #12]
 8012464:	613b      	str	r3, [r7, #16]
  *len = MIN(USBD_MAX_STR_DESC_SIZ, ((uint16_t)USBD_GetLen(pdesc) * 2U) + 2U);
 8012466:	6938      	ldr	r0, [r7, #16]
 8012468:	f000 f842 	bl	80124f0 <USBD_GetLen>
 801246c:	4603      	mov	r3, r0
 801246e:	3301      	adds	r3, #1
 8012470:	005b      	lsls	r3, r3, #1
 8012472:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8012476:	d808      	bhi.n	801248a <USBD_GetString+0x3e>
 8012478:	6938      	ldr	r0, [r7, #16]
 801247a:	f000 f839 	bl	80124f0 <USBD_GetLen>
 801247e:	4603      	mov	r3, r0
 8012480:	3301      	adds	r3, #1
 8012482:	b29b      	uxth	r3, r3
 8012484:	005b      	lsls	r3, r3, #1
 8012486:	b29a      	uxth	r2, r3
 8012488:	e001      	b.n	801248e <USBD_GetString+0x42>
 801248a:	f44f 7200 	mov.w	r2, #512	@ 0x200
 801248e:	687b      	ldr	r3, [r7, #4]
 8012490:	801a      	strh	r2, [r3, #0]

  unicode[idx] = *(uint8_t *)len;
 8012492:	7dfb      	ldrb	r3, [r7, #23]
 8012494:	68ba      	ldr	r2, [r7, #8]
 8012496:	4413      	add	r3, r2
 8012498:	687a      	ldr	r2, [r7, #4]
 801249a:	7812      	ldrb	r2, [r2, #0]
 801249c:	701a      	strb	r2, [r3, #0]
  idx++;
 801249e:	7dfb      	ldrb	r3, [r7, #23]
 80124a0:	3301      	adds	r3, #1
 80124a2:	75fb      	strb	r3, [r7, #23]
  unicode[idx] = USB_DESC_TYPE_STRING;
 80124a4:	7dfb      	ldrb	r3, [r7, #23]
 80124a6:	68ba      	ldr	r2, [r7, #8]
 80124a8:	4413      	add	r3, r2
 80124aa:	2203      	movs	r2, #3
 80124ac:	701a      	strb	r2, [r3, #0]
  idx++;
 80124ae:	7dfb      	ldrb	r3, [r7, #23]
 80124b0:	3301      	adds	r3, #1
 80124b2:	75fb      	strb	r3, [r7, #23]

  while (*pdesc != (uint8_t)'\0')
 80124b4:	e013      	b.n	80124de <USBD_GetString+0x92>
  {
    unicode[idx] = *pdesc;
 80124b6:	7dfb      	ldrb	r3, [r7, #23]
 80124b8:	68ba      	ldr	r2, [r7, #8]
 80124ba:	4413      	add	r3, r2
 80124bc:	693a      	ldr	r2, [r7, #16]
 80124be:	7812      	ldrb	r2, [r2, #0]
 80124c0:	701a      	strb	r2, [r3, #0]
    pdesc++;
 80124c2:	693b      	ldr	r3, [r7, #16]
 80124c4:	3301      	adds	r3, #1
 80124c6:	613b      	str	r3, [r7, #16]
    idx++;
 80124c8:	7dfb      	ldrb	r3, [r7, #23]
 80124ca:	3301      	adds	r3, #1
 80124cc:	75fb      	strb	r3, [r7, #23]

    unicode[idx] = 0U;
 80124ce:	7dfb      	ldrb	r3, [r7, #23]
 80124d0:	68ba      	ldr	r2, [r7, #8]
 80124d2:	4413      	add	r3, r2
 80124d4:	2200      	movs	r2, #0
 80124d6:	701a      	strb	r2, [r3, #0]
    idx++;
 80124d8:	7dfb      	ldrb	r3, [r7, #23]
 80124da:	3301      	adds	r3, #1
 80124dc:	75fb      	strb	r3, [r7, #23]
  while (*pdesc != (uint8_t)'\0')
 80124de:	693b      	ldr	r3, [r7, #16]
 80124e0:	781b      	ldrb	r3, [r3, #0]
 80124e2:	2b00      	cmp	r3, #0
 80124e4:	d1e7      	bne.n	80124b6 <USBD_GetString+0x6a>
 80124e6:	e000      	b.n	80124ea <USBD_GetString+0x9e>
    return;
 80124e8:	bf00      	nop
  }
}
 80124ea:	3718      	adds	r7, #24
 80124ec:	46bd      	mov	sp, r7
 80124ee:	bd80      	pop	{r7, pc}

080124f0 <USBD_GetLen>:
  *         return the string length
   * @param  buf : pointer to the ascii string buffer
  * @retval string length
  */
static uint8_t USBD_GetLen(uint8_t *buf)
{
 80124f0:	b480      	push	{r7}
 80124f2:	b085      	sub	sp, #20
 80124f4:	af00      	add	r7, sp, #0
 80124f6:	6078      	str	r0, [r7, #4]
  uint8_t  len = 0U;
 80124f8:	2300      	movs	r3, #0
 80124fa:	73fb      	strb	r3, [r7, #15]
  uint8_t *pbuff = buf;
 80124fc:	687b      	ldr	r3, [r7, #4]
 80124fe:	60bb      	str	r3, [r7, #8]

  while (*pbuff != (uint8_t)'\0')
 8012500:	e005      	b.n	801250e <USBD_GetLen+0x1e>
  {
    len++;
 8012502:	7bfb      	ldrb	r3, [r7, #15]
 8012504:	3301      	adds	r3, #1
 8012506:	73fb      	strb	r3, [r7, #15]
    pbuff++;
 8012508:	68bb      	ldr	r3, [r7, #8]
 801250a:	3301      	adds	r3, #1
 801250c:	60bb      	str	r3, [r7, #8]
  while (*pbuff != (uint8_t)'\0')
 801250e:	68bb      	ldr	r3, [r7, #8]
 8012510:	781b      	ldrb	r3, [r3, #0]
 8012512:	2b00      	cmp	r3, #0
 8012514:	d1f5      	bne.n	8012502 <USBD_GetLen+0x12>
  }

  return len;
 8012516:	7bfb      	ldrb	r3, [r7, #15]
}
 8012518:	4618      	mov	r0, r3
 801251a:	3714      	adds	r7, #20
 801251c:	46bd      	mov	sp, r7
 801251e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012522:	4770      	bx	lr

08012524 <USBD_CtlSendData>:
  * @param  len: length of data to be sent
  * @retval status
  */
USBD_StatusTypeDef USBD_CtlSendData(USBD_HandleTypeDef *pdev,
                                    uint8_t *pbuf, uint32_t len)
{
 8012524:	b580      	push	{r7, lr}
 8012526:	b084      	sub	sp, #16
 8012528:	af00      	add	r7, sp, #0
 801252a:	60f8      	str	r0, [r7, #12]
 801252c:	60b9      	str	r1, [r7, #8]
 801252e:	607a      	str	r2, [r7, #4]
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_DATA_IN;
 8012530:	68fb      	ldr	r3, [r7, #12]
 8012532:	2202      	movs	r2, #2
 8012534:	f8c3 2294 	str.w	r2, [r3, #660]	@ 0x294
  pdev->ep_in[0].total_length = len;
 8012538:	68fb      	ldr	r3, [r7, #12]
 801253a:	687a      	ldr	r2, [r7, #4]
 801253c:	619a      	str	r2, [r3, #24]

#ifdef USBD_AVOID_PACKET_SPLIT_MPS
  pdev->ep_in[0].rem_length = 0U;
#else
  pdev->ep_in[0].rem_length = len;
 801253e:	68fb      	ldr	r3, [r7, #12]
 8012540:	687a      	ldr	r2, [r7, #4]
 8012542:	61da      	str	r2, [r3, #28]
#endif /* USBD_AVOID_PACKET_SPLIT_MPS */

  /* Start the transfer */
  (void)USBD_LL_Transmit(pdev, 0x00U, pbuf, len);
 8012544:	687b      	ldr	r3, [r7, #4]
 8012546:	68ba      	ldr	r2, [r7, #8]
 8012548:	2100      	movs	r1, #0
 801254a:	68f8      	ldr	r0, [r7, #12]
 801254c:	f000 fc95 	bl	8012e7a <USBD_LL_Transmit>

  return USBD_OK;
 8012550:	2300      	movs	r3, #0
}
 8012552:	4618      	mov	r0, r3
 8012554:	3710      	adds	r7, #16
 8012556:	46bd      	mov	sp, r7
 8012558:	bd80      	pop	{r7, pc}

0801255a <USBD_CtlContinueSendData>:
  * @param  len: length of data to be sent
  * @retval status
  */
USBD_StatusTypeDef USBD_CtlContinueSendData(USBD_HandleTypeDef *pdev,
                                            uint8_t *pbuf, uint32_t len)
{
 801255a:	b580      	push	{r7, lr}
 801255c:	b084      	sub	sp, #16
 801255e:	af00      	add	r7, sp, #0
 8012560:	60f8      	str	r0, [r7, #12]
 8012562:	60b9      	str	r1, [r7, #8]
 8012564:	607a      	str	r2, [r7, #4]
  /* Start the next transfer */
  (void)USBD_LL_Transmit(pdev, 0x00U, pbuf, len);
 8012566:	687b      	ldr	r3, [r7, #4]
 8012568:	68ba      	ldr	r2, [r7, #8]
 801256a:	2100      	movs	r1, #0
 801256c:	68f8      	ldr	r0, [r7, #12]
 801256e:	f000 fc84 	bl	8012e7a <USBD_LL_Transmit>

  return USBD_OK;
 8012572:	2300      	movs	r3, #0
}
 8012574:	4618      	mov	r0, r3
 8012576:	3710      	adds	r7, #16
 8012578:	46bd      	mov	sp, r7
 801257a:	bd80      	pop	{r7, pc}

0801257c <USBD_CtlPrepareRx>:
  * @param  len: length of data to be received
  * @retval status
  */
USBD_StatusTypeDef USBD_CtlPrepareRx(USBD_HandleTypeDef *pdev,
                                     uint8_t *pbuf, uint32_t len)
{
 801257c:	b580      	push	{r7, lr}
 801257e:	b084      	sub	sp, #16
 8012580:	af00      	add	r7, sp, #0
 8012582:	60f8      	str	r0, [r7, #12]
 8012584:	60b9      	str	r1, [r7, #8]
 8012586:	607a      	str	r2, [r7, #4]
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_DATA_OUT;
 8012588:	68fb      	ldr	r3, [r7, #12]
 801258a:	2203      	movs	r2, #3
 801258c:	f8c3 2294 	str.w	r2, [r3, #660]	@ 0x294
  pdev->ep_out[0].total_length = len;
 8012590:	68fb      	ldr	r3, [r7, #12]
 8012592:	687a      	ldr	r2, [r7, #4]
 8012594:	f8c3 2158 	str.w	r2, [r3, #344]	@ 0x158

#ifdef USBD_AVOID_PACKET_SPLIT_MPS
  pdev->ep_out[0].rem_length = 0U;
#else
  pdev->ep_out[0].rem_length = len;
 8012598:	68fb      	ldr	r3, [r7, #12]
 801259a:	687a      	ldr	r2, [r7, #4]
 801259c:	f8c3 215c 	str.w	r2, [r3, #348]	@ 0x15c
#endif /* USBD_AVOID_PACKET_SPLIT_MPS */

  /* Start the transfer */
  (void)USBD_LL_PrepareReceive(pdev, 0U, pbuf, len);
 80125a0:	687b      	ldr	r3, [r7, #4]
 80125a2:	68ba      	ldr	r2, [r7, #8]
 80125a4:	2100      	movs	r1, #0
 80125a6:	68f8      	ldr	r0, [r7, #12]
 80125a8:	f000 fc88 	bl	8012ebc <USBD_LL_PrepareReceive>

  return USBD_OK;
 80125ac:	2300      	movs	r3, #0
}
 80125ae:	4618      	mov	r0, r3
 80125b0:	3710      	adds	r7, #16
 80125b2:	46bd      	mov	sp, r7
 80125b4:	bd80      	pop	{r7, pc}

080125b6 <USBD_CtlContinueRx>:
  * @param  len: length of data to be received
  * @retval status
  */
USBD_StatusTypeDef USBD_CtlContinueRx(USBD_HandleTypeDef *pdev,
                                      uint8_t *pbuf, uint32_t len)
{
 80125b6:	b580      	push	{r7, lr}
 80125b8:	b084      	sub	sp, #16
 80125ba:	af00      	add	r7, sp, #0
 80125bc:	60f8      	str	r0, [r7, #12]
 80125be:	60b9      	str	r1, [r7, #8]
 80125c0:	607a      	str	r2, [r7, #4]
  (void)USBD_LL_PrepareReceive(pdev, 0U, pbuf, len);
 80125c2:	687b      	ldr	r3, [r7, #4]
 80125c4:	68ba      	ldr	r2, [r7, #8]
 80125c6:	2100      	movs	r1, #0
 80125c8:	68f8      	ldr	r0, [r7, #12]
 80125ca:	f000 fc77 	bl	8012ebc <USBD_LL_PrepareReceive>

  return USBD_OK;
 80125ce:	2300      	movs	r3, #0
}
 80125d0:	4618      	mov	r0, r3
 80125d2:	3710      	adds	r7, #16
 80125d4:	46bd      	mov	sp, r7
 80125d6:	bd80      	pop	{r7, pc}

080125d8 <USBD_CtlSendStatus>:
  *         send zero lzngth packet on the ctl pipe
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_CtlSendStatus(USBD_HandleTypeDef *pdev)
{
 80125d8:	b580      	push	{r7, lr}
 80125da:	b082      	sub	sp, #8
 80125dc:	af00      	add	r7, sp, #0
 80125de:	6078      	str	r0, [r7, #4]
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_IN;
 80125e0:	687b      	ldr	r3, [r7, #4]
 80125e2:	2204      	movs	r2, #4
 80125e4:	f8c3 2294 	str.w	r2, [r3, #660]	@ 0x294

  /* Start the transfer */
  (void)USBD_LL_Transmit(pdev, 0x00U, NULL, 0U);
 80125e8:	2300      	movs	r3, #0
 80125ea:	2200      	movs	r2, #0
 80125ec:	2100      	movs	r1, #0
 80125ee:	6878      	ldr	r0, [r7, #4]
 80125f0:	f000 fc43 	bl	8012e7a <USBD_LL_Transmit>

  return USBD_OK;
 80125f4:	2300      	movs	r3, #0
}
 80125f6:	4618      	mov	r0, r3
 80125f8:	3708      	adds	r7, #8
 80125fa:	46bd      	mov	sp, r7
 80125fc:	bd80      	pop	{r7, pc}

080125fe <USBD_CtlReceiveStatus>:
  *         receive zero lzngth packet on the ctl pipe
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_CtlReceiveStatus(USBD_HandleTypeDef *pdev)
{
 80125fe:	b580      	push	{r7, lr}
 8012600:	b082      	sub	sp, #8
 8012602:	af00      	add	r7, sp, #0
 8012604:	6078      	str	r0, [r7, #4]
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_OUT;
 8012606:	687b      	ldr	r3, [r7, #4]
 8012608:	2205      	movs	r2, #5
 801260a:	f8c3 2294 	str.w	r2, [r3, #660]	@ 0x294

  /* Start the transfer */
  (void)USBD_LL_PrepareReceive(pdev, 0U, NULL, 0U);
 801260e:	2300      	movs	r3, #0
 8012610:	2200      	movs	r2, #0
 8012612:	2100      	movs	r1, #0
 8012614:	6878      	ldr	r0, [r7, #4]
 8012616:	f000 fc51 	bl	8012ebc <USBD_LL_PrepareReceive>

  return USBD_OK;
 801261a:	2300      	movs	r3, #0
}
 801261c:	4618      	mov	r0, r3
 801261e:	3708      	adds	r7, #8
 8012620:	46bd      	mov	sp, r7
 8012622:	bd80      	pop	{r7, pc}

08012624 <MX_USB_DEVICE_Init>:
/**
  * Init USB device Library, add supported class and start the library
  * @retval None
  */
void MX_USB_DEVICE_Init(void)
{
 8012624:	b580      	push	{r7, lr}
 8012626:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN USB_DEVICE_Init_PreTreatment */

  /* USER CODE END USB_DEVICE_Init_PreTreatment */

  /* Init Device Library, add supported class and start the library. */
  if (USBD_Init(&hUsbDeviceHS, &HS_Desc, DEVICE_HS) != USBD_OK)
 8012628:	2201      	movs	r2, #1
 801262a:	4913      	ldr	r1, [pc, #76]	@ (8012678 <MX_USB_DEVICE_Init+0x54>)
 801262c:	4813      	ldr	r0, [pc, #76]	@ (801267c <MX_USB_DEVICE_Init+0x58>)
 801262e:	f7fe fd05 	bl	801103c <USBD_Init>
 8012632:	4603      	mov	r3, r0
 8012634:	2b00      	cmp	r3, #0
 8012636:	d001      	beq.n	801263c <MX_USB_DEVICE_Init+0x18>
  {
    Error_Handler();
 8012638:	f7ef fc0a 	bl	8001e50 <Error_Handler>
  }
  if (USBD_RegisterClass(&hUsbDeviceHS, &USBD_AUDIO) != USBD_OK)
 801263c:	4910      	ldr	r1, [pc, #64]	@ (8012680 <MX_USB_DEVICE_Init+0x5c>)
 801263e:	480f      	ldr	r0, [pc, #60]	@ (801267c <MX_USB_DEVICE_Init+0x58>)
 8012640:	f7fe fd2c 	bl	801109c <USBD_RegisterClass>
 8012644:	4603      	mov	r3, r0
 8012646:	2b00      	cmp	r3, #0
 8012648:	d001      	beq.n	801264e <MX_USB_DEVICE_Init+0x2a>
  {
    Error_Handler();
 801264a:	f7ef fc01 	bl	8001e50 <Error_Handler>
  }
  if (USBD_AUDIO_RegisterInterface(&hUsbDeviceHS, &USBD_AUDIO_fops_HS) != USBD_OK)
 801264e:	490d      	ldr	r1, [pc, #52]	@ (8012684 <MX_USB_DEVICE_Init+0x60>)
 8012650:	480a      	ldr	r0, [pc, #40]	@ (801267c <MX_USB_DEVICE_Init+0x58>)
 8012652:	f7fe fca7 	bl	8010fa4 <USBD_AUDIO_RegisterInterface>
 8012656:	4603      	mov	r3, r0
 8012658:	2b00      	cmp	r3, #0
 801265a:	d001      	beq.n	8012660 <MX_USB_DEVICE_Init+0x3c>
  {
    Error_Handler();
 801265c:	f7ef fbf8 	bl	8001e50 <Error_Handler>
  }
  if (USBD_Start(&hUsbDeviceHS) != USBD_OK)
 8012660:	4806      	ldr	r0, [pc, #24]	@ (801267c <MX_USB_DEVICE_Init+0x58>)
 8012662:	f7fe fd51 	bl	8011108 <USBD_Start>
 8012666:	4603      	mov	r3, r0
 8012668:	2b00      	cmp	r3, #0
 801266a:	d001      	beq.n	8012670 <MX_USB_DEVICE_Init+0x4c>
  {
    Error_Handler();
 801266c:	f7ef fbf0 	bl	8001e50 <Error_Handler>
  }

  /* USER CODE BEGIN USB_DEVICE_Init_PostTreatment */
  HAL_PWREx_EnableUSBVoltageDetector();
 8012670:	f7f7 f904 	bl	800987c <HAL_PWREx_EnableUSBVoltageDetector>

  /* USER CODE END USB_DEVICE_Init_PostTreatment */
}
 8012674:	bf00      	nop
 8012676:	bd80      	pop	{r7, pc}
 8012678:	240001fc 	.word	0x240001fc
 801267c:	240007d0 	.word	0x240007d0
 8012680:	2400012c 	.word	0x2400012c
 8012684:	240001e0 	.word	0x240001e0

08012688 <AUDIO_Init_HS>:
  * @param  Volume: Initial volume level (from 0 (Mute) to 100 (Max))
  * @param  options: Reserved for future use
  * @retval USBD_OK if all operations are OK else USBD_FAIL
  */
static int8_t AUDIO_Init_HS(uint32_t AudioFreq, uint32_t Volume, uint32_t options)
{
 8012688:	b480      	push	{r7}
 801268a:	b085      	sub	sp, #20
 801268c:	af00      	add	r7, sp, #0
 801268e:	60f8      	str	r0, [r7, #12]
 8012690:	60b9      	str	r1, [r7, #8]
 8012692:	607a      	str	r2, [r7, #4]
  /* USER CODE BEGIN 9 */
  UNUSED(AudioFreq);
  UNUSED(Volume);
  UNUSED(options);
  return (USBD_OK);
 8012694:	2300      	movs	r3, #0
  /* USER CODE END 9 */
}
 8012696:	4618      	mov	r0, r3
 8012698:	3714      	adds	r7, #20
 801269a:	46bd      	mov	sp, r7
 801269c:	f85d 7b04 	ldr.w	r7, [sp], #4
 80126a0:	4770      	bx	lr

080126a2 <AUDIO_DeInit_HS>:
  * @brief  DeInitializes the AUDIO media low layer
  * @param  options: Reserved for future use
  * @retval USBD_OK if all operations are OK else USBD_FAIL
  */
static int8_t AUDIO_DeInit_HS(uint32_t options)
{
 80126a2:	b480      	push	{r7}
 80126a4:	b083      	sub	sp, #12
 80126a6:	af00      	add	r7, sp, #0
 80126a8:	6078      	str	r0, [r7, #4]
  /* USER CODE BEGIN 10 */
  UNUSED(options);
  return (USBD_OK);
 80126aa:	2300      	movs	r3, #0
  /* USER CODE END 10 */
}
 80126ac:	4618      	mov	r0, r3
 80126ae:	370c      	adds	r7, #12
 80126b0:	46bd      	mov	sp, r7
 80126b2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80126b6:	4770      	bx	lr

080126b8 <AUDIO_AudioCmd_HS>:
  * @param  size: Number of data to be sent (in bytes)
  * @param  cmd: Command opcode
  * @retval USBD_OK if all operations are OK else USBD_FAIL
  */
static int8_t AUDIO_AudioCmd_HS(uint8_t* pbuf, uint32_t size, uint8_t cmd)
{
 80126b8:	b480      	push	{r7}
 80126ba:	b085      	sub	sp, #20
 80126bc:	af00      	add	r7, sp, #0
 80126be:	60f8      	str	r0, [r7, #12]
 80126c0:	60b9      	str	r1, [r7, #8]
 80126c2:	4613      	mov	r3, r2
 80126c4:	71fb      	strb	r3, [r7, #7]
  /* USER CODE BEGIN 11 */
  switch(cmd)
 80126c6:	79fb      	ldrb	r3, [r7, #7]
 80126c8:	2b01      	cmp	r3, #1
 80126ca:	d001      	beq.n	80126d0 <AUDIO_AudioCmd_HS+0x18>
 80126cc:	2b02      	cmp	r3, #2
  {
    case AUDIO_CMD_START:
    break;

    case AUDIO_CMD_PLAY:
    break;
 80126ce:	e000      	b.n	80126d2 <AUDIO_AudioCmd_HS+0x1a>
    break;
 80126d0:	bf00      	nop
  }
  UNUSED(pbuf);
  UNUSED(size);
  UNUSED(cmd);
  return (USBD_OK);
 80126d2:	2300      	movs	r3, #0
  /* USER CODE END 11 */
}
 80126d4:	4618      	mov	r0, r3
 80126d6:	3714      	adds	r7, #20
 80126d8:	46bd      	mov	sp, r7
 80126da:	f85d 7b04 	ldr.w	r7, [sp], #4
 80126de:	4770      	bx	lr

080126e0 <AUDIO_VolumeCtl_HS>:
  * @brief  Controls AUDIO Volume.
  * @param  vol: volume level (0..100)
  * @retval USBD_OK if all operations are OK else USBD_FAIL
  */
static int8_t AUDIO_VolumeCtl_HS(uint8_t vol)
{
 80126e0:	b480      	push	{r7}
 80126e2:	b083      	sub	sp, #12
 80126e4:	af00      	add	r7, sp, #0
 80126e6:	4603      	mov	r3, r0
 80126e8:	71fb      	strb	r3, [r7, #7]
  /* USER CODE BEGIN 12 */
  UNUSED(vol);
  return (USBD_OK);
 80126ea:	2300      	movs	r3, #0
  /* USER CODE END 12 */
}
 80126ec:	4618      	mov	r0, r3
 80126ee:	370c      	adds	r7, #12
 80126f0:	46bd      	mov	sp, r7
 80126f2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80126f6:	4770      	bx	lr

080126f8 <AUDIO_MuteCtl_HS>:
  * @brief  Controls AUDIO Mute.
  * @param  cmd: command opcode
  * @retval USBD_OK if all operations are OK else USBD_FAIL
  */
static int8_t AUDIO_MuteCtl_HS(uint8_t cmd)
{
 80126f8:	b480      	push	{r7}
 80126fa:	b083      	sub	sp, #12
 80126fc:	af00      	add	r7, sp, #0
 80126fe:	4603      	mov	r3, r0
 8012700:	71fb      	strb	r3, [r7, #7]
  /* USER CODE BEGIN 13 */
  UNUSED(cmd);
  return (USBD_OK);
 8012702:	2300      	movs	r3, #0
  /* USER CODE END 13 */
}
 8012704:	4618      	mov	r0, r3
 8012706:	370c      	adds	r7, #12
 8012708:	46bd      	mov	sp, r7
 801270a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801270e:	4770      	bx	lr

08012710 <AUDIO_PeriodicTC_HS>:
  * @brief  AUDIO_PeriodicTC_HS
  * @param  cmd: command opcode
  * @retval USBD_OK if all operations are OK else USBD_FAIL
  */
static int8_t AUDIO_PeriodicTC_HS(uint8_t *pbuf, uint32_t size, uint8_t cmd)
{
 8012710:	b480      	push	{r7}
 8012712:	b085      	sub	sp, #20
 8012714:	af00      	add	r7, sp, #0
 8012716:	60f8      	str	r0, [r7, #12]
 8012718:	60b9      	str	r1, [r7, #8]
 801271a:	4613      	mov	r3, r2
 801271c:	71fb      	strb	r3, [r7, #7]
  /* USER CODE BEGIN 14 */
  UNUSED(pbuf);
  UNUSED(size);
  UNUSED(cmd);
  return (USBD_OK);
 801271e:	2300      	movs	r3, #0
  /* USER CODE END 14 */
}
 8012720:	4618      	mov	r0, r3
 8012722:	3714      	adds	r7, #20
 8012724:	46bd      	mov	sp, r7
 8012726:	f85d 7b04 	ldr.w	r7, [sp], #4
 801272a:	4770      	bx	lr

0801272c <AUDIO_GetState_HS>:
/**
  * @brief  Gets AUDIO state.
  * @retval USBD_OK if all operations are OK else USBD_FAIL
  */
static int8_t AUDIO_GetState_HS(void)
{
 801272c:	b480      	push	{r7}
 801272e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN 15 */
  return (USBD_OK);
 8012730:	2300      	movs	r3, #0
  /* USER CODE END 15 */
}
 8012732:	4618      	mov	r0, r3
 8012734:	46bd      	mov	sp, r7
 8012736:	f85d 7b04 	ldr.w	r7, [sp], #4
 801273a:	4770      	bx	lr

0801273c <USBD_HS_DeviceDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_HS_DeviceDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 801273c:	b480      	push	{r7}
 801273e:	b083      	sub	sp, #12
 8012740:	af00      	add	r7, sp, #0
 8012742:	4603      	mov	r3, r0
 8012744:	6039      	str	r1, [r7, #0]
 8012746:	71fb      	strb	r3, [r7, #7]
  UNUSED(speed);
  *length = sizeof(USBD_HS_DeviceDesc);
 8012748:	683b      	ldr	r3, [r7, #0]
 801274a:	2212      	movs	r2, #18
 801274c:	801a      	strh	r2, [r3, #0]
  return USBD_HS_DeviceDesc;
 801274e:	4b03      	ldr	r3, [pc, #12]	@ (801275c <USBD_HS_DeviceDescriptor+0x20>)
}
 8012750:	4618      	mov	r0, r3
 8012752:	370c      	adds	r7, #12
 8012754:	46bd      	mov	sp, r7
 8012756:	f85d 7b04 	ldr.w	r7, [sp], #4
 801275a:	4770      	bx	lr
 801275c:	2400021c 	.word	0x2400021c

08012760 <USBD_HS_LangIDStrDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_HS_LangIDStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 8012760:	b480      	push	{r7}
 8012762:	b083      	sub	sp, #12
 8012764:	af00      	add	r7, sp, #0
 8012766:	4603      	mov	r3, r0
 8012768:	6039      	str	r1, [r7, #0]
 801276a:	71fb      	strb	r3, [r7, #7]
  UNUSED(speed);
  *length = sizeof(USBD_LangIDDesc);
 801276c:	683b      	ldr	r3, [r7, #0]
 801276e:	2204      	movs	r2, #4
 8012770:	801a      	strh	r2, [r3, #0]
  return USBD_LangIDDesc;
 8012772:	4b03      	ldr	r3, [pc, #12]	@ (8012780 <USBD_HS_LangIDStrDescriptor+0x20>)
}
 8012774:	4618      	mov	r0, r3
 8012776:	370c      	adds	r7, #12
 8012778:	46bd      	mov	sp, r7
 801277a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801277e:	4770      	bx	lr
 8012780:	24000230 	.word	0x24000230

08012784 <USBD_HS_ProductStrDescriptor>:
  * @param  speed : current device speed
  * @param  length : pointer to data length variable
  * @retval pointer to descriptor buffer
  */
uint8_t * USBD_HS_ProductStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 8012784:	b580      	push	{r7, lr}
 8012786:	b082      	sub	sp, #8
 8012788:	af00      	add	r7, sp, #0
 801278a:	4603      	mov	r3, r0
 801278c:	6039      	str	r1, [r7, #0]
 801278e:	71fb      	strb	r3, [r7, #7]
  if(speed == 0)
 8012790:	79fb      	ldrb	r3, [r7, #7]
 8012792:	2b00      	cmp	r3, #0
 8012794:	d105      	bne.n	80127a2 <USBD_HS_ProductStrDescriptor+0x1e>
  {
    USBD_GetString((uint8_t *)USBD_PRODUCT_STRING_HS, USBD_StrDesc, length);
 8012796:	683a      	ldr	r2, [r7, #0]
 8012798:	4907      	ldr	r1, [pc, #28]	@ (80127b8 <USBD_HS_ProductStrDescriptor+0x34>)
 801279a:	4808      	ldr	r0, [pc, #32]	@ (80127bc <USBD_HS_ProductStrDescriptor+0x38>)
 801279c:	f7ff fe56 	bl	801244c <USBD_GetString>
 80127a0:	e004      	b.n	80127ac <USBD_HS_ProductStrDescriptor+0x28>
  }
  else
  {
    USBD_GetString((uint8_t *)USBD_PRODUCT_STRING_HS, USBD_StrDesc, length);
 80127a2:	683a      	ldr	r2, [r7, #0]
 80127a4:	4904      	ldr	r1, [pc, #16]	@ (80127b8 <USBD_HS_ProductStrDescriptor+0x34>)
 80127a6:	4805      	ldr	r0, [pc, #20]	@ (80127bc <USBD_HS_ProductStrDescriptor+0x38>)
 80127a8:	f7ff fe50 	bl	801244c <USBD_GetString>
  }
  return USBD_StrDesc;
 80127ac:	4b02      	ldr	r3, [pc, #8]	@ (80127b8 <USBD_HS_ProductStrDescriptor+0x34>)
}
 80127ae:	4618      	mov	r0, r3
 80127b0:	3708      	adds	r7, #8
 80127b2:	46bd      	mov	sp, r7
 80127b4:	bd80      	pop	{r7, pc}
 80127b6:	bf00      	nop
 80127b8:	24000aac 	.word	0x24000aac
 80127bc:	08013168 	.word	0x08013168

080127c0 <USBD_HS_ManufacturerStrDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_HS_ManufacturerStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 80127c0:	b580      	push	{r7, lr}
 80127c2:	b082      	sub	sp, #8
 80127c4:	af00      	add	r7, sp, #0
 80127c6:	4603      	mov	r3, r0
 80127c8:	6039      	str	r1, [r7, #0]
 80127ca:	71fb      	strb	r3, [r7, #7]
  UNUSED(speed);
  USBD_GetString((uint8_t *)USBD_MANUFACTURER_STRING, USBD_StrDesc, length);
 80127cc:	683a      	ldr	r2, [r7, #0]
 80127ce:	4904      	ldr	r1, [pc, #16]	@ (80127e0 <USBD_HS_ManufacturerStrDescriptor+0x20>)
 80127d0:	4804      	ldr	r0, [pc, #16]	@ (80127e4 <USBD_HS_ManufacturerStrDescriptor+0x24>)
 80127d2:	f7ff fe3b 	bl	801244c <USBD_GetString>
  return USBD_StrDesc;
 80127d6:	4b02      	ldr	r3, [pc, #8]	@ (80127e0 <USBD_HS_ManufacturerStrDescriptor+0x20>)
}
 80127d8:	4618      	mov	r0, r3
 80127da:	3708      	adds	r7, #8
 80127dc:	46bd      	mov	sp, r7
 80127de:	bd80      	pop	{r7, pc}
 80127e0:	24000aac 	.word	0x24000aac
 80127e4:	08013174 	.word	0x08013174

080127e8 <USBD_HS_SerialStrDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_HS_SerialStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 80127e8:	b580      	push	{r7, lr}
 80127ea:	b082      	sub	sp, #8
 80127ec:	af00      	add	r7, sp, #0
 80127ee:	4603      	mov	r3, r0
 80127f0:	6039      	str	r1, [r7, #0]
 80127f2:	71fb      	strb	r3, [r7, #7]
  UNUSED(speed);
  *length = USB_SIZ_STRING_SERIAL;
 80127f4:	683b      	ldr	r3, [r7, #0]
 80127f6:	221a      	movs	r2, #26
 80127f8:	801a      	strh	r2, [r3, #0]

  /* Update the serial number string descriptor with the data from the unique
   * ID */
  Get_SerialNum();
 80127fa:	f000 f843 	bl	8012884 <Get_SerialNum>
  /* USER CODE BEGIN USBD_HS_SerialStrDescriptor */

  /* USER CODE END USBD_HS_SerialStrDescriptor */

  return (uint8_t *) USBD_StringSerial;
 80127fe:	4b02      	ldr	r3, [pc, #8]	@ (8012808 <USBD_HS_SerialStrDescriptor+0x20>)
}
 8012800:	4618      	mov	r0, r3
 8012802:	3708      	adds	r7, #8
 8012804:	46bd      	mov	sp, r7
 8012806:	bd80      	pop	{r7, pc}
 8012808:	24000234 	.word	0x24000234

0801280c <USBD_HS_ConfigStrDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_HS_ConfigStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 801280c:	b580      	push	{r7, lr}
 801280e:	b082      	sub	sp, #8
 8012810:	af00      	add	r7, sp, #0
 8012812:	4603      	mov	r3, r0
 8012814:	6039      	str	r1, [r7, #0]
 8012816:	71fb      	strb	r3, [r7, #7]
  if(speed == USBD_SPEED_HIGH)
 8012818:	79fb      	ldrb	r3, [r7, #7]
 801281a:	2b00      	cmp	r3, #0
 801281c:	d105      	bne.n	801282a <USBD_HS_ConfigStrDescriptor+0x1e>
  {
    USBD_GetString((uint8_t *)USBD_CONFIGURATION_STRING_HS, USBD_StrDesc, length);
 801281e:	683a      	ldr	r2, [r7, #0]
 8012820:	4907      	ldr	r1, [pc, #28]	@ (8012840 <USBD_HS_ConfigStrDescriptor+0x34>)
 8012822:	4808      	ldr	r0, [pc, #32]	@ (8012844 <USBD_HS_ConfigStrDescriptor+0x38>)
 8012824:	f7ff fe12 	bl	801244c <USBD_GetString>
 8012828:	e004      	b.n	8012834 <USBD_HS_ConfigStrDescriptor+0x28>
  }
  else
  {
    USBD_GetString((uint8_t *)USBD_CONFIGURATION_STRING_HS, USBD_StrDesc, length);
 801282a:	683a      	ldr	r2, [r7, #0]
 801282c:	4904      	ldr	r1, [pc, #16]	@ (8012840 <USBD_HS_ConfigStrDescriptor+0x34>)
 801282e:	4805      	ldr	r0, [pc, #20]	@ (8012844 <USBD_HS_ConfigStrDescriptor+0x38>)
 8012830:	f7ff fe0c 	bl	801244c <USBD_GetString>
  }
  return USBD_StrDesc;
 8012834:	4b02      	ldr	r3, [pc, #8]	@ (8012840 <USBD_HS_ConfigStrDescriptor+0x34>)
}
 8012836:	4618      	mov	r0, r3
 8012838:	3708      	adds	r7, #8
 801283a:	46bd      	mov	sp, r7
 801283c:	bd80      	pop	{r7, pc}
 801283e:	bf00      	nop
 8012840:	24000aac 	.word	0x24000aac
 8012844:	08013180 	.word	0x08013180

08012848 <USBD_HS_InterfaceStrDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_HS_InterfaceStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 8012848:	b580      	push	{r7, lr}
 801284a:	b082      	sub	sp, #8
 801284c:	af00      	add	r7, sp, #0
 801284e:	4603      	mov	r3, r0
 8012850:	6039      	str	r1, [r7, #0]
 8012852:	71fb      	strb	r3, [r7, #7]
  if(speed == 0)
 8012854:	79fb      	ldrb	r3, [r7, #7]
 8012856:	2b00      	cmp	r3, #0
 8012858:	d105      	bne.n	8012866 <USBD_HS_InterfaceStrDescriptor+0x1e>
  {
    USBD_GetString((uint8_t *)USBD_INTERFACE_STRING_HS, USBD_StrDesc, length);
 801285a:	683a      	ldr	r2, [r7, #0]
 801285c:	4907      	ldr	r1, [pc, #28]	@ (801287c <USBD_HS_InterfaceStrDescriptor+0x34>)
 801285e:	4808      	ldr	r0, [pc, #32]	@ (8012880 <USBD_HS_InterfaceStrDescriptor+0x38>)
 8012860:	f7ff fdf4 	bl	801244c <USBD_GetString>
 8012864:	e004      	b.n	8012870 <USBD_HS_InterfaceStrDescriptor+0x28>
  }
  else
  {
    USBD_GetString((uint8_t *)USBD_INTERFACE_STRING_HS, USBD_StrDesc, length);
 8012866:	683a      	ldr	r2, [r7, #0]
 8012868:	4904      	ldr	r1, [pc, #16]	@ (801287c <USBD_HS_InterfaceStrDescriptor+0x34>)
 801286a:	4805      	ldr	r0, [pc, #20]	@ (8012880 <USBD_HS_InterfaceStrDescriptor+0x38>)
 801286c:	f7ff fdee 	bl	801244c <USBD_GetString>
  }
  return USBD_StrDesc;
 8012870:	4b02      	ldr	r3, [pc, #8]	@ (801287c <USBD_HS_InterfaceStrDescriptor+0x34>)
}
 8012872:	4618      	mov	r0, r3
 8012874:	3708      	adds	r7, #8
 8012876:	46bd      	mov	sp, r7
 8012878:	bd80      	pop	{r7, pc}
 801287a:	bf00      	nop
 801287c:	24000aac 	.word	0x24000aac
 8012880:	08013190 	.word	0x08013190

08012884 <Get_SerialNum>:
  * @brief  Create the serial number string descriptor
  * @param  None
  * @retval None
  */
static void Get_SerialNum(void)
{
 8012884:	b580      	push	{r7, lr}
 8012886:	b084      	sub	sp, #16
 8012888:	af00      	add	r7, sp, #0
  uint32_t deviceserial0;
  uint32_t deviceserial1;
  uint32_t deviceserial2;

  deviceserial0 = *(uint32_t *) DEVICE_ID1;
 801288a:	4b0f      	ldr	r3, [pc, #60]	@ (80128c8 <Get_SerialNum+0x44>)
 801288c:	681b      	ldr	r3, [r3, #0]
 801288e:	60fb      	str	r3, [r7, #12]
  deviceserial1 = *(uint32_t *) DEVICE_ID2;
 8012890:	4b0e      	ldr	r3, [pc, #56]	@ (80128cc <Get_SerialNum+0x48>)
 8012892:	681b      	ldr	r3, [r3, #0]
 8012894:	60bb      	str	r3, [r7, #8]
  deviceserial2 = *(uint32_t *) DEVICE_ID3;
 8012896:	4b0e      	ldr	r3, [pc, #56]	@ (80128d0 <Get_SerialNum+0x4c>)
 8012898:	681b      	ldr	r3, [r3, #0]
 801289a:	607b      	str	r3, [r7, #4]

  deviceserial0 += deviceserial2;
 801289c:	68fa      	ldr	r2, [r7, #12]
 801289e:	687b      	ldr	r3, [r7, #4]
 80128a0:	4413      	add	r3, r2
 80128a2:	60fb      	str	r3, [r7, #12]

  if (deviceserial0 != 0)
 80128a4:	68fb      	ldr	r3, [r7, #12]
 80128a6:	2b00      	cmp	r3, #0
 80128a8:	d009      	beq.n	80128be <Get_SerialNum+0x3a>
  {
    IntToUnicode(deviceserial0, &USBD_StringSerial[2], 8);
 80128aa:	2208      	movs	r2, #8
 80128ac:	4909      	ldr	r1, [pc, #36]	@ (80128d4 <Get_SerialNum+0x50>)
 80128ae:	68f8      	ldr	r0, [r7, #12]
 80128b0:	f000 f814 	bl	80128dc <IntToUnicode>
    IntToUnicode(deviceserial1, &USBD_StringSerial[18], 4);
 80128b4:	2204      	movs	r2, #4
 80128b6:	4908      	ldr	r1, [pc, #32]	@ (80128d8 <Get_SerialNum+0x54>)
 80128b8:	68b8      	ldr	r0, [r7, #8]
 80128ba:	f000 f80f 	bl	80128dc <IntToUnicode>
  }
}
 80128be:	bf00      	nop
 80128c0:	3710      	adds	r7, #16
 80128c2:	46bd      	mov	sp, r7
 80128c4:	bd80      	pop	{r7, pc}
 80128c6:	bf00      	nop
 80128c8:	08fff800 	.word	0x08fff800
 80128cc:	08fff804 	.word	0x08fff804
 80128d0:	08fff808 	.word	0x08fff808
 80128d4:	24000236 	.word	0x24000236
 80128d8:	24000246 	.word	0x24000246

080128dc <IntToUnicode>:
  * @param  pbuf: pointer to the buffer
  * @param  len: buffer length
  * @retval None
  */
static void IntToUnicode(uint32_t value, uint8_t * pbuf, uint8_t len)
{
 80128dc:	b480      	push	{r7}
 80128de:	b087      	sub	sp, #28
 80128e0:	af00      	add	r7, sp, #0
 80128e2:	60f8      	str	r0, [r7, #12]
 80128e4:	60b9      	str	r1, [r7, #8]
 80128e6:	4613      	mov	r3, r2
 80128e8:	71fb      	strb	r3, [r7, #7]
  uint8_t idx = 0;
 80128ea:	2300      	movs	r3, #0
 80128ec:	75fb      	strb	r3, [r7, #23]

  for (idx = 0; idx < len; idx++)
 80128ee:	2300      	movs	r3, #0
 80128f0:	75fb      	strb	r3, [r7, #23]
 80128f2:	e027      	b.n	8012944 <IntToUnicode+0x68>
  {
    if (((value >> 28)) < 0xA)
 80128f4:	68fb      	ldr	r3, [r7, #12]
 80128f6:	0f1b      	lsrs	r3, r3, #28
 80128f8:	2b09      	cmp	r3, #9
 80128fa:	d80b      	bhi.n	8012914 <IntToUnicode+0x38>
    {
      pbuf[2 * idx] = (value >> 28) + '0';
 80128fc:	68fb      	ldr	r3, [r7, #12]
 80128fe:	0f1b      	lsrs	r3, r3, #28
 8012900:	b2da      	uxtb	r2, r3
 8012902:	7dfb      	ldrb	r3, [r7, #23]
 8012904:	005b      	lsls	r3, r3, #1
 8012906:	4619      	mov	r1, r3
 8012908:	68bb      	ldr	r3, [r7, #8]
 801290a:	440b      	add	r3, r1
 801290c:	3230      	adds	r2, #48	@ 0x30
 801290e:	b2d2      	uxtb	r2, r2
 8012910:	701a      	strb	r2, [r3, #0]
 8012912:	e00a      	b.n	801292a <IntToUnicode+0x4e>
    }
    else
    {
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
 8012914:	68fb      	ldr	r3, [r7, #12]
 8012916:	0f1b      	lsrs	r3, r3, #28
 8012918:	b2da      	uxtb	r2, r3
 801291a:	7dfb      	ldrb	r3, [r7, #23]
 801291c:	005b      	lsls	r3, r3, #1
 801291e:	4619      	mov	r1, r3
 8012920:	68bb      	ldr	r3, [r7, #8]
 8012922:	440b      	add	r3, r1
 8012924:	3237      	adds	r2, #55	@ 0x37
 8012926:	b2d2      	uxtb	r2, r2
 8012928:	701a      	strb	r2, [r3, #0]
    }

    value = value << 4;
 801292a:	68fb      	ldr	r3, [r7, #12]
 801292c:	011b      	lsls	r3, r3, #4
 801292e:	60fb      	str	r3, [r7, #12]

    pbuf[2 * idx + 1] = 0;
 8012930:	7dfb      	ldrb	r3, [r7, #23]
 8012932:	005b      	lsls	r3, r3, #1
 8012934:	3301      	adds	r3, #1
 8012936:	68ba      	ldr	r2, [r7, #8]
 8012938:	4413      	add	r3, r2
 801293a:	2200      	movs	r2, #0
 801293c:	701a      	strb	r2, [r3, #0]
  for (idx = 0; idx < len; idx++)
 801293e:	7dfb      	ldrb	r3, [r7, #23]
 8012940:	3301      	adds	r3, #1
 8012942:	75fb      	strb	r3, [r7, #23]
 8012944:	7dfa      	ldrb	r2, [r7, #23]
 8012946:	79fb      	ldrb	r3, [r7, #7]
 8012948:	429a      	cmp	r2, r3
 801294a:	d3d3      	bcc.n	80128f4 <IntToUnicode+0x18>
  }
}
 801294c:	bf00      	nop
 801294e:	bf00      	nop
 8012950:	371c      	adds	r7, #28
 8012952:	46bd      	mov	sp, r7
 8012954:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012958:	4770      	bx	lr
	...

0801295c <HAL_PCD_MspInit>:
                       LL Driver Callbacks (PCD -> USB Device Library)
*******************************************************************************/
/* MSP Init */

void HAL_PCD_MspInit(PCD_HandleTypeDef* pcdHandle)
{
 801295c:	b580      	push	{r7, lr}
 801295e:	b08a      	sub	sp, #40	@ 0x28
 8012960:	af00      	add	r7, sp, #0
 8012962:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8012964:	f107 0314 	add.w	r3, r7, #20
 8012968:	2200      	movs	r2, #0
 801296a:	601a      	str	r2, [r3, #0]
 801296c:	605a      	str	r2, [r3, #4]
 801296e:	609a      	str	r2, [r3, #8]
 8012970:	60da      	str	r2, [r3, #12]
 8012972:	611a      	str	r2, [r3, #16]
  if(pcdHandle->Instance==USB_OTG_HS)
 8012974:	687b      	ldr	r3, [r7, #4]
 8012976:	681b      	ldr	r3, [r3, #0]
 8012978:	4a26      	ldr	r2, [pc, #152]	@ (8012a14 <HAL_PCD_MspInit+0xb8>)
 801297a:	4293      	cmp	r3, r2
 801297c:	d146      	bne.n	8012a0c <HAL_PCD_MspInit+0xb0>

  /* USER CODE END USB_OTG_HS_MspInit 0 */

  /** Enable USB Voltage detector
  */
    HAL_PWREx_EnableUSBVoltageDetector();
 801297e:	f7f6 ff7d 	bl	800987c <HAL_PWREx_EnableUSBVoltageDetector>

    __HAL_RCC_GPIOA_CLK_ENABLE();
 8012982:	4b25      	ldr	r3, [pc, #148]	@ (8012a18 <HAL_PCD_MspInit+0xbc>)
 8012984:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
 8012988:	4a23      	ldr	r2, [pc, #140]	@ (8012a18 <HAL_PCD_MspInit+0xbc>)
 801298a:	f043 0301 	orr.w	r3, r3, #1
 801298e:	f8c2 3140 	str.w	r3, [r2, #320]	@ 0x140
 8012992:	4b21      	ldr	r3, [pc, #132]	@ (8012a18 <HAL_PCD_MspInit+0xbc>)
 8012994:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
 8012998:	f003 0301 	and.w	r3, r3, #1
 801299c:	613b      	str	r3, [r7, #16]
 801299e:	693b      	ldr	r3, [r7, #16]
    /**USB_OTG_HS GPIO Configuration
    PA11     ------> USB_OTG_HS_DM
    PA12     ------> USB_OTG_HS_DP
    */
    GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_12;
 80129a0:	f44f 53c0 	mov.w	r3, #6144	@ 0x1800
 80129a4:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80129a6:	2302      	movs	r3, #2
 80129a8:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80129aa:	2300      	movs	r3, #0
 80129ac:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 80129ae:	2303      	movs	r3, #3
 80129b0:	623b      	str	r3, [r7, #32]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80129b2:	f107 0314 	add.w	r3, r7, #20
 80129b6:	4619      	mov	r1, r3
 80129b8:	4818      	ldr	r0, [pc, #96]	@ (8012a1c <HAL_PCD_MspInit+0xc0>)
 80129ba:	f7f3 fdc1 	bl	8006540 <HAL_GPIO_Init>

    /* Peripheral clock enable */
    __HAL_RCC_USB_OTG_HS_CLK_ENABLE();
 80129be:	4b16      	ldr	r3, [pc, #88]	@ (8012a18 <HAL_PCD_MspInit+0xbc>)
 80129c0:	f8d3 3138 	ldr.w	r3, [r3, #312]	@ 0x138
 80129c4:	4a14      	ldr	r2, [pc, #80]	@ (8012a18 <HAL_PCD_MspInit+0xbc>)
 80129c6:	f043 7300 	orr.w	r3, r3, #33554432	@ 0x2000000
 80129ca:	f8c2 3138 	str.w	r3, [r2, #312]	@ 0x138
 80129ce:	4b12      	ldr	r3, [pc, #72]	@ (8012a18 <HAL_PCD_MspInit+0xbc>)
 80129d0:	f8d3 3138 	ldr.w	r3, [r3, #312]	@ 0x138
 80129d4:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 80129d8:	60fb      	str	r3, [r7, #12]
 80129da:	68fb      	ldr	r3, [r7, #12]

    /* Peripheral interrupt init */
    HAL_NVIC_SetPriority(OTG_HS_EP1_OUT_IRQn, 0, 0);
 80129dc:	2200      	movs	r2, #0
 80129de:	2100      	movs	r1, #0
 80129e0:	204a      	movs	r0, #74	@ 0x4a
 80129e2:	f7f1 fb7a 	bl	80040da <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(OTG_HS_EP1_OUT_IRQn);
 80129e6:	204a      	movs	r0, #74	@ 0x4a
 80129e8:	f7f1 fb91 	bl	800410e <HAL_NVIC_EnableIRQ>
    HAL_NVIC_SetPriority(OTG_HS_EP1_IN_IRQn, 0, 0);
 80129ec:	2200      	movs	r2, #0
 80129ee:	2100      	movs	r1, #0
 80129f0:	204b      	movs	r0, #75	@ 0x4b
 80129f2:	f7f1 fb72 	bl	80040da <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(OTG_HS_EP1_IN_IRQn);
 80129f6:	204b      	movs	r0, #75	@ 0x4b
 80129f8:	f7f1 fb89 	bl	800410e <HAL_NVIC_EnableIRQ>
    HAL_NVIC_SetPriority(OTG_HS_IRQn, 0, 0);
 80129fc:	2200      	movs	r2, #0
 80129fe:	2100      	movs	r1, #0
 8012a00:	204d      	movs	r0, #77	@ 0x4d
 8012a02:	f7f1 fb6a 	bl	80040da <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(OTG_HS_IRQn);
 8012a06:	204d      	movs	r0, #77	@ 0x4d
 8012a08:	f7f1 fb81 	bl	800410e <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN USB_OTG_HS_MspInit 1 */

  /* USER CODE END USB_OTG_HS_MspInit 1 */
  }
}
 8012a0c:	bf00      	nop
 8012a0e:	3728      	adds	r7, #40	@ 0x28
 8012a10:	46bd      	mov	sp, r7
 8012a12:	bd80      	pop	{r7, pc}
 8012a14:	40040000 	.word	0x40040000
 8012a18:	58024400 	.word	0x58024400
 8012a1c:	58020000 	.word	0x58020000

08012a20 <HAL_PCD_SetupStageCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_SetupStageCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_SetupStageCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 8012a20:	b580      	push	{r7, lr}
 8012a22:	b082      	sub	sp, #8
 8012a24:	af00      	add	r7, sp, #0
 8012a26:	6078      	str	r0, [r7, #4]
  USBD_LL_SetupStage((USBD_HandleTypeDef*)hpcd->pData, (uint8_t *)hpcd->Setup);
 8012a28:	687b      	ldr	r3, [r7, #4]
 8012a2a:	f8d3 24e0 	ldr.w	r2, [r3, #1248]	@ 0x4e0
 8012a2e:	687b      	ldr	r3, [r7, #4]
 8012a30:	f203 439c 	addw	r3, r3, #1180	@ 0x49c
 8012a34:	4619      	mov	r1, r3
 8012a36:	4610      	mov	r0, r2
 8012a38:	f7fe fbb3 	bl	80111a2 <USBD_LL_SetupStage>
}
 8012a3c:	bf00      	nop
 8012a3e:	3708      	adds	r7, #8
 8012a40:	46bd      	mov	sp, r7
 8012a42:	bd80      	pop	{r7, pc}

08012a44 <HAL_PCD_DataOutStageCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_DataOutStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#else
void HAL_PCD_DataOutStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 8012a44:	b580      	push	{r7, lr}
 8012a46:	b082      	sub	sp, #8
 8012a48:	af00      	add	r7, sp, #0
 8012a4a:	6078      	str	r0, [r7, #4]
 8012a4c:	460b      	mov	r3, r1
 8012a4e:	70fb      	strb	r3, [r7, #3]
  USBD_LL_DataOutStage((USBD_HandleTypeDef*)hpcd->pData, epnum, hpcd->OUT_ep[epnum].xfer_buff);
 8012a50:	687b      	ldr	r3, [r7, #4]
 8012a52:	f8d3 04e0 	ldr.w	r0, [r3, #1248]	@ 0x4e0
 8012a56:	78fa      	ldrb	r2, [r7, #3]
 8012a58:	6879      	ldr	r1, [r7, #4]
 8012a5a:	4613      	mov	r3, r2
 8012a5c:	00db      	lsls	r3, r3, #3
 8012a5e:	4413      	add	r3, r2
 8012a60:	009b      	lsls	r3, r3, #2
 8012a62:	440b      	add	r3, r1
 8012a64:	f503 7318 	add.w	r3, r3, #608	@ 0x260
 8012a68:	681a      	ldr	r2, [r3, #0]
 8012a6a:	78fb      	ldrb	r3, [r7, #3]
 8012a6c:	4619      	mov	r1, r3
 8012a6e:	f7fe fbed 	bl	801124c <USBD_LL_DataOutStage>
}
 8012a72:	bf00      	nop
 8012a74:	3708      	adds	r7, #8
 8012a76:	46bd      	mov	sp, r7
 8012a78:	bd80      	pop	{r7, pc}

08012a7a <HAL_PCD_DataInStageCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_DataInStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#else
void HAL_PCD_DataInStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 8012a7a:	b580      	push	{r7, lr}
 8012a7c:	b082      	sub	sp, #8
 8012a7e:	af00      	add	r7, sp, #0
 8012a80:	6078      	str	r0, [r7, #4]
 8012a82:	460b      	mov	r3, r1
 8012a84:	70fb      	strb	r3, [r7, #3]
  USBD_LL_DataInStage((USBD_HandleTypeDef*)hpcd->pData, epnum, hpcd->IN_ep[epnum].xfer_buff);
 8012a86:	687b      	ldr	r3, [r7, #4]
 8012a88:	f8d3 04e0 	ldr.w	r0, [r3, #1248]	@ 0x4e0
 8012a8c:	78fa      	ldrb	r2, [r7, #3]
 8012a8e:	6879      	ldr	r1, [r7, #4]
 8012a90:	4613      	mov	r3, r2
 8012a92:	00db      	lsls	r3, r3, #3
 8012a94:	4413      	add	r3, r2
 8012a96:	009b      	lsls	r3, r3, #2
 8012a98:	440b      	add	r3, r1
 8012a9a:	3320      	adds	r3, #32
 8012a9c:	681a      	ldr	r2, [r3, #0]
 8012a9e:	78fb      	ldrb	r3, [r7, #3]
 8012aa0:	4619      	mov	r1, r3
 8012aa2:	f7fe fc86 	bl	80113b2 <USBD_LL_DataInStage>
}
 8012aa6:	bf00      	nop
 8012aa8:	3708      	adds	r7, #8
 8012aaa:	46bd      	mov	sp, r7
 8012aac:	bd80      	pop	{r7, pc}

08012aae <HAL_PCD_SOFCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_SOFCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_SOFCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 8012aae:	b580      	push	{r7, lr}
 8012ab0:	b082      	sub	sp, #8
 8012ab2:	af00      	add	r7, sp, #0
 8012ab4:	6078      	str	r0, [r7, #4]
  USBD_LL_SOF((USBD_HandleTypeDef*)hpcd->pData);
 8012ab6:	687b      	ldr	r3, [r7, #4]
 8012ab8:	f8d3 34e0 	ldr.w	r3, [r3, #1248]	@ 0x4e0
 8012abc:	4618      	mov	r0, r3
 8012abe:	f7fe fdc0 	bl	8011642 <USBD_LL_SOF>
}
 8012ac2:	bf00      	nop
 8012ac4:	3708      	adds	r7, #8
 8012ac6:	46bd      	mov	sp, r7
 8012ac8:	bd80      	pop	{r7, pc}

08012aca <HAL_PCD_ResetCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_ResetCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_ResetCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 8012aca:	b580      	push	{r7, lr}
 8012acc:	b084      	sub	sp, #16
 8012ace:	af00      	add	r7, sp, #0
 8012ad0:	6078      	str	r0, [r7, #4]
  USBD_SpeedTypeDef speed = USBD_SPEED_FULL;
 8012ad2:	2301      	movs	r3, #1
 8012ad4:	73fb      	strb	r3, [r7, #15]

  if ( hpcd->Init.speed == PCD_SPEED_HIGH)
 8012ad6:	687b      	ldr	r3, [r7, #4]
 8012ad8:	79db      	ldrb	r3, [r3, #7]
 8012ada:	2b00      	cmp	r3, #0
 8012adc:	d102      	bne.n	8012ae4 <HAL_PCD_ResetCallback+0x1a>
  {
    speed = USBD_SPEED_HIGH;
 8012ade:	2300      	movs	r3, #0
 8012ae0:	73fb      	strb	r3, [r7, #15]
 8012ae2:	e008      	b.n	8012af6 <HAL_PCD_ResetCallback+0x2c>
  }
  else if ( hpcd->Init.speed == PCD_SPEED_FULL)
 8012ae4:	687b      	ldr	r3, [r7, #4]
 8012ae6:	79db      	ldrb	r3, [r3, #7]
 8012ae8:	2b02      	cmp	r3, #2
 8012aea:	d102      	bne.n	8012af2 <HAL_PCD_ResetCallback+0x28>
  {
    speed = USBD_SPEED_FULL;
 8012aec:	2301      	movs	r3, #1
 8012aee:	73fb      	strb	r3, [r7, #15]
 8012af0:	e001      	b.n	8012af6 <HAL_PCD_ResetCallback+0x2c>
  }
  else
  {
    Error_Handler();
 8012af2:	f7ef f9ad 	bl	8001e50 <Error_Handler>
  }
    /* Set Speed. */
  USBD_LL_SetSpeed((USBD_HandleTypeDef*)hpcd->pData, speed);
 8012af6:	687b      	ldr	r3, [r7, #4]
 8012af8:	f8d3 34e0 	ldr.w	r3, [r3, #1248]	@ 0x4e0
 8012afc:	7bfa      	ldrb	r2, [r7, #15]
 8012afe:	4611      	mov	r1, r2
 8012b00:	4618      	mov	r0, r3
 8012b02:	f7fe fd5a 	bl	80115ba <USBD_LL_SetSpeed>

  /* Reset Device. */
  USBD_LL_Reset((USBD_HandleTypeDef*)hpcd->pData);
 8012b06:	687b      	ldr	r3, [r7, #4]
 8012b08:	f8d3 34e0 	ldr.w	r3, [r3, #1248]	@ 0x4e0
 8012b0c:	4618      	mov	r0, r3
 8012b0e:	f7fe fd02 	bl	8011516 <USBD_LL_Reset>
}
 8012b12:	bf00      	nop
 8012b14:	3710      	adds	r7, #16
 8012b16:	46bd      	mov	sp, r7
 8012b18:	bd80      	pop	{r7, pc}
	...

08012b1c <HAL_PCD_SuspendCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_SuspendCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_SuspendCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 8012b1c:	b580      	push	{r7, lr}
 8012b1e:	b082      	sub	sp, #8
 8012b20:	af00      	add	r7, sp, #0
 8012b22:	6078      	str	r0, [r7, #4]
  /* Inform USB library that core enters in suspend Mode. */
  USBD_LL_Suspend((USBD_HandleTypeDef*)hpcd->pData);
 8012b24:	687b      	ldr	r3, [r7, #4]
 8012b26:	f8d3 34e0 	ldr.w	r3, [r3, #1248]	@ 0x4e0
 8012b2a:	4618      	mov	r0, r3
 8012b2c:	f7fe fd55 	bl	80115da <USBD_LL_Suspend>
  __HAL_PCD_GATE_PHYCLOCK(hpcd);
 8012b30:	687b      	ldr	r3, [r7, #4]
 8012b32:	681b      	ldr	r3, [r3, #0]
 8012b34:	f503 6360 	add.w	r3, r3, #3584	@ 0xe00
 8012b38:	681b      	ldr	r3, [r3, #0]
 8012b3a:	687a      	ldr	r2, [r7, #4]
 8012b3c:	6812      	ldr	r2, [r2, #0]
 8012b3e:	f502 6260 	add.w	r2, r2, #3584	@ 0xe00
 8012b42:	f043 0301 	orr.w	r3, r3, #1
 8012b46:	6013      	str	r3, [r2, #0]
  /* Enter in STOP mode. */
  /* USER CODE BEGIN 2 */
  if (hpcd->Init.low_power_enable)
 8012b48:	687b      	ldr	r3, [r7, #4]
 8012b4a:	7adb      	ldrb	r3, [r3, #11]
 8012b4c:	2b00      	cmp	r3, #0
 8012b4e:	d005      	beq.n	8012b5c <HAL_PCD_SuspendCallback+0x40>
  {
    /* Set SLEEPDEEP bit and SleepOnExit of Cortex System Control Register. */
    SCB->SCR |= (uint32_t)((uint32_t)(SCB_SCR_SLEEPDEEP_Msk | SCB_SCR_SLEEPONEXIT_Msk));
 8012b50:	4b04      	ldr	r3, [pc, #16]	@ (8012b64 <HAL_PCD_SuspendCallback+0x48>)
 8012b52:	691b      	ldr	r3, [r3, #16]
 8012b54:	4a03      	ldr	r2, [pc, #12]	@ (8012b64 <HAL_PCD_SuspendCallback+0x48>)
 8012b56:	f043 0306 	orr.w	r3, r3, #6
 8012b5a:	6113      	str	r3, [r2, #16]
  }
  /* USER CODE END 2 */
}
 8012b5c:	bf00      	nop
 8012b5e:	3708      	adds	r7, #8
 8012b60:	46bd      	mov	sp, r7
 8012b62:	bd80      	pop	{r7, pc}
 8012b64:	e000ed00 	.word	0xe000ed00

08012b68 <HAL_PCD_ResumeCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_ResumeCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_ResumeCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 8012b68:	b580      	push	{r7, lr}
 8012b6a:	b082      	sub	sp, #8
 8012b6c:	af00      	add	r7, sp, #0
 8012b6e:	6078      	str	r0, [r7, #4]
  /* USER CODE BEGIN 3 */

  /* USER CODE END 3 */
  USBD_LL_Resume((USBD_HandleTypeDef*)hpcd->pData);
 8012b70:	687b      	ldr	r3, [r7, #4]
 8012b72:	f8d3 34e0 	ldr.w	r3, [r3, #1248]	@ 0x4e0
 8012b76:	4618      	mov	r0, r3
 8012b78:	f7fe fd4b 	bl	8011612 <USBD_LL_Resume>
}
 8012b7c:	bf00      	nop
 8012b7e:	3708      	adds	r7, #8
 8012b80:	46bd      	mov	sp, r7
 8012b82:	bd80      	pop	{r7, pc}

08012b84 <HAL_PCD_ISOOUTIncompleteCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_ISOOUTIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#else
void HAL_PCD_ISOOUTIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 8012b84:	b580      	push	{r7, lr}
 8012b86:	b082      	sub	sp, #8
 8012b88:	af00      	add	r7, sp, #0
 8012b8a:	6078      	str	r0, [r7, #4]
 8012b8c:	460b      	mov	r3, r1
 8012b8e:	70fb      	strb	r3, [r7, #3]
  USBD_LL_IsoOUTIncomplete((USBD_HandleTypeDef*)hpcd->pData, epnum);
 8012b90:	687b      	ldr	r3, [r7, #4]
 8012b92:	f8d3 34e0 	ldr.w	r3, [r3, #1248]	@ 0x4e0
 8012b96:	78fa      	ldrb	r2, [r7, #3]
 8012b98:	4611      	mov	r1, r2
 8012b9a:	4618      	mov	r0, r3
 8012b9c:	f7fe fda3 	bl	80116e6 <USBD_LL_IsoOUTIncomplete>
}
 8012ba0:	bf00      	nop
 8012ba2:	3708      	adds	r7, #8
 8012ba4:	46bd      	mov	sp, r7
 8012ba6:	bd80      	pop	{r7, pc}

08012ba8 <HAL_PCD_ISOINIncompleteCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_ISOINIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#else
void HAL_PCD_ISOINIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 8012ba8:	b580      	push	{r7, lr}
 8012baa:	b082      	sub	sp, #8
 8012bac:	af00      	add	r7, sp, #0
 8012bae:	6078      	str	r0, [r7, #4]
 8012bb0:	460b      	mov	r3, r1
 8012bb2:	70fb      	strb	r3, [r7, #3]
  USBD_LL_IsoINIncomplete((USBD_HandleTypeDef*)hpcd->pData, epnum);
 8012bb4:	687b      	ldr	r3, [r7, #4]
 8012bb6:	f8d3 34e0 	ldr.w	r3, [r3, #1248]	@ 0x4e0
 8012bba:	78fa      	ldrb	r2, [r7, #3]
 8012bbc:	4611      	mov	r1, r2
 8012bbe:	4618      	mov	r0, r3
 8012bc0:	f7fe fd5f 	bl	8011682 <USBD_LL_IsoINIncomplete>
}
 8012bc4:	bf00      	nop
 8012bc6:	3708      	adds	r7, #8
 8012bc8:	46bd      	mov	sp, r7
 8012bca:	bd80      	pop	{r7, pc}

08012bcc <HAL_PCD_ConnectCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_ConnectCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_ConnectCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 8012bcc:	b580      	push	{r7, lr}
 8012bce:	b082      	sub	sp, #8
 8012bd0:	af00      	add	r7, sp, #0
 8012bd2:	6078      	str	r0, [r7, #4]
  USBD_LL_DevConnected((USBD_HandleTypeDef*)hpcd->pData);
 8012bd4:	687b      	ldr	r3, [r7, #4]
 8012bd6:	f8d3 34e0 	ldr.w	r3, [r3, #1248]	@ 0x4e0
 8012bda:	4618      	mov	r0, r3
 8012bdc:	f7fe fdb5 	bl	801174a <USBD_LL_DevConnected>
}
 8012be0:	bf00      	nop
 8012be2:	3708      	adds	r7, #8
 8012be4:	46bd      	mov	sp, r7
 8012be6:	bd80      	pop	{r7, pc}

08012be8 <HAL_PCD_DisconnectCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_DisconnectCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_DisconnectCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 8012be8:	b580      	push	{r7, lr}
 8012bea:	b082      	sub	sp, #8
 8012bec:	af00      	add	r7, sp, #0
 8012bee:	6078      	str	r0, [r7, #4]
  USBD_LL_DevDisconnected((USBD_HandleTypeDef*)hpcd->pData);
 8012bf0:	687b      	ldr	r3, [r7, #4]
 8012bf2:	f8d3 34e0 	ldr.w	r3, [r3, #1248]	@ 0x4e0
 8012bf6:	4618      	mov	r0, r3
 8012bf8:	f7fe fdb2 	bl	8011760 <USBD_LL_DevDisconnected>
}
 8012bfc:	bf00      	nop
 8012bfe:	3708      	adds	r7, #8
 8012c00:	46bd      	mov	sp, r7
 8012c02:	bd80      	pop	{r7, pc}

08012c04 <USBD_LL_Init>:
  * @brief  Initializes the low level portion of the device driver.
  * @param  pdev: Device handle
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_Init(USBD_HandleTypeDef *pdev)
{
 8012c04:	b580      	push	{r7, lr}
 8012c06:	b082      	sub	sp, #8
 8012c08:	af00      	add	r7, sp, #0
 8012c0a:	6078      	str	r0, [r7, #4]
  /* Init USB Ip. */
  if (pdev->id == DEVICE_HS) {
 8012c0c:	687b      	ldr	r3, [r7, #4]
 8012c0e:	781b      	ldrb	r3, [r3, #0]
 8012c10:	2b01      	cmp	r3, #1
 8012c12:	d140      	bne.n	8012c96 <USBD_LL_Init+0x92>
  /* Link the driver to the stack. */
  hpcd_USB_OTG_HS.pData = pdev;
 8012c14:	4a22      	ldr	r2, [pc, #136]	@ (8012ca0 <USBD_LL_Init+0x9c>)
 8012c16:	687b      	ldr	r3, [r7, #4]
 8012c18:	f8c2 34e0 	str.w	r3, [r2, #1248]	@ 0x4e0
  pdev->pData = &hpcd_USB_OTG_HS;
 8012c1c:	687b      	ldr	r3, [r7, #4]
 8012c1e:	4a20      	ldr	r2, [pc, #128]	@ (8012ca0 <USBD_LL_Init+0x9c>)
 8012c20:	f8c3 22c8 	str.w	r2, [r3, #712]	@ 0x2c8

  hpcd_USB_OTG_HS.Instance = USB_OTG_HS;
 8012c24:	4b1e      	ldr	r3, [pc, #120]	@ (8012ca0 <USBD_LL_Init+0x9c>)
 8012c26:	4a1f      	ldr	r2, [pc, #124]	@ (8012ca4 <USBD_LL_Init+0xa0>)
 8012c28:	601a      	str	r2, [r3, #0]
  hpcd_USB_OTG_HS.Init.dev_endpoints = 9;
 8012c2a:	4b1d      	ldr	r3, [pc, #116]	@ (8012ca0 <USBD_LL_Init+0x9c>)
 8012c2c:	2209      	movs	r2, #9
 8012c2e:	711a      	strb	r2, [r3, #4]
  hpcd_USB_OTG_HS.Init.speed = PCD_SPEED_FULL;
 8012c30:	4b1b      	ldr	r3, [pc, #108]	@ (8012ca0 <USBD_LL_Init+0x9c>)
 8012c32:	2202      	movs	r2, #2
 8012c34:	71da      	strb	r2, [r3, #7]
  hpcd_USB_OTG_HS.Init.dma_enable = DISABLE;
 8012c36:	4b1a      	ldr	r3, [pc, #104]	@ (8012ca0 <USBD_LL_Init+0x9c>)
 8012c38:	2200      	movs	r2, #0
 8012c3a:	719a      	strb	r2, [r3, #6]
  hpcd_USB_OTG_HS.Init.phy_itface = USB_OTG_EMBEDDED_PHY;
 8012c3c:	4b18      	ldr	r3, [pc, #96]	@ (8012ca0 <USBD_LL_Init+0x9c>)
 8012c3e:	2202      	movs	r2, #2
 8012c40:	725a      	strb	r2, [r3, #9]
  hpcd_USB_OTG_HS.Init.Sof_enable = DISABLE;
 8012c42:	4b17      	ldr	r3, [pc, #92]	@ (8012ca0 <USBD_LL_Init+0x9c>)
 8012c44:	2200      	movs	r2, #0
 8012c46:	729a      	strb	r2, [r3, #10]
  hpcd_USB_OTG_HS.Init.low_power_enable = DISABLE;
 8012c48:	4b15      	ldr	r3, [pc, #84]	@ (8012ca0 <USBD_LL_Init+0x9c>)
 8012c4a:	2200      	movs	r2, #0
 8012c4c:	72da      	strb	r2, [r3, #11]
  hpcd_USB_OTG_HS.Init.lpm_enable = DISABLE;
 8012c4e:	4b14      	ldr	r3, [pc, #80]	@ (8012ca0 <USBD_LL_Init+0x9c>)
 8012c50:	2200      	movs	r2, #0
 8012c52:	731a      	strb	r2, [r3, #12]
  hpcd_USB_OTG_HS.Init.vbus_sensing_enable = DISABLE;
 8012c54:	4b12      	ldr	r3, [pc, #72]	@ (8012ca0 <USBD_LL_Init+0x9c>)
 8012c56:	2200      	movs	r2, #0
 8012c58:	739a      	strb	r2, [r3, #14]
  hpcd_USB_OTG_HS.Init.use_dedicated_ep1 = DISABLE;
 8012c5a:	4b11      	ldr	r3, [pc, #68]	@ (8012ca0 <USBD_LL_Init+0x9c>)
 8012c5c:	2200      	movs	r2, #0
 8012c5e:	73da      	strb	r2, [r3, #15]
  hpcd_USB_OTG_HS.Init.use_external_vbus = DISABLE;
 8012c60:	4b0f      	ldr	r3, [pc, #60]	@ (8012ca0 <USBD_LL_Init+0x9c>)
 8012c62:	2200      	movs	r2, #0
 8012c64:	741a      	strb	r2, [r3, #16]
  if (HAL_PCD_Init(&hpcd_USB_OTG_HS) != HAL_OK)
 8012c66:	480e      	ldr	r0, [pc, #56]	@ (8012ca0 <USBD_LL_Init+0x9c>)
 8012c68:	f7f5 fb30 	bl	80082cc <HAL_PCD_Init>
 8012c6c:	4603      	mov	r3, r0
 8012c6e:	2b00      	cmp	r3, #0
 8012c70:	d001      	beq.n	8012c76 <USBD_LL_Init+0x72>
  {
    Error_Handler( );
 8012c72:	f7ef f8ed 	bl	8001e50 <Error_Handler>
  HAL_PCD_RegisterDataInStageCallback(&hpcd_USB_OTG_HS, PCD_DataInStageCallback);
  HAL_PCD_RegisterIsoOutIncpltCallback(&hpcd_USB_OTG_HS, PCD_ISOOUTIncompleteCallback);
  HAL_PCD_RegisterIsoInIncpltCallback(&hpcd_USB_OTG_HS, PCD_ISOINIncompleteCallback);
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
  /* USER CODE BEGIN TxRx_HS_Configuration */
  HAL_PCDEx_SetRxFiFo(&hpcd_USB_OTG_HS, 0x200);
 8012c76:	f44f 7100 	mov.w	r1, #512	@ 0x200
 8012c7a:	4809      	ldr	r0, [pc, #36]	@ (8012ca0 <USBD_LL_Init+0x9c>)
 8012c7c:	f7f6 fd83 	bl	8009786 <HAL_PCDEx_SetRxFiFo>
  HAL_PCDEx_SetTxFiFo(&hpcd_USB_OTG_HS, 0, 0x80);
 8012c80:	2280      	movs	r2, #128	@ 0x80
 8012c82:	2100      	movs	r1, #0
 8012c84:	4806      	ldr	r0, [pc, #24]	@ (8012ca0 <USBD_LL_Init+0x9c>)
 8012c86:	f7f6 fd37 	bl	80096f8 <HAL_PCDEx_SetTxFiFo>
  HAL_PCDEx_SetTxFiFo(&hpcd_USB_OTG_HS, 1, 0x174);
 8012c8a:	f44f 72ba 	mov.w	r2, #372	@ 0x174
 8012c8e:	2101      	movs	r1, #1
 8012c90:	4803      	ldr	r0, [pc, #12]	@ (8012ca0 <USBD_LL_Init+0x9c>)
 8012c92:	f7f6 fd31 	bl	80096f8 <HAL_PCDEx_SetTxFiFo>
  /* USER CODE END TxRx_HS_Configuration */
  }
  return USBD_OK;
 8012c96:	2300      	movs	r3, #0
}
 8012c98:	4618      	mov	r0, r3
 8012c9a:	3708      	adds	r7, #8
 8012c9c:	46bd      	mov	sp, r7
 8012c9e:	bd80      	pop	{r7, pc}
 8012ca0:	24000cac 	.word	0x24000cac
 8012ca4:	40040000 	.word	0x40040000

08012ca8 <USBD_LL_Start>:
  * @brief  Starts the low level portion of the device driver.
  * @param  pdev: Device handle
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_Start(USBD_HandleTypeDef *pdev)
{
 8012ca8:	b580      	push	{r7, lr}
 8012caa:	b084      	sub	sp, #16
 8012cac:	af00      	add	r7, sp, #0
 8012cae:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef hal_status = HAL_OK;
 8012cb0:	2300      	movs	r3, #0
 8012cb2:	73fb      	strb	r3, [r7, #15]
  USBD_StatusTypeDef usb_status = USBD_OK;
 8012cb4:	2300      	movs	r3, #0
 8012cb6:	73bb      	strb	r3, [r7, #14]

  hal_status = HAL_PCD_Start(pdev->pData);
 8012cb8:	687b      	ldr	r3, [r7, #4]
 8012cba:	f8d3 32c8 	ldr.w	r3, [r3, #712]	@ 0x2c8
 8012cbe:	4618      	mov	r0, r3
 8012cc0:	f7f5 fc10 	bl	80084e4 <HAL_PCD_Start>
 8012cc4:	4603      	mov	r3, r0
 8012cc6:	73fb      	strb	r3, [r7, #15]

  usb_status =  USBD_Get_USB_Status(hal_status);
 8012cc8:	7bfb      	ldrb	r3, [r7, #15]
 8012cca:	4618      	mov	r0, r3
 8012ccc:	f000 f942 	bl	8012f54 <USBD_Get_USB_Status>
 8012cd0:	4603      	mov	r3, r0
 8012cd2:	73bb      	strb	r3, [r7, #14]

  return usb_status;
 8012cd4:	7bbb      	ldrb	r3, [r7, #14]
}
 8012cd6:	4618      	mov	r0, r3
 8012cd8:	3710      	adds	r7, #16
 8012cda:	46bd      	mov	sp, r7
 8012cdc:	bd80      	pop	{r7, pc}

08012cde <USBD_LL_OpenEP>:
  * @param  ep_type: Endpoint type
  * @param  ep_mps: Endpoint max packet size
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_OpenEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr, uint8_t ep_type, uint16_t ep_mps)
{
 8012cde:	b580      	push	{r7, lr}
 8012ce0:	b084      	sub	sp, #16
 8012ce2:	af00      	add	r7, sp, #0
 8012ce4:	6078      	str	r0, [r7, #4]
 8012ce6:	4608      	mov	r0, r1
 8012ce8:	4611      	mov	r1, r2
 8012cea:	461a      	mov	r2, r3
 8012cec:	4603      	mov	r3, r0
 8012cee:	70fb      	strb	r3, [r7, #3]
 8012cf0:	460b      	mov	r3, r1
 8012cf2:	70bb      	strb	r3, [r7, #2]
 8012cf4:	4613      	mov	r3, r2
 8012cf6:	803b      	strh	r3, [r7, #0]
  HAL_StatusTypeDef hal_status = HAL_OK;
 8012cf8:	2300      	movs	r3, #0
 8012cfa:	73fb      	strb	r3, [r7, #15]
  USBD_StatusTypeDef usb_status = USBD_OK;
 8012cfc:	2300      	movs	r3, #0
 8012cfe:	73bb      	strb	r3, [r7, #14]

  hal_status = HAL_PCD_EP_Open(pdev->pData, ep_addr, ep_mps, ep_type);
 8012d00:	687b      	ldr	r3, [r7, #4]
 8012d02:	f8d3 02c8 	ldr.w	r0, [r3, #712]	@ 0x2c8
 8012d06:	78bb      	ldrb	r3, [r7, #2]
 8012d08:	883a      	ldrh	r2, [r7, #0]
 8012d0a:	78f9      	ldrb	r1, [r7, #3]
 8012d0c:	f7f6 f911 	bl	8008f32 <HAL_PCD_EP_Open>
 8012d10:	4603      	mov	r3, r0
 8012d12:	73fb      	strb	r3, [r7, #15]

  usb_status =  USBD_Get_USB_Status(hal_status);
 8012d14:	7bfb      	ldrb	r3, [r7, #15]
 8012d16:	4618      	mov	r0, r3
 8012d18:	f000 f91c 	bl	8012f54 <USBD_Get_USB_Status>
 8012d1c:	4603      	mov	r3, r0
 8012d1e:	73bb      	strb	r3, [r7, #14]

  return usb_status;
 8012d20:	7bbb      	ldrb	r3, [r7, #14]
}
 8012d22:	4618      	mov	r0, r3
 8012d24:	3710      	adds	r7, #16
 8012d26:	46bd      	mov	sp, r7
 8012d28:	bd80      	pop	{r7, pc}

08012d2a <USBD_LL_CloseEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint number
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_CloseEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 8012d2a:	b580      	push	{r7, lr}
 8012d2c:	b084      	sub	sp, #16
 8012d2e:	af00      	add	r7, sp, #0
 8012d30:	6078      	str	r0, [r7, #4]
 8012d32:	460b      	mov	r3, r1
 8012d34:	70fb      	strb	r3, [r7, #3]
  HAL_StatusTypeDef hal_status = HAL_OK;
 8012d36:	2300      	movs	r3, #0
 8012d38:	73fb      	strb	r3, [r7, #15]
  USBD_StatusTypeDef usb_status = USBD_OK;
 8012d3a:	2300      	movs	r3, #0
 8012d3c:	73bb      	strb	r3, [r7, #14]

  hal_status = HAL_PCD_EP_Close(pdev->pData, ep_addr);
 8012d3e:	687b      	ldr	r3, [r7, #4]
 8012d40:	f8d3 32c8 	ldr.w	r3, [r3, #712]	@ 0x2c8
 8012d44:	78fa      	ldrb	r2, [r7, #3]
 8012d46:	4611      	mov	r1, r2
 8012d48:	4618      	mov	r0, r3
 8012d4a:	f7f6 f95a 	bl	8009002 <HAL_PCD_EP_Close>
 8012d4e:	4603      	mov	r3, r0
 8012d50:	73fb      	strb	r3, [r7, #15]

  usb_status =  USBD_Get_USB_Status(hal_status);
 8012d52:	7bfb      	ldrb	r3, [r7, #15]
 8012d54:	4618      	mov	r0, r3
 8012d56:	f000 f8fd 	bl	8012f54 <USBD_Get_USB_Status>
 8012d5a:	4603      	mov	r3, r0
 8012d5c:	73bb      	strb	r3, [r7, #14]

  return usb_status;
 8012d5e:	7bbb      	ldrb	r3, [r7, #14]
}
 8012d60:	4618      	mov	r0, r3
 8012d62:	3710      	adds	r7, #16
 8012d64:	46bd      	mov	sp, r7
 8012d66:	bd80      	pop	{r7, pc}

08012d68 <USBD_LL_StallEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint number
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_StallEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 8012d68:	b580      	push	{r7, lr}
 8012d6a:	b084      	sub	sp, #16
 8012d6c:	af00      	add	r7, sp, #0
 8012d6e:	6078      	str	r0, [r7, #4]
 8012d70:	460b      	mov	r3, r1
 8012d72:	70fb      	strb	r3, [r7, #3]
  HAL_StatusTypeDef hal_status = HAL_OK;
 8012d74:	2300      	movs	r3, #0
 8012d76:	73fb      	strb	r3, [r7, #15]
  USBD_StatusTypeDef usb_status = USBD_OK;
 8012d78:	2300      	movs	r3, #0
 8012d7a:	73bb      	strb	r3, [r7, #14]

  hal_status = HAL_PCD_EP_SetStall(pdev->pData, ep_addr);
 8012d7c:	687b      	ldr	r3, [r7, #4]
 8012d7e:	f8d3 32c8 	ldr.w	r3, [r3, #712]	@ 0x2c8
 8012d82:	78fa      	ldrb	r2, [r7, #3]
 8012d84:	4611      	mov	r1, r2
 8012d86:	4618      	mov	r0, r3
 8012d88:	f7f6 fa12 	bl	80091b0 <HAL_PCD_EP_SetStall>
 8012d8c:	4603      	mov	r3, r0
 8012d8e:	73fb      	strb	r3, [r7, #15]

  usb_status =  USBD_Get_USB_Status(hal_status);
 8012d90:	7bfb      	ldrb	r3, [r7, #15]
 8012d92:	4618      	mov	r0, r3
 8012d94:	f000 f8de 	bl	8012f54 <USBD_Get_USB_Status>
 8012d98:	4603      	mov	r3, r0
 8012d9a:	73bb      	strb	r3, [r7, #14]

  return usb_status;
 8012d9c:	7bbb      	ldrb	r3, [r7, #14]
}
 8012d9e:	4618      	mov	r0, r3
 8012da0:	3710      	adds	r7, #16
 8012da2:	46bd      	mov	sp, r7
 8012da4:	bd80      	pop	{r7, pc}

08012da6 <USBD_LL_ClearStallEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint number
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_ClearStallEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 8012da6:	b580      	push	{r7, lr}
 8012da8:	b084      	sub	sp, #16
 8012daa:	af00      	add	r7, sp, #0
 8012dac:	6078      	str	r0, [r7, #4]
 8012dae:	460b      	mov	r3, r1
 8012db0:	70fb      	strb	r3, [r7, #3]
  HAL_StatusTypeDef hal_status = HAL_OK;
 8012db2:	2300      	movs	r3, #0
 8012db4:	73fb      	strb	r3, [r7, #15]
  USBD_StatusTypeDef usb_status = USBD_OK;
 8012db6:	2300      	movs	r3, #0
 8012db8:	73bb      	strb	r3, [r7, #14]

  hal_status = HAL_PCD_EP_ClrStall(pdev->pData, ep_addr);
 8012dba:	687b      	ldr	r3, [r7, #4]
 8012dbc:	f8d3 32c8 	ldr.w	r3, [r3, #712]	@ 0x2c8
 8012dc0:	78fa      	ldrb	r2, [r7, #3]
 8012dc2:	4611      	mov	r1, r2
 8012dc4:	4618      	mov	r0, r3
 8012dc6:	f7f6 fa56 	bl	8009276 <HAL_PCD_EP_ClrStall>
 8012dca:	4603      	mov	r3, r0
 8012dcc:	73fb      	strb	r3, [r7, #15]

  usb_status =  USBD_Get_USB_Status(hal_status);
 8012dce:	7bfb      	ldrb	r3, [r7, #15]
 8012dd0:	4618      	mov	r0, r3
 8012dd2:	f000 f8bf 	bl	8012f54 <USBD_Get_USB_Status>
 8012dd6:	4603      	mov	r3, r0
 8012dd8:	73bb      	strb	r3, [r7, #14]

  return usb_status;
 8012dda:	7bbb      	ldrb	r3, [r7, #14]
}
 8012ddc:	4618      	mov	r0, r3
 8012dde:	3710      	adds	r7, #16
 8012de0:	46bd      	mov	sp, r7
 8012de2:	bd80      	pop	{r7, pc}

08012de4 <USBD_LL_IsStallEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint number
  * @retval Stall (1: Yes, 0: No)
  */
uint8_t USBD_LL_IsStallEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 8012de4:	b480      	push	{r7}
 8012de6:	b085      	sub	sp, #20
 8012de8:	af00      	add	r7, sp, #0
 8012dea:	6078      	str	r0, [r7, #4]
 8012dec:	460b      	mov	r3, r1
 8012dee:	70fb      	strb	r3, [r7, #3]
  PCD_HandleTypeDef *hpcd = (PCD_HandleTypeDef*) pdev->pData;
 8012df0:	687b      	ldr	r3, [r7, #4]
 8012df2:	f8d3 32c8 	ldr.w	r3, [r3, #712]	@ 0x2c8
 8012df6:	60fb      	str	r3, [r7, #12]

  if((ep_addr & 0x80) == 0x80)
 8012df8:	f997 3003 	ldrsb.w	r3, [r7, #3]
 8012dfc:	2b00      	cmp	r3, #0
 8012dfe:	da0b      	bge.n	8012e18 <USBD_LL_IsStallEP+0x34>
  {
    return hpcd->IN_ep[ep_addr & 0x7F].is_stall;
 8012e00:	78fb      	ldrb	r3, [r7, #3]
 8012e02:	f003 027f 	and.w	r2, r3, #127	@ 0x7f
 8012e06:	68f9      	ldr	r1, [r7, #12]
 8012e08:	4613      	mov	r3, r2
 8012e0a:	00db      	lsls	r3, r3, #3
 8012e0c:	4413      	add	r3, r2
 8012e0e:	009b      	lsls	r3, r3, #2
 8012e10:	440b      	add	r3, r1
 8012e12:	3316      	adds	r3, #22
 8012e14:	781b      	ldrb	r3, [r3, #0]
 8012e16:	e00b      	b.n	8012e30 <USBD_LL_IsStallEP+0x4c>
  }
  else
  {
    return hpcd->OUT_ep[ep_addr & 0x7F].is_stall;
 8012e18:	78fb      	ldrb	r3, [r7, #3]
 8012e1a:	f003 027f 	and.w	r2, r3, #127	@ 0x7f
 8012e1e:	68f9      	ldr	r1, [r7, #12]
 8012e20:	4613      	mov	r3, r2
 8012e22:	00db      	lsls	r3, r3, #3
 8012e24:	4413      	add	r3, r2
 8012e26:	009b      	lsls	r3, r3, #2
 8012e28:	440b      	add	r3, r1
 8012e2a:	f203 2356 	addw	r3, r3, #598	@ 0x256
 8012e2e:	781b      	ldrb	r3, [r3, #0]
  }
}
 8012e30:	4618      	mov	r0, r3
 8012e32:	3714      	adds	r7, #20
 8012e34:	46bd      	mov	sp, r7
 8012e36:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012e3a:	4770      	bx	lr

08012e3c <USBD_LL_SetUSBAddress>:
  * @param  pdev: Device handle
  * @param  dev_addr: Device address
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_SetUSBAddress(USBD_HandleTypeDef *pdev, uint8_t dev_addr)
{
 8012e3c:	b580      	push	{r7, lr}
 8012e3e:	b084      	sub	sp, #16
 8012e40:	af00      	add	r7, sp, #0
 8012e42:	6078      	str	r0, [r7, #4]
 8012e44:	460b      	mov	r3, r1
 8012e46:	70fb      	strb	r3, [r7, #3]
  HAL_StatusTypeDef hal_status = HAL_OK;
 8012e48:	2300      	movs	r3, #0
 8012e4a:	73fb      	strb	r3, [r7, #15]
  USBD_StatusTypeDef usb_status = USBD_OK;
 8012e4c:	2300      	movs	r3, #0
 8012e4e:	73bb      	strb	r3, [r7, #14]

  hal_status = HAL_PCD_SetAddress(pdev->pData, dev_addr);
 8012e50:	687b      	ldr	r3, [r7, #4]
 8012e52:	f8d3 32c8 	ldr.w	r3, [r3, #712]	@ 0x2c8
 8012e56:	78fa      	ldrb	r2, [r7, #3]
 8012e58:	4611      	mov	r1, r2
 8012e5a:	4618      	mov	r0, r3
 8012e5c:	f7f6 f845 	bl	8008eea <HAL_PCD_SetAddress>
 8012e60:	4603      	mov	r3, r0
 8012e62:	73fb      	strb	r3, [r7, #15]

  usb_status =  USBD_Get_USB_Status(hal_status);
 8012e64:	7bfb      	ldrb	r3, [r7, #15]
 8012e66:	4618      	mov	r0, r3
 8012e68:	f000 f874 	bl	8012f54 <USBD_Get_USB_Status>
 8012e6c:	4603      	mov	r3, r0
 8012e6e:	73bb      	strb	r3, [r7, #14]

  return usb_status;
 8012e70:	7bbb      	ldrb	r3, [r7, #14]
}
 8012e72:	4618      	mov	r0, r3
 8012e74:	3710      	adds	r7, #16
 8012e76:	46bd      	mov	sp, r7
 8012e78:	bd80      	pop	{r7, pc}

08012e7a <USBD_LL_Transmit>:
  * @param  pbuf: Pointer to data to be sent
  * @param  size: Data size
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_Transmit(USBD_HandleTypeDef *pdev, uint8_t ep_addr, uint8_t *pbuf, uint32_t size)
{
 8012e7a:	b580      	push	{r7, lr}
 8012e7c:	b086      	sub	sp, #24
 8012e7e:	af00      	add	r7, sp, #0
 8012e80:	60f8      	str	r0, [r7, #12]
 8012e82:	607a      	str	r2, [r7, #4]
 8012e84:	603b      	str	r3, [r7, #0]
 8012e86:	460b      	mov	r3, r1
 8012e88:	72fb      	strb	r3, [r7, #11]
  HAL_StatusTypeDef hal_status = HAL_OK;
 8012e8a:	2300      	movs	r3, #0
 8012e8c:	75fb      	strb	r3, [r7, #23]
  USBD_StatusTypeDef usb_status = USBD_OK;
 8012e8e:	2300      	movs	r3, #0
 8012e90:	75bb      	strb	r3, [r7, #22]

  hal_status = HAL_PCD_EP_Transmit(pdev->pData, ep_addr, pbuf, size);
 8012e92:	68fb      	ldr	r3, [r7, #12]
 8012e94:	f8d3 02c8 	ldr.w	r0, [r3, #712]	@ 0x2c8
 8012e98:	7af9      	ldrb	r1, [r7, #11]
 8012e9a:	683b      	ldr	r3, [r7, #0]
 8012e9c:	687a      	ldr	r2, [r7, #4]
 8012e9e:	f7f6 f94d 	bl	800913c <HAL_PCD_EP_Transmit>
 8012ea2:	4603      	mov	r3, r0
 8012ea4:	75fb      	strb	r3, [r7, #23]

  usb_status =  USBD_Get_USB_Status(hal_status);
 8012ea6:	7dfb      	ldrb	r3, [r7, #23]
 8012ea8:	4618      	mov	r0, r3
 8012eaa:	f000 f853 	bl	8012f54 <USBD_Get_USB_Status>
 8012eae:	4603      	mov	r3, r0
 8012eb0:	75bb      	strb	r3, [r7, #22]

  return usb_status;
 8012eb2:	7dbb      	ldrb	r3, [r7, #22]
}
 8012eb4:	4618      	mov	r0, r3
 8012eb6:	3718      	adds	r7, #24
 8012eb8:	46bd      	mov	sp, r7
 8012eba:	bd80      	pop	{r7, pc}

08012ebc <USBD_LL_PrepareReceive>:
  * @param  pbuf: Pointer to data to be received
  * @param  size: Data size
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_PrepareReceive(USBD_HandleTypeDef *pdev, uint8_t ep_addr, uint8_t *pbuf, uint32_t size)
{
 8012ebc:	b580      	push	{r7, lr}
 8012ebe:	b086      	sub	sp, #24
 8012ec0:	af00      	add	r7, sp, #0
 8012ec2:	60f8      	str	r0, [r7, #12]
 8012ec4:	607a      	str	r2, [r7, #4]
 8012ec6:	603b      	str	r3, [r7, #0]
 8012ec8:	460b      	mov	r3, r1
 8012eca:	72fb      	strb	r3, [r7, #11]
  HAL_StatusTypeDef hal_status = HAL_OK;
 8012ecc:	2300      	movs	r3, #0
 8012ece:	75fb      	strb	r3, [r7, #23]
  USBD_StatusTypeDef usb_status = USBD_OK;
 8012ed0:	2300      	movs	r3, #0
 8012ed2:	75bb      	strb	r3, [r7, #22]

  hal_status = HAL_PCD_EP_Receive(pdev->pData, ep_addr, pbuf, size);
 8012ed4:	68fb      	ldr	r3, [r7, #12]
 8012ed6:	f8d3 02c8 	ldr.w	r0, [r3, #712]	@ 0x2c8
 8012eda:	7af9      	ldrb	r1, [r7, #11]
 8012edc:	683b      	ldr	r3, [r7, #0]
 8012ede:	687a      	ldr	r2, [r7, #4]
 8012ee0:	f7f6 f8d9 	bl	8009096 <HAL_PCD_EP_Receive>
 8012ee4:	4603      	mov	r3, r0
 8012ee6:	75fb      	strb	r3, [r7, #23]

  usb_status =  USBD_Get_USB_Status(hal_status);
 8012ee8:	7dfb      	ldrb	r3, [r7, #23]
 8012eea:	4618      	mov	r0, r3
 8012eec:	f000 f832 	bl	8012f54 <USBD_Get_USB_Status>
 8012ef0:	4603      	mov	r3, r0
 8012ef2:	75bb      	strb	r3, [r7, #22]

  return usb_status;
 8012ef4:	7dbb      	ldrb	r3, [r7, #22]
}
 8012ef6:	4618      	mov	r0, r3
 8012ef8:	3718      	adds	r7, #24
 8012efa:	46bd      	mov	sp, r7
 8012efc:	bd80      	pop	{r7, pc}

08012efe <USBD_LL_GetRxDataSize>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint number
  * @retval Received Data Size
  */
uint32_t USBD_LL_GetRxDataSize(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 8012efe:	b580      	push	{r7, lr}
 8012f00:	b082      	sub	sp, #8
 8012f02:	af00      	add	r7, sp, #0
 8012f04:	6078      	str	r0, [r7, #4]
 8012f06:	460b      	mov	r3, r1
 8012f08:	70fb      	strb	r3, [r7, #3]
  return HAL_PCD_EP_GetRxCount((PCD_HandleTypeDef*) pdev->pData, ep_addr);
 8012f0a:	687b      	ldr	r3, [r7, #4]
 8012f0c:	f8d3 32c8 	ldr.w	r3, [r3, #712]	@ 0x2c8
 8012f10:	78fa      	ldrb	r2, [r7, #3]
 8012f12:	4611      	mov	r1, r2
 8012f14:	4618      	mov	r0, r3
 8012f16:	f7f6 f8f9 	bl	800910c <HAL_PCD_EP_GetRxCount>
 8012f1a:	4603      	mov	r3, r0
}
 8012f1c:	4618      	mov	r0, r3
 8012f1e:	3708      	adds	r7, #8
 8012f20:	46bd      	mov	sp, r7
 8012f22:	bd80      	pop	{r7, pc}

08012f24 <USBD_static_malloc>:
  * @brief  Static single allocation.
  * @param  size: Size of allocated memory
  * @retval None
  */
void *USBD_static_malloc(uint32_t size)
{
 8012f24:	b480      	push	{r7}
 8012f26:	b083      	sub	sp, #12
 8012f28:	af00      	add	r7, sp, #0
 8012f2a:	6078      	str	r0, [r7, #4]
  UNUSED(size);
  static uint32_t mem[(sizeof(USBD_AUDIO_HandleTypeDef)/4)+1];/* On 32-bit boundary */
  return mem;
 8012f2c:	4b03      	ldr	r3, [pc, #12]	@ (8012f3c <USBD_static_malloc+0x18>)
}
 8012f2e:	4618      	mov	r0, r3
 8012f30:	370c      	adds	r7, #12
 8012f32:	46bd      	mov	sp, r7
 8012f34:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012f38:	4770      	bx	lr
 8012f3a:	bf00      	nop
 8012f3c:	24001190 	.word	0x24001190

08012f40 <USBD_static_free>:
  * @brief  Dummy memory free
  * @param  p: Pointer to allocated  memory address
  * @retval None
  */
void USBD_static_free(void *p)
{
 8012f40:	b480      	push	{r7}
 8012f42:	b083      	sub	sp, #12
 8012f44:	af00      	add	r7, sp, #0
 8012f46:	6078      	str	r0, [r7, #4]
  UNUSED(p);
}
 8012f48:	bf00      	nop
 8012f4a:	370c      	adds	r7, #12
 8012f4c:	46bd      	mov	sp, r7
 8012f4e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012f52:	4770      	bx	lr

08012f54 <USBD_Get_USB_Status>:
  * @brief  Returns the USB status depending on the HAL status:
  * @param  hal_status: HAL status
  * @retval USB status
  */
USBD_StatusTypeDef USBD_Get_USB_Status(HAL_StatusTypeDef hal_status)
{
 8012f54:	b480      	push	{r7}
 8012f56:	b085      	sub	sp, #20
 8012f58:	af00      	add	r7, sp, #0
 8012f5a:	4603      	mov	r3, r0
 8012f5c:	71fb      	strb	r3, [r7, #7]
  USBD_StatusTypeDef usb_status = USBD_OK;
 8012f5e:	2300      	movs	r3, #0
 8012f60:	73fb      	strb	r3, [r7, #15]

  switch (hal_status)
 8012f62:	79fb      	ldrb	r3, [r7, #7]
 8012f64:	2b03      	cmp	r3, #3
 8012f66:	d817      	bhi.n	8012f98 <USBD_Get_USB_Status+0x44>
 8012f68:	a201      	add	r2, pc, #4	@ (adr r2, 8012f70 <USBD_Get_USB_Status+0x1c>)
 8012f6a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8012f6e:	bf00      	nop
 8012f70:	08012f81 	.word	0x08012f81
 8012f74:	08012f87 	.word	0x08012f87
 8012f78:	08012f8d 	.word	0x08012f8d
 8012f7c:	08012f93 	.word	0x08012f93
  {
    case HAL_OK :
      usb_status = USBD_OK;
 8012f80:	2300      	movs	r3, #0
 8012f82:	73fb      	strb	r3, [r7, #15]
    break;
 8012f84:	e00b      	b.n	8012f9e <USBD_Get_USB_Status+0x4a>
    case HAL_ERROR :
      usb_status = USBD_FAIL;
 8012f86:	2303      	movs	r3, #3
 8012f88:	73fb      	strb	r3, [r7, #15]
    break;
 8012f8a:	e008      	b.n	8012f9e <USBD_Get_USB_Status+0x4a>
    case HAL_BUSY :
      usb_status = USBD_BUSY;
 8012f8c:	2301      	movs	r3, #1
 8012f8e:	73fb      	strb	r3, [r7, #15]
    break;
 8012f90:	e005      	b.n	8012f9e <USBD_Get_USB_Status+0x4a>
    case HAL_TIMEOUT :
      usb_status = USBD_FAIL;
 8012f92:	2303      	movs	r3, #3
 8012f94:	73fb      	strb	r3, [r7, #15]
    break;
 8012f96:	e002      	b.n	8012f9e <USBD_Get_USB_Status+0x4a>
    default :
      usb_status = USBD_FAIL;
 8012f98:	2303      	movs	r3, #3
 8012f9a:	73fb      	strb	r3, [r7, #15]
    break;
 8012f9c:	bf00      	nop
  }
  return usb_status;
 8012f9e:	7bfb      	ldrb	r3, [r7, #15]
}
 8012fa0:	4618      	mov	r0, r3
 8012fa2:	3714      	adds	r7, #20
 8012fa4:	46bd      	mov	sp, r7
 8012fa6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012faa:	4770      	bx	lr

08012fac <memset>:
 8012fac:	4402      	add	r2, r0
 8012fae:	4603      	mov	r3, r0
 8012fb0:	4293      	cmp	r3, r2
 8012fb2:	d100      	bne.n	8012fb6 <memset+0xa>
 8012fb4:	4770      	bx	lr
 8012fb6:	f803 1b01 	strb.w	r1, [r3], #1
 8012fba:	e7f9      	b.n	8012fb0 <memset+0x4>

08012fbc <__errno>:
 8012fbc:	4b01      	ldr	r3, [pc, #4]	@ (8012fc4 <__errno+0x8>)
 8012fbe:	6818      	ldr	r0, [r3, #0]
 8012fc0:	4770      	bx	lr
 8012fc2:	bf00      	nop
 8012fc4:	24000250 	.word	0x24000250

08012fc8 <__libc_init_array>:
 8012fc8:	b570      	push	{r4, r5, r6, lr}
 8012fca:	4d0d      	ldr	r5, [pc, #52]	@ (8013000 <__libc_init_array+0x38>)
 8012fcc:	4c0d      	ldr	r4, [pc, #52]	@ (8013004 <__libc_init_array+0x3c>)
 8012fce:	1b64      	subs	r4, r4, r5
 8012fd0:	10a4      	asrs	r4, r4, #2
 8012fd2:	2600      	movs	r6, #0
 8012fd4:	42a6      	cmp	r6, r4
 8012fd6:	d109      	bne.n	8012fec <__libc_init_array+0x24>
 8012fd8:	4d0b      	ldr	r5, [pc, #44]	@ (8013008 <__libc_init_array+0x40>)
 8012fda:	4c0c      	ldr	r4, [pc, #48]	@ (801300c <__libc_init_array+0x44>)
 8012fdc:	f000 f8b8 	bl	8013150 <_init>
 8012fe0:	1b64      	subs	r4, r4, r5
 8012fe2:	10a4      	asrs	r4, r4, #2
 8012fe4:	2600      	movs	r6, #0
 8012fe6:	42a6      	cmp	r6, r4
 8012fe8:	d105      	bne.n	8012ff6 <__libc_init_array+0x2e>
 8012fea:	bd70      	pop	{r4, r5, r6, pc}
 8012fec:	f855 3b04 	ldr.w	r3, [r5], #4
 8012ff0:	4798      	blx	r3
 8012ff2:	3601      	adds	r6, #1
 8012ff4:	e7ee      	b.n	8012fd4 <__libc_init_array+0xc>
 8012ff6:	f855 3b04 	ldr.w	r3, [r5], #4
 8012ffa:	4798      	blx	r3
 8012ffc:	3601      	adds	r6, #1
 8012ffe:	e7f2      	b.n	8012fe6 <__libc_init_array+0x1e>
 8013000:	08013308 	.word	0x08013308
 8013004:	08013308 	.word	0x08013308
 8013008:	08013308 	.word	0x08013308
 801300c:	0801330c 	.word	0x0801330c

08013010 <expf>:
 8013010:	ee10 2a10 	vmov	r2, s0
 8013014:	f240 412a 	movw	r1, #1066	@ 0x42a
 8013018:	f3c2 530a 	ubfx	r3, r2, #20, #11
 801301c:	428b      	cmp	r3, r1
 801301e:	b430      	push	{r4, r5}
 8013020:	eeb7 6ac0 	vcvt.f64.f32	d6, s0
 8013024:	d92a      	bls.n	801307c <expf+0x6c>
 8013026:	f512 0f00 	cmn.w	r2, #8388608	@ 0x800000
 801302a:	d058      	beq.n	80130de <expf+0xce>
 801302c:	f5b3 6fff 	cmp.w	r3, #2040	@ 0x7f8
 8013030:	d303      	bcc.n	801303a <expf+0x2a>
 8013032:	ee30 0a00 	vadd.f32	s0, s0, s0
 8013036:	bc30      	pop	{r4, r5}
 8013038:	4770      	bx	lr
 801303a:	eddf 7a2a 	vldr	s15, [pc, #168]	@ 80130e4 <expf+0xd4>
 801303e:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8013042:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8013046:	dd03      	ble.n	8013050 <expf+0x40>
 8013048:	bc30      	pop	{r4, r5}
 801304a:	2000      	movs	r0, #0
 801304c:	f000 b87a 	b.w	8013144 <__math_oflowf>
 8013050:	eddf 7a25 	vldr	s15, [pc, #148]	@ 80130e8 <expf+0xd8>
 8013054:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8013058:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801305c:	d503      	bpl.n	8013066 <expf+0x56>
 801305e:	bc30      	pop	{r4, r5}
 8013060:	2000      	movs	r0, #0
 8013062:	f000 b863 	b.w	801312c <__math_uflowf>
 8013066:	eddf 7a21 	vldr	s15, [pc, #132]	@ 80130ec <expf+0xdc>
 801306a:	eeb4 0ae7 	vcmpe.f32	s0, s15
 801306e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8013072:	d503      	bpl.n	801307c <expf+0x6c>
 8013074:	bc30      	pop	{r4, r5}
 8013076:	2000      	movs	r0, #0
 8013078:	f000 b85e 	b.w	8013138 <__math_may_uflowf>
 801307c:	4b1c      	ldr	r3, [pc, #112]	@ (80130f0 <expf+0xe0>)
 801307e:	eeb7 0b00 	vmov.f64	d0, #112	@ 0x3f800000  1.0
 8013082:	ed93 5b4a 	vldr	d5, [r3, #296]	@ 0x128
 8013086:	ed93 4b48 	vldr	d4, [r3, #288]	@ 0x120
 801308a:	eeb0 7b44 	vmov.f64	d7, d4
 801308e:	eea5 7b06 	vfma.f64	d7, d5, d6
 8013092:	ee17 0a10 	vmov	r0, s14
 8013096:	ee37 7b44 	vsub.f64	d7, d7, d4
 801309a:	f000 021f 	and.w	r2, r0, #31
 801309e:	ee95 7b06 	vfnms.f64	d7, d5, d6
 80130a2:	ed93 5b4c 	vldr	d5, [r3, #304]	@ 0x130
 80130a6:	ee27 4b07 	vmul.f64	d4, d7, d7
 80130aa:	ed93 6b4e 	vldr	d6, [r3, #312]	@ 0x138
 80130ae:	eb03 01c2 	add.w	r1, r3, r2, lsl #3
 80130b2:	eea5 6b07 	vfma.f64	d6, d5, d7
 80130b6:	f853 4032 	ldr.w	r4, [r3, r2, lsl #3]
 80130ba:	684d      	ldr	r5, [r1, #4]
 80130bc:	ed93 5b50 	vldr	d5, [r3, #320]	@ 0x140
 80130c0:	2100      	movs	r1, #0
 80130c2:	190a      	adds	r2, r1, r4
 80130c4:	eb05 33c0 	add.w	r3, r5, r0, lsl #15
 80130c8:	eea5 0b07 	vfma.f64	d0, d5, d7
 80130cc:	ec43 2b17 	vmov	d7, r2, r3
 80130d0:	eea6 0b04 	vfma.f64	d0, d6, d4
 80130d4:	ee20 0b07 	vmul.f64	d0, d0, d7
 80130d8:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
 80130dc:	e7ab      	b.n	8013036 <expf+0x26>
 80130de:	ed9f 0a05 	vldr	s0, [pc, #20]	@ 80130f4 <expf+0xe4>
 80130e2:	e7a8      	b.n	8013036 <expf+0x26>
 80130e4:	42b17217 	.word	0x42b17217
 80130e8:	c2cff1b4 	.word	0xc2cff1b4
 80130ec:	c2ce8ecf 	.word	0xc2ce8ecf
 80130f0:	080131c0 	.word	0x080131c0
 80130f4:	00000000 	.word	0x00000000

080130f8 <with_errnof>:
 80130f8:	b510      	push	{r4, lr}
 80130fa:	ed2d 8b02 	vpush	{d8}
 80130fe:	eeb0 8a40 	vmov.f32	s16, s0
 8013102:	4604      	mov	r4, r0
 8013104:	f7ff ff5a 	bl	8012fbc <__errno>
 8013108:	eeb0 0a48 	vmov.f32	s0, s16
 801310c:	ecbd 8b02 	vpop	{d8}
 8013110:	6004      	str	r4, [r0, #0]
 8013112:	bd10      	pop	{r4, pc}

08013114 <xflowf>:
 8013114:	b130      	cbz	r0, 8013124 <xflowf+0x10>
 8013116:	eef1 7a40 	vneg.f32	s15, s0
 801311a:	ee27 0a80 	vmul.f32	s0, s15, s0
 801311e:	2022      	movs	r0, #34	@ 0x22
 8013120:	f7ff bfea 	b.w	80130f8 <with_errnof>
 8013124:	eef0 7a40 	vmov.f32	s15, s0
 8013128:	e7f7      	b.n	801311a <xflowf+0x6>
	...

0801312c <__math_uflowf>:
 801312c:	ed9f 0a01 	vldr	s0, [pc, #4]	@ 8013134 <__math_uflowf+0x8>
 8013130:	f7ff bff0 	b.w	8013114 <xflowf>
 8013134:	10000000 	.word	0x10000000

08013138 <__math_may_uflowf>:
 8013138:	ed9f 0a01 	vldr	s0, [pc, #4]	@ 8013140 <__math_may_uflowf+0x8>
 801313c:	f7ff bfea 	b.w	8013114 <xflowf>
 8013140:	1a200000 	.word	0x1a200000

08013144 <__math_oflowf>:
 8013144:	ed9f 0a01 	vldr	s0, [pc, #4]	@ 801314c <__math_oflowf+0x8>
 8013148:	f7ff bfe4 	b.w	8013114 <xflowf>
 801314c:	70000000 	.word	0x70000000

08013150 <_init>:
 8013150:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8013152:	bf00      	nop
 8013154:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8013156:	bc08      	pop	{r3}
 8013158:	469e      	mov	lr, r3
 801315a:	4770      	bx	lr

0801315c <_fini>:
 801315c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801315e:	bf00      	nop
 8013160:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8013162:	bc08      	pop	{r3}
 8013164:	469e      	mov	lr, r3
 8013166:	4770      	bx	lr
